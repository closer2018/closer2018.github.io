<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>closer的自留地</title>
  
  <subtitle>此后如竟没有炬火，我便是唯一的光.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://closer_laps.gitee.io/"/>
  <updated>2020-04-13T04:17:30.012Z</updated>
  <id>https://closer_laps.gitee.io/</id>
  
  <author>
    <name>closer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>按键精灵语法</title>
    <link href="https://closer_laps.gitee.io/2020/04/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5/%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5%E8%AF%AD%E6%B3%95/"/>
    <id>https://closer_laps.gitee.io/2020/04/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5/%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5%E8%AF%AD%E6%B3%95/</id>
    <published>2020-04-09T12:58:18.000Z</published>
    <updated>2020-04-13T04:17:30.012Z</updated>
    
    <content type="html"><![CDATA[<p>windows或者Android(需要root权限)下按键精灵有时候写一些简单的脚本还是挺好用的。没有最好的语言，只有最适合的工具。在此记录下常用的基本语法。</p><h2 id="句柄及后台运行"><a href="#句柄及后台运行" class="headerlink" title="句柄及后台运行"></a>句柄及后台运行</h2><p>句柄可以获取后台窗口的类名或者标题，以达到获取坐标或后台运行脚本的目的。<br><strong>后台只支持部分窗口，以实际测试为准。</strong></p><p>句柄的类名或者标题，可以用按键精灵自带的抓抓工具抓取。</p><pre><code class="vb">//声明窗口句柄变量，窗口大小变量Dim Hwnd, sRect//声明数组Dim Array//Plugin.Window.Find()--命令功能-查找窗口类名或者标题//下面这句是查找窗口类名(&quot;Notepad&quot;)或者标题(0),返回找到的句柄HwndHwnd = Plugin.Window.Find(&quot;Notepad&quot;,&quot;0&quot;)//调试输出句柄-功能-在调试窗口打印文字TracePrint Hwnd//该函数返回窗口大小sRect = Plugin.Window.GetWindowRect(Hwnd)//窗口大小转为数组，可以获得窗口左上角的坐标//语法 Split(expression[, delimiter[, count[, start]]])//字符串为sRect，分割方式‘|’Array = Split(sRect, &quot;|&quot;)//左上角坐标的X,Y轴坐标TracePrint Array(0)TracePrint Array(1)//下拉型自定义变量//格式: UserVar 变量名=DropList{选项0:值0|选项1:值1|选项2:值2}=默认显示的选项编号 {注释}//解释:这个命令预先设定多个变量值，用户可在基面通过下拉方式进行选择//示例UserVar Var1=DropList{&quot;低于10%时补血&quot;:0.1|&quot;低于20%时补血&quot;:0.2|&quot;低于30%时补血&quot;:0.3}=2 &quot;自动补血设置&quot;//左键点击5次LeftClick 5//Function函数Function increase(x,y)    If v = 1 Then        //键盘输入enter        KeyPress &quot;Enter&quot;, 1    Else        //鼠标移动到指定坐标        MoveTo Array(0)+406, Array(1)+342    End IfEnd Function//调用函数或子程序call Function_name//LeftClick 左键单击//命令功能 向后台窗口句柄送一个鼠标左键单击 (注意：只支持部分窗口，以实际测试为准。)Call Plugin.Bkgnd.LeftClick(Hwnd, 550, 262)//后台输入按键enter，13是按键码，可以在按键精灵中与实际按键互相转换Call Plugin.Bkgnd.KeyPress(Hwnd, 13)//添加延迟，单位毫秒msDelay 500//For循环For i=0 To 5    For j=0 TO 7        Call increase(x, y)        x = x + 30    Next    x = 488    y = y + 30Next</code></pre><h2 id="带GUI的脚本"><a href="#带GUI的脚本" class="headerlink" title="带GUI的脚本"></a>带GUI的脚本</h2><p>先要在界面画出窗体（form）及各种输入框，下拉框，标签，按钮等。。。</p><p>下面是QQ后台刷屏脚本，先画4个标签，4个输入框，1个下拉框，1个按钮</p><pre><code class="VB">//事件：form是窗体，load是加载，定义下拉框属性Event Form1.Load    //窗体1中的ComboBox1下拉框1有是和否2个选择    Form1.ComboBox1.List = &quot;是|否&quot;    //窗体下拉框初始选项    Form1.ComboBox1.ListIndex = 0End Event//定义窗体1的按钮1的点击触发事件Event Form1.Button1.Click    //窗体1的输入框1的文本赋予变量title    title = Form1.InputBox1.Text    //找到QQ窗口句柄    Hwnd=Plugin.Window.Find(&quot;TXGuiFoundation&quot;,title)    t = 1    //窗体1的输入框4的文本转化为int赋予变量times    times = Int(Form1.InputBox4.Text)    //数组真假赋予subfix    subfix=Array(true,false)    text = Form1.InputBox2.Text    rate = Form1.InputBox3.Text    //while循环    While t &lt;= times OR times = 0        If subfix(Form1.ComboBox1.ListIndex) Then            //后台发送文本加自增计数变量            Call Plugin.Bkgnd.SendString(Hwnd,text &amp; t)        Else            //后台发送文本text            Call Plugin.Bkgnd.SendString(Hwnd,text)        End If        //输入enter        Call Plugin.Bkgnd.KeyPress(Hwnd, 13)        t = t + 1        //发送事件间隔为变量rate        Delay rate    WendEnd Event</code></pre><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><pre><code class="VB">DimEnv T1DimEnv T2Call start_1Sub start_1    //线程1    T1 = BeginThread(thread1)    T2 = BeginThread(thread2)    BeginThread StopEnd SubSub thread1    name_1 = &quot;测试1&quot;    t_1 = 0    rate_1 = 1000    times_1 = 100    subfix_1=true    test_1 = &quot;测试&quot;    //while循环    Hwnd_1 = Plugin.Window.Find(0, name_1)    //当输入t=-1时则循环发送消息至按终止键为止    While t_1 &lt;= times_1 OR times_1 = 0        If subfix_1 Then            //后台发送文本加自增计数变量            Call Plugin.Bkgnd.SendString(Hwnd_1,test_1 &amp; t_1)        Else            //后台发送文本test_1            Call Plugin.Bkgnd.SendString(Hwnd_1,test_1)        End If        Call Plugin.Bkgnd.KeyPress(Hwnd_1, 13)        t_1 = t_1 + 1        //发送事件间隔为变量rate_1        Delay rate_1    WendEnd SubSub thread2    name_2 = &quot;测试2&quot;    t_2 = 0    rate_2 = 1000    times_2 = 100    subfix_2=true    test_2 = &quot;测试&quot;    //while循环    Hwnd_2 = Plugin.Window.Find(0,name_2)    While t_2 &lt;= times_2 OR times_2 = 0        If subfix_2 Then            //后台发送文本加自增计数变量            Call Plugin.Bkgnd.SendString(Hwnd_2,test_2 &amp; t_2)        Else            //后台发送文本test_2            Call Plugin.Bkgnd.SendString(Hwnd_2,test_2)        End If        Call Plugin.Bkgnd.KeyPress(Hwnd_2, 13)        t_2 = t_2 + 1        //发送事件间隔为变量rate_2        Delay rate_2    WendEnd SubSub stop    s_1 = &quot;A&quot;    s_2 = &quot;Z&quot;    running = True    While True        //监听按键        s = Waitkey        If s = Asc(s_1) and running  Then            PauseThread T1            running = False        ElseIf s = Asc(s_1) and not running Then            PauseThread T1            running = True        ElseIf s = Asc(s_2) Then            StopThread T2        End If    WendEnd Sub</code></pre><h2 id="一个简单的脚本示例"><a href="#一个简单的脚本示例" class="headerlink" title="一个简单的脚本示例"></a>一个简单的脚本示例</h2><pre><code class="VB">//声明窗口句柄变量Dim Hwnd, sRectDim Array//下面这句是查找窗口类名(&quot;Notepad&quot;)或者标题(0),返回找到的句柄HwndHwnd = Plugin.Window.Find(&quot;DNF Taiwan&quot;,&quot;DNF Taiwan&quot;)//调试输出TracePrint Hwnd//返回窗口大小sRect = Plugin.Window.GetWindowRect(Hwnd)//窗口大小转为数组Array = Split(sRect, &quot;|&quot;)TracePrint Array(0)TracePrint Array(1)//功能选择UserVar Var0 = DropList{&quot;自动增幅&quot;:&quot;1&quot;|&quot;娃娃机&quot;:&quot;2&quot;|&quot;先娃娃机再增幅&quot;:&quot;3&quot;|&quot;鼠标左键连点&quot;:&quot;4&quot;|&quot;自动锻造&quot;:&quot;5&quot;}=3 &quot;功能选择&quot;//选择窗口，选择力量还是智力UserVar Var1 = DropList{&quot;增幅力量&quot;:&quot;1&quot;|&quot;增幅智力&quot;:&quot;2&quot;}=0 &quot;选择增幅力量还是智力&quot;//选择窗口，选择15还是13增幅券UserVar Var2 = DropList{&quot;13&quot;:13|&quot;15&quot;:15}=1 &quot;选择13还是15增幅券&quot;//设置鼠标点击延迟UserVar Yanshi=50 &quot;两次点击的时间间隔（毫秒）&quot;//强打增幅1件装备Function increase(x,y)    //使用强打书    KeyPress &quot;1&quot;, 1    //延迟    Delay 200    //点击力量增幅    If var1 = 1 Then        MoveTo Array(0)+406, Array(1)+300        LeftClick 1        //点击智力增幅    Else        MoveTo Array(0)+406, Array(1)+342        LeftClick 1    End If    Delay 200    //点击使用    MoveTo Array(0)+374, Array(1)+391    LeftClick 1    Delay 200    //点击第一格装备    MoveTo Array(0)+x, Array(1)+y    LeftClick 1    Delay 200    //确定    KeyPress &quot;Enter&quot;, 1    Delay 200    KeyPress &quot;Enter&quot;, 1    Delay 200    //使用增幅书    KeyPress &quot;2&quot;, 1    Delay 200    //点击第一格装备    MoveTo Array(0)+x, Array(1)+y    LeftClick 1    Delay 200    //确定    KeyPress &quot;Enter&quot;, 1    Delay 200    If var2 = 13 Then        KeyPress &quot;Enter&quot;, 1        Delay 200    End If    //一格装备完成End Function//增幅装备栏Function zengfu()    //主程序    x = 488    y = 288    For i=0 To 5        For j=0 TO 7            Call increase(x, y)            x = x + 30        Next        x = 488        y = y + 30    NextEnd Function//抽娃娃机Function wawaji()    For temp=0 TO 46        //投币        MoveTo Array(0)+152, Array(1)+402        LeftClick 1        Delay 200        //确认        MoveTo Array(0)+358, Array(1)+345        LeftClick 1        Delay 200        //停止        MoveTo Array(0)+200, Array(1)+402        LeftClick 1        Delay 5500        //确定        KeyPress &quot;Enter&quot;, 1        Delay 200    NextEnd Function//抽娃娃机和增幅装备栏Function wawajiandzengfu()    Call wawaji()    KeyPress &quot;Esc&quot;, 1    Delay 200    KeyPress &quot;i&quot;, 1    Delay 200    Call zengfu()End Function//鼠标左击Function autoLeftClick()    While True        //说明：按照一定频率反复点击鼠标左键        //1秒 = 1000毫秒        LeftClick 1        Delay Yanshi    WendEnd Function//自动锻造Function autoDuanZao()    SetSimMode 0    While True        //拖拽第一格装备到锻造炉        MoveTo Array(0) + 488, Array(1) + 288        LeftDownS 1        Delay 200        MoveTo Array(0) + 331, Array(1) + 295        Delay 200        LeftUpS 1        //确定        MoveTo Array(0) + 336, Array(1) + 375        Delay 200        LeftClick 1        //延迟        Delay 6500        //确定        KeyPress &quot;Enter&quot;, 1        Delay 200    WendEnd Function//主程序If Var0 = 1 Then    Call zengfu()ElseIf Var0 = 2 Then    Call wawaji()ElseIf Var0 = 3 Then    Call wawajiandzengfu()ElseIf Var0 = 4 Then    Call autoLeftClick()ElseIf  Var0 = 5 Then    Call autoDuanZao()End If</code></pre><h2 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h2><p><a href="https://space.bilibili.com/3196036/channel/detail?cid=100704" target="_blank" rel="noopener">https://space.bilibili.com/3196036/channel/detail?cid=100704</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;windows或者Android(需要root权限)下按键精灵有时候写一些简单的脚本还是挺好用的。没有最好的语言，只有最适合的工具。在此记录下常用的基本语法。&lt;/p&gt;
&lt;h2 id=&quot;句柄及后台运行&quot;&gt;&lt;a href=&quot;#句柄及后台运行&quot; class=&quot;headerlink
      
    
    </summary>
    
    
    
      <category term="按键精灵" scheme="https://closer_laps.gitee.io/tags/%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>SQL语言学习笔记</title>
    <link href="https://closer_laps.gitee.io/2020/04/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/SQL/SQL%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://closer_laps.gitee.io/2020/04/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/SQL/SQL%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-03T06:31:27.000Z</published>
    <updated>2020-04-13T04:17:30.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、SQL简介"><a href="#一、SQL简介" class="headerlink" title="一、SQL简介"></a>一、SQL简介</h2><h3 id="1-1-SQL是什么"><a href="#1-1-SQL是什么" class="headerlink" title="1.1 SQL是什么"></a>1.1 SQL是什么</h3><blockquote><p>SQL是结构化查询语言，它是一种用于存储，操作和检索存储在关系数据库中的数据的计算机语言</p></blockquote><h3 id="1-2-SQL命令"><a href="#1-2-SQL命令" class="headerlink" title="1.2 SQL命令"></a>1.2 SQL命令</h3><h4 id="1）-DDL——数据定义语言"><a href="#1）-DDL——数据定义语言" class="headerlink" title="1） DDL——数据定义语言"></a>1） DDL——数据定义语言</h4><table><thead><tr><th>序号</th><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>CREATE</td><td>用于在数据库中创建新表，表视图或其他对象</td></tr><tr><td>2</td><td>ALTER</td><td>用于修改现有数据库对象，例如：表</td></tr><tr><td>3</td><td>DROP</td><td>用于删除整个表，数据库中的表或其他对象的视图</td></tr></tbody></table><h4 id="2）-DML——数据操纵语言"><a href="#2）-DML——数据操纵语言" class="headerlink" title="2） DML——数据操纵语言"></a>2） DML——数据操纵语言</h4><table><thead><tr><th>序号</th><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>SELECT</td><td>从一个或多个表中检索某些记录</td></tr><tr><td>2</td><td>INSERT</td><td>创建一条记录</td></tr><tr><td>3</td><td>UPDATE</td><td>用于修改(更新)记录</td></tr><tr><td>4</td><td>DELETE</td><td>删除记录</td></tr></tbody></table><h4 id="3）-DCL——数据控制语言"><a href="#3）-DCL——数据控制语言" class="headerlink" title="3） DCL——数据控制语言"></a>3） DCL——数据控制语言</h4><table><thead><tr><th>序号</th><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>GRANT</td><td>为用户提供权限</td></tr><tr><td>2</td><td>REVOKE</td><td>撤销用户授予的权限</td></tr></tbody></table><h3 id="1-3-数据的完整性"><a href="#1-3-数据的完整性" class="headerlink" title="1.3 数据的完整性"></a>1.3 数据的完整性</h3><p>每个RDBMS(关系型数据库)都存在以下类别的数据完整性</p><ul><li><p>实体完整性 - 表中没有重复的行。</p></li><li><p>域完整性 - 通过限制值的类型，格式或范围，为给定列强制执行有效条目。</p></li><li><p>参照完整性 - 其他记录使用(引用)导致这些行无法删除。</p></li><li><p>用户定义的完整性 - 实施一些不属于实体，域或参照完整性的特定业务规则</p></li></ul><h3 id="1-4-SQL约束"><a href="#1-4-SQL约束" class="headerlink" title="1.4 SQL约束"></a>1.4 SQL约束</h3><ul><li><p><a href="https://www.yiibai.com/sql/sql-not-null.html" target="_blank" rel="noopener">NOT NULL约束</a> - 确保列不能具有NULL值。</p></li><li><p><a href="https://www.yiibai.com/sql/sql-default.html" target="_blank" rel="noopener">默认值约束</a> - 在未指定列时为列提供默认值。</p></li><li><p><a href="https://www.yiibai.com/sql/sql-unique.html" target="_blank" rel="noopener">唯一约束</a> - 确保列中的所有值都不同。</p></li><li><p><a href="https://www.yiibai.com/sql/sql-primary-key.html" target="_blank" rel="noopener">主键</a> - 唯一标识数据库表中的每一行/记录。</p></li><li><p><a href="https://www.yiibai.com/sql/sql-foreign-key.html" target="_blank" rel="noopener">外键</a> - 唯一标识任何其他数据库表中的行/记录。</p></li><li><p><a href="https://www.yiibai.com/sql/sql-check.html" target="_blank" rel="noopener">检查约束</a> - CHECK约束确保列中的所有值都满足特定条件。</p></li><li><p><a href="https://www.yiibai.com/sql/sql-index.html" target="_blank" rel="noopener">索引</a> - 用于非常快速地从数据库创建和检索数据。</p></li></ul><h3 id="1-5-数据库范式"><a href="#1-5-数据库范式" class="headerlink" title="1.5 数据库范式"></a>1.5 数据库范式</h3><h4 id="1）-第一范式（1NF）"><a href="#1）-第一范式（1NF）" class="headerlink" title="1） 第一范式（1NF）"></a>1） 第一范式（1NF）</h4><ol><li>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</li><li>所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</li><li>简而言之，第一范式就是无重复的列。</li></ol><h4 id="2）-第二范式（2NF）"><a href="#2）-第二范式（2NF）" class="headerlink" title="2） 第二范式（2NF）"></a>2） 第二范式（2NF）</h4><ol><li>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。这个唯一属性列被称为主关键字或主键、主码。</li><li>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。</li><li>简而言之，第二范式就是非主属性<strong>部分依赖于主关键字</strong>。</li></ol><h4 id="3）-第三范式（3NF）"><a href="#3）-第三范式（3NF）" class="headerlink" title="3） 第三范式（3NF）"></a>3） 第三范式（3NF）</h4><ol><li>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。</li><li>例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。</li><li>简而言之，第三范式就是属性<strong>不依赖于其它非主属性</strong>。</li></ol><h3 id="1-6-运算符"><a href="#1-6-运算符" class="headerlink" title="1.6 运算符"></a>1.6 运算符</h3><p>假设变量a的值是：10，变量b的值是：20</p><h4 id="1）-SQL算术运算符"><a href="#1）-SQL算术运算符" class="headerlink" title="1） SQL算术运算符"></a>1） SQL算术运算符</h4><table><thead><tr><th>操作符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>+</td><td>加法，执行加法运算。</td><td>a + b = 30</td></tr><tr><td>-</td><td>减法，执行减法运算。</td><td>a + b = -10</td></tr><tr><td>*</td><td>除法，执行除法运算</td><td>a * b = 200</td></tr><tr><td>/</td><td>用左操作数除右手操作数</td><td>b / a = 2</td></tr><tr><td>%</td><td>用左手操作数除左手操作数并返回余数</td><td>b % a = 0</td></tr></tbody></table><h3 id="1-7-在MySQL中创建表的示例"><a href="#1-7-在MySQL中创建表的示例" class="headerlink" title="1.7 在MySQL中创建表的示例"></a>1.7 在MySQL中创建表的示例</h3><pre><code class="SQL">create database test default character set utf8 collate utf8_general_ci;CREATE TABLE regions (    region_id INT (11) AUTO_INCREMENT PRIMARY KEY,    region_name VARCHAR (25) DEFAULT NULL);CREATE TABLE countries (    country_id CHAR (2) PRIMARY KEY,    country_name VARCHAR (40) DEFAULT NULL,    region_id INT (11) NOT NULL,    FOREIGN KEY (region_id) REFERENCES regions (region_id) ON DELETE CASCADE ON UPDATE CASCADE);CREATE TABLE locations (    location_id INT (11) AUTO_INCREMENT PRIMARY KEY,    street_address VARCHAR (40) DEFAULT NULL,    postal_code VARCHAR (12) DEFAULT NULL,    city VARCHAR (30) NOT NULL,    state_province VARCHAR (25) DEFAULT NULL,    country_id CHAR (2) NOT NULL,    FOREIGN KEY (country_id) REFERENCES countries (country_id) ON DELETE CASCADE ON UPDATE CASCADE);CREATE TABLE jobs (    job_id INT (11) AUTO_INCREMENT PRIMARY KEY,    job_title VARCHAR (35) NOT NULL,    min_salary DECIMAL (8, 2) DEFAULT NULL,    max_salary DECIMAL (8, 2) DEFAULT NULL);CREATE TABLE departments (    department_id INT (11) AUTO_INCREMENT PRIMARY KEY,    department_name VARCHAR (30) NOT NULL,    location_id INT (11) DEFAULT NULL,    FOREIGN KEY (location_id) REFERENCES locations (location_id) ON DELETE CASCADE ON UPDATE CASCADE);CREATE TABLE employees (    employee_id INT (11) AUTO_INCREMENT PRIMARY KEY,    first_name VARCHAR (20) DEFAULT NULL,    last_name VARCHAR (25) NOT NULL,    email VARCHAR (100) NOT NULL,    phone_number VARCHAR (20) DEFAULT NULL,    hire_date DATE NOT NULL,    job_id INT (11) NOT NULL,    salary DECIMAL (8, 2) NOT NULL,    manager_id INT (11) DEFAULT NULL,    department_id INT (11) DEFAULT NULL,    FOREIGN KEY (job_id) REFERENCES jobs (job_id) ON DELETE CASCADE ON UPDATE CASCADE,    FOREIGN KEY (department_id) REFERENCES departments (department_id) ON DELETE CASCADE ON UPDATE CASCADE,    FOREIGN KEY (manager_id) REFERENCES employees (employee_id));CREATE TABLE dependents (    dependent_id INT (11) AUTO_INCREMENT PRIMARY KEY,    first_name VARCHAR (50) NOT NULL,    last_name VARCHAR (50) NOT NULL,    relationship VARCHAR (25) NOT NULL,    employee_id INT (11) NOT NULL,    FOREIGN KEY (employee_id) REFERENCES employees (employee_id) ON DELETE CASCADE ON UPDATE CASCADE);</code></pre><h2 id="二、SQL数据库操作"><a href="#二、SQL数据库操作" class="headerlink" title="二、SQL数据库操作"></a>二、SQL数据库操作</h2><p>语句<code>SHOW DATABASES;</code>用于查看可用数据库列表。</p><h3 id="2-1-Create-Database-语句"><a href="#2-1-Create-Database-语句" class="headerlink" title="2.1 Create Database 语句"></a>2.1 Create Database 语句</h3><p>SQL中<code>CREATE DATABASE</code>语句用于创建新的SQL数据库：</p><pre><code class="SQL">--语法格式CREATE DATABASE database_name;/*示例*/CREATE DATABASE testdb;/*查看*/mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || testdb             |+--------------------+3 rows in set</code></pre><p><strong>数据库名称(<code>database_name</code>)在<code>RDBMS(关系数据库管理系统)</code>中必须是唯一的</strong></p><h3 id="2-2-Drop-Database-语句"><a href="#2-2-Drop-Database-语句" class="headerlink" title="2.2 Drop Database 语句"></a>2.2 Drop Database 语句</h3><p>SQL中<code>DROP DATABASE</code>语句用于删除SQL模式中已存在的数据库。</p><pre><code class="SQL">--语法格式DROP DATABASE database_name;/*示例*/DROP DATABASE testdb;mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              |+--------------------+2 rows in set</code></pre><h3 id="2-3-Rename-Database-语句"><a href="#2-3-Rename-Database-语句" class="headerlink" title="2.3 Rename Database 语句"></a>2.3 Rename Database 语句</h3><p>当需要更改数据库的名称时，将使用SQL <code>RENAME DATABASE</code></p><pre><code class="SQL">RENAME DATABASE old_db_name TO new_db_name;ALTER DATABASE old_name MODIFY NAME = new_name;</code></pre><h3 id="2-4-Use-语句"><a href="#2-4-Use-语句" class="headerlink" title="2.4 Use 语句"></a>2.4 Use 语句</h3><p>如果SQL模式中有多个数据库，那么在开始操作之前，需要选择一个将执行操作的数据库。</p><p>SQL中的<code>USE</code>语句用于选择SQL模式中的任何现有数据库。</p><pre><code class="SQL">--语法格式USE database_name;/*示例*/mysql&gt; SHOW DATABASES;+--------------------+| Database           |+--------------------+| information_schema || mysql              || test               |+--------------------+3 rows in setUSE test;</code></pre><h2 id="三、表操作"><a href="#三、表操作" class="headerlink" title="三、表操作"></a>三、表操作</h2><h3 id="3-1-Create-Table"><a href="#3-1-Create-Table" class="headerlink" title="3.1 Create Table"></a>3.1 Create Table</h3><pre><code class="SQL">CREATE TABLE table_name(     column_name_1 data_type default value column_constraint,     column_name_2 data_type default value column_constraint,     ...,     table_constraint);</code></pre><ul><li>由table_name指定的表名在数据库中必须是唯一的</li><li>每个列定义由列名，列的<a href="https://www.yiibai.com/sql/sql-data-types.html" target="_blank" rel="noopener">数据类型</a>，默认值和一个或多个列约束组成</li><li>列的数据类型指定列可以存储的数据类型。 列的数据类型可以是数字，字符，日期等</li><li>列约束控制可以存储在列中的值的类型。 例如，<code>NOT NULL</code>约束确保列不包含<code>NULL</code>值。列可能有多个列约束。 例如，<code>users</code>表的<code>username</code>列可以同时具有<code>NOT NULL</code>和<a href="https://www.yiibai.com/sql/sql-unique-constraint.html" target="_blank" rel="noopener"><code>UNIQUE</code>约束</a>。</li><li>如果约束包含多个列，则使用表约束。 例如，如果表的主键包含两列，则在这种情况下，必须使用<code>PRIMARY KEY</code><a href="https://www.yiibai.com/sql/sql-primary-key.html" target="_blank" rel="noopener">主键约束</a>。</li></ul><pre><code class="SQL">/*示例*/CREATE TABLE courses (    course_id INT AUTO_INCREMENT PRIMARY KEY,    course_name VARCHAR(50) NOT NULL);/*courses课程表有两列：course_id和course_name;course_id是课程表的主键列。 每个表都有一个且只有一个主键，用于唯一标识表中的每一行course_id的数据类型是整数，由INT关键字表示。 此外，course_id列的值为AUTO_INCREMENT(自动递增)。表示当在courses表中插入新行而不提供course_id列的值时，数据库系统将为该列生成一个整数值course_name存储课程名称。 其数据类型是最大长度为50的可变长度的字符串(VARCHAR)。NOT NULL约束确保course_name列中不存储NULL值。*/</code></pre><pre><code class="SQL">--示例/*有了课程表。 要存储训练数据，请按如下方式创建名为training的新表。*/CREATE TABLE trainings (    employee_id INT,    course_id INT,    taken_date DATE,    PRIMARY KEY (employee_id , course_id));/*trainings表包含三列：employee_id列存储参加课程的员工的ID。course_id列存储员工所采用的课程。taken_date列存储员工参加课程的日期。因为trainings表的主键由两列组成：employee_id和course_id，所以必须使用PRIMARY KEY表约束。*/</code></pre><h3 id="3-2-Alter-Table"><a href="#3-2-Alter-Table" class="headerlink" title="3.2 Alter Table"></a>3.2 Alter Table</h3><p>使用SQL <code>ALTER TABLE</code>更改数据库中现有表的结构</p><p><code>ALTER TABLE</code>语句用于对现有表执行以下操作：</p><ul><li>使用<code>ADD</code>子句添加新列。</li><li>使用<code>CHANGE</code>子句用于修改表中的列名称和数据类型。</li><li>使用<code>ALTER SET DEFAULT</code>子句修改或删除表中指定列的默认值。</li><li>使用<code>MODIFY</code>子句修改列的属性，例如：约束，默认值等。</li><li>使用<code>DROP</code>子句删除列。</li></ul><h4 id="3-2-1-ALTER-TABLE-ADD列"><a href="#3-2-1-ALTER-TABLE-ADD列" class="headerlink" title="3.2.1 ALTER TABLE ADD列"></a>3.2.1 ALTER TABLE ADD列</h4><p>该子句的作用是向表中添加一个或多个列</p><pre><code class="SQL">--语法格式ALTER TABLE table_nameADD [COLUMN] column_name data_type column_constraint [AFTER existing_column];/*要向表中添加一个或多个列，需要执行以下步骤：首先，在ALTER TABLE子句之后指定要添加table_name，表示列所在的表。其次，将新列定义放在ADD子句之后。 如果要在表中指定新列的顺序，可以使用可选子句AFTER existing_column。*//* 以下语句将一个名称为credit_hours的新列添加到courses表中。*/ALTER TABLE courses ADD credit_hours INT NOT NULL;/*示例*/ALTER TABLE coursesADD COLUMN fee NUMERIC (10, 2) AFTER course_name,ADD COLUMN max_limit INT AFTER course_name;</code></pre><h4 id="3-2-2-ALTER-TABLE-CHANGE列名称和属性"><a href="#3-2-2-ALTER-TABLE-CHANGE列名称和属性" class="headerlink" title="3.2.2 ALTER TABLE CHANGE列名称和属性"></a>3.2.2 ALTER TABLE CHANGE列名称和属性</h4><p><code>CHANGE</code>子句用于修改表中的列名称和数据类型。</p><pre><code class="SQL">--语法格式ALTER TABLE table_nameCHANGE [COLUMN] column_name new_column_name column_properties;/*示例*/ALTER TABLE studentsCHANGE students_name names varchar(100) NOT NULL;</code></pre><h4 id="3-2-3-ALTER-TABLE-ALTER-SET-DEFAULT列"><a href="#3-2-3-ALTER-TABLE-ALTER-SET-DEFAULT列" class="headerlink" title="3.2.3 ALTER TABLE ALTER SET DEFAULT列"></a>3.2.3 ALTER TABLE ALTER SET DEFAULT列</h4><p><code>ALTER [COLUMN] SET</code>子句修改或删除表中指定列的默认值。</p><pre><code class="SQL">--语法格式ALTER TABLE table_nameALTER [COLUMN] column_name SET DEFAULT &#39;xxx&#39;;/*示例*/ALTER TABLE customersALTER city SET DEFAULT &#39;beijing&#39;;</code></pre><h4 id="3-2-4-ALTERE-TABLE-MODIFY列"><a href="#3-2-4-ALTERE-TABLE-MODIFY列" class="headerlink" title="3.2.4 ALTERE TABLE MODIFY列"></a>3.2.4 ALTERE TABLE MODIFY列</h4><p>MODIFY子句用于更改现有列的某些属性,例如，NOT NULL，UNIQUE和数据类型。</p><pre><code class="SQL">--语法格式ALTER TABLE table_nameMODIFY [COLUMN] column_name column_properties;/*示例*/ALTER TABLE students MODIFY name VARCHAR(20) NOT NULL;</code></pre><h4 id="3-2-5-ALTER-TABLE-DROP列"><a href="#3-2-5-ALTER-TABLE-DROP列" class="headerlink" title="3.2.5 ALTER TABLE DROP列"></a>3.2.5 ALTER TABLE DROP列</h4><p>当表的列已过时且未被任何其他数据库对象(如触发器，视图，存储过程和存储过程)使用时，将其从表中删除，请使用以下语法：</p><pre><code class="SQL">--语法格式ALTER TABLE table_nameDROP [COLUMN] column_name,DROP [COLUMN] column_name,.../*示例1-删除一列*/ALTER TABLE courses DROP fee;/*示例2-删除多列*/ALTER TABLE coursesDROP COLUMN max_limit,DROP COLUMN credit_hours;</code></pre><h3 id="3-3-DROP-TABLE"><a href="#3-3-DROP-TABLE" class="headerlink" title="3.3 DROP TABLE"></a>3.3 DROP TABLE</h3><p>使用SQL <code>DROP TABLE</code>语句删除数据库中的一个或多个表</p><pre><code class="SQL">--语法格式DROP TABLE [IF EXISTS] table_name;--为了防止删除不存在的表的错误，使用可选子句IF EXISTS。/*示例*/DROP TABLE students;/*删除多个表*/DROP TABLE IF EXISTS table_name1,table_name2,...;</code></pre><ul><li><p>DROP TABLE语句永久删除表的数据和结构，某些数据库系统要求表中的记录必须为空时才能从数据库中删除。这有助于防止意外删除仍在使用的表。</p></li><li><p>要删除表中的所有数据，可以使用<a href="https://www.yiibai.com/sql/sql-delete.html" target="_blank" rel="noopener">DELETE</a>或<a href="https://www.yiibai.com/sql/sql-truncate-table.html" target="_blank" rel="noopener">TRUNCATE TABLE</a>语句。</p></li><li><p>要删除由另一个表的外键约束引用的表，必须在删除表之前禁用或删除外部约束。</p></li></ul><h3 id="3-4-TURNCATE-TABLE"><a href="#3-4-TURNCATE-TABLE" class="headerlink" title="3.4 TURNCATE TABLE"></a>3.4 TURNCATE TABLE</h3><p>使用SQL <code>TRUNCATE TABLE</code>语句高效，快速地删除表中的所有数据</p><pre><code class="SQL">--语法格式TRUNCATE TABLE table_name;     /*快速删除大表中的所有行*/TRUNCATE TABLE IF EXISTS table_name1, table_name2, ...;/*示例*/TRUNCATE TABLE IF EXISTS students, teachers;</code></pre><h3 id="3-5-RENAME-TABLE"><a href="#3-5-RENAME-TABLE" class="headerlink" title="3.5 RENAME TABLE"></a>3.5 RENAME TABLE</h3><p>SQL RENAME TABLE用于更改表的名称。</p><pre><code class="SQL">--语法格式1ALTER TABLE table_nameRENAME TO new_table_name;--语法格式2RENAME TABLE old_table_name To new_table_name;/*示例1*/ALTER TABLE StudentsRENAME TO Student_bank;/*示例2*/RENAME TABLE Student_bank TO Students;</code></pre><h3 id="3-6-复制表-amp-临时表"><a href="#3-6-复制表-amp-临时表" class="headerlink" title="3.6 复制表&amp;临时表"></a>3.6 复制表&amp;临时表</h3><h4 id="1）-复制表"><a href="#1）-复制表" class="headerlink" title="1） 复制表"></a>1） 复制表</h4><p>如果要将SQL表复制到同一数据库中的另一个表中，可以使用<code>select</code>语句。</p><pre><code class="SQL">--语法格式1--从一个表复制到另一个表的语法如下：SELECT * INTO &lt;destination_table&gt; FROM &lt;source_table&gt;/*示例*/SELECT * INTO my_table_2 FROM my_table_1;</code></pre><blockquote><p>注意：<code>SELECT INTO</code>与<code>INSERT INTO</code>语句完全不同。</p></blockquote><h4 id="2）-临时表"><a href="#2）-临时表" class="headerlink" title="2） 临时表"></a>2） 临时表</h4><p>临时表可以在运行时创建，并且可以像普通表一样执行各种操作，这些临时表是在<code>tempdb</code>数据库中创建的。</p><p>根据行为和范围，有如下两种类型的临时表。1. 局部临时变量。 2. 全局临时变量。</p><p>① 局部临时变量</p><pre><code class="SQL">/*示例*//*局部临时变量表仅在当前连接时可用。 当用户与实例断开连接时，它会自动删除。 它以哈希(#)符号开头*/CREATE TABLE #local temp table (      User_id int,      User_name varchar (50),      User_address varchar (150)  )</code></pre><p>② 全局临时变量</p><pre><code class="SQL">/*全局临时表名称以双哈希(##)开头。 创建此表后，它就像一个永久表。 它始终为所有用户准备好，并且在撤消总连接之前不会被删除。*/cREATE TABLE ##new global temp table (      User_id int,      User_name varchar (50),      User_address varchar (150)  </code></pre><h2 id="四、数据操作语句"><a href="#四、数据操作语句" class="headerlink" title="四、数据操作语句"></a>四、数据操作语句</h2><h3 id="4-1-INSERT语句"><a href="#4-1-INSERT语句" class="headerlink" title="4.1 INSERT语句"></a>4.1 INSERT语句</h3><p>SQL提供了<code>INSERT</code>语句，用于将一行或多行插入表中。 <code>INSERT</code>语句用于：</p><ul><li>向表中插入一行</li><li>向表中插入多行</li><li>将行从一个表复制到另一个表中。</li></ul><pre><code class="SQL">--语法格式--插入一行,不建议省略column。INSERT INTO table1 (column1, column2,...)VALUES    (value1, value2,...);--插入多行INSERT INTO table1 (column1, column2,...)VALUES    (value1, value2,...),    (value1, value2,...),    (value1, value2,...);--从其他表复制行记录INSERT INTO table1 (column1, column2,...)SELECT    column1,    column2FROM    table2WHERE    condition1;/*示例1*/INSERT INTO temp(id,name)VALUES    (1,&#39;xiaoming&#39;);/*示例2*/INSERT INTO temp(id,name)VALUES    (2,&#39;xiaoli&#39;),    (3,&#39;xiaowang&#39;),    (4,&#39;xiaojun&#39;);/*示例3,需要先创建temp1表*/INSERT INTO temp1SELECT    id,nameFROM    tempWHERE    id=1;</code></pre><h3 id="4-2-Insert-Into-Select"><a href="#4-2-Insert-Into-Select" class="headerlink" title="4.2 Insert Into Select"></a>4.2 Insert Into Select</h3><p>在表中插入多行，可以将<code>Insert</code>与<code>select</code>语句结合使用。</p><pre><code class="SQL">INSERT INTO &quot;table 1&quot; (&quot;column1&quot;, &quot;column2&quot;,....)  SELECT &quot;column3&quot;, &quot;column4&quot;,....  FROM &quot;table2&quot;;</code></pre><p><code>INSERT INTO</code>语句还可以包含许多子句，如：<code>SELECT</code>，<code>GROUP BY</code>，<code>HAVING</code>以及<code>JOIN</code>和<code>ALIAS</code>。 因此，<code>insert into select</code>语句可能会有些复杂。</p><pre><code class="SQL">/*示例*/INSERT INTO store (store_name, sales, transaction_date)  SELECT store_name, sum (sales), transaction_date  FROM sales_information  GROUP BY store_name, transaction_date;</code></pre><h3 id="4-3-Update语句"><a href="#4-3-Update语句" class="headerlink" title="4.3 Update语句"></a>4.3 Update语句</h3><p>使用SQL <code>UPDATE</code>语句来修改表中现有行的数据</p><pre><code class="SQL">--语法格式UPDATE table_nameSET column1 = value1, column2 = value2[WHERE    condition];/*在上面的语法中首先，在SET子句中指定要修改的列。 SET子句中未列出的列的值不会被修改。其次，指定WHERE子句中要更新的行。第三，WHERE子句是可选的，如果省略它，表中的所有行都将受到影响。*/--语法格式2lcasewhen pred1 then result1when pred2 then result2...when predn then resultnelse result0end/*示例1--小于3000的工资改为3000*/UPDATE    workersSET    salary=3000WHERE    salary&lt;3000;/*示例2--确保子项dependents的last_name始终与employees表中的last_name匹配*/UPDATE dependentsSET last_name = (    SELECT        last_name    FROM        employees    WHERE        employee_id = dependents.employee_id);/*示例3--给工资超过100000美元的教师涨3%的工资，其余教师涨5%*/UPDATE instructorSET salary=case        when salary&lt;=100000 then salary * 1.05        else salary * 1.03end</code></pre><h3 id="4-4-UPDATE-amp-JOIN语句"><a href="#4-4-UPDATE-amp-JOIN语句" class="headerlink" title="4.4 UPDATE &amp; JOIN语句"></a>4.4 UPDATE &amp; JOIN语句</h3><p><code>UPDATE JOIN</code>可使用一个表和连接条件来更新另一个表。</p><pre><code class="SQL">/*假设有一个客户表，要用最新数据来更新客户表。可使用客户ID来连接在目标表和源表之间执行连接*//*语法格式*/UPDATE customer_table  INNER JOIN  Customer_table  ON customer_table.rel_cust_name = customer_table.cust_id  SET customer_table.rel_cust_name = customer_table.cust_name--示例/*在table2中共有3行，假设想要将table1中的值更新为table2中column1为21和31行的值。仅更新column2和column3的值。最简单和最常用的方法是在update语句中使用join子句并在update语句中使用多个表。*/UPDATE table1 t1LEFT JOIN  table2 t2ON t1.column1 = t2.column1SET t1.column2 = t2.column2,  t1.column3 = t2.column3where t1.column1 in(21,31);</code></pre><h3 id="4-5-更新日期数据"><a href="#4-5-更新日期数据" class="headerlink" title="4.5 更新日期数据"></a>4.5 更新日期数据</h3><p>要在SQL中更新日期和时间字段，则应使用以下查询。</p><pre><code class="SQL">--语法格式UPDATE tableSET Column_Name = &#39;YYYY-MM-DD HH:MM:SS&#39;  WHERE Id = value/*示例*/UPDATE table1SET EndDate = &#39;2019-03-16 00:00:00.000&#39;WHERE id in(1,3);</code></pre><h3 id="4-6-DELETE语句"><a href="#4-6-DELETE语句" class="headerlink" title="4.6 DELETE语句"></a>4.6 DELETE语句</h3><p>使用SQL <code>DELETE</code>语句删除表中的一行或多行。</p><pre><code class="SQL">--语法格式DELETEFROM    table_nameWHERE    condition;/*1. 提供要删除行的表名称(table_name)。2. 在WHERE子句中指定条件以标识需要删除的行记录。 如果省略WHERE子句，则将删除表中的所有行记录。 因此，应始终谨慎使用DELETE语句。*//*示例*/DELETE FROM dependentsWHERE    employee_id IN (100 , 101, 102);</code></pre><h2 id="五、SQL查询语句"><a href="#五、SQL查询语句" class="headerlink" title="五、SQL查询语句"></a>五、SQL查询语句</h2><p>SQL查询语句的通用形式：</p><pre><code class="SQL">select &lt;[distinct] c1，c2…&gt;from &lt;r1,……&gt;[where &lt;condition&gt;][group by &lt;c1，c2.…&gt; [having &lt;cond2&gt;]][order by&lt;c1[desc] ,[c2[desc|asc],…]&gt;</code></pre><p>SQL查询语句执行顺序：<br><code>from→where→group（aggregate）→having→select→order by</code></p><h3 id="5-1-SELECT语句"><a href="#5-1-SELECT语句" class="headerlink" title="5.1 SELECT语句"></a>5.1 SELECT语句</h3><p>除了<code>SELECT</code>和<code>FROM</code>子句之外，<code>SELECT</code>语句还可以包含许多其他子句，例如 -</p><ul><li><a href="https://www.yiibai.com/sql/sql-where.html" target="_blank" rel="noopener">WHERE</a> - 用于根据指定条件过滤数据</li><li><a href="https://www.yiibai.com/sql/sql-order-by.html" target="_blank" rel="noopener">ORDER BY</a> - 用于对结果集进行排序</li><li><a href="https://www.yiibai.com/sql/sql-limit.html" target="_blank" rel="noopener">LIMIT</a> - 用于限制返回的行</li><li><a href="https://www.yiibai.com/sql/sql-inner-join.html" target="_blank" rel="noopener">JOIN</a> - 用于查询来自多个相关表的数据</li><li><a href="https://www.yiibai.com/sql/sql-group-by.html" target="_blank" rel="noopener">GROUP BY</a> - 用于根据一列或多列对数据进行分组</li><li><a href="https://www.yiibai.com/sql/sql-having.html" target="_blank" rel="noopener">HAVING</a> - 用于过滤分组</li></ul><pre><code class="SQL">--语法格式/*查询表中所有的数据*/SELECT    *FROM    table_name/*示例*//*查询特定的列*/SELECT    employee_id,    first_name,    last_name,    hire_dateFROM    employees;/*执行简单的计算*//*以下查询使用FLOOR()，DATEDIFF()和CURRENT_DATE函数计算员工的服务年份。要计算服务年份，将DATEDIFF()函数的结果除以365。FLOOR()函数返回小于或等于数值表达式结果的最大整数。YoS是下面表达式的列别名。*/SELECT    employee_id,    first_name,    last_name,    FLOOR(DATEDIFF(NOW(), hire_date) / 365) AS YoSFROM    employees;</code></pre><h3 id="5-2-ORDER-BY排序"><a href="#5-2-ORDER-BY排序" class="headerlink" title="5.2 ORDER BY排序"></a>5.2 ORDER BY排序</h3><p>SQL <code>ORDER BY</code>子句根据指定的标准按升序或降序对结果集进行排序。</p><pre><code class="SQL">--语法格式SELECT    column1, column2FROM    table_nameORDER BY column1 ASC ,  --默认升序         column2 DESC;  --降序/*在此语法中，ORDER BY子句放在FROM子句之后。 如果SELECT语句包含WHERE子句，则ORDER BY子句必须放在WHERE子句之后。要指定要排序的列以及排序顺序的类型：1. 升序(使用：ASC表示，默认是升序)2. 降序(使用：DESC表示)*//*示例*/SELECT    employee_id,    first_name,    last_name,    hire_date,    salaryFROM    employeesORDER BY    first_name,    last_name DESC;</code></pre><h3 id="5-3-DISTINCT运算符"><a href="#5-3-DISTINCT运算符" class="headerlink" title="5.3 DISTINCT运算符"></a>5.3 DISTINCT运算符</h3><p>使用SQL <code>DISTINCT</code>运算符从结果集中删除重复数据项。</p><pre><code class="SQL">--语法格式SELECT DISTINCT    column1,column2......FROM    table1;/*DISTINCT运算符将所有NULL值视为相同的值。因此在结果集中，DISTINCT运算符只保留一个NULL值，并从结果集中删除其它的NULL值。*//*示例*/SELECT DISTINCT    job_id,    salaryFROM    employeesORDER BY    job_id,    salary DESC;</code></pre><h3 id="5-4-LIMIT子句"><a href="#5-4-LIMIT子句" class="headerlink" title="5.4 LIMIT子句"></a>5.4 LIMIT子句</h3><p>使用SQL <code>LIMIT</code>子句来限制<code>SELECT</code>语句返回的行数。</p><pre><code class="SQL">--语法格式--使用LIMIT和OFFSET子句。SELECT    column_listFROM    table1ORDER BY column_listLIMIT row_count OFFSET offset_count;/*1. row_count确定将返回的行数。2. OFFSET子句在开始返回行之前跳过偏移行。OFFSET子句是可选的。如果同时使用LIMIT和OFFSET子句，OFFSET会在LIMIT约束行数之前先跳过偏移行。*//*示例-跳过三行并获取接下来的五行*/SELECT    employee_id, first_name, last_nameFROM    employeesORDER BY first_nameLIMIT 5 OFFSET 3;/*示例2-获取薪水最高的前5名*/SELECT    employee_id, first_name, last_name, salaryFROM    employeesORDER BY salary DESCLIMIT 5;/*示例3-获取薪水排名第二高的人名*//*通过嵌套子查询，先查出第二高的是多少salary，然后查name*/SELECT    employee_id, first_name, last_name, salaryFROM    employeesWHERE    salary = (SELECT DISTINCT            salary        FROM            employees        ORDER BY salary DESC        LIMIT 1 , 1);</code></pre><h3 id="5-5-ALL-ANY-SOME语句"><a href="#5-5-ALL-ANY-SOME语句" class="headerlink" title="5.5 ALL,ANY,SOME语句"></a>5.5 ALL,ANY,SOME语句</h3><p>SQL <code>ALL</code>与集合中所有元素比较；<code>ANY</code>和<code>SOME</code>与集合中的某些元素比较。</p><pre><code class="SQL">/*示例1--找出所有 工资至少比生物系一个教师的工资要高 的教师*/SELECT nameFROM instructorWHERE salary &gt; SOME(SELECT salary                    FROM instructor                    WHERE dept_name=&#39;Biology&#39;);/*示例2--找出平均工资最高的系*/SELECT dept_nameFROM instructorGROUP BY dept_namehaving avg(salary) &gt;= ALL(SELECT avg(salary)                          FROM instructor                          GROUP BY dept_name);</code></pre><h3 id="5-6-BETWEEN-IN-LIKE-NULL"><a href="#5-6-BETWEEN-IN-LIKE-NULL" class="headerlink" title="5.6 BETWEEN | IN | LIKE | NULL"></a>5.6 BETWEEN | IN | LIKE | NULL</h3><h4 id="5-6-1-BETWEEN"><a href="#5-6-1-BETWEEN" class="headerlink" title="5.6.1 BETWEEN"></a>5.6.1 BETWEEN</h4><p>SQL <code>BETWEEN</code>运算符选择指定范围内的值。</p><pre><code class="SQL">--语法格式expression BETWEEN low AND high;expression NOT BETWEEN low AND high;/*示例*/SELECT    employee_id, first_name, last_name, hire_dateFROM    employeesWHERE    hire_date BETWEEN &#39;1999-01-01&#39; AND &#39;2000-12-31&#39;ORDER BY hire_date;/*1. BETWEEN运算符需要低值和高值。如果低值大于高值，将得到一个空的结果集。2. 2000-12-31默认为2000-12-31  00:00:00.000000*/</code></pre><h4 id="5-6-2-IN"><a href="#5-6-2-IN" class="headerlink" title="5.6.2 IN"></a>5.6.2 IN</h4><p>SQL <code>IN</code>运算符将列中的值与括号内的一组值进行比较。<br>要比较连续的值可用<code>LIMIT</code>，比如5-100。</p><pre><code class="SQL">--语法格式expression IN (value1,value2,...)expression NOT IN (value1, value2,...)/*示例--查找工作ID不是8,9或10的所有员工*/SELECT    employee_id, first_name, last_name, job_idFROM    employeesWHERE    job_id NOT IN (8, 9, 10)ORDER BY    job_id;</code></pre><h4 id="5-6-3-LIKE"><a href="#5-6-3-LIKE" class="headerlink" title="5.6.3 LIKE"></a>5.6.3 LIKE</h4><p>SQL <code>LIKE</code>运算符来测试表达式是否与模式匹配。</p><p>要构造模式，请使用两个SQL通配符：</p><ul><li><code>%</code> 百分号匹配零个，一个或多个字符。</li><li><code>_</code> 下划线符号匹配单个字符</li></ul><p>下表说明了一些模式及其含义：</p><table><thead><tr><th>模式</th><th>含义</th></tr></thead><tbody><tr><td>LIKE ‘Yii%’</td><td>匹配以Yii开始的字符串</td></tr><tr><td>LIKE ‘%su’</td><td>匹配以su结尾的字符串</td></tr><tr><td>LIKE ‘%ch%</td><td>匹配包含ch的字符串</td></tr><tr><td>LIKE ‘Luc_’</td><td>以Luc开始，后面只有一个字符，例如：Lucy，LucC等</td></tr><tr><td>LIKE ‘_cy’</td><td>以cy结尾，前面只有一个字符，例如：Lcy，ucy等</td></tr><tr><td>LIKE ‘%yiiBai_’</td><td>包含yiiBai，以任意数量的字符开头，最多以一个字符结尾。</td></tr><tr><td>LIKE ‘_yiiBai%’</td><td>包含yiiBai，最多以一个字符开头，以任意数量的字符结尾。</td></tr></tbody></table><pre><code class="SQL">--语法格式expression LIKE pattern/*如果要匹配通配符%或_，则必须使用反斜杠字符\来对其进行转义。 如果要使用其它的转义字符而不是反斜杠，可以在LIKE表达式中使用ESCAPE子句，如下所示：*/expression LIKE pattern ESCAPE escape_character/*示例--要查找名字以M开头但不以Ma开头的所有员工，请使用以下语句：*/SELECT    employee_id, first_name, last_nameFROM    employeesWHERE    first_name LIKE &#39;M%&#39;AND first_name NOT LIKE &#39;Ma%&#39;ORDER BY    first_name;</code></pre><h4 id="5-6-4-NULL"><a href="#5-6-4-NULL" class="headerlink" title="5.6.4 NULL"></a>5.6.4 NULL</h4><p>使用SQL <code>IS NULL</code>和<code>IS NOT NULL</code>运算符来测试表达式是否为<code>NULL</code>。</p><p><code>NULL</code>表示数据未知的值，在数据库中缺少数据。</p><pre><code class="SQL">--语法格式expression IS NULL;/*示例--查找具有电话号码的所有员工，请使用IS NOT NULL，如以下语句所示：*/SELECT    employee_id,    first_name,    last_name,    phone_numberFROM    employeesWHERE    phone_number IS NOT NULL;</code></pre><p>注意：</p><ol><li>不能使用比较运算符的等于(=)将值与<code>NULL</code>值进行比较</li><li><code>NULL</code>值是特殊的，任何与<code>NULL</code>值的比较都不会返回<code>true</code>或<code>false</code>，而是返回未知</li></ol><h3 id="5-7-SQL别名"><a href="#5-7-SQL别名" class="headerlink" title="5.7 SQL别名"></a>5.7 SQL别名</h3><p>SQL别名，包括表和列别名，使查询更短，更易理解。</p><p>使用关键词<code>AS</code>，可省略。</p><h4 id="5-7-1-列别名"><a href="#5-7-1-列别名" class="headerlink" title="5.7.1 列别名"></a>5.7.1 列别名</h4><pre><code class="SQL">/*示例*/SELECT    inv_no AS invoice_no,    amount,    due_date AS &#39;截止日期&#39;,    cust_no &#39;客户编号&#39;FROM    invoices;/*别名包含空格，必须使用单引号(&#39;)或双引号(&quot;)来包围别名。*/</code></pre><h4 id="5-7-2-表别名"><a href="#5-7-2-表别名" class="headerlink" title="5.7.2 表别名"></a>5.7.2 表别名</h4><pre><code class="SQL">--语法格式SELECT    d.department_nameFROM    departments AS d/*示例一--以下查询使用inner join子句从employees和departments表中选择数据。*/SELECT    employee_id,    first_name,    last_name,    e.department_id,    department_nameFROM    employees eINNER JOIN departments d ON d.department_id = e.department_idORDER BY    first_name;/*示例二--以下查询使用self-join将employee表自联接。*/SELECT    e.first_name AS employee,    m.first_name AS managerFROM    employees eLEFT JOIN employees m ON m.employee_id = e.manager_idORDER BY    manager;</code></pre><h3 id="5-8-JOIN操作"><a href="#5-8-JOIN操作" class="headerlink" title="5.8 JOIN操作"></a>5.8 JOIN操作</h3><p><code>SELECT</code>语句不仅能从单个表中查询数据，而且可以将多个表链接在一起。连接表的过程称为<code>Join</code>。</p><p>SQL提供了多种连接，如内连接，左连接，右连接，全外连接等。</p><h4 id="5-8-1-INNER-JOIN"><a href="#5-8-1-INNER-JOIN" class="headerlink" title="5.8.1 INNER JOIN"></a>5.8.1 INNER JOIN</h4><p>SQL <code>INNER JOIN</code>内连接子句来查询来自两个或多个表的数据。</p><p>内连接子句消除了与另一个表的行不匹配的行，相当于交集。</p><pre><code class="SQL">--语法格式SELECT  A.nFROM AINNER JOIN B ON B.n = A.n/*示例--employees表中的department_id列是将员工链接到departments表的外键列。*/SELECT    first_name,    last_name,    employees.department_id,    departments.department_id,    department_nameFROM    employees        INNER JOIN    departments ON departments.department_id = employees.department_idWHERE    employees.department_id IN (1, 2, 3);--语法格式/*INNER JOIN子句可以连接三个或更多表，只要它们具有关系，通常是外键关系。*/SELECT  A.nFROM AINNER JOIN B ON B.n = A.nINNER JOIN C ON C.n = A.n;/*示例--使用内部联接子句连接3个表：员工，部门和工作岗位，以获取在部门ID为：1,2和3中工作的员工的信息。*/SELECT    first_name, last_name, job_title, department_nameFROM    employees eINNER JOIN departments d ON d.department_id = e.department_idINNER JOIN jobs j ON j.job_id = e.job_idWHERE    e.department_id IN (1, 2, 3);</code></pre><h4 id="5-8-2-LEFT-JOIN"><a href="#5-8-2-LEFT-JOIN" class="headerlink" title="5.8.2 LEFT JOIN"></a>5.8.2 LEFT JOIN</h4><p>左连接将返回左表中的所有行，而不管右表中是否存在匹配的行，相当于AB交集后显示A。</p><pre><code class="SQL">--语法格式SELECT    A.nFROM    ALEFT JOIN B ON B.n = A.n;/*示例*/SELECT    c.country_name, c.country_id, l.country_id, l.street_address, l.cityFROM    countries cLEFT JOIN locations l ON l.country_id = c.country_idWHERE    c.country_id IN (&#39;US&#39;, &#39;UK&#39;, &#39;CN&#39;)/*右表中的非匹配行使用NULL值填充*/</code></pre><h4 id="5-8-3-FULL-OUTER-JOIN"><a href="#5-8-3-FULL-OUTER-JOIN" class="headerlink" title="5.8.3 FULL OUTER JOIN"></a>5.8.3 FULL OUTER JOIN</h4><p>完全外连接是左连接和右连接的组合。完整外连接包括连接表中的所有行，相当于并集。</p><p>如果连接表中的行不匹配，则使用NULL值填充。</p><pre><code class="SQL">--语法格式SELECT column_listFROM AFULL OUTER JOIN B ON B.n = A.n;/*示例--查找不存储任何水果的空篮子*/SELECT    basket_name,    fruit_nameFROM    fruitsFULL OUTER JOIN baskets ON baskets.basket_id = fruits.basket_idWHERE    fruit_name IS NULL;</code></pre><h4 id="5-8-4-Cross-Join"><a href="#5-8-4-Cross-Join" class="headerlink" title="5.8.4 Cross Join"></a>5.8.4 Cross Join</h4><p>SQL <code>Cross Join</code>交叉连接是一种连接操作，它生成两个或多个表的笛卡尔积。</p><pre><code class="SQL">--语法格式SELECT column_listFROM table_ACROSS JOIN table_B;/*在SQL中，假设A表有n行，而B表有m行，那么A和B表的交叉连接结果有n x m行*//*以下语句等同于使用上面的CROSS JOIN子句的语句*/SELECT    column_listFROM    table_A,table_B;</code></pre><h4 id="5-8-5-自连接"><a href="#5-8-5-自连接" class="headerlink" title="5.8.5 自连接"></a>5.8.5 自连接</h4><p>SQL自连接技术将表连接到自身。</p><p>我们将一张表连接到自身来评估同一个表中其他行的行。 要执行自联接，我们使用内连接或左连接子句。</p><p>因为同一张表在单个查询中出现两次，所以必须使用表别名。</p><pre><code class="SQL">--语法格式SELECT    column1,    column2,    column3,        ...FROM    table1 AINNER JOIN table1 B ON B.column1 = A.column2;/*在此语句中，使用INNER JOIN子句将table1连接到自身。 A和B是table1的表别名。 B.column1 = A.column2是连接条件。*//*示例一--查询每位员工的上级经理信息。*/SELECT    CONCAT(e.first_name, &#39; &#39;, e.last_name) as employee,    CONCAT(m.first_name, &#39; &#39;, m.last_name) as managerFROM    employees e        INNER JOIN    employees m ON m.employee_id = e.manager_idORDER BY manager;/*示例二--查询每位员工的上级经理信息。包含最高领导。*/SELECT    CONCAT(e.first_name, &#39; &#39;, e.last_name) as employee,    CONCAT(m.first_name, &#39; &#39;, m.last_name) as managerFROM    employees e        LEFT JOIN    employees m ON m.employee_id = e.manager_idORDER BY manager;</code></pre><h2 id="六、聚合函数"><a href="#六、聚合函数" class="headerlink" title="六、聚合函数"></a>六、聚合函数</h2><p>SQL聚合函数计算一组值并返回单个值。</p><p>因为聚合函数对一组值进行操作，所以它通常与<code>SELECT</code>语句的<code>GROUP BY</code>子句一起使用。<code>GROUP BY</code>子句将结果集划分为值分组，聚合函数为每个分组返回单个值。</p><p>以下是常用的SQL聚合函数：</p><ul><li>AVG() - 返回集合的平均值。</li><li>COUNT() - 返回集合中的项目数。</li><li>MAX() - 返回集合中的最大值。</li><li>MIN() - 返回集合中的最小值</li><li>SUM() - 返回集合中所有或不同值的总和。</li></ul><h3 id="6-1-AVG-（平均）"><a href="#6-1-AVG-（平均）" class="headerlink" title="6.1  AVG （平均）"></a>6.1  AVG （平均）</h3><p><code>AVG()</code>函数返回集合中的平均值</p><pre><code class="SQL">--语法格式AVG([ALL|DISTINCT] expression)/*ALL关键字计算所有值的平均值，而DISTINCT关键字强制函数仅对不同的值进行操作。默认情况下，使用ALL选项*//*示例1*/SELECT    AVG(salary)FROM    employees;SELECT    ROUND(AVG(DISTINCT salary), 2)FROM    employees;--使用ROUND函数，结果舍入为2位小数/*示例2 ： 与分组一起使用*/SELECT    department_id,    AVG(salary)FROM    employeesGROUP BY    department_id;/*示例3：与JOIN一起使用*/SELECT    e.department_id,    department_name,    AVG(salary)FROM    employees eINNER JOIN departments d ON d.department_id = e.department_idGROUP BY    e.department_id;/*示例4 ： 与HAVING一起使用*/SELECT    e.department_id,    department_name,    AVG(salary) AS avgsalaryFROM    employees eINNER JOIN departments d ON d.department_id = e.department_idGROUP BY    e.department_idHAVING avgsalary&lt;5000ORDER BY    AVG(salary) DESC;/*示例5： 子查询*/SELECT    AVG(employee_sal_avg)FROM    (        SELECT            AVG(salary) employee_sal_avg        FROM            employees        GROUP BY            department_id    ) t;</code></pre><h3 id="6-2-COUNT（统计）"><a href="#6-2-COUNT（统计）" class="headerlink" title="6.2 COUNT（统计）"></a>6.2 COUNT（统计）</h3><p>SQL <code>COUNT</code>函数来获取组中的项目数。它返回符合条件行数。</p><pre><code class="SQL">--语法格式COUNT ([ALL | DISTINCT] expression);/*COUNT(*)函数返回表中的行数，包括包含NULL值的行。*//*示例1 ： 与GROUP BY一起使用*/SELECT    e.department_id,    department_name,    COUNT(*)FROM    employees eINNER JOIN departments d ON d.department_id = e.department_idGROUP BY    e.department_id;/*示例2 ：与HAVING一起使用 *//*要按COUNT(*)函数的结果过滤分组，需要在COUNT(*)函数使用HAVING子句*/SELECT    e.department_id,    department_name,    COUNT(*)FROM    employees eINNER JOIN departments d ON d.department_id = e.department_idGROUP BY    e.department_idHAVING    COUNT(*) &gt; 5ORDER BY    COUNT(*) DESC;</code></pre><h3 id="6-3-SUM（求和）"><a href="#6-3-SUM（求和）" class="headerlink" title="6.3 SUM（求和）"></a>6.3 SUM（求和）</h3><pre><code class="SQL">--语法格式SUM([ALL|DISTINCT] expression)/*只能将SUM函数应用于数字列，SUM函数忽略NULL值。*//*示例1 ：与HAVING 以及 GROUP BY一起使用*/SELECT    e.department_id,    department_name,    SUM(salary)FROM    employees eINNER JOIN departments d ON d.department_id = e.department_idGROUP BY    e.department_idHAVING    SUM(salary) &gt; 30000ORDER BY    SUM(salary) DESC;</code></pre><h3 id="6-4-MAX-amp-MIN"><a href="#6-4-MAX-amp-MIN" class="headerlink" title="6.4 MAX &amp; MIN"></a>6.4 MAX &amp; MIN</h3><p>SQL <code>Max</code>函数查找组中的最大值，<code>Min</code>函数查找组中的最小值。。</p><pre><code class="SQL">--语法格式MAX(expression)MIN(expression)/*示例1 ： 用于子查询中*/SELECT    employee_id,    first_name,    last_name,    salaryFROM    employeesWHERE    salary = (        SELECT            MAX(salary)        FROM            employees    );/*示例2 ： 返回每个部门中员工的最高工资，并根据最高工资对结果集进行排序。*/SELECT    d.department_id,    department_name,    MAX(salary)FROM    employees eINNER JOIN departments d ON d.department_id = e.department_idGROUP BY    e.department_idORDER BY    MAX(salary) DESC;/*示例3 ： 获得具有最高薪水大于12000的员工的部门*/SELECT    d.department_id,    department_name,    MAX(salary)FROM    employees eINNER JOIN departments d ON d.department_id = e.department_idGROUP BY    e.department_idHAVING    MAX(salary) &gt; 12000;</code></pre><h3 id="6-6-Group-By子句"><a href="#6-6-Group-By子句" class="headerlink" title="6.6 Group By子句"></a>6.6 Group By子句</h3><p><code>GROUP BY</code>子句是<code>SELECT</code>语句的可选子句，它根据指定列中的匹配值将行组合成组，每组返回一行。</p><p>经常将<code>GROUP BY</code>与<code>MIN，MAX，AVG，SUM</code>或<code>COUNT</code>等聚合函数结合使用，以计算为每个分组提供信息的度量。</p><pre><code class="SQL">--语法格式SELECT    column1,    column2,    AGGREGATE_FUNCTION (column3)FROM    table1GROUP BY    column1,    column2;</code></pre><h3 id="6-6-HAVING"><a href="#6-6-HAVING" class="headerlink" title="6.6 HAVING"></a>6.6 HAVING</h3><p>SQL <code>HAVING</code>子句，该子句用于为<code>GROUP BY</code>子句汇总的组指定条件</p><pre><code class="SQL">--示例SELECT    column1,    column2,    AGGREGATE_FUNCTION (column3)FROM    table1GROUP BY    column1,    column2HAVING    group_condition;/*注：需要注意的是，在GROUP BY子句之前应用WHERE子句之后应用HAVING子句之前*/</code></pre><h2 id="七、高级查询"><a href="#七、高级查询" class="headerlink" title="七、高级查询"></a>七、高级查询</h2><h3 id="7-1-GROUPING-SETS运算符"><a href="#7-1-GROUPING-SETS运算符" class="headerlink" title="7.1 GROUPING SETS运算符"></a>7.1 GROUPING SETS运算符</h3><p>使用SQL <code>GROUPING SETS</code>运算符生成多个分组集</p><p>分组集是一组使用<code>GROUP BY</code>子句进行分组的列。 通常，单个聚合查询定义单个分组集</p><pre><code class="SQL">--语法格式SELECT    c1,    c2,    aggregate (c3)FROM    tableGROUP BY    GROUPING SETS (        (c1, c2),        (c1),        (c2),        ());</code></pre><h3 id="7-2-ROLLUP运算符"><a href="#7-2-ROLLUP运算符" class="headerlink" title="7.2 ROLLUP运算符"></a>7.2 ROLLUP运算符</h3><p><code>ROLLUP</code>是<code>GROUP BY</code>子句的扩展。<code>ROLLUP</code>选项允许包含表示小计的额外行，通常称为超级聚合行，以及总计行。</p><pre><code class="SQL">--语法格式SELECT    c1, c2, aggregate_function(c3)FROM    tableGROUP BY ROLLUP (c1, c2);/*ROLLUP假定输入列之间存在层次结构。 例如，如果输入列是(c1，c2)，则层次结构c1&gt; c2。ROLLUP生成考虑此层次结构有意义的所有分组集。 这就是为什么我们经常使用ROLLUP来生成小计和总计以用于报告目的*//*示例1*/SELECT    COALESCE(warehouse, &#39;All warehouses&#39;) AS warehouse,    SUM(quantity)FROM    inventoryGROUP BY ROLLUP (warehouse);/*示例2*/SELECT    warehouse, product, SUM(quantity)FROM    inventoryGROUP BY warehouse, ROLLUP (product);</code></pre><h3 id="7-3-UNION运算符-并集"><a href="#7-3-UNION运算符-并集" class="headerlink" title="7.3 UNION运算符 (并集)"></a>7.3 UNION运算符 (并集)</h3><p>使用SQL <code>UNION</code>组合来自多个查询的两个或多个结果集，<code>UNION</code>运算符将两个或多个<code>SELECT</code>语句的结果集合并到一个结果集中,相当于并集。</p><pre><code class="SQL">--语法格式SELECT    column1, column2FROM    table1UNION [ALL]SELECT    column3, column4FROM    table2;/*带ALL参数不去重，不带ALL则去重*/</code></pre><h3 id="7-4-INTERSECT-交"><a href="#7-4-INTERSECT-交" class="headerlink" title="7.4 INTERSECT(交)"></a>7.4 INTERSECT(交)</h3><p>SQL <code>INTERSECT</code>运算符，来获取两个或多个查询的交集。</p><pre><code class="SQL">--语法格式SELECT    idFROM    aINTERSECTSELECT    idFROM    b;</code></pre><p>要使用<code>INTERSECT</code>运算符，<code>SELECT</code>语句的列需要遵循以下规则：</p><ul><li>列的数据类型必须兼容。</li><li><code>SELECT</code>语句中的列数及其顺序必须相同</li></ul><h3 id="7-5-MINUS（差）"><a href="#7-5-MINUS（差）" class="headerlink" title="7.5 MINUS（差）"></a>7.5 MINUS（差）</h3><p>SQL <code>MINUS</code>运算符从另一个结果集中减去一个结果集。</p><pre><code class="SQL">--语法格式SELECT    idFROM    AMINUSSELECT    idFROM    B;/*示例*/SELECT    employee_idFROM    employeesMINUSSELECT    employee_idFROM    dependentsORDER BY employee_id;</code></pre><h3 id="7-6-子查询"><a href="#7-6-子查询" class="headerlink" title="7.6 子查询"></a>7.6 子查询</h3><pre><code class="SQL">/*示例1*/SELECT    employee_id, first_name, last_nameFROM    employeesWHERE    department_id NOT IN (SELECT            department_id        FROM            departments        WHERE            location_id = 1700)ORDER BY first_name , last_name;/*示例2*/SELECT    employee_id, first_name, last_name, salaryFROM    employeesWHERE    salary &gt; (SELECT            AVG(salary)        FROM            employees);</code></pre><h3 id="7-7-EXISTS运算符"><a href="#7-7-EXISTS运算符" class="headerlink" title="7.7 EXISTS运算符"></a>7.7 EXISTS运算符</h3><p><code>EXISTS</code>运算符用于指定子查询以测试行的存在。如果子查询包含任何行，则返回<code>true</code>。否则，它返回<code>false</code>。</p><pre><code class="SQL">--语法格式EXISTS (subquery)NOT EXISTS (subquery)/*示例--查找没有任何家属的员工*/SELECT    department_nameFROM    departments dWHERE    NOT EXISTS( SELECT            1        FROM            employees e        WHERE            salary &gt; 10000                AND e.department_id = d.department_id)ORDER BY department_name;</code></pre><h2 id="八、约束"><a href="#八、约束" class="headerlink" title="八、约束"></a>八、约束</h2><p>完整性约束保证授权用户对数据库所做的修改不会破坏数据的一致性。</p><h3 id="8-1-SQL主键约束"><a href="#8-1-SQL主键约束" class="headerlink" title="8.1 SQL主键约束"></a>8.1 SQL主键约束</h3><p>每个表都有一个且只有一个主键。 主键不接受<code>NULL</code>或重复值。如果主键由两列或更多列组成，则值可能在一列中重复，但主键中所有列的值组合必须是唯一的。</p><pre><code class="SQL">/*示例1 ： 主键由多列组成，用PRIMARY KEY定义主键*/CREATE TABLE project_assignments (    project_id INT,    employee_id INT,    join_date DATE NOT NULL,    CONSTRAINT pk_assgn PRIMARY KEY (project_id , employee_id));/*示例2-- 使用ALTER TABLE语句添加主键，将milestone_id列设置为主键。*/ALTER TABLE project_milestonesADD PRIMARY KEY (milestone_id);/*示例3-- 删除project_milestones表的主键约束*/ALTER TABLE project_milestonesDROP CONSTRAINT pk_milestone_id;</code></pre><h3 id="8-2-外键约束"><a href="#8-2-外键约束" class="headerlink" title="8.2 外键约束"></a>8.2 外键约束</h3><p>SQL外键<code>FOREIGN KEY</code>约束以强制表之间的关系。定义外码的主要目的是：让系统做参照完整性约束的检查。</p><p><strong>参照关系中外码的值必须在被参照关系中实际存在或为null</strong>。</p><pre><code class="SQL">--语法格式--默认地，外码参照被参照关系中的主码，即下面dept_name是外码，department是主码foreign key (dept_name) references department/*示例1--创建表时创建FOREIGN KEY约束*/CREATE TABLE project_milestones (    milestone_id INT AUTO_INCREMENT PRIMARY KEY,    project_id INT,    milestone_name VARCHAR(100),    FOREIGN KEY (project_id)        REFERENCES projects (project_id));--FOREIGN KEY子句将project_milestones表的project_id设置为引用project表的project_id列的外键。/*可以为FOREIGN KEY约束指定名称*/CREATE TABLE project_milestones (    milestone_id INT AUTO_INCREMENT PRIMARY KEY,    project_id INT,    milestone_name VARCHAR(100),    CONSTRAINT fk_project FOREIGN KEY (project_id)        REFERENCES projects (project_id));--fk_project是FOREIGN KEY约束的名称。/*使用ALTER来向现有表中添加FOREIGN KEY约束*/ALTER TABLE table_1ADD CONSTRAINT fk_name FOREIGN KEY (fk_key_column)   REFERENCES table_2(pk_key_column)/*删除外键约束*/ALTER TABLE table_nameDROP CONSTRAINT fk_name;</code></pre><h3 id="8-3-唯一约束"><a href="#8-3-唯一约束" class="headerlink" title="8.3 唯一约束"></a>8.3 唯一约束</h3><p>使用SQL <code>UNIQUE</code>约束强制列或一组列中值的唯一性</p><p><code>UNIQUE</code>约束定义了一个规则，该规则可防止存储在不参与主键的特定列中有重复值</p><p><code>UNIQUE</code>约束和<code>PRIMARY KEY</code>约束之间的区别：<br>比较项|<code>PRIMARY KEY</code>约束|<code>UNIQUE</code>约束<br>-|-|-<br>约束的数量|一个|多个<br>NULL值|不允许|允许</p><pre><code class="SQL">/*示例1--创建了UNIQUE约束作为列约束。*/CREATE TABLE users (    user_id INT AUTO_INCREMENT PRIMARY KEY,    username VARCHAR(255) NOT NULL UNIQUE,    password VARCHAR(255) NOT NULL);/*示例2--表约束语法创建的UNIQUE约束*/CREATE TABLE users (    user_id INT AUTO_INCREMENT PRIMARY KEY,    username VARCHAR(255) NOT NULL,    password VARCHAR(255) NOT NULL,    CONSTRAINT uc_username UNIQUE (username));/*示例3： 将UNIQUE约束添加到现有表*/ALTER TABLE usersADD CONSTRAINT uc_username UNIQUE(username);ALTER TABLE usersADD new_column data_type UNIQUE;/*示例4： 删除UNIQUE约束*/ALTER TABLE table_nameDROP CONSTRAINT unique_constraint_name;</code></pre><h3 id="8-4-NOT-NULL"><a href="#8-4-NOT-NULL" class="headerlink" title="8.4 NOT NULL"></a>8.4 NOT NULL</h3><p><code>NOT NULL</code>约束是一个列约束，它定义将列限制为仅具有非<code>NULL</code>值的规则。</p><pre><code class="SQL">--语法格式CREATE TABLE table_name(   ...   column_name data_type NOT NULL,   ...);/*示例1*/CREATE TABLE training (    employee_id INT,    course_id INT,    taken_date DATE NOT NULL,    PRIMARY KEY (employee_id , course_id));/*示例2--ALTER TABLE NOT NULL语句*/ALTER TABLE trainingMODIFY taken_date date NOT NULL;</code></pre><h3 id="8-5-检查约束"><a href="#8-5-检查约束" class="headerlink" title="8.5 检查约束"></a>8.5 检查约束</h3><p><code>CHECK</code>约束是SQL中的完整性约束，它允许指定列或列集中的值必须满足布尔表达式</p><pre><code class="SQL">--语法格式--CHECK约束由关键字CHECK后跟括号中的布尔表达式组成：CHECK(Boolean_expression)--如果要为CHECK约束指定名称，请使用以下语法：CONSTRAINT constraint_name CHECK(Boolean_expression)/*示例1--其products_price列中的值必须为正数*/CREATE TABLE products (    product_id INT PRIMARY KEY,    product_name VARCHAR(255) NOT NULL,    selling_price NUMERIC(10,2) CHECK (selling_price &gt; 0));/*示例2--分配CHECK约束名称*/CREATE TABLE products (    product_id INT PRIMARY KEY,    product_name VARCHAR(255) NOT NULL,    selling_price NUMERIC(10,2) CONSTRAINT positive_selling_price CHECK (selling_price &gt; 0));/*示例3： 涉及多个列 （表约束）*/CREATE TABLE products (    product_id INT PRIMARY KEY,    product_name VARCHAR (255) NOT NULL,    selling_price NUMERIC (10, 2) CHECK (selling_price &gt; 0),    cost NUMERIC (10, 2) CHECK (cost &gt; 0),    CONSTRAINT valid_selling_price  CHECK (selling_price &gt; cost));</code></pre><h3 id="8-6-域约束"><a href="#8-6-域约束" class="headerlink" title="8.6 域约束"></a>8.6 域约束</h3><p><code>create domain</code>域约束是完整性约束的最基本形式，可用于检测插入到数据库中的数据的合法性</p><pre><code class="SQL">--从现有数据类型可以创建新的域create domain Dollars as numeric(12，2) not nullcreate domain Pounds as numeric(12，2);create table instructor    (ID char(5) primary key,    name varchar(20),    dept name varchar(20),    salary Dollars,    comm Pounds    );</code></pre><h3 id="8-7-级联动作"><a href="#8-7-级联动作" class="headerlink" title="8.7 级联动作"></a>8.7 级联动作</h3><pre><code class="SQL">--语法格式create table course(    ...    foreign key(dept_name) references department        [on delete cascade]        [on update cascade]    ...);</code></pre><h2 id="九、视图与索引"><a href="#九、视图与索引" class="headerlink" title="九、视图与索引"></a>九、视图与索引</h2><h3 id="9-1-视图"><a href="#9-1-视图" class="headerlink" title="9.1 视图"></a>9.1 视图</h3><p>在某些情况下，让所有用户看到整个逻辑模型是不合适的，视图就提供了这种机制：向用户隐藏特定的数据。</p><p>SQL允许通过查询来定义“虚关系”，它在概念上包含查询的结果，但并不预先计算并存储。像这种作为虚关系对用户可见的关系称为视图（view）。</p><h4 id="9-1-1-创建视图"><a href="#9-1-1-创建视图" class="headerlink" title="9.1.1 创建视图"></a>9.1.1 创建视图</h4><pre><code class="SQL">--创建视图语法格式create view v as &lt;query expression〉/*1. &lt;query expression&gt;可以是任何合法的查询表达式v表示视图名2. 使用视图的目的：安全及易于使用3. 对应地，删除视图，使用命令：drop view v*//*示例--使用视图physics_fall_2009，找到所有于2009年秋季学期在Watson大楼开设的Physics课程*/select course_id, room_numberfrom physics_fall_2009where building=&#39;Watson&#39;;/*示例2--视图嵌套。*//*视图physics_fall_2009_Watson，列出于2009年秋季学期在Watson大楼开设的所有Physics课程的标识和教室号*/create view physics_fall_2009_watson asselect course_id，room_numberfrom physics_fall_2009where building=&#39;Watson&#39;；</code></pre><h4 id="9-1-2-更新视图"><a href="#9-1-2-更新视图" class="headerlink" title="9.1.2 更新视图"></a>9.1.2 更新视图</h4><p>一般地，如果定义视图的查询能满足下列条件，我们称SQL视图是可更新的（updatable），即视图上可以执行插入、更新或删除</p><ul><li><code>from</code>子句中只有一个数据库关系</li><li><code>select</code>子句中只包含关系的属性名，不包含任何表达式、聚集或<code>distinct</code>声明</li><li>任何没有出现在<code>select</code>子句中的属性可以取空值；即这些属性上没有<code>not null</code>约束，也不构成主码的一部分</li><li>查询中不含有<code>group by</code>或<code>having</code>子句</li></ul><pre><code class="SQL">--假设我们向视图faculty插入一条新元组，可写为：insert into faculty values(‘30765&#39;，‘Green&#39;，‘Music&#39;);</code></pre><h3 id="9-2-索引"><a href="#9-2-索引" class="headerlink" title="9.2 索引"></a>9.2 索引</h3><p>我们用<code>create index</code>命令，为关系中的某些属性创建索引，它允许数据库系统高效地找到关系中那些在索引属性上取给定值的元组，而不用扫描关系中的所有元组</p><pre><code class="SQL">--语法格式CREATE INDEX &lt;i_name&gt; ON &lt;table_name&gt; (&lt;attribute-list&gt;);/*示例*/CREATE INDEX ins_ID_name_index on instructor（ID，name）;--我们用`create unique index`命令，为关系中的某些属性创建唯一索引CREATE UNIQUE INDEX uni_stu_index on student（ID）;--我们用`drop index`命令，删除一个索引DROP INDEX &lt;i_name&gt;</code></pre><h2 id="十、事务"><a href="#十、事务" class="headerlink" title="十、事务"></a>十、事务</h2><p>事务（transaction）由查询和更新语句的序列组成。SQL标准规定当一条SQL语句被执行，就隐式地开始了一个事务。</p><p>下列SQL语句之一会结束一个事务：</p><ul><li><code>Commit work</code>：提交当前事务，也就是将该事务所做的更新在数据库中持久保存。在事务被提交后，一个新的事务自动开始</li><li><code>Rollback work</code>：回滚当前事务，即撤销该事务中所有SQL语句对数据库的更新。这样，数据库就恢复到执行该事务第一条语句之前的状态</li></ul><h2 id="十一、断言及触发器"><a href="#十一、断言及触发器" class="headerlink" title="十一、断言及触发器"></a>十一、断言及触发器</h2><h3 id="11-1-断言"><a href="#11-1-断言" class="headerlink" title="11.1 断言"></a>11.1 断言</h3><p>断言（assertion）是表达要求数据库永远满足的条件的谓词（复杂check条件）</p><p>SQL中的断言形式如下：</p><pre><code class="SQL">create assertion &lt;assertion_name&gt; check &lt;predicate&gt;</code></pre><p>创建了某断言之后，系统将检查它的合法性，并对每一个可能破坏该断言的数据库更新进行检测<br><strong>这种检测会产生大量的开销，因此断言的使用应非常谨慎</strong></p><pre><code class="SQL">--例2，每位教师不能在同一个学期的同一个时间段在两个不同的教室授create assertion ins_teaches_constraint check not exists(select ID，name,section_id,semester,year,time_slot_id,    count(distinct building,room,number)from instructor natural join teaches natural join sectiongroup by (ID,name,section_id,semester,year,time_slot_id)having count(building,room_number)&gt;1)</code></pre><h3 id="11-2-触发器"><a href="#11-2-触发器" class="headerlink" title="11.2 触发器"></a>11.2 触发器</h3><p>触发器（trigger）是由数据库更新操作引起的被系统自动执行的语句</p><p>设计触发器必须：</p><ul><li>指明触发器被执行的条件</li><li>指明触发器执行时所做的具体操作</li></ul><pre><code class="SQL">--例，使用触发器来确保关系section中属性time_slot_id的参照完整性create trigger timeslot_check1 after insert on section         referencing new row as nrow         for each row         when (nrow.time_slot_id not in                (select time_slot_id from                 time_slot))/*time_slot中不存在该time_slot_id*/begin rollback end;--例，某种物品库存量小到一定程度就发订货单或打开报警灯create trigger reorder_trigger after update of level on inventory    referencing old row as orow, new row as nrow    for each row    when nrow.level&lt;=/*保证修改后库存量低于最小库存量,更新前库存大于最小库存*/            (select level/*目的是只更新一次*/            from minlevel            where minlevel.item=nrow.item) and orow.level&gt;                    (select level                    from minlevel                    where minlevel.item= orow.item)begin    insert into orders            (select item, amount             from reorder             where reorder.item= orow.item)end</code></pre><h2 id="十二、-安全性"><a href="#十二、-安全性" class="headerlink" title="十二、 安全性"></a>十二、 安全性</h2><h3 id="12-1-权限管理"><a href="#12-1-权限管理" class="headerlink" title="12.1 权限管理"></a>12.1 权限管理</h3><p>数据库系统级</p><ul><li><strong>验证</strong>和<strong>授权</strong>机制使得特定用户存取特定数据</li><li>本章中主要讨论授权机制</li></ul><p>对数据的授权包括：</p><ul><li>读权限 允许读，但不允许更新数据</li><li>插入权限 允许插入新数据，但不允许更新现有数据</li><li>修改权限 允许修改，但不允许删除数据</li><li>删除权限 允许删除数据</li></ul><p>对修改数据库模式的授权包括：</p><ul><li>索引权限-允许创建和删除索引</li><li>资源权限-允许创建新关系</li><li>修改权限-允许增加或删除关系的属性</li><li>删除权限-允许删除关系</li></ul><pre><code class="SQL">--语法格式--grant语句用于授权GRANT &lt;privilege list&gt;ON &lt;relation name or view name&gt; TO &lt;user list&gt;;</code></pre><p><code>privilege list</code>可有以下选择:</p><ol><li>select：允许读关系，或查询视图<pre><code> 例如：授予用户U1，U2，Ua对instructor关系的select权限： `grant select on instructor to U1,U2,U3`</code></pre></li><li><code>insert</code>：允许插入元组</li><li><code>update</code>：允许修改元组</li><li><code>delete</code>：允许删除元组</li><li><code>references</code>：创建关系时允许声明外键</li><li><code>all privileges</code>：所有权限</li><li><code>with grant option</code>：允许用户把被授予的权限再转授给其他用户<pre><code> 例如：授予U1，对instructor的select权限并允许U1，将此权限授予其他用户 `grant select on instructor to U1 with grant option`</code></pre></li></ol><pre><code class="SQL">--收回权限--revoke语句用于回收权限REVOKE &lt;privilege list&gt; ON &lt;relation name or view name&gt;FROM &lt;user list&gt; [ restrict | cascade ]/*示例*/revoke select on instructor from U1,,U2,U3 cascade/*从一用户收回权限可能导致其他用户也失去该权限，称为级联回收*/--指定restrict可以阻止级联回收revoke select on instructor from U1,U2,U3 restrict/*如果要求级联回收，则带有restrict的revoke命令将会失败*/</code></pre><h3 id="12-2-审计跟踪"><a href="#12-2-审计跟踪" class="headerlink" title="12.2 审计跟踪"></a>12.2 审计跟踪</h3><p>分为语句审计和对象审计</p><pre><code class="SQL">--语法格式-语句审计AUDIT &lt;st-opt&gt; [BY &lt;users&gt;][BY SESSION | ACCESS][WHENEVER SUCCESSFUL | WHENEVER NOT SUCCESSFUL]--当BY &lt;users&gt;缺省，对所有用户审计--BY SESSION每次会话期间，相同类型的需审计的SQL语句仅记录一次--常用的&lt;st-opt&gt;:table，view，role，index，……--取消审计：NOAUDIT…（其余同audit语句）/*示例--审计用户scott每次成功执行有关table的语句。*/audit table by scott by access whenever successful;</code></pre><pre><code class="SQL">--语法格式-对象审计AUDIT &lt;obj-opt&gt; ON &lt;obj&gt;|DEFAULT[BY SESSION | BY ACCESS][WHENEVER SUCCESSFUL | WHENEVER NOT SUCCESSFUL]--obj-opt:insert，delete，update，select，grant，…--实体审计对所有的用户起作用--ON&lt;obj&gt;指出审计对象表、视图名--ONDEFAULT 对其后创建的所有对象起作用--取消审计：NOAUDIT…/*示例--审计所有用户对student表的delete和update操作*/audit delete,update on student;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、SQL简介&quot;&gt;&lt;a href=&quot;#一、SQL简介&quot; class=&quot;headerlink&quot; title=&quot;一、SQL简介&quot;&gt;&lt;/a&gt;一、SQL简介&lt;/h2&gt;&lt;h3 id=&quot;1-1-SQL是什么&quot;&gt;&lt;a href=&quot;#1-1-SQL是什么&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="SQL" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/SQL/"/>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="SQL" scheme="https://closer_laps.gitee.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>使用python控制鼠标和键盘</title>
    <link href="https://closer_laps.gitee.io/2020/03/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/%E4%BD%BF%E7%94%A8python%E6%8E%A7%E5%88%B6%E9%BC%A0%E6%A0%87%E5%92%8C%E9%94%AE%E7%9B%98/"/>
    <id>https://closer_laps.gitee.io/2020/03/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/%E4%BD%BF%E7%94%A8python%E6%8E%A7%E5%88%B6%E9%BC%A0%E6%A0%87%E5%92%8C%E9%94%AE%E7%9B%98/</id>
    <published>2020-03-27T13:05:48.000Z</published>
    <updated>2020-03-29T11:51:48.690Z</updated>
    
    <content type="html"><![CDATA[<p>使用pyautogui这个库，来达到和按键精灵差不多的效果。可以运行在多平台。</p><p>PyAutoGUI的五个特点:</p><ul><li>移动鼠标点击或输入其他应用程序的窗口。</li><li>按键发送给应用程序(例如,填写表格)。</li><li>截图,给定一个图像(例如,一个按钮或复选框),在屏幕上找到它。</li><li>定位应用程序的窗口,和移动,调整,最大化、最小化、关闭(仅适用于windows,目前)</li><li>显示消息框进行用户交互,而您的GUI自动化脚本运行。</li></ul><h2 id="一：-安装pyautogui库"><a href="#一：-安装pyautogui库" class="headerlink" title="一： 安装pyautogui库"></a>一： 安装pyautogui库</h2><p><code>pip3 install pyautogui</code></p><p><strong>ubuntu系统，可能需要<code>sudo apt-get install python3-tk python3-dev</code>，如果安装不上，请参考<a href="https://pyautogui.readthedocs.io/en/latest/install.html" target="_blank" rel="noopener">官方文档如何安装</a></strong></p><h2 id="二：-使用方法"><a href="#二：-使用方法" class="headerlink" title="二： 使用方法"></a>二： 使用方法</h2><p><a href="https://pyautogui.readthedocs.io/en/latest/" target="_blank" rel="noopener">官方文档</a></p><h3 id="2-1-常规功能"><a href="#2-1-常规功能" class="headerlink" title="2.1 常规功能"></a>2.1 常规功能</h3><pre><code class="py">&gt;&gt;&gt; import pyautogui&gt;&gt;&gt; pyautogui.position()  # 当前鼠标 x， y坐标(968, 56)&gt;&gt;&gt; pyautogui.size()  # 当前屏幕分辨率宽和高(1920, 1080)&gt;&gt;&gt; pyautogui.onScreen(x, y)  # 鼠标坐标x且y，在屏幕内True&gt;&gt;&gt; pyautogui.PAUSE = 2.5 # 在每次PyAutoGUI调用之后设置2.5秒的暂停：</code></pre><h3 id="2-2-鼠标功能"><a href="#2-2-鼠标功能" class="headerlink" title="2.2 鼠标功能"></a>2.2 鼠标功能</h3><pre><code class="py"># XY坐标在屏幕的左上角具有0、0的原点。X向右增加，Y向向下增加。# 移动鼠标&gt;&gt;&gt; pyautogui.moveTo(x, y, duration=num_seconds)  # num秒内移动鼠标到XY坐标&gt;&gt;&gt; pyautogui.move(xOffset, yOffset, duration=num_seconds)  # 相对于当前位置，鼠标移动XY# 如果duration为0或未指定，则立即移动，duration以秒为单位。# 例： pyautogui.move(300, 200, 2)# 拖拽鼠标&gt;&gt;&gt; pyautogui.dragTo(x, y, duration=num_seconds)  # 拖拽鼠标到XY&gt;&gt;&gt; pyautogui.drag(xOffset, yOffset, duration=num_seconds)  # 相对于当前位置，鼠标拖拽XY# 例： pyautogui.drag(300, 200, 2)# 点击鼠标# 调用click()即在鼠标的当前位置左键单击一次，但是关键字参数可以改变它：&gt;&gt;&gt; pyautogui.click(x=moveToX, y=moveToY, clicks=num_of_clicks, interval=secs_between_clicks, button=&#39;left&#39;)# clicks关键字控制点击次数;interval关键字控制点击时间间隔。# 该button关键字参数可以是&#39;left&#39;，&#39;middle&#39;或&#39;right&#39;。即左击，中击，右击。# 例：pyautogui.click(300, 200,clicks=2,interval=3,button=&#39;right&#39;)# 右击，中击及双、三击&gt;&gt;&gt; pyautogui.rightClick(x=moveToX, y=moveToY)&gt;&gt;&gt; pyautogui.middleClick(x=moveToX, y=moveToY)&gt;&gt;&gt; pyautogui.doubleClick(x=moveToX, y=moveToY) # 双击&gt;&gt;&gt; pyautogui.tripleClick(x=moveToX, y=moveToY) # 三击# 鼠标中键滚动# 正向滚动将向上滚动，负向滚动将向下滚动：&gt;&gt;&gt; pyautogui.scroll(amount_to_scroll, x=moveToX, y=moveToY)# 例： pyautogui.scroll(-10) # 鼠标按下或者弹起：&gt;&gt;&gt; pyautogui.mouseDown(x=moveToX, y=moveToY, button=&#39;left&#39;)&gt;&gt;&gt; pyautogui.mouseUp(x=moveToX, y=moveToY, button=&#39;left&#39;)</code></pre><h3 id="2-3-键盘功能"><a href="#2-3-键盘功能" class="headerlink" title="2.3 键盘功能"></a>2.3 键盘功能</h3><pre><code class="py"># 在键盘光标所在的位置按键。# 输入字符串&gt;&gt;&gt; pyautogui.write(&#39;Hello world!\n&#39;, interval=secs_between_keys)  # 用于输入文本，回车换行# interval是字母输入间隔时间# 依次按下键盘# 也可以传递键名列表：&gt;&gt;&gt; pyautogui.write([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;left&#39;, &#39;backspace&#39;, &#39;enter&#39;, &#39;f1&#39;], interval=secs_between_keys)# 键名的完整列表在pyautogui.KEYBOARD_KEYS中。# 例： pyautogwrite([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], interval=0.25)# 多次按键&gt;&gt;&gt; pyautogui.press([&#39;left&#39;, &#39;left&#39;, &#39;left&#39;])# 或者你可以设置按多少次左键 :&gt;&gt;&gt; pyautogui.press(&#39;1&#39;, presses=3)# 键盘快捷键（如Ctrl-S或Ctrl-Shift-1）可以通过将键名列表传递给来完成hotkey()：&gt;&gt;&gt; pyautogui.hotkey(&#39;ctrl&#39;, &#39;c&#39;)  # ctrl-c to copy&gt;&gt;&gt; pyautogui.hotkey(&#39;ctrl&#39;, &#39;v&#39;)  # ctrl-v to paste# 键盘按下和弹起可以分别调用：&gt;&gt;&gt; pyautogui.keyDown(key_name)&gt;&gt;&gt; pyautogui.keyUp(key_name)</code></pre><h3 id="2-4-消息框的功能"><a href="#2-4-消息框的功能" class="headerlink" title="2.4 消息框的功能"></a>2.4 消息框的功能</h3><pre><code class="py"># PyAutoGUI利用PyMsgBox消息框功能提供跨平台的,纯Python方法显示javascript式消息框。 有四个消息框功能。# alert显示()函数 &gt;&gt;&gt; alert(text=&#39;&#39;, title=&#39;&#39;, button=&#39;OK&#39;)# 显示一个简单的消息框,文本和一个OK按钮。 返回文本的按钮点击。# 例：pyautogui.alert(&#39;这将显示一些文本和OK按钮.&#39;)# confirm确认()函数 &gt;&gt;&gt; confirm(text=&#39;&#39;, title=&#39;&#39;, buttons=[&#39;OK&#39;, &#39;Cancel&#39;])# 显示一个消息框好和取消按钮。 数量和文本的按钮可以定制。 返回文本的按钮点击。# 例： pyautogui.confirm(&#39;显示文本和OK及取消键。&#39;)# prompt提示()函数 &gt;&gt;&gt; prompt(text=&#39;&#39;, title=&#39;&#39; , default=&#39;&#39;)# 显示一个消息框,文本输入,OK和Cancel按钮。 返回输入的文本,或没有,如果点击取消。# 例： pyautogui.prompt(text=&#39;显示文本输入框，OK及取消键&#39;, title=&#39;标题&#39; , default=&#39;&#39;)# password密码()函数 &gt;&gt;&gt; password(text=&#39;&#39;, title=&#39;&#39;, default=&#39;&#39;, mask=&#39;*&#39;)# 显示一个消息框,文本输入,OK和Cancel按钮。 输入字符显示为 * 。 返回输入的文本,或没有,如果点击取消。# 例： pyautogui.password(text=&#39;显示文本输入框，OK及取消键&#39;, title=&#39;标题&#39; , default=&#39;默认密码&#39; , mask=&#39;*&#39;)</code></pre><h3 id="2-5-屏幕截图功能"><a href="#2-5-屏幕截图功能" class="headerlink" title="2.5 屏幕截图功能"></a>2.5 屏幕截图功能</h3><p>在ubuntu系统中支持的不是很好，比较复杂。<br><a href="https://pyautogui.readthedocs.io/en/latest/screenshot.html" target="_blank" rel="noopener">具体参照官方文档</a></p><p>还可以根据色块或图片返回对应的坐标。这个就比较强大啦。比如可以制作自动游戏脚本等等。</p><h2 id="三：-实战演练"><a href="#三：-实战演练" class="headerlink" title="三： 实战演练"></a>三： 实战演练</h2><h3 id="3-1-实时显示鼠标位置"><a href="#3-1-实时显示鼠标位置" class="headerlink" title="3.1 实时显示鼠标位置"></a>3.1 实时显示鼠标位置</h3><pre><code class="py">#!/usr/bin/python3# -*- coding: utf-8 -*-import pyautogui, sysprint(&#39;Press Ctrl-C to quit.&#39;)try:    while True:        x, y = pyautogui.position()        positionStr = &#39;X: &#39; + str(x).rjust(4) + &#39; Y: &#39; + str(y).rjust(4)        print(positionStr, end=&#39;&#39;)        print(&#39;\b&#39; * len(positionStr), end=&#39;&#39;, flush=True)except KeyboardInterrupt:    print(&#39;\n&#39;)</code></pre><h3 id="3-2-画图软件中画出方形螺旋图"><a href="#3-2-画图软件中画出方形螺旋图" class="headerlink" title="3.2 画图软件中画出方形螺旋图"></a>3.2 画图软件中画出方形螺旋图</h3><pre><code class="py">#!/usr/bin/python3# -*- coding: utf-8 -*-import pyautoguidistance = 200while distance &gt; 0:        pyautogui.drag(distance, 0, duration=0.5)   # move right        distance -= 5        pyautogui.drag(0, distance, duration=0.5)   # move down        pyautogui.drag(-distance, 0, duration=0.5)  # move left        distance -= 5        pyautogui.drag(0, -distance, duration=0.5)  # move up</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用pyautogui这个库，来达到和按键精灵差不多的效果。可以运行在多平台。&lt;/p&gt;
&lt;p&gt;PyAutoGUI的五个特点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移动鼠标点击或输入其他应用程序的窗口。&lt;/li&gt;
&lt;li&gt;按键发送给应用程序(例如,填写表格)。&lt;/li&gt;
&lt;li&gt;截图,
      
    
    </summary>
    
    
      <category term="python" scheme="https://closer_laps.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://closer_laps.gitee.io/tags/python/"/>
    
      <category term="按键精灵" scheme="https://closer_laps.gitee.io/tags/%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>【转】 利用爬虫和树莓派打造萝莉音天气闹钟</title>
    <link href="https://closer_laps.gitee.io/2020/03/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/%E3%80%90%E8%BD%AC%E3%80%91%C2%96%E5%88%A9%E7%94%A8%E7%88%AC%E8%99%AB%E5%92%8C%E6%A0%91%E8%8E%93%E6%B4%BE3%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AF%AD%E9%9F%B3%E5%A4%A9%E6%B0%94%E9%97%B9%E9%92%9F/"/>
    <id>https://closer_laps.gitee.io/2020/03/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/%E3%80%90%E8%BD%AC%E3%80%91%C2%96%E5%88%A9%E7%94%A8%E7%88%AC%E8%99%AB%E5%92%8C%E6%A0%91%E8%8E%93%E6%B4%BE3%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AF%AD%E9%9F%B3%E5%A4%A9%E6%B0%94%E9%97%B9%E9%92%9F/</id>
    <published>2020-03-21T11:35:24.000Z</published>
    <updated>2020-03-21T12:23:59.754Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://zhuanlan.zhihu.com/p/24983204?refer=woodenrobot" target="_blank" rel="noopener">原帖地址</a></p></blockquote><h2 id="一、-前期准备"><a href="#一、-前期准备" class="headerlink" title="一、 前期准备"></a>一、 前期准备</h2><ol><li>树莓派一个</li><li>小音箱一对</li></ol><p><strong>获取所在位置天气</strong></p><p>这里选择墨迹天气获取实时天气信息，地址：</p><p><a href="http://tianqi.moji.com/" target="_blank" rel="noopener">http://tianqi.moji.com/</a></p><p>进入墨迹天气的页面，墨迹天气会根据你的ip加载相应地区的天气。</p><p>这次我们主要抓取温度、天气、湿度、风力、空气质量和天气提示这几个数据。</p><p>这种小爬虫我们就使用requests和BeautifulSoup这两个超级好用的库可以快速实现。</p><h2 id="二、-环境"><a href="#二、-环境" class="headerlink" title="二、 环境"></a>二、 环境</h2><p>首先树莓派安装python3，python3-pip和requests、beautifulsoup4两个库及mplayer软件。</p><pre><code class="sh">sudo apt install python3 -ysudo apt install python3-pip -ypip3 install requestspip3 install beautifulsoup4sudo apt-get install mplayer -y</code></pre><p>至于Requests和Beautiful Soup的用法这里就先不多说了，大家可以去看他们的中文文档。</p><ol><li><a href="https://zh_cn/en/master/zh_CN/latest/index/" target="_blank" rel="noopener">Requests中文wendnag</a></li><li><a href="https://beautifulsoup.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">Beautiful Soup中文文档</a></li></ol><p><strong>使用mplayer实现语音播放,通过以下命令安装mplayer:</strong></p><p>用法很简单输入以下命令即可播放本地音乐：</p><p><code>mplayer \xxx\xxx\xxx.mp3(绝对地址)</code></p><p>如果是在线音乐也可以用mplayer直接通过URL播放：</p><p><code>mplayer &quot;URl&quot;(URL外面一定要用双引号圈起来)</code></p><h2 id="三、-文字转语音"><a href="#三、-文字转语音" class="headerlink" title="三、 文字转语音"></a>三、 文字转语音</h2><p>刚开始想通过python的库实现本地文字转语音，在windows系统下没有问题，但树莓派3上中文无法转换。后来就找到了百度的文字转换语音API，地址：<a href="http://yuyin.baidu.com/#try" target="_blank" rel="noopener">http://yuyin.baidu.com/#try</a></p><p>还可以选各种声音，调节语速。虽然它没有给出直接的api接口，但是我们利用Chrome浏览器的开发者模式可以找到api。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/%E5%88%A9%E7%94%A8%E7%88%AC%E8%99%AB%E5%92%8C%E6%A0%91%E8%8E%93%E6%B4%BE%E6%89%93%E9%80%A0%E8%90%9D%E8%8E%89%E9%9F%B3%E5%A4%A9%E6%B0%94%E9%97%B9%E9%92%9F.png" srcset="/img/loading.gif" alt="百度语音识别"></p><p>打开开发者模式，点击播放的按钮，在network里就可以找到刚刚发出的请求。</p><p><a href="http://tts.baidu.com/text2audio?idx=1&amp;tex=1&amp;cuid=baidu_speech_demo&amp;cod=2&amp;lan=zh&amp;ctp=1&amp;pdt=1&amp;spd=5&amp;per=4&amp;vol=5&amp;pit=5" target="_blank" rel="noopener">http://tts.baidu.com/text2audio?idx=1&amp;tex=1&amp;cuid=baidu_speech_demo&amp;cod=2&amp;lan=zh&amp;ctp=1&amp;pdt=1&amp;spd=5&amp;per=4&amp;vol=5&amp;pit=5</a></p><p>就我们要找的百度文字转语音API,其中per是参数是语音的类型，spd是语速，vol是音量，而tex则是需要转换的文字。通过以下代码就可以实现将特定的文字转换为语音。</p><pre><code class="PY">import osurl = u&#39;http://tts.baidu.com/text2audio?idx=1&amp;tex={0}&amp;cuid=baidu_speech_&#39; \      u&#39;demo&amp;cod=2&amp;lan=zh&amp;ctp=1&amp;pdt=1&amp;spd=4&amp;per=4&amp;vol=5&amp;pit=5&#39;.format(text)os.system(&#39;mplayer &quot;%s&quot;&#39; % url)</code></pre><h2 id="四、-代码"><a href="#四、-代码" class="headerlink" title="四、 代码"></a>四、 代码</h2><p>numtozh()函数专门转换数字为中文。最后所有的代码整合起来就是这样啦。</p><pre><code class="sh"># 新建weather_voice.py文件touch weather_voice.py# 黏贴如下代码nano weather_voice.py</code></pre><pre><code class="py"># -*- coding: utf-8 -*-# !/usr/bin/python3import osimport reimport timeimport requestsfrom datetime import datetime, timedeltafrom bs4 import BeautifulSoupheaders = {    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#39;                  &#39;/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safar&#39;                  &#39;i/537.36&#39;,}def numtozh(num):    num_dict = {1: &#39;一&#39;, 2: &#39;二&#39;, 3: &#39;三&#39;, 4: &#39;四&#39;, 5: &#39;五&#39;, 6: &#39;六&#39;, 7: &#39;七&#39;,                8: &#39;八&#39;, 9: &#39;九&#39;, 0: &#39;零&#39;}    num = int(num)    if 100 &lt;= num &lt; 1000:        b_num = num // 100        s_num = (num - b_num * 100) // 10        g_num = (num - b_num * 100) % 10        if g_num == 0 and s_num == 0:            num = &#39;%s百&#39; % (num_dict[b_num])        elif s_num == 0:            num = &#39;%s百%s%s&#39; % (num_dict[b_num], num_dict.get(s_num, &#39;&#39;), num_dict.get(g_num, &#39;&#39;))        elif g_num == 0:            num = &#39;%s百%s十&#39; % (num_dict[b_num], num_dict.get(s_num, &#39;&#39;))        else:            num = &#39;%s百%s十%s&#39; % (num_dict[b_num], num_dict.get(s_num, &#39;&#39;), num_dict.get(g_num, &#39;&#39;))    elif 10 &lt;= num &lt; 100:        s_num = num // 10        g_num = (num - s_num * 10) % 10        if g_num == 0:            g_num = &#39;&#39;        num = &#39;%s十%s&#39; % (num_dict[s_num], num_dict.get(g_num, &#39;&#39;))    elif 0 &lt;= num &lt; 10:        g_num = num        num = &#39;%s&#39; % (num_dict[g_num])    elif -10 &lt; num &lt; 0:        g_num = -num        num = &#39;零下%s&#39; % (num_dict[g_num])    elif -100 &lt; num &lt;= -10:        num = -num        s_num = num // 10        g_num = (num - s_num * 10) % 10        if g_num == 0:            g_num = &#39;&#39;        num = &#39;零下%s十%s&#39; % (num_dict[s_num], num_dict.get(g_num, &#39;&#39;))    return numdef get_weather():    # 下载墨迹天气主页源码    res = requests.get(&#39;http://tianqi.moji.com/&#39;, headers=headers)    # 用BeautifulSoup获取所需信息    soup = BeautifulSoup(res.text, &quot;html.parser&quot;)    temp = soup.find(&#39;div&#39;, attrs={&#39;class&#39;: &#39;wea_weather clearfix&#39;}).em.getText()    temp = numtozh(int(temp))    weather = soup.find(&#39;div&#39;, attrs={&#39;class&#39;: &#39;wea_weather clearfix&#39;}).b.getText()    sd = soup.find(&#39;div&#39;, attrs={&#39;class&#39;: &#39;wea_about clearfix&#39;}).span.getText()    sd_num = re.search(r&#39;\d+&#39;, sd).group()    sd_num_zh = numtozh(int(sd_num))    sd = sd.replace(sd_num, sd_num_zh)    wind = soup.find(&#39;div&#39;, attrs={&#39;class&#39;: &#39;wea_about clearfix&#39;}).em.getText()    aqi = soup.find(&#39;div&#39;, attrs={&#39;class&#39;: &#39;wea_alert clearfix&#39;}).em.getText()    aqi_num = re.search(r&#39;\d+&#39;, aqi).group()    aqi_num_zh = numtozh(int(aqi_num))    aqi = aqi.replace(aqi_num, aqi_num_zh).replace(&#39; &#39;, &#39;,空气质量&#39;)    info = soup.find(&#39;div&#39;, attrs={&#39;class&#39;: &#39;wea_tips clearfix&#39;}).em.getText()    sd = sd.replace(&#39; &#39;, &#39;百分之&#39;).replace(&#39;%&#39;, &#39;&#39;)    aqi = &#39;aqi&#39; + aqi    info = info.replace(&#39;，&#39;, &#39;,&#39;)    # 获取今天的日期    today = datetime.now().date().strftime(&#39;%Y年%m月%d日&#39;)    # 将获取的信息拼接成一句话    text = &#39;早上好！今天是%s,天气%s,温度%s摄氏度,%s,%s,%s,%s&#39; % \           (today, weather, temp, sd, wind, aqi, info)    return textdef text2voice(text):    url = &#39;http://tts.baidu.com/text2audio?idx=1&amp;tex={0}&amp;cuid=baidu_speech_&#39; \          &#39;demo&amp;cod=2&amp;lan=zh&amp;ctp=1&amp;pdt=1&amp;spd=4&amp;per=4&amp;vol=5&amp;pit=5&#39;.format(text)    # 直接播放语音    os.system(&#39;mplayer &quot;%s&quot;&#39; % url)def main():    # 获取需要转换语音的文字    text = get_weather()    print(text)    # 获取音乐文件绝对地址    mp3path2 = os.path.join(os.path.dirname(__file__), &#39;2.mp3&#39;)    # 先播放渔舟唱晚cut版做为闹钟    os.system(&#39;mplayer %s&#39; % &quot;http://m7.music.126.net/20200321204545/92ef85b98df3233ebcf66b41529b1e0c/ymusic/714d/2975/d488/bcfd91fa30f23266c7151fbf43052634.mp3&quot;)    # 播报语音天气    text2voice(text)if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="五、-定时任务"><a href="#五、-定时任务" class="headerlink" title="五、 定时任务"></a>五、 定时任务</h2><p>输入如下命令添加定时任务。</p><p><code>crontab -e</code></p><p>每天8点语音天气。假设你的<code>weather_voice.py</code>绝对路径为<code>/home/pi/Documents/weather_voice.py</code>，则文末添加一句：</p><p><code>0 8 * * * /usr/bin/python3 /home/pi/Documents/weather_voice.py</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24983204?refer=woodenrobot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原帖地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="python" scheme="https://closer_laps.gitee.io/categories/python/"/>
    
      <category term="树莓派" scheme="https://closer_laps.gitee.io/categories/python/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
      <category term="树莓派" scheme="https://closer_laps.gitee.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="python" scheme="https://closer_laps.gitee.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux VPS一键更换软件源脚本</title>
    <link href="https://closer_laps.gitee.io/2020/03/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/Linux-VPS%E4%B8%80%E9%94%AE%E6%9B%B4%E6%8D%A2%E8%BD%AF%E4%BB%B6%E6%BA%90%E8%84%9A%E6%9C%AC/"/>
    <id>https://closer_laps.gitee.io/2020/03/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/Linux-VPS%E4%B8%80%E9%94%AE%E6%9B%B4%E6%8D%A2%E8%BD%AF%E4%BB%B6%E6%BA%90%E8%84%9A%E6%9C%AC/</id>
    <published>2020-03-14T17:44:23.000Z</published>
    <updated>2020-03-14T17:50:20.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时候会遇到Linux的源更新速度非常的缓慢，特别是在国内使用默认的源，因为国内的网络环境，经常会出现无法更新，更新缓慢的情况。在这种情况下，更换一个更适合或者说更近，更快的软件源，会为你的Linux安装更新操作更加的流畅和顺利。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>系统要求</strong>：<code>CentOS 5+</code>、<code>Ubuntu 14.04+</code>、<code>Debian 7+</code></p><p>使用命令：</p><pre><code class="sh">#下载脚本wget git.io/superupdate.sh#运行脚本bash superupdate.sh</code></pre><p>如果第一步你出现错误或执行后无任何输出，请检查是否安装<code>wget</code>和<code>ca-certificates</code>，使用命令：</p><pre><code class="sh">#Debian、Ubuntuapt-get install -y wget &amp;&amp; apt-get install -y ca-certificates#CentOSyum install -y wget &amp;&amp; yum install -y ca-certificates</code></pre><p>对于Debian默认换源为<code>Fastly CDN</code>的<code>mirror</code>这个源有<code>Fastly</code>的加持对境外主机都有不错的速度。对于<code>Ubuntu</code>和 <code>CentOS</code>系统都默认换为阿里云的<code>mirror</code>，这个源有阿里云全球CDN的加持，全球都有不错的速度。</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>对于<code>Debian</code>系统还设置了四套其他的源，<code>阿里云</code>，<code>CloudFront CDN</code>，<code>网易163</code>，<code>中科大的源</code>，请根据需要使用参数一键设置如：</p><pre><code class="sh">bash superupdate.sh cnbash superupdate.sh 163bash superupdate.sh aliyunbash superupdate.sh aws</code></pre><h2 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h2><p>如果配置的文件不满意，一键还原</p><pre><code class="sh">bash superupdate.sh restore</code></pre><p><strong><a href="https://www.moerats.com/archives/784/" target="_blank" rel="noopener">文章出处</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有时候会遇到Linux的源更新速度非常的缓慢，特别是在国内使用默认的源，因为国内的网络环境，经常会出现无法更新，更新缓慢的情况。在这种情况下
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://closer_laps.gitee.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://closer_laps.gitee.io/tags/Linux/"/>
    
      <category term="换软件源" scheme="https://closer_laps.gitee.io/tags/%E6%8D%A2%E8%BD%AF%E4%BB%B6%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>局域网内的主机实现外网访问(通过反向代理)</title>
    <link href="https://closer_laps.gitee.io/2020/03/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%BB%E6%9C%BA%E5%AE%9E%E7%8E%B0%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://closer_laps.gitee.io/2020/03/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%BB%E6%9C%BA%E5%AE%9E%E7%8E%B0%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</id>
    <published>2020-03-13T14:25:59.000Z</published>
    <updated>2020-04-14T11:24:22.968Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>比较简单的方法：<a href="https://zhuanlan.zhihu.com/p/36156129" target="_blank" rel="noopener">下载脚本，使用frp实现内网穿透</a></p></blockquote><p>本文记录如何在树莓派上如何实现反向代理，穿透内网进行远程登录和操作树莓派。本方法也适用于其他 Linux 系统和 mac osx<br>系统，但目录上有所区别。</p><h2 id="一：-必备条件"><a href="#一：-必备条件" class="headerlink" title="一： 必备条件"></a>一： 必备条件</h2><ol><li>具有公网 IP 的 vps 或者云主机。</li><li>局域网主机（如树莓派、nas）。</li></ol><h2 id="二：-准备工作（局域网主机上操作）"><a href="#二：-准备工作（局域网主机上操作）" class="headerlink" title="二： 准备工作（局域网主机上操作）"></a>二： 准备工作（局域网主机上操作）</h2><ol><li>局域网主机生成密匙(如果已经生成，请跳过)<br>打开终端，输入。<br><code>ssh-keygen</code> # 然后连续按三次Enter</li><li>输入如下命令：<br><code>ssh-copy-id -i ~/.ssh/id_rsa.pub 中文改为你的云主机用户名@中文改为你的云主机外网IP</code></li><li>使pi默认可以root登录<br><code>sudo passwd root</code> # 修改pi的root密码<br><code>sudo nano /etc/ssh/sshd_config</code><br>找到PermitRootLogin这一行，将前面的‘#’去掉，这一行改为<code>PermitRootLogin yes</code>。</li></ol><h2 id="三：-反向代理的操作"><a href="#三：-反向代理的操作" class="headerlink" title="三： 反向代理的操作"></a>三： 反向代理的操作</h2><p>原理图：</p><table><thead><tr><th>编号</th><th>IP</th><th>用户名</th><th>说明</th></tr></thead><tbody><tr><td>A</td><td>192.168.1.A</td><td>U_a</td><td>目标 计算机，（即树莓派），在局域网中，可以访问 A</td></tr><tr><td>B</td><td>B.B.B.B</td><td>U_b</td><td>代理服务器（我们的 vps 或云主机），在外网中，无法访问 A</td></tr><tr><td>C</td><td>-</td><td>U_c</td><td>外部的计算机，比如公司的电脑，可以访问B，无法直接访问 A</td></tr></tbody></table><h3 id="3-1-设计方案"><a href="#3-1-设计方案" class="headerlink" title="3.1 设计方案"></a>3.1 设计方案</h3><p>在 A 机器上做到 B 机器的反向代理；在 B 机器上做正向代理本地端口转发</p><h3 id="3-2环境需求"><a href="#3-2环境需求" class="headerlink" title="3.2环境需求"></a>3.2环境需求</h3><ul><li>每台机器上都需要 SSH 客户端</li><li>A、B 两台机器上需要 SSH 服务器端。通常是 openssh-server。</li></ul><p>ubuntu和debian上安装ssh代码如下：<br><code>sudo apt install openssl-server</code></p><h3 id="3-3-SSH-参数解释"><a href="#3-3-SSH-参数解释" class="headerlink" title="3.3 SSH 参数解释"></a>3.3 SSH 参数解释</h3><pre><code class="C">-f 后台运行-C 允许压缩数据-N 不执行任何命令-R 将端口绑定到远程服务器，反向代理-L 将端口绑定到本地客户端，正向代理*******************区分大小写啊各位亲******************</code></pre><h3 id="3-4-具体步骤"><a href="#3-4-具体步骤" class="headerlink" title="3.4 具体步骤"></a>3.4 具体步骤</h3><h3 id="3-4-1-登录云主机上开启自动端口转发【云主机上操作】"><a href="#3-4-1-登录云主机上开启自动端口转发【云主机上操作】" class="headerlink" title="3.4.1 登录云主机上开启自动端口转发【云主机上操作】"></a>3.4.1 登录云主机上开启自动端口转发【云主机上操作】</h3><p><code>sudo vi /etc/ssh/sshd_config</code></p><p>找到GatewayPorts把前面的#去掉,后面改成yes，开启自动端口转发</p><h3 id="3-4-2-为-B-机器上端口，用来与-A-机器上的22端口绑定-【云主机上操作】"><a href="#3-4-2-为-B-机器上端口，用来与-A-机器上的22端口绑定-【云主机上操作】" class="headerlink" title="3.4.2 为 B 机器上端口，用来与 A 机器上的22端口绑定 【云主机上操作】"></a>3.4.2 为 B 机器上端口，用来与 A 机器上的22端口绑定 【云主机上操作】</h3><pre><code class="sh">`ssh -fCNL &#39;*:&lt;port_b2&gt;:localhost:&lt;port_b1&gt;&#39; localhost`# 其中&lt;port_b1&gt;跟上面的端口相同# &lt;port_b2&gt;改为和&lt;port_b1&gt;不同的大于1000端口号，如12345# 代码示例：ssh -fCNL &#39;*:12345:localhost:7280&#39; localhost# 查看ssh进程ps aux | grep ssh# 将云主机设为开机就正向代理which rc.local# cd进入上面的路径,我这边的路径是/etc/sudo vi /etc/rc.local#按i编辑，最后一行添加如下代码，:qw保存退出sshpass -p &#39;云主机密码&#39; ssh -fCNL &#39;*:12345:localhost:7280&#39; localhost</code></pre><h2 id="四：-autossh-反向代理"><a href="#四：-autossh-反向代理" class="headerlink" title="四： autossh 反向代理"></a>四： autossh 反向代理</h2><h3 id="4-1-局域网主机（树莓派）开启autossh反向代理"><a href="#4-1-局域网主机（树莓派）开启autossh反向代理" class="headerlink" title="4.1 局域网主机（树莓派）开启autossh反向代理"></a>4.1 局域网主机（树莓派）开启autossh反向代理</h3><p><strong>在上文中，我们已经能够在C 计算机通过 B 计算机访问 A 计算机，但这个代理是暂时的，会出现代理随时断开或者下次重启树莓派又要重新开启，步骤麻烦。因此，我们把方案优化，升级 ssh 的代理工具，使用 autossh 这个工具。</strong></p><p>我们先要安装 autossh,在局域网主机（树莓派）上。<br><code>sudo apt install autossh -y</code><br><code>sudo apt install sshpass -y</code></p><p>然后输入命令绑定<br><code>autossh -M 5678 -NR &lt;port_b1&gt;:localhost:22 云主机用户名@云主机外网IP</code><br>代码示例：<br><code>sudo sshpass -p &#39;云主机密码&#39; autossh -M 5678 -CNR 7280:localhost:22 root@123.123.123.123</code></p><pre><code class="SH">#ssh密码登录sudo nano /etc/rc.localsudo sshpass -p &#39;云主机密码&#39; autossh -M 5678 -CNR 7280:localhost:22 root@123.123.123.123</code></pre><p>就这样开启了反向代理，作用跟前面的一致。但，这里当代理连接断开后，会自动重连，不需要担心，突然连不上自己的 树莓派 了。</p><p>但我们的 pi 重启后，也是要输入上述 autossh 的命令，为了更加自动化，把autossh 加入开机启动里(需要ssh免密码登录)</p><pre><code class="SH"># ssh免密码登录sudo nano /etc/rc.local# 光标移动到exit 0 的上一行，输入命令。比如花生壳是用phddns.start启动，再这里加入后花生壳就会自动启动了。/bin/su -c /usr/bin/autossh -M 5678 -CNR 7280:localhost:22 root@123.123.123.123</code></pre><p>-M 5678参数，负责通过5678端口监视连接状态，连接有问题时就会自动重连.</p><h3 id="4-2-通过其他电脑手机访问局域网主机（树莓派）"><a href="#4-2-通过其他电脑手机访问局域网主机（树莓派）" class="headerlink" title="4.2 通过其他电脑手机访问局域网主机（树莓派）"></a>4.2 通过其他电脑手机访问局域网主机（树莓派）</h3><p><code>ssh -p &lt;port_b2&gt; 你的云主机用户名@你的云主机外网IP</code><br><code>&lt;port_b2&gt;</code>改成上面的端口号，如1234</p><p>代码示例：<br><code>ssh -p12345 root@123.123.123.123</code></p><h2 id="五：-参考文档"><a href="#五：-参考文档" class="headerlink" title="五： 参考文档"></a>五： 参考文档</h2><blockquote><p><a href="https://qimajiang.com/2017/02/25/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86/?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">参考文档</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;比较简单的方法：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36156129&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载脚本，使用frp实现内网穿透&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://closer_laps.gitee.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://closer_laps.gitee.io/tags/Linux/"/>
    
      <category term="反向代理" scheme="https://closer_laps.gitee.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
      <category term="外网访问" scheme="https://closer_laps.gitee.io/tags/%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>selenium操作cookie</title>
    <link href="https://closer_laps.gitee.io/2020/03/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%20%E4%BA%8C%EF%BC%9Acookie/"/>
    <id>https://closer_laps.gitee.io/2020/03/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%20%E4%BA%8C%EF%BC%9Acookie/</id>
    <published>2020-03-07T06:04:52.000Z</published>
    <updated>2020-03-07T11:58:37.532Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：-查看cookie"><a href="#一：-查看cookie" class="headerlink" title="一： 查看cookie"></a>一： 查看cookie</h2><ol><li>查看cookie的方法：按下F12打开开发者工具。<br>在<code>network</code>中可以看到请求发送的信息，在返回头中，会带有服务器提供的设置cookie的信息。<br>在<code>application</code>当中，可以看到相应网站的所有cookie，并不是只有登录信息，也不是所有的网站都有cookie。</li><li>http协议是一个无状态的协议，用到cookie和session来保存访问中的一些状态。<br>cookie和session都是由服务器生成的，cookie将保存在浏览器的本地，session记录在服务端。</li><li>cookie的几大属性<ul><li>name：名字（键），cookie的必须字段。</li><li>value：值。</li><li>domain：域。cookie的作用域名。</li><li>path：表示路径。/表示当前域名下所有的网页都能使用该cookie。<br>domain和path结合在一起，限定了cookie的适用范围。</li><li>expires：生命周期。限定cookie的使用时间。如果生命周期为Session的，表示只在当前这次会话中cookie有效，关闭浏览器之后立即失效。</li><li>sessionID：本次访问的会话留下的ID号。</li></ul></li></ol><h2 id="二：-用selenium操作"><a href="#二：-用selenium操作" class="headerlink" title="二： 用selenium操作"></a>二： 用selenium操作</h2><p>通过<code>driver.add_cookie(my_cookie)</code>的方法，加载cookie，在浏览器向服务端发起请求时带上cookie进行访问。</p><p>通过<code>driver.getcookie()</code>的方法，获取cookie。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一：-查看cookie&quot;&gt;&lt;a href=&quot;#一：-查看cookie&quot; class=&quot;headerlink&quot; title=&quot;一： 查看cookie&quot;&gt;&lt;/a&gt;一： 查看cookie&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;查看cookie的方法：按下F12打开开发者工具。&lt;br
      
    
    </summary>
    
    
      <category term="python" scheme="https://closer_laps.gitee.io/categories/python/"/>
    
      <category term="cookie" scheme="https://closer_laps.gitee.io/categories/python/cookie/"/>
    
    
      <category term="python" scheme="https://closer_laps.gitee.io/tags/python/"/>
    
      <category term="cookie" scheme="https://closer_laps.gitee.io/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>树莓派配置</title>
    <link href="https://closer_laps.gitee.io/2020/03/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE/"/>
    <id>https://closer_laps.gitee.io/2020/03/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE/</id>
    <published>2020-03-06T06:29:38.000Z</published>
    <updated>2020-04-14T12:21:50.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-修改密码及时间"><a href="#一-修改密码及时间" class="headerlink" title="一: 修改密码及时间"></a>一: 修改密码及时间</h2><h3 id="1-1-设置su及pi密码"><a href="#1-1-设置su及pi密码" class="headerlink" title="1.1 设置su及pi密码"></a>1.1 设置su及pi密码</h3><pre><code class="shell">sudo passwd pi                   # 修改 Pi 密码  sudo passwd root                 # 设置 root 密码su root                          # 切换到 root 用户  su pi                            # 切换到 pi 用户</code></pre><h3 id="1-2-修改时间"><a href="#1-2-修改时间" class="headerlink" title="1.2 修改时间"></a>1.2 修改时间</h3><p>使用date 语句查看时间，如不正确，则：首先在终端中用下面的命令安装ntpdate工具</p><p><code>sudo apt install ntpdate</code></p><p>启用NTP </p><p><code>sudo timedatectl set-ntp true</code></p><p>继续使用date语句查看时间，如不正确，则：</p><p><code>sudo dpkg-reconfigure tzdata</code></p><p>修改时区为Asia Shanghai，继续使用date语句查看时间并确认正确</p><h2 id="二-中文环境"><a href="#二-中文环境" class="headerlink" title="二: 中文环境"></a>二: 中文环境</h2><h2 id="2-1-安装中文输入法"><a href="#2-1-安装中文输入法" class="headerlink" title="2.1 安装中文输入法"></a>2.1 安装中文输入法</h2><p><code>sudo apt install scim-pinyin</code></p><h2 id="2-2-配置中文环境"><a href="#2-2-配置中文环境" class="headerlink" title="2.2 配置中文环境"></a>2.2 配置中文环境</h2><p><code>sudo raspi-config</code></p><p>按4 -&gt; 1<br>在Configuring locales窗口中，找到zh_CN.UTF-8 UTF-8</p><p>空格选中，并在确认后再次选择zh_CN.UTF-8</p><h3 id="2-3-安装中文字库"><a href="#2-3-安装中文字库" class="headerlink" title="2.3 安装中文字库"></a>2.3 安装中文字库</h3><p><code>sudo apt install ttf-wqy-zenhei</code></p><p><code>reboot</code></p><h2 id="三-基本设置"><a href="#三-基本设置" class="headerlink" title="三: 基本设置"></a>三: 基本设置</h2><h3 id="3-1-开启SSH访问"><a href="#3-1-开启SSH访问" class="headerlink" title="3.1 开启SSH访问"></a>3.1 开启SSH访问</h3><p><code>sudo raspi-config</code></p><p>5 -&gt; P2 SSH -&gt; enable.</p><h3 id="3-2-设置为固定ip访问"><a href="#3-2-设置为固定ip访问" class="headerlink" title="3.2 设置为固定ip访问"></a>3.2 设置为固定ip访问</h3><p>先进入配置文件<br><code>sudo nano /etc/dhcpcd.conf</code></p><pre><code class="shell"># 有线设置interface eth0# 路由器ipstatic routers=192.168.2.1# DNSstatic domain_name_servers=192.168.2.1 8.8.8.8static ip_address=192.168.2.4/24# 无线设置interface wlan0static routers=192.168.2.1static domain_name_servers=192.168.2.1 8.8.8.8static ip_address=192.168.2.4/24</code></pre><h3 id="3-3-添加树莓派开机启动命令，如花生壳"><a href="#3-3-添加树莓派开机启动命令，如花生壳" class="headerlink" title="3.3 添加树莓派开机启动命令，如花生壳"></a>3.3 添加树莓派开机启动命令，如花生壳</h3><pre><code class="SH">sudo nano /etc/rc.local# 在exit 0 的上一行输入命令。比如花生壳是用phddns.start启动，再这里加入后花生壳就会自动启动了。sudo phddns.start</code></pre><h2 id="四-安装Pi-hole搭建DNS缓存服务器，过滤网页广告"><a href="#四-安装Pi-hole搭建DNS缓存服务器，过滤网页广告" class="headerlink" title="四: 安装Pi-hole搭建DNS缓存服务器，过滤网页广告"></a>四: 安装Pi-hole搭建DNS缓存服务器，过滤网页广告</h2><p><strong>pi-hole使用后发现并不好用，故不推荐安装。</strong></p><h3 id="4-1-安装Pi-hole"><a href="#4-1-安装Pi-hole" class="headerlink" title="4.1 安装Pi-hole"></a>4.1 安装Pi-hole</h3><p>使用脚本自定义安装，在安装过程中可以自定义Pi-hole，命令如下：</p><pre><code class="sh">git clone --depth 1 https://github.com/pi-hole/pi-hole.git Pi-holecd Pi-hole/automated\ install/bash basic-install.sh</code></pre><p>安装过程中，将会下载安装软件包，然后弹出一个红蓝界面，可以选择Pi-hole的配置，选择默认方式即可。安装后会生成后台的登陆密码，请记住，如果没看到这个密码也没关系，安装成功后可以自己设置。等待脚本的安装完成，约1-2个小时。</p><h3 id="4-2-使用"><a href="#4-2-使用" class="headerlink" title="4.2 使用"></a>4.2 使用</h3><p>Pi-hole安装成功后就会开始运行，如果你要使用它，请将你电脑的DNS改为树莓派的IP地址，同时，也应该将家庭路由器的DNS地址更改为树莓派当前的IP地址，这样才能使用树莓派的DNS服务和广告拦截服务。</p><h3 id="4-3-登陆Pi-hole"><a href="#4-3-登陆Pi-hole" class="headerlink" title="4.3 登陆Pi-hole"></a>4.3 登陆Pi-hole</h3><p>Pi-hole有一个美观的界面，可以直观的看到今日DNS查询屏蔽次数、今日DNS查询次数、屏蔽比例、屏蔽库中的域名数量等信息。Pi-hole界面的查看地址为：</p><p><code>http://&lt;your pi’s IP address&gt;/admin</code></p><p>其中<code>&lt;your pi’s IP address&gt;</code>用树莓派的IP地址替换即可。</p><h3 id="4-4-重置密码"><a href="#4-4-重置密码" class="headerlink" title="4.4 重置密码"></a>4.4 重置密码</h3><p>如果你忘记了密码，通过以下命令可以重置新的密码。</p><p><code>sudo pihole -a -p newpassword</code></p><h3 id="4-5-实时监控"><a href="#4-5-实时监控" class="headerlink" title="4.5 实时监控"></a>4.5 实时监控</h3><p>通过SSH实时监控，输入命令：</p><p><code>pihole -c</code></p><h3 id="4-6-升级Pihole"><a href="#4-6-升级Pihole" class="headerlink" title="4.6 升级Pihole"></a>4.6 升级Pihole</h3><p><code>pihole -up</code></p><h3 id="4-7-更改-重置GUI管理员密码"><a href="#4-7-更改-重置GUI管理员密码" class="headerlink" title="4.7 更改/重置GUI管理员密码"></a>4.7 更改/重置GUI管理员密码</h3><p><code>pihole -a -p</code></p><h3 id="4-8-检查pi-hole状态"><a href="#4-8-检查pi-hole状态" class="headerlink" title="4.8 检查pi-hole状态"></a>4.8 检查pi-hole状态</h3><p><code>pihole status</code></p><h3 id="4-9-重新配置pi-hole系统"><a href="#4-9-重新配置pi-hole系统" class="headerlink" title="4.9 重新配置pi-hole系统"></a>4.9 重新配置pi-hole系统</h3><p><code>pihole -r</code></p><h3 id="4-10-从系统中卸载Pi-hole"><a href="#4-10-从系统中卸载Pi-hole" class="headerlink" title="4.10 从系统中卸载Pi-hole"></a>4.10 从系统中卸载Pi-hole</h3><p><code>pihole uninstall</code></p><p>第一次选Y，第二次选N</p><h3 id="4-11-重启Pi-holes子系统"><a href="#4-11-重启Pi-holes子系统" class="headerlink" title="4.11 重启Pi-holes子系统"></a>4.11 重启Pi-holes子系统</h3><p><code>pihole restartdns</code></p><h3 id="4-12-帮助"><a href="#4-12-帮助" class="headerlink" title="4.12 帮助"></a>4.12 帮助</h3><p><code>pihole --help</code></p><p><strong>pi-hole使用后发现并不好用，故不推荐安装，已经卸载。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-修改密码及时间&quot;&gt;&lt;a href=&quot;#一-修改密码及时间&quot; class=&quot;headerlink&quot; title=&quot;一: 修改密码及时间&quot;&gt;&lt;/a&gt;一: 修改密码及时间&lt;/h2&gt;&lt;h3 id=&quot;1-1-设置su及pi密码&quot;&gt;&lt;a href=&quot;#1-1-设置su及p
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://closer_laps.gitee.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://closer_laps.gitee.io/tags/Linux/"/>
    
      <category term="树莓派" scheme="https://closer_laps.gitee.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>关系数据库MySQL入门</title>
    <link href="https://closer_laps.gitee.io/2020/02/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/SQL/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93MySQL/"/>
    <id>https://closer_laps.gitee.io/2020/02/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/SQL/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93MySQL/</id>
    <published>2020-02-23T07:18:37.000Z</published>
    <updated>2020-02-23T08:20:53.888Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文转载于GitHub项目<a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">Python - 100天从新手到大师</a></strong></p></blockquote><h3 id="一：-关系数据库概述"><a href="#一：-关系数据库概述" class="headerlink" title="一： 关系数据库概述"></a>一： 关系数据库概述</h3><ol><li><p>数据持久化 - 将数据保存到能够长久保存数据的存储介质中，在掉电的情况下数据也不会丢失。</p></li><li><p>数据库发展史 - 网状数据库、层次数据库、关系数据库、NoSQL数据库。</p><blockquote><p>1970年，IBM的研究员E.F.Codd在<em>Communication of the ACM</em>上发表了名为<em>A Relational Model of Data for Large Shared Data Banks</em>的论文，提出了关系模型的概念，奠定了关系模型的理论基础。后来Codd又陆续发表多篇文章，论述了范式理论和衡量关系系统的12条标准，用数学理论奠定了关系数据库的基础。</p></blockquote></li><li><p>关系数据库特点。</p><ul><li><p>理论基础：集合论和关系代数。</p></li><li><p>具体表象：用二维表（有行和列）组织数据。</p></li><li><p>编程语言：结构化查询语言（SQL）。</p></li></ul></li><li><p>ER模型（实体关系模型）和概念模型图。</p><p><strong>ER模型</strong>，全称为<strong>实体关系模型</strong>（Entity-Relationship Model），由美籍华裔计算机科学家陈品山先生提出，是概念数据模型的高层描述方式，如下图所示。</p><p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/MySQL/er_diagram.png" srcset="/img/loading.gif" alt="er_diagram.png"></p><ul><li>实体 - 矩形框</li><li>属性 - 椭圆框</li><li>关系 - 菱形框</li><li>重数 - 1:1（一对一） / 1:N（一对多） / M:N（多对多）</li></ul><p>实际项目开发中，我们可以利用数据库建模工具（如：PowerDesigner）来绘制概念数据模型（其本质就是ER模型），然后再设置好目标数据库系统，将概念模型转换成物理模型，最终生成创建二维表的SQL（很多工具都可以根据我们设计的物理模型图以及设定的目标数据库来导出SQL或直接生成数据表）。</p><p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/MySQL/conceptual_model.png" srcset="/img/loading.gif" alt="conceptual_model.png"></p></li><li><p>关系数据库产品。</p><ul><li><a href="https://www.oracle.com/index.html" target="_blank" rel="noopener">Oracle</a> - 目前世界上使用最为广泛的数据库管理系统，作为一个通用的数据库系统，它具有完整的数据管理功能；作为一个关系数据库，它是一个完备关系的产品；作为分布式数据库，它实现了分布式处理的功能。在Oracle最新的12c版本中，还引入了多承租方架构，使用该架构可轻松部署和管理数据库云。</li><li><a href="https://www.ibm.com/analytics/us/en/db2/" target="_blank" rel="noopener">DB2</a> - IBM公司开发的、主要运行于Unix（包括IBM自家的<a href="https://zh.wikipedia.org/wiki/AIX" target="_blank" rel="noopener">AIX</a>）、Linux、以及Windows服务器版等系统的关系数据库产品。DB2历史悠久且被认为是最早使用SQL的数据库产品，它拥有较为强大的商业智能功能。</li><li><a href="https://www.microsoft.com/en-us/sql-server/" target="_blank" rel="noopener">SQL Server</a> - 由Microsoft开发和推广的关系型数据库产品，最初适用于中小企业的数据管理，但是近年来它的应用范围有所扩展，部分大企业甚至是跨国公司也开始基于它来构建自己的数据管理系统。</li><li><a href="https://www.mysql.com/" target="_blank" rel="noopener">MySQL</a> - MySQL是开放源代码的，任何人都可以在GPL（General Public License）的许可下下载并根据个性化的需要对其进行修改。MySQL因为其速度、可靠性和适应性而备受关注。</li><li><a href="">PostgreSQL</a> - 在BSD许可证下发行的开放源代码的关系数据库产品。</li></ul></li></ol><h3 id="二：-MySQL简介"><a href="#二：-MySQL简介" class="headerlink" title="二： MySQL简介"></a>二： MySQL简介</h3><p>MySQL最早是由瑞典的MySQL AB公司开发的一个开放源码的关系数据库管理系统，该公司于2008年被昇阳微系统公司（Sun Microsystems）收购。在2009年，甲骨文公司（Oracle）收购昇阳微系统公司，因此在这之后MySQL成为了Oracle旗下产品。</p><p>MySQL在过去由于性能高、成本低、可靠性好，已经成为最流行的开源数据库，因此被广泛地应用于中小型网站开发。随着MySQL的不断成熟，它也逐渐被应用于更多大规模网站和应用，比如维基百科、谷歌（Google）、脸书（Facebook）、淘宝网等网站都使用了MySQL来提供数据持久化服务。</p><p>甲骨文公司收购后昇阳微系统公司，大幅调涨MySQL商业版的售价，且甲骨文公司不再支持另一个自由软件项目<a href="https://zh.wikipedia.org/wiki/OpenSolaris" target="_blank" rel="noopener">OpenSolaris</a>的发展，因此导致自由软件社区对于Oracle是否还会持续支持MySQL社区版（MySQL的各个发行版本中唯一免费的版本）有所担忧，MySQL的创始人麦克尔·维德纽斯以MySQL为基础，成立分支计划<a href="https://zh.wikipedia.org/wiki/MariaDB" target="_blank" rel="noopener">MariaDB</a>（以他女儿的名字命名的数据库）。有许多原来使用MySQL数据库的公司（例如：维基百科）已经陆续完成了从MySQL数据库到MariaDB数据库的迁移。</p><ol><li><p>安装和配置</p><blockquote><p><strong>说明</strong>：下面的安装和配置都是以CentOS Linux环境为例，如果需要在其他系统下安装MySQL，读者可以自行在网络上查找对应的安装教程）。</p></blockquote><ul><li><p>刚才说过，MySQL有一个分支版本名叫MariaDB，该数据库旨在继续保持MySQL数据库在<a href="https://zh.wikipedia.org/wiki/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81" target="_blank" rel="noopener">GNU GPL</a>下开源。如果要使用MariaDB作为MySQL的替代品，可以使用下面的命令进行安装。</p><pre><code class="Shell">yum install mariadb mariadb-server</code></pre></li><li><p>如果要安装官方版本的MySQL，可以在<a href="https://www.mysql.com/" target="_blank" rel="noopener">MySQL官方网站</a>下载安装文件。首先在下载页面中选择平台和版本，然后找到对应的下载链接。下面以MySQL 5.7.26版本和Red Hat Enterprise Linux为例，直接下载包含所有安装文件的归档文件，解归档之后通过包管理工具进行安装。</p><pre><code class="Shell">wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tartar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar</code></pre><p>如果系统上有MariaDB相关的文件，需要先移除MariaDB相关的文件。</p><pre><code class="Shell">yum list installed | grep mariadb | awk &#39;{print $1}&#39; | xargs yum erase -y</code></pre><p>接下来可以按照如下所示的顺序用RPM（Redhat Package Manager）工具安装MySQL。</p><pre><code class="Shell">rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm</code></pre><p>可以使用下面的命令查看已经安装的MySQL相关的包。</p><pre><code class="Shell">rpm -qa | grep mysql</code></pre></li><li><p>配置MySQL。</p><p>MySQL的配置文件在<code>/etc</code>目录下，名为<code>my.cnf</code>，默认的配置文件内容如下所示。如果对这个文件不理解并没有关系，什么时候用到这个配置文件什么时候再了解它就行了。</p><pre><code class="Shell">cat /etc/my.cnf</code></pre><pre><code class="INI"># For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html[mysqld]## Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M## Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin## Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2Mdatadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid</code></pre></li><li><p>启动MySQL服务。</p><p>可以使用下面的命令来启动MySQL。</p><pre><code class="Shell">service mysqld start</code></pre><p>在CentOS 7中，更推荐使用下面的命令来启动MySQL。</p><pre><code class="Shell">systemctl start mysqld</code></pre><p>启动MySQL成功后，可以通过下面的命令来检查网络端口使用情况，MySQL默认使用3306端口。</p><pre><code class="Shell">netstat -ntlp | grep mysql</code></pre><p>也可以使用下面的命令查找是否有名为mysqld的进程。</p><pre><code class="Shell">pgrep mysqld</code></pre></li><li><p>使用MySQL客户端工具连接服务器。</p><p>命令行工具：</p><pre><code class="Shell">mysql -u root -p</code></pre><blockquote><p>说明：启动客户端时，<code>-u</code>参数用来指定用户名，MySQL默认的超级管理账号为<code>root</code>；<code>-p</code>表示要输入密码（用户口令）；如果连接的是其他主机而非本机，可以用<code>-h</code>来指定连接主机的主机名或IP地址。</p></blockquote><p>如果是首次安装MySQL，可以使用下面的命令来找到默认的初始密码。</p><pre><code class="Shell">cat /var/log/mysqld.log | grep password</code></pre><p>上面的命令会查看MySQL的日志带有password的行，在显示的结果中<code>root@localhost:</code>后面的部分就是默认设置的初始密码。</p><p>修改超级管理员（root）的访问口令为<code>123456</code>。</p><pre><code class="SQL">set global validate_password_policy=0;set global validate_password_length=6;alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;</code></pre><blockquote><p><strong>说明</strong>：MySQL较新的版本默认不允许使用弱口令作为用户口令，所以我们通过上面的前两条命令修改了验证用户口令的策略和口令的长度。事实上我们不应该使用弱口令，因为存在用户口令被暴力破解的风险。近年来，攻击数据库窃取数据和劫持数据库勒索比特币的事件屡见不鲜，要避免这些潜在的风险，最为重要的一点是不要让数据库服务器暴露在公网上（最好的做法是将数据库置于内网，至少要做到不向公网开放数据库服务器的访问端口），另外要保管好<code>root</code>账号的口令，应用系统需要访问数据库时，通常不使用<code>root</code>账号进行访问，而是创建其他拥有适当权限的账号来访问。</p></blockquote><p>再次使用客户端工具连接MySQL服务器时，就可以使用新设置的口令了。在实际开发中，为了方便用户操作，可以选择图形化的客户端工具来连接MySQL服务器，包括：</p><ul><li>MySQL Workbench（官方提供的工具）</li><li>Navicat for MySQL（界面简单优雅，功能直观强大）</li><li>SQLyog for MySQL（强大的MySQL数据库管理员工具）</li></ul></li></ul></li><li><p>常用命令。</p><ul><li><p>查看服务器版本。</p><pre><code class="SQL">select version();</code></pre></li><li><p>查看所有数据库。</p><pre><code class="SQL">show databases;</code></pre></li><li><p>切换到指定数据库。</p><pre><code class="SQL">use mysql;</code></pre></li><li><p>查看数据库下所有表。</p><pre><code class="Shell">show tables;</code></pre></li><li><p>获取帮助。</p><pre><code class="SQL">? contents;? functions;? numeric functions;? round;? data types;? longblob;</code></pre></li></ul></li></ol><h3 id="三：-SQL详解"><a href="#三：-SQL详解" class="headerlink" title="三： SQL详解"></a>三： SQL详解</h3><h4 id="3-1-基本操作"><a href="#3-1-基本操作" class="headerlink" title="3.1 基本操作"></a>3.1 基本操作</h4><p>我们通常可以将SQL分为三类：DDL（数据定义语言）、DML（数据操作语言）和DCL（数据控制语言）。DDL主要用于创建（create）、删除（drop）、修改（alter）数据库中的对象，比如创建、删除和修改二维表；DML主要负责插入数据（insert）、删除数据（delete）、更新数据（update）和查询（select）；DCL通常用于授予权限（grant）和召回权限（revoke）。</p><blockquote><p>说明：SQL是不区分大小写的语言，为了书写方便，下面的SQL都使用了小写字母来书写。</p></blockquote><ol><li><p>DDL（数据定义语言）</p><pre><code class="SQL">-- 如果存在名为school的数据库就删除它drop database if exists school;-- 创建名为school的数据库并设置默认的字符集和排序方式create database school default charset utf8;-- 切换到school数据库上下文环境use school;-- 创建学院表create table tb_college(collid         int auto_increment comment &#39;编号&#39;,collname     varchar(50) not null comment &#39;名称&#39;,collintro     varchar(500) default &#39;&#39; comment &#39;介绍&#39;,primary key (collid));-- 创建学生表create table tb_student(stuid         int not null comment &#39;学号&#39;,stuname     varchar(20) not null comment &#39;姓名&#39;,stusex         boolean default 1 comment &#39;性别&#39;,stubirth     date not null comment &#39;出生日期&#39;,stuaddr     varchar(255) default &#39;&#39; comment &#39;籍贯&#39;,collid         int not null comment &#39;所属学院&#39;,primary key (stuid),foreign key (collid) references tb_college (collid));-- 创建教师表create table tb_teacher(teaid         int not null comment &#39;工号&#39;,teaname     varchar(20) not null comment &#39;姓名&#39;,teatitle     varchar(10) default &#39;助教&#39; comment &#39;职称&#39;,collid         int not null comment &#39;所属学院&#39;,primary key (teaid),foreign key (collid) references tb_college (collid));-- 创建课程表create table tb_course(couid         int not null comment &#39;编号&#39;,couname     varchar(50) not null comment &#39;名称&#39;,coucredit     int not null comment &#39;学分&#39;,teaid         int not null comment &#39;授课老师&#39;,primary key (couid),foreign key (teaid) references tb_teacher (teaid));-- 创建选课记录表create table tb_record(recid         int auto_increment comment &#39;选课记录编号&#39;,sid         int not null comment &#39;选课学生&#39;,cid         int not null comment &#39;所选课程&#39;,seldate     datetime default now() comment &#39;选课时间日期&#39;,score         decimal(4,1) comment &#39;考试成绩&#39;,primary key (recid),foreign key (sid) references tb_student (stuid),foreign key (cid) references tb_course (couid),unique (sid, cid));</code></pre><p>上面的DDL有几个地方需要强调一下：</p><ul><li><p>创建数据库时，我们通过<code>default charset utf8</code>指定了数据库默认使用的字符集，我们推荐使用该字符集，因为utf8能够支持国际化编码。如果将来数据库中用到的字符可能包括类似于Emoji这样的图片字符，也可以将默认字符集设定为utf8mb4（最大4字节的utf-8编码）。查看MySQL支持的字符集可以执行下面的语句。</p><pre><code class="SQL">show character set;</code></pre><pre><code>+----------+---------------------------------+---------------------+--------+| Charset  | Description                     | Default collation   | Maxlen |+----------+---------------------------------+---------------------+--------+| big5     | Big5 Traditional Chinese        | big5_chinese_ci     |      2 || dec8     | DEC West European               | dec8_swedish_ci     |      1 || cp850    | DOS West European               | cp850_general_ci    |      1 || hp8      | HP West European                | hp8_english_ci      |      1 || koi8r    | KOI8-R Relcom Russian           | koi8r_general_ci    |      1 || latin1   | cp1252 West European            | latin1_swedish_ci   |      1 || latin2   | ISO 8859-2 Central European     | latin2_general_ci   |      1 || swe7     | 7bit Swedish                    | swe7_swedish_ci     |      1 || ascii    | US ASCII                        | ascii_general_ci    |      1 || ujis     | EUC-JP Japanese                 | ujis_japanese_ci    |      3 || sjis     | Shift-JIS Japanese              | sjis_japanese_ci    |      2 || hebrew   | ISO 8859-8 Hebrew               | hebrew_general_ci   |      1 || tis620   | TIS620 Thai                     | tis620_thai_ci      |      1 || euckr    | EUC-KR Korean                   | euckr_korean_ci     |      2 || koi8u    | KOI8-U Ukrainian                | koi8u_general_ci    |      1 || gb2312   | GB2312 Simplified Chinese       | gb2312_chinese_ci   |      2 || greek    | ISO 8859-7 Greek                | greek_general_ci    |      1 || cp1250   | Windows Central European        | cp1250_general_ci   |      1 || gbk      | GBK Simplified Chinese          | gbk_chinese_ci      |      2 || latin5   | ISO 8859-9 Turkish              | latin5_turkish_ci   |      1 || armscii8 | ARMSCII-8 Armenian              | armscii8_general_ci |      1 || utf8     | UTF-8 Unicode                   | utf8_general_ci     |      3 || ucs2     | UCS-2 Unicode                   | ucs2_general_ci     |      2 || cp866    | DOS Russian                     | cp866_general_ci    |      1 || keybcs2  | DOS Kamenicky Czech-Slovak      | keybcs2_general_ci  |      1 || macce    | Mac Central European            | macce_general_ci    |      1 || macroman | Mac West European               | macroman_general_ci |      1 || cp852    | DOS Central European            | cp852_general_ci    |      1 || latin7   | ISO 8859-13 Baltic              | latin7_general_ci   |      1 || utf8mb4  | UTF-8 Unicode                   | utf8mb4_general_ci  |      4 || cp1251   | Windows Cyrillic                | cp1251_general_ci   |      1 || utf16    | UTF-16 Unicode                  | utf16_general_ci    |      4 || utf16le  | UTF-16LE Unicode                | utf16le_general_ci  |      4 || cp1256   | Windows Arabic                  | cp1256_general_ci   |      1 || cp1257   | Windows Baltic                  | cp1257_general_ci   |      1 || utf32    | UTF-32 Unicode                  | utf32_general_ci    |      4 || binary   | Binary pseudo charset           | binary              |      1 || geostd8  | GEOSTD8 Georgian                | geostd8_general_ci  |      1 || cp932    | SJIS for Windows Japanese       | cp932_japanese_ci   |      2 || eucjpms  | UJIS for Windows Japanese       | eucjpms_japanese_ci |      3 || gb18030  | China National Standard GB18030 | gb18030_chinese_ci  |      4 |+----------+---------------------------------+---------------------+--------+41 rows in set (0.00 sec)</code></pre><p>如果要设置MySQL服务启动时默认使用的字符集，可以修改MySQL的配置并添加以下内容</p><pre><code class="INI">[mysqld]character-set-server=utf8</code></pre></li><li><p>在创建表的时候，我们可以在右圆括号的后面通过<code>engine=XXX</code>来指定表的存储引擎，MySQL支持多种存储引擎，可以通过<code>show engines</code>命令进行查看。MySQL 5.5以后的版本默认使用的存储引擎是InnoDB，它正好也就是我们推荐大家使用的存储引擎（因为InnoDB更适合互联网应用对高并发、性能以及事务支持等方面的需求）。</p><pre><code class="SQL">show engines\G</code></pre><pre><code>*************************** 1. row ***************************      Engine: InnoDB     Support: DEFAULT     Comment: Supports transactions, row-level locking, and foreign keysTransactions: YES          XA: YES  Savepoints: YES*************************** 2. row ***************************      Engine: MRG_MYISAM     Support: YES     Comment: Collection of identical MyISAM tablesTransactions: NO          XA: NO  Savepoints: NO*************************** 3. row ***************************      Engine: MEMORY     Support: YES     Comment: Hash based, stored in memory, useful for temporary tablesTransactions: NO          XA: NO  Savepoints: NO*************************** 4. row ***************************      Engine: BLACKHOLE     Support: YES     Comment: /dev/null storage engine (anything you write to it disappears)Transactions: NO          XA: NO  Savepoints: NO*************************** 5. row ***************************      Engine: MyISAM     Support: YES     Comment: MyISAM storage engineTransactions: NO          XA: NO  Savepoints: NO*************************** 6. row ***************************      Engine: CSV     Support: YES     Comment: CSV storage engineTransactions: NO          XA: NO  Savepoints: NO*************************** 7. row ***************************      Engine: ARCHIVE     Support: YES     Comment: Archive storage engineTransactions: NO          XA: NO  Savepoints: NO*************************** 8. row ***************************      Engine: PERFORMANCE_SCHEMA     Support: YES     Comment: Performance SchemaTransactions: NO          XA: NO  Savepoints: NO*************************** 9. row ***************************      Engine: FEDERATED     Support: NO     Comment: Federated MySQL storage engineTransactions: NULL          XA: NULL  Savepoints: NULL9 rows in set (0.00 sec)</code></pre><p>下面的表格对MySQL几种常用的数据引擎进行了简单的对比。</p><table><thead><tr><th>特性</th><th>InnoDB</th><th>MRG_MYISAM</th><th>MEMORY</th><th>MyISAM</th></tr></thead><tbody><tr><td>存储限制</td><td>有</td><td>没有</td><td>有</td><td>有</td></tr><tr><td>事务</td><td>支持</td><td></td><td></td><td></td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td></td></tr><tr><td>全文检索</td><td>支持（5.6+）</td><td></td><td></td><td>支持</td></tr><tr><td>集群索引</td><td>支持</td><td></td><td></td><td></td></tr><tr><td>数据缓存</td><td>支持</td><td></td><td>支持</td><td></td></tr><tr><td>索引缓存</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据可压缩</td><td></td><td></td><td></td><td>支持</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中</td><td>低</td></tr><tr><td>存储空间使用</td><td>高</td><td>低</td><td></td><td>低</td></tr><tr><td>批量插入性能</td><td>低</td><td>高</td><td>高</td><td>高</td></tr><tr><td>是否支持外键</td><td>支持</td><td></td><td></td><td></td></tr></tbody></table><p>通过上面的比较我们可以了解到，InnoDB是唯一能够支持外键、事务以及行锁的存储引擎，所以我们之前说它更适合互联网应用，而且它也是较新的MySQL版本中默认使用的存储引擎。</p></li><li><p>在定义表结构为每个字段选择数据类型时，如果不清楚哪个数据类型更合适，可以通过MySQL的帮助系统来了解每种数据类型的特性、数据的长度和精度等相关信息。</p><pre><code class="SQL">? data types</code></pre><pre><code>You asked for help about help category: &quot;Data Types&quot;For more information, type &#39;help &lt;item&gt;&#39;, where &lt;item&gt; is one of the followingtopics:   AUTO_INCREMENT   BIGINT   BINARY   BIT   BLOB   BLOB DATA TYPE   BOOLEAN   CHAR   CHAR BYTE   DATE   DATETIME   DEC   DECIMAL   DOUBLE   DOUBLE PRECISION   ENUM   FLOAT   INT   INTEGER   LONGBLOB   LONGTEXT   MEDIUMBLOB   MEDIUMINT   MEDIUMTEXT   SET DATA TYPE   SMALLINT   TEXT   TIME   TIMESTAMP   TINYBLOB   TINYINT   TINYTEXT   VARBINARY   VARCHAR   YEAR DATA TYPE</code></pre><pre><code class="SQL">? varchar</code></pre><pre><code>Name: &#39;VARCHAR&#39;Description:[NATIONAL] VARCHAR(M) [CHARACTER SET charset_name] [COLLATEcollation_name]A variable-length string. M represents the maximum column length incharacters. The range of M is 0 to 65,535. The effective maximum lengthof a VARCHAR is subject to the maximum row size (65,535 bytes, which isshared among all columns) and the character set used. For example, utf8characters can require up to three bytes per character, so a VARCHARcolumn that uses the utf8 character set can be declared to be a maximumof 21,844 characters. Seehttp://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html.MySQL stores VARCHAR values as a 1-byte or 2-byte length prefix plusdata. The length prefix indicates the number of bytes in the value. AVARCHAR column uses one length byte if values require no more than 255bytes, two length bytes if values may require more than 255 bytes.*Note*:MySQL follows the standard SQL specification, and does not removetrailing spaces from VARCHAR values.VARCHAR is shorthand for CHARACTER VARYING. NATIONAL VARCHAR is thestandard SQL way to define that a VARCHAR column should use somepredefined character set. MySQL uses utf8 as this predefined characterset. http://dev.mysql.com/doc/refman/5.7/en/charset-national.html.NVARCHAR is shorthand for NATIONAL VARCHAR.URL: http://dev.mysql.com/doc/refman/5.7/en/string-type-overview.html</code></pre><p>在数据类型的选择上，保存字符串数据通常都使用VARCHAR和CHAR两种类型，前者通常称为变长字符串，而后者通常称为定长字符串；对于InnoDB存储引擎，行存储格式没有区分固定长度和可变长度列，因此VARCHAR类型好CHAR类型没有本质区别，后者不一定比前者性能更好。如果要保存的很大字符串，可以使用TEXT类型；如果要保存很大的字节串，可以使用BLOB（二进制大对象）类型。在MySQL中，TEXT和BLOB又分别包括TEXT、MEDIUMTEXT、LONGTEXT和BLOB、MEDIUMBLOB、LONGBLOB三种不同的类型，它们主要的区别在于存储数据的最大大小不同。保存浮点数可以用FLOAT或DOUBLE类型，而保存定点数应该使用DECIMAL类型。如果要保存时间日期，DATETIME类型优于TIMESTAMP类型，因为前者能表示的时间日期范围更大。</p></li></ul></li><li><p>DML</p><pre><code class="SQL">-- 插入学院数据insert into tb_college (collname, collintro) values (&#39;计算机学院&#39;, &#39;创建于1956年是我国首批建立计算机专业。学院现有计算机科学与技术一级学科和网络空间安全一级学科博士学位授予权，其中计算机科学与技术一级学科具有博士后流动站。计算机科学与技术一级学科在2017年全国第四轮学科评估中评为A；2019 U.S.News全球计算机学科排名26名；ESI学科排名0.945‰，进入全球前1‰，位列第43位。&#39;),(&#39;外国语学院&#39;, &#39;1998年浙江大学、杭州大学、浙江农业大学、浙江医科大学四校合并，成立新的浙江大学。1999年原浙江大学外语系、原杭州大学外国语学院、原杭州大学大外部、原浙江农业大学公外部、原浙江医科大学外语教学部合并，成立浙江大学外国语学院。2003年学院更名为浙江大学外国语言文化与国际交流学院。&#39;),(&#39;经济管理学院&#39;, &#39;四川大学经济学院历史悠久、传承厚重，其前身是创办于1905年的四川大学经济科,距今已有100多年的历史。已故著名经济学家彭迪先、张与九、蒋学模、胡寄窗、陶大镛、胡代光，以及当代著名学者刘诗白等曾先后在此任教或学习。在长期的办学过程中，学院坚持以马克思主义的立场、观点、方法为指导，围绕建设世界一流经济学院的奋斗目标，做实“两个伟大”深度融合，不断提高党的建设质量与科学推进一流事业深度融合。&#39;);-- 插入学生数据insert into tb_student (stuid, stuname, stusex, stubirth, stuaddr, collid) values(1001, &#39;杨逍&#39;, 1, &#39;1990-3-4&#39;, &#39;四川成都&#39;, 1),(1002, &#39;任我行&#39;, 1, &#39;1992-2-2&#39;, &#39;湖南长沙&#39;, 1),(1033, &#39;王语嫣&#39;, 0, &#39;1989-12-3&#39;, &#39;四川成都&#39;, 1),(1572, &#39;岳不群&#39;, 1, &#39;1993-7-19&#39;, &#39;陕西咸阳&#39;, 1),(1378, &#39;纪嫣然&#39;, 0, &#39;1995-8-12&#39;, &#39;四川绵阳&#39;, 1),(1954, &#39;林平之&#39;, 1, &#39;1994-9-20&#39;, &#39;福建莆田&#39;, 1),(2035, &#39;东方不败&#39;, 1, &#39;1988-6-30&#39;, null, 2),(3011, &#39;林震南&#39;, 1, &#39;1985-12-12&#39;, &#39;福建莆田&#39;, 3),(3755, &#39;项少龙&#39;, 1, &#39;1993-1-25&#39;, null, 3),(3923, &#39;杨不悔&#39;, 0, &#39;1985-4-17&#39;, &#39;四川成都&#39;, 3),(4040, &#39;隔壁老王&#39;, 1, &#39;1989-1-1&#39;, &#39;四川成都&#39;, 2);-- 删除学生数据delete from tb_student where stuid=4040;-- 更新学生数据update tb_student set stuname=&#39;杨过&#39;, stuaddr=&#39;湖南长沙&#39; where stuid=1001;-- 插入老师数据insert into tb_teacher (teaid, teaname, teatitle, collid) values (1122, &#39;张三丰&#39;, &#39;教授&#39;, 1),(1133, &#39;宋远桥&#39;, &#39;副教授&#39;, 1),(1144, &#39;杨逍&#39;, &#39;副教授&#39;, 1),(2255, &#39;范遥&#39;, &#39;副教授&#39;, 2),(3366, &#39;韦一笑&#39;, &#39;讲师&#39;, 3);-- 插入课程数据insert into tb_course (couid, couname, coucredit, teaid) values (1111, &#39;Python程序设计&#39;, 3, 1122),(2222, &#39;Web前端开发&#39;, 2, 1122),(3333, &#39;操作系统&#39;, 4, 1122),(4444, &#39;计算机网络&#39;, 2, 1133),(5555, &#39;编译原理&#39;, 4, 1144),(6666, &#39;算法和数据结构&#39;, 3, 1144),(7777, &#39;经贸法语&#39;, 3, 2255),(8888, &#39;成本会计&#39;, 2, 3366),(9999, &#39;审计学&#39;, 3, 3366);-- 插入选课数据insert into tb_record (sid, cid, seldate, score) values (1001, 1111, &#39;2017-09-01&#39;, 95),(1001, 2222, &#39;2017-09-01&#39;, 87.5),(1001, 3333, &#39;2017-09-01&#39;, 100),(1001, 4444, &#39;2018-09-03&#39;, null),(1001, 6666, &#39;2017-09-02&#39;, 100),(1002, 1111, &#39;2017-09-03&#39;, 65),(1002, 5555, &#39;2017-09-01&#39;, 42),(1033, 1111, &#39;2017-09-03&#39;, 92.5),(1033, 4444, &#39;2017-09-01&#39;, 78),(1033, 5555, &#39;2017-09-01&#39;, 82.5),(1572, 1111, &#39;2017-09-02&#39;, 78),(1378, 1111, &#39;2017-09-05&#39;, 82),(1378, 7777, &#39;2017-09-02&#39;, 65.5),(2035, 7777, &#39;2018-09-03&#39;, 88),(2035, 9999, default, null),(3755, 1111, default, null),(3755, 8888, default, null),(3755, 9999, &#39;2017-09-01&#39;, 92);</code></pre><pre><code class="SQL">-- 查询所有学生信息select * from tb_student;-- 查询所有课程名称及学分(投影和别名)select couname, coucredit from tb_course;select couname as 课程名称, coucredit as 学分 from tb_course;-- 查询所有学生的姓名和性别(条件运算)select stuname as 姓名, case stusex when 1 then &#39;男&#39; else &#39;女&#39; end as 性别 from tb_student;select stuname as 姓名, if(stusex, &#39;男&#39;, &#39;女&#39;) as 性别 from tb_student;-- 查询所有女学生的姓名和出生日期(筛选)select stuname, stubirth from tb_student where stusex=0;-- 查询所有80后学生的姓名、性别和出生日期(筛选)select stuname, stusex, stubirth from tb_student where stubirth&gt;=&#39;1980-1-1&#39; and stubirth&lt;=&#39;1989-12-31&#39;;select stuname, stusex, stubirth from tb_student where stubirth between &#39;1980-1-1&#39; and &#39;1989-12-31&#39;;-- 查询姓&quot;杨&quot;的学生姓名和性别(模糊)select stuname, stusex from tb_student where stuname like &#39;杨%&#39;;-- 查询姓&quot;杨&quot;名字两个字的学生姓名和性别(模糊)select stuname, stusex from tb_student where stuname like &#39;杨_&#39;;-- 查询姓&quot;杨&quot;名字三个字的学生姓名和性别(模糊)select stuname, stusex from tb_student where stuname like &#39;杨__&#39;;-- 查询名字中有&quot;不&quot;字或&quot;嫣&quot;字的学生的姓名(模糊)select stuname, stusex from tb_student where stuname like &#39;%不%&#39; or stuname like &#39;%嫣%&#39;;-- 查询没有录入家庭住址的学生姓名(空值)select stuname from tb_student where stuaddr is null;-- 查询录入了家庭住址的学生姓名(空值)select stuname from tb_student where stuaddr is not null;-- 查询学生选课的所有日期(去重)select distinct seldate from tb_record;-- 查询学生的家庭住址(去重)select distinct stuaddr from tb_student where stuaddr is not null;-- 查询男学生的姓名和生日按年龄从大到小排列(排序)select stuname as 姓名, datediff(curdate(), stubirth) div 365 as 年龄 from tb_student where stusex=1 order by 年龄 desc;-- 查询年龄最大的学生的出生日期(聚合函数)select min(stubirth) from tb_student;-- 查询年龄最小的学生的出生日期(聚合函数)select max(stubirth) from tb_student;-- 查询男女学生的人数(分组和聚合函数)select stusex, count(*) from tb_student group by stusex;-- 查询课程编号为1111的课程的平均成绩(筛选和聚合函数)select avg(score) from tb_record where cid=1111;-- 查询学号为1001的学生所有课程的平均分(筛选和聚合函数)select avg(score) from tb_record where sid=1001;-- 查询每个学生的学号和平均成绩(分组和聚合函数)select sid as 学号, avg(score) as 平均分 from tb_record group by sid;-- 查询平均成绩大于等于90分的学生的学号和平均成绩-- 分组以前的筛选使用where子句 / 分组以后的筛选使用having子句select sid as 学号, avg(score) as 平均分 from tb_record group by sid having 平均分&gt;=90;-- 查询年龄最大的学生的姓名(子查询/嵌套的查询)select stuname from tb_student where stubirth=( select min(stubirth) from tb_student );-- 查询年龄最大的学生姓名和年龄(子查询+运算)select stuname as 姓名, datediff(curdate(), stubirth) div 365 as 年龄 from tb_student where stubirth=( select min(stubirth) from tb_student );-- 查询选了两门以上的课程的学生姓名(子查询/分组条件/集合运算)select stuname from tb_student where stuid in ( select stuid from tb_record group by stuid having count(stuid)&gt;2 );-- 查询学生姓名、课程名称以及成绩(连接查询)select stuname, couname, score from tb_student t1, tb_course t2, tb_record t3 where stuid=sid and couid=cid and score is not null;-- 查询学生姓名、课程名称以及成绩按成绩从高到低查询第11-15条记录(内连接+分页)select stuname, couname, score from tb_student inner join tb_record on stuid=sid inner join tb_course on couid=cid where score is not null order by score desc limit 5 offset 10;select stuname, couname, score from tb_student inner join tb_record on stuid=sid inner join tb_course on couid=cid where score is not null order by score desc limit 10, 5;-- 查询选课学生的姓名和平均成绩(子查询和连接查询)select stuname, avgmark from tb_student, ( select sid, avg(score) as avgmark from tb_record group by sid ) temp where stuid=sid;select stuname, avgmark from tb_student inner join ( select sid, avg(score) as avgmark from tb_record group by sid ) temp on stuid=sid;-- 查询每个学生的姓名和选课数量(左外连接和子查询)select stuname, ifnull(total, 0) from tb_student left outer join ( select sid, count(sid) as total from tb_record group by sid ) temp on stuid=sid;</code></pre><p>上面的DML有几个地方需要加以说明：</p><ol><li><p>MySQL中支持多种类型的运算符，包括：算术运算符（+、-、*、/、%）、比较运算符（=、&lt;&gt;、&lt;=&gt;、&lt;、&lt;=、&gt;、&gt;=、BETWEEN…AND…、IN、IS NULL、IS NOT NULL、LIKE、RLIKE、REGEXP）、逻辑运算符（NOT、AND、OR、XOR）和位运算符（&amp;、|、^、~、&gt;&gt;、&lt;&lt;），我们可以在DML中使用这些运算符处理数据。</p></li><li><p>在查询数据时，可以在SELECT语句及其子句（如WHERE子句、ORDER BY子句、HAVING子句等）中使用函数，这些函数包括字符串函数、数值函数、时间日期函数、流程函数等，如下面的表格所示。</p><p>常用字符串函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT</td><td>将多个字符串连接成一个字符串</td></tr><tr><td>FORMAT</td><td>将数值格式化成字符串并指定保留几位小数</td></tr><tr><td>FROM_BASE64 / TO_BASE64</td><td>BASE64解码/编码</td></tr><tr><td>BIN / OCT / HEX</td><td>将数值转换成二进制/八进制/十六进制字符串</td></tr><tr><td>LOCATE</td><td>在字符串中查找一个子串的位置</td></tr><tr><td>LEFT / RIGHT</td><td>返回一个字符串左边/右边指定长度的字符</td></tr><tr><td>LENGTH / CHAR_LENGTH</td><td>返回字符串的长度以字节/字符为单位</td></tr><tr><td>LOWER / UPPER</td><td>返回字符串的小写/大写形式</td></tr><tr><td>LPAD / RPAD</td><td>如果字符串的长度不足，在字符串左边/右边填充指定的字符</td></tr><tr><td>LTRIM / RTRIM</td><td>去掉字符串前面/后面的空格</td></tr><tr><td>ORD / CHAR</td><td>返回字符对应的编码/返回编码对应的字符</td></tr><tr><td>STRCMP</td><td>比较字符串，返回-1、0、1分别表示小于、等于、大于</td></tr><tr><td>SUBSTRING</td><td>返回字符串指定范围的子串</td></tr></tbody></table><p>常用数值函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>ABS</td><td>返回一个数的绝度值</td></tr><tr><td>CEILING / FLOOR</td><td>返回一个数上取整/下取整的结果</td></tr><tr><td>CONV</td><td>将一个数从一种进制转换成另一种进制</td></tr><tr><td>CRC32</td><td>计算循环冗余校验码</td></tr><tr><td>EXP / LOG / LOG2 / LOG10</td><td>计算指数/对数</td></tr><tr><td>POW</td><td>求幂</td></tr><tr><td>RAND</td><td>返回[0,1)范围的随机数</td></tr><tr><td>ROUND</td><td>返回一个数四舍五入后的结果</td></tr><tr><td>SQRT</td><td>返回一个数的平方根</td></tr><tr><td>TRUNCATE</td><td>截断一个数到指定的精度</td></tr><tr><td>SIN / COS / TAN / COT / ASIN / ACOS / ATAN</td><td>三角函数</td></tr></tbody></table><p>常用时间日期函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE / CURTIME / NOW</td><td>获取当前日期/时间/日期和时间</td></tr><tr><td>ADDDATE / SUBDATE</td><td>将两个日期表达式相加/相减并返回结果</td></tr><tr><td>DATE / TIME</td><td>从字符串中获取日期/时间</td></tr><tr><td>YEAR / MONTH / DAY</td><td>从日期中获取年/月/日</td></tr><tr><td>HOUR / MINUTE / SECOND</td><td>从时间中获取时/分/秒</td></tr><tr><td>DATEDIFF / TIMEDIFF</td><td>返回两个时间日期表达式相差多少天/小时</td></tr><tr><td>MAKEDATE / MAKETIME</td><td>制造一个日期/时间</td></tr></tbody></table><p>常用流程函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF</td><td>根据条件是否成立返回不同的值</td></tr><tr><td>IFNULL</td><td>如果为NULL则返回指定的值否则就返回本身</td></tr><tr><td>NULLIF</td><td>两个表达式相等就返回NULL否则返回第一个表达式的值</td></tr></tbody></table><p>其他常用函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>MD5 / SHA1 / SHA2</td><td>返回字符串对应的哈希摘要</td></tr><tr><td>CHARSET / COLLATION</td><td>返回字符集/校对规则</td></tr><tr><td>USER / CURRENT_USER</td><td>返回当前用户</td></tr><tr><td>DATABASE</td><td>返回当前数据库名</td></tr><tr><td>VERSION</td><td>返回当前数据库版本</td></tr><tr><td>FOUND_ROWS / ROW_COUNT</td><td>返回查询到的行数/受影响的行数</td></tr><tr><td>LAST_INSERT_ID</td><td>返回最后一个自增主键的值</td></tr><tr><td>UUID / UUID_SHORT</td><td>返回全局唯一标识符</td></tr></tbody></table></li></ol></li><li><p>DCL</p><pre><code class="SQL">-- 创建可以远程登录的root账号并为其指定口令create user &#39;root&#39;@&#39;%&#39; identified by &#39;123456&#39;;-- 为远程登录的root账号授权操作所有数据库所有对象的所有权限并允许其将权限再次赋予其他用户grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; with grant option;-- 创建名为hellokitty的用户并为其指定口令create user &#39;hellokitty&#39;@&#39;%&#39; identified by &#39;123123&#39;;-- 将对school数据库所有对象的所有操作权限授予hellokittygrant all privileges on school.* to &#39;hellokitty&#39;@&#39;%&#39;;-- 召回hellokitty对school数据库所有对象的insert/delete/update权限revoke insert, delete, update on school.* from &#39;hellokitty&#39;@&#39;%&#39;;</code></pre><blockquote><p>说明：创建一个可以允许任意主机登录并且具有超级管理员权限的用户在现实中并不是一个明智的决定，因为一旦该账号的口令泄露或者被破解，数据库将会面临灾难级的风险。</p></blockquote></li></ol><h4 id="3-2-索引"><a href="#3-2-索引" class="headerlink" title="3.2 索引"></a>3.2 索引</h4><p>索引是关系型数据库中用来提升查询性能最为重要的手段。关系型数据库中的索引就像一本书的目录，我们可以想象一下，如果要从一本书中找出某个知识点，但是这本书没有目录，这将是意见多么可怕的事情（我们估计得一篇一篇的翻下去，才能确定这个知识点到底在什么位置）。创建索引虽然会带来存储空间上的开销，就像一本书的目录会占用一部分的篇幅一样，但是在牺牲空间后换来的查询时间的减少也是非常显著的。</p><p>MySQL中，所有数据类型的列都可以被索引，常用的存储引擎InnoDB和MyISAM能支持每个表创建16个索引。InnoDB和MyISAM使用的索引其底层算法是B-tree（B树），B-tree是一种自平衡的树，类似于平衡二叉排序树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的操作都在对数时间内完成。</p><p>接下来我们通过一个简单的例子来说明索引的意义，比如我们要根据学生的姓名来查找学生，这个场景在实际开发中应该经常遇到，就跟通过商品名称查找商品道理是一样的。我们可以使用MySQL的<code>explain</code>关键字来查看SQL的执行计划。</p><pre><code class="SQL">explain select * from tb_student where stuname=&#39;林震南&#39;\G</code></pre><pre><code>*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: tb_student   partitions: NULL         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 11     filtered: 10.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><p>在上面的SQL执行计划中，有几项值得我们关注：</p><ol><li>type：MySQL在表中找到满足条件的行的方式，也称为访问类型，包括：ALL（全表扫描）、index（索引全扫描）、range（索引范围扫描）、ref（非唯一索引扫描）、eq_ref（唯一索引扫描）、const/system、NULL。在所有的访问类型中，很显然ALL是性能最差的，它代表了全表扫描是指要扫描表中的每一行才能找到匹配的行。</li><li>possible_keys：MySQL可以选择的索引，但是<strong>有可能不会使用</strong>。</li><li>key：MySQL真正使用的索引。</li><li>rows：执行查询需要扫描的行数，这是一个<strong>预估值</strong>。</li></ol><p>从上面的执行计划可以看出，当我们通过学生名字查询学生时实际上是进行了全表扫描，不言而喻这个查询性能肯定是非常糟糕的，尤其是在表中的行很多的时候。如果我们需要经常通过学生姓名来查询学生，那么就应该在学生姓名对应的列上创建索引，通过索引来加速查询。</p><pre><code class="SQL">create index idx_student_name on tb_student(stuname);</code></pre><p>再次查看刚才的SQL对应的执行计划。</p><pre><code class="SQL">explain select * from tb_student where stuname=&#39;林震南&#39;\G</code></pre><pre><code>*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: tb_student   partitions: NULL         type: refpossible_keys: idx_student_name          key: idx_student_name      key_len: 62          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><p>可以注意到，在对学生姓名创建索引后，刚才的查询已经不是全表扫描而是基于索引的查询，而且扫描的行只有唯一的一行，这显然大大的提升了查询的性能。MySQL中还允许创建前缀索引，即对索引字段的前N个字符创建索引，这样的话可以减少索引占用的空间（但节省了空间很有可能会浪费时间，<strong>时间和空间是不可调和的矛盾</strong>），如下所示。</p><pre><code class="SQL">create index idx_student_name_1 on tb_student(stuname(1));</code></pre><p>上面的索引相当于是根据学生姓名的第一个字来创建的索引，我们再看看SQL执行计划。</p><pre><code class="SQL">explain select * from tb_student where stuname=&#39;林震南&#39;\G</code></pre><pre><code>*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: tb_student   partitions: NULL         type: refpossible_keys: idx_student_name          key: idx_student_name      key_len: 5          ref: const         rows: 2     filtered: 100.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><p>不知道大家是否注意到，这一次扫描的行变成了2行，因为学生表中有两个姓“林”的学生，我们只用姓名的第一个字作为索引的话，在查询时通过索引就会找到这两行。</p><p>如果要删除索引，可以使用下面的SQL。</p><pre><code class="SQL">alter table tb_student drop index idx_student_name;</code></pre><p>或者</p><pre><code class="SQL">drop index idx_student_name on tb_student;</code></pre><p>我们简单的为大家总结一下索引的设计原则：</p><ol><li><strong>最适合</strong>索引的列是出现在<strong>WHERE子句</strong>和连接子句中的列。</li><li>索引列的基数越大（取值多重复值少），索引的效果就越好。</li><li>使用<strong>前缀索引</strong>可以减少索引占用的空间，内存中可以缓存更多的索引。</li><li><strong>索引不是越多越好</strong>，虽然索引加速了读操作（查询），但是写操作（增、删、改）都会变得更慢，因为数据的变化会导致索引的更新，就如同书籍章节的增删需要更新目录一样。</li><li>使用InnoDB存储引擎时，表的普通索引都会保存主键的值，所以<strong>主键要尽可能选择较短的数据类型</strong>，这样可以有效的减少索引占用的空间，利用提升索引的缓存效果。</li></ol><p>最后，还有一点需要说明，InnoDB使用的B-tree索引，数值类型的列除了等值判断时索引会生效之外，使用&gt;、&lt;、&gt;=、&lt;=、BETWEEN…AND… 、&lt;&gt;时，索引仍然生效；对于字符串类型的列，如果使用不以通配符开头的模糊查询，索引也是起作用的，但是其他的情况会导致索引失效，这就意味着很有可能会做全表查询。</p><h4 id="3-3-视图"><a href="#3-3-视图" class="headerlink" title="3.3 视图"></a>3.3 视图</h4><p>视图是关系型数据库中将一组查询指令构成的结果集组合成可查询的数据表的对象。简单的说，视图就是虚拟的表，但与数据表不同的是，数据表是一种实体结构，而视图是一种虚拟结构，你也可以将视图理解为保存在数据库中被赋予名字的SQL语句。</p><p>使用视图可以获得以下好处：</p><ol><li>可以将实体数据表隐藏起来，让外部程序无法得知实际的数据结构，让访问者可以使用表的组成部分而不是整个表，降低数据库被攻击的风险。</li><li>在大多数的情况下视图是只读的（更新视图的操作通常都有诸多的限制），外部程序无法直接透过视图修改数据。</li><li>重用SQL语句，将高度复杂的查询包装在视图表中，直接访问该视图即可取出需要的数据；也可以将视图视为数据表进行连接查询。</li><li>视图可以返回与实体数据表不同格式的数据，</li></ol><p>创建视图。</p><pre><code class="SQL">create view vw_score as     select sid, round(avg(score), 1) as avgscore from tb_record group by sid;create view vw_student_score as     select stuname, avgscore         from tb_student, vw_score          where stuid=sid;</code></pre><blockquote><p><strong>提示</strong>：因为视图不包含数据，所以每次使用视图时，都必须执行查询以获得数据，如果你使用了连接查询、嵌套查询创建了较为复杂的视图，你可能会发现查询性能下降得很厉害。因此，在使用复杂的视图前，应该进行测试以确保其性能能够满足应用的需求。</p></blockquote><p>使用视图。</p><pre><code class="SQL">select stuname, avgscore from vw_student_score order by avgscore desc;</code></pre><pre><code>+--------------+----------+| stuname      | avgscore |+--------------+----------+| 杨过         |     95.6 || 任我行       |     53.5 || 王语嫣       |     84.3 || 纪嫣然       |     73.8 || 岳不群       |     78.0 || 东方不败     |     88.0 || 项少龙       |     92.0 |+--------------+----------+</code></pre><p>既然视图是一张虚拟的表，那么视图的中的数据可以更新吗？视图的可更新性要视具体情况而定，以下类型的视图是不能更新的：</p><ol><li>使用了聚合函数（SUM、MIN、MAX、AVG、COUNT等）、DISTINCT、GROUP BY、HAVING、UNION或者UNION ALL的视图。</li><li>SELECT中包含了子查询的视图。</li><li>FROM子句中包含了一个不能更新的视图的视图。</li><li>WHERE子句的子查询引用了FROM子句中的表的视图。</li></ol><p>删除视图。</p><pre><code class="SQL">drop view vw_student_score;</code></pre><blockquote><p><strong>说明</strong>：如果希望更新视图，可以先用上面的命令删除视图，也可以通过<code>create or replace view</code>来更新视图。</p></blockquote><p>视图的规则和限制。</p><ol><li>视图可以嵌套，可以利用从其他视图中检索的数据来构造一个新的视图。视图也可以和表一起使用。</li><li>创建视图时可以使用<code>order by</code>子句，但如果从视图中检索数据时也使用了<code>order by</code>，那么该视图中原先的<code>order by</code>会被覆盖。</li><li>视图无法使用索引，也不会激发触发器（实际开发中因为性能等各方面的考虑，通常不建议使用触发器，所以我们也不对这个概念进行介绍）的执行。</li></ol><h4 id="3-4-存储过程"><a href="#3-4-存储过程" class="headerlink" title="3.4 存储过程"></a>3.4 存储过程</h4><p>存储过程是事先编译好存储在数据库中的一组SQL的集合，调用存储过程可以简化应用程序开发人员的工作，减少与数据库服务器之间的通信，对于提升数据操作的性能也是有帮助的。其实迄今为止，我们使用的SQL语句都是针对一个或多个表的单条语句，但在实际开发中经常会遇到某个操作需要多条SQL语句才能完成的情况。例如，电商网站在受理用户订单时，需要做以下一系列的处理。 </p><ol><li>通过查询来核对库存中是否有对应的物品以及库存是否充足。</li><li>如果库存有物品，需要锁定库存以确保这些物品不再卖给别人， 并且要减少可用的物品数量以反映正确的库存量。</li><li>如果库存不足，可能需要进一步与供应商进行交互或者至少产生一条系统提示消息。 </li><li>不管受理订单是否成功，都需要产生流水记录，而且需要给对应的用户产生一条通知信息。 </li></ol><p>我们可以通过存储过程将复杂的操作封装起来，这样不仅有助于保证数据的一致性，而且将来如果业务发生了变动，只需要调整和修改存储过程即可。对于调用存储过程的用户来说，存储过程并没有暴露数据表的细节，而且执行存储过程比一条条的执行一组SQL要快得多。</p><p>下面的存储过程实现了查询某门课程的最高分、最低分和平均分。</p><pre><code class="SQL">drop procedure if exists sp_score_by_cid;delimiter $$create procedure sp_score_by_cid(    courseId int,     out maxScore decimal(4,1),     out minScore decimal(4,1),    out avgScore decimal(4,1))begin    select max(score) into maxScore from tb_record         where cid=courseId;    select min(score) into minScore from tb_record         where cid=courseId;    select avg(score) into avgScore from tb_record         where cid=courseId;end $$delimiter ;call sp_score_by_cid(1111, @a, @b, @c);select @a, @b, @c;</code></pre><blockquote><p>说明：在定义存储过程时，因为可能需要书写多条SQL，而分隔这些SQL需要使用分号作为分隔符，如果这个时候，仍然用分号表示整段代码结束，那么定义存储过程的SQL就会出现错误，所以上面我们用<code>delimiter $$</code>将整段代码结束的标记定义为<code>$$</code>，那么代码中的分号将不再表示整段代码的结束，需要马上执行，整段代码在遇到<code>end $$</code>时才输入完成并执行。在定义完存储过程后，通过<code>delimiter ;</code>将结束符重新改回成分号。</p></blockquote><p>上面定义的存储过程有四个参数，其中第一个参数是输入参数，代表课程的编号，后面的参数都是输出参数，因为存储过程不能定义返回值，只能通过输出参数将执行结果带出，定义输出参数的关键字是<code>out</code>，默认情况下参数都是输入参数。</p><p>调用存储过程。</p><pre><code class="SQL">call sp_score_by_cid(1111, @a, @b, @c);</code></pre><p>获取输出参数的值。</p><pre><code class="SQL">select @a as 最高分, @b as 最低分, @c as 平均分;</code></pre><p>删除存储过程。</p><pre><code class="SQL">drop procedure sp_score_by_cid;</code></pre><p>在存储过程中，我们可以定义变量、条件，可以使用分支和循环语句，可以通过游标操作查询结果，还可以使用事件调度器，这些内容我们暂时不在此处进行介绍。虽然我们说了很多存储过程的好处，但是在实际开发中，如果过度的使用存储过程，将大量复杂的运算放到存储过程中，也会导致占用数据库服务器的CPU资源，造成数据库服务器承受巨大的压力。为此，我们一般会将复杂的运算和处理交给应用服务器，因为很容易部署多台应用服务器来分摊这些压力。</p><h3 id="四：-几个重要的概念"><a href="#四：-几个重要的概念" class="headerlink" title="四： 几个重要的概念"></a>四： 几个重要的概念</h3><h4 id="4-1-范式理论-设计二维表的指导思想"><a href="#4-1-范式理论-设计二维表的指导思想" class="headerlink" title="4.1 范式理论 - 设计二维表的指导思想"></a>4.1 范式理论 - 设计二维表的指导思想</h4><ol><li>第一范式：数据表的每个列的值域都是由原子值组成的，不能够再分割。</li><li>第二范式：数据表里的所有数据都要和该数据表的键（主键与候选键）有完全依赖关系。</li><li>第三范式：所有非键属性都只和候选键有相关性，也就是说非键属性之间应该是独立无关的。</li></ol><h4 id="4-2-数据完整性"><a href="#4-2-数据完整性" class="headerlink" title="4.2 数据完整性"></a>4.2 数据完整性</h4><ol><li><p>实体完整性 - 每个实体都是独一无二的</p><ul><li>主键（primary key） / 唯一约束 / 唯一索引（unique）</li></ul></li><li><p>引用完整性（参照完整性）- 关系中不允许引用不存在的实体</p><ul><li>外键（foreign key）</li></ul></li><li><p>域完整性 - 数据是有效的</p><ul><li><p>数据类型及长度</p></li><li><p>非空约束（not null）</p></li><li><p>默认值约束（default）</p></li><li><p>检查约束（check）</p><blockquote><p>说明：在MySQL数据库中，检查约束并不起作用。</p></blockquote></li></ul></li></ol><h4 id="4-3-数据一致性"><a href="#4-3-数据一致性" class="headerlink" title="4.3 数据一致性"></a>4.3 数据一致性</h4><ol><li><p>事务：一系列对数据库进行读/写的操作，这些操作要么全都成功，要么全都失败。</p></li><li><p>事务的ACID特性</p><ul><li>原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行</li><li>一致性：事务应确保数据库的状态从一个一致状态转变为另一个一致状态</li><li>隔离性：多个事务并发执行时，一个事务的执行不应影响其他事务的执行</li><li>持久性：已被提交的事务对数据库的修改应该永久保存在数据库中</li></ul></li><li><p>MySQL中的事务操作</p><ul><li><p>开启事务环境</p><pre><code class="SQL">start transaction</code></pre><p>或</p><pre><code class="SQL">begin</code></pre></li><li><p>提交事务</p><pre><code class="SQL">commit</code></pre></li><li><p>回滚事务</p><pre><code class="SQL">rollback</code></pre></li></ul></li></ol><h3 id="五：-其他内容"><a href="#五：-其他内容" class="headerlink" title="五： 其他内容"></a>五： 其他内容</h3><p>大家应该能够想到，关于MySQL的知识肯定远远不止上面列出的这些，比如MySQL的性能优化、管理和维护MySQL的相关工具、MySQL数据的备份和恢复、监控MySQL、部署高可用架构等问题我们在这里都没有进行讨论。当然，这些内容也都是跟项目开发密切相关的，我们就留到后续的章节中再续点进行讲解。</p><h3 id="六：-Python数据库编程"><a href="#六：-Python数据库编程" class="headerlink" title="六： Python数据库编程"></a>六： Python数据库编程</h3><p>我们用如下所示的数据库来演示在Python中如何访问MySQL数据库。</p><pre><code class="SQL">drop database if exists hrs;create database hrs default charset utf8;use hrs;drop table if exists tb_emp;drop table if exists tb_dept;create table tb_dept(dno   int not null comment &#39;编号&#39;,dname varchar(10) not null comment &#39;名称&#39;,dloc  varchar(20) not null comment &#39;所在地&#39;,primary key (dno));insert into tb_dept values     (10, &#39;会计部&#39;, &#39;北京&#39;),    (20, &#39;研发部&#39;, &#39;成都&#39;),    (30, &#39;销售部&#39;, &#39;重庆&#39;),    (40, &#39;运维部&#39;, &#39;深圳&#39;);create table tb_emp(eno   int not null comment &#39;员工编号&#39;,ename varchar(20) not null comment &#39;员工姓名&#39;,job   varchar(20) not null comment &#39;员工职位&#39;,mgr   int comment &#39;主管编号&#39;,sal   int not null comment &#39;员工月薪&#39;,comm  int comment &#39;每月补贴&#39;,dno   int comment &#39;所在部门编号&#39;,primary key (eno));alter table tb_emp add constraint fk_emp_dno foreign key (dno) references tb_dept (dno);insert into tb_emp values     (7800, &#39;张三丰&#39;, &#39;总裁&#39;, null, 9000, 1200, 20),    (2056, &#39;乔峰&#39;, &#39;分析师&#39;, 7800, 5000, 1500, 20),    (3088, &#39;李莫愁&#39;, &#39;设计师&#39;, 2056, 3500, 800, 20),    (3211, &#39;张无忌&#39;, &#39;程序员&#39;, 2056, 3200, null, 20),    (3233, &#39;丘处机&#39;, &#39;程序员&#39;, 2056, 3400, null, 20),    (3251, &#39;张翠山&#39;, &#39;程序员&#39;, 2056, 4000, null, 20),    (5566, &#39;宋远桥&#39;, &#39;会计师&#39;, 7800, 4000, 1000, 10),    (5234, &#39;郭靖&#39;, &#39;出纳&#39;, 5566, 2000, null, 10),    (3344, &#39;黄蓉&#39;, &#39;销售主管&#39;, 7800, 3000, 800, 30),    (1359, &#39;胡一刀&#39;, &#39;销售员&#39;, 3344, 1800, 200, 30),    (4466, &#39;苗人凤&#39;, &#39;销售员&#39;, 3344, 2500, null, 30),    (3244, &#39;欧阳锋&#39;, &#39;程序员&#39;, 3088, 3200, null, 20),    (3577, &#39;杨过&#39;, &#39;会计&#39;, 5566, 2200, null, 10),    (3588, &#39;朱九真&#39;, &#39;会计&#39;, 5566, 2500, null, 10);</code></pre><p>在Python 3中，我们通常使用纯Python的三方库PyMySQL来访问MySQL数据库，它应该是目前Python操作MySQL数据库最好的选择。</p><ol><li><p>安装PyMySQL。</p><pre><code class="Shell">pip install pymysql</code></pre></li><li><p>添加一个部门。</p><pre><code class="Python">import pymysql</code></pre></li></ol><p>   def main():<br>       no = int(input(‘编号: ‘))<br>       name = input(‘名字: ‘)<br>       loc = input(‘所在地: ‘)<br>       # 1. 创建数据库连接对象<br>       con = pymysql.connect(host=’localhost’, port=3306,<br>                             database=’hrs’, charset=’utf8’,<br>                             user=’yourname’, password=’yourpass’)<br>       try:<br>           # 2. 通过连接对象获取游标<br>           with con.cursor() as cursor:<br>               # 3. 通过游标执行SQL并获得执行结果<br>               result = cursor.execute(<br>                   ‘insert into tb_dept values (%s, %s, %s)’,<br>                   (no, name, loc)<br>               )<br>           if result == 1:<br>               print(‘添加成功!’)<br>           # 4. 操作成功提交事务<br>           con.commit()<br>       finally:<br>           # 5. 关闭连接释放资源<br>           con.close()</p><p>   if <strong>name</strong> == ‘<strong>main</strong>‘:<br>       main()</p><pre><code>3. 删除一个部门。   ```Python   import pymysql   def main():       no = int(input(&#39;编号: &#39;))       con = pymysql.connect(host=&#39;localhost&#39;, port=3306,                             database=&#39;hrs&#39;, charset=&#39;utf8&#39;,                             user=&#39;yourname&#39;, password=&#39;yourpass&#39;,                             autocommit=True)       try:           with con.cursor() as cursor:               result = cursor.execute(                   &#39;delete from tb_dept where dno=%s&#39;,                   (no, )               )           if result == 1:               print(&#39;删除成功!&#39;)       finally:           con.close()   if __name__ == &#39;__main__&#39;:       main()</code></pre><blockquote><p>说明：如果不希望每次SQL操作之后手动提交或回滚事务，可以像上面的代码那样，在创建连接的时候多加一个名为<code>autocommit</code>的参数并将它的值设置为<code>True</code>，表示每次执行SQL之后自动提交。如果程序中不需要使用事务环境也不希望手动的提交或回滚就可以这么做。</p></blockquote><ol start="4"><li><p>更新一个部门。</p><pre><code class="Python">import pymysql</code></pre></li></ol><p>   def main():<br>       no = int(input(‘编号: ‘))<br>       name = input(‘名字: ‘)<br>       loc = input(‘所在地: ‘)<br>       con = pymysql.connect(host=’localhost’, port=3306,<br>                             database=’hrs’, charset=’utf8’,<br>                             user=’yourname’, password=’yourpass’,<br>                             autocommit=True)<br>       try:<br>           with con.cursor() as cursor:<br>               result = cursor.execute(<br>                   ‘update tb_dept set dname=%s, dloc=%s where dno=%s’,<br>                   (name, loc, no)<br>               )<br>           if result == 1:<br>               print(‘更新成功!’)<br>       finally:<br>           con.close()</p><p>   if <strong>name</strong> == ‘<strong>main</strong>‘:<br>       main()</p><pre><code>5. 查询所有部门。   ```Python   import pymysql   from pymysql.cursors import DictCursor   def main():       con = pymysql.connect(host=&#39;localhost&#39;, port=3306,                             database=&#39;hrs&#39;, charset=&#39;utf8&#39;,                             user=&#39;yourname&#39;, password=&#39;yourpass&#39;)       try:           with con.cursor(cursor=DictCursor) as cursor:               cursor.execute(&#39;select dno as no, dname as name, dloc as loc from tb_dept&#39;)               results = cursor.fetchall()               print(results)               print(&#39;编号\t名称\t\t所在地&#39;)               for dept in results:                   print(dept[&#39;no&#39;], end=&#39;\t&#39;)                   print(dept[&#39;name&#39;], end=&#39;\t&#39;)                   print(dept[&#39;loc&#39;])       finally:           con.close()   if __name__ == &#39;__main__&#39;:       main()</code></pre><ol start="6"><li><p>分页查询员工信息。</p><pre><code class="Python">import pymysqlfrom pymysql.cursors import DictCursor</code></pre></li></ol><p>   class Emp(object):</p><pre><code>   def __init__(self, no, name, job, sal):       self.no = no       self.name = name       self.job = job       self.sal = sal   def __str__(self):       return f&#39;\n编号：{self.no}\n姓名：{self.name}\n职位：{self.job}\n月薪：{self.sal}\n&#39;</code></pre><p>   def main():<br>       page = int(input(‘页码: ‘))<br>       size = int(input(‘大小: ‘))<br>       con = pymysql.connect(host=’localhost’, port=3306,<br>                             database=’hrs’, charset=’utf8’,<br>                             user=’yourname’, password=’yourpass’)<br>       try:<br>           with con.cursor() as cursor:<br>               cursor.execute(<br>                   ‘select eno as no, ename as name, job, sal from tb_emp limit %s,%s’,<br>                   ((page - 1) * size, size)<br>               )<br>               for emp_tuple in cursor.fetchall():<br>                   emp = Emp(*emp_tuple)<br>                   print(emp)<br>       finally:<br>           con.close()</p><p>   if <strong>name</strong> == ‘<strong>main</strong>‘:<br>       main()</p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文转载于GitHub项目&lt;a href=&quot;https://github.com/jackfrued/Python-100-Days&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python - 100天从新手到
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="MYSQL" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/MYSQL/"/>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="MySQL" scheme="https://closer_laps.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>玩转Linux操作系统</title>
    <link href="https://closer_laps.gitee.io/2020/02/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/%E7%8E%A9%E8%BD%ACLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://closer_laps.gitee.io/2020/02/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/%E7%8E%A9%E8%BD%ACLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-02-23T07:05:45.000Z</published>
    <updated>2020-03-12T10:55:01.085Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文转载于GitHub项目<a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">Python - 100天从新手到大师</a></strong></p></blockquote><blockquote><p>说明：本文中对Linux命令的讲解都是基于名为CentOS的Linux发行版本，我自己使用的是阿里云服务器，系统版本为CentOS Linux release 7.6.1810。不同的Linux发行版本在Shell命令和工具程序上会有一些差别，但是这些差别是很小的。</p></blockquote><h3 id="一：-操作系统发展史"><a href="#一：-操作系统发展史" class="headerlink" title="一： 操作系统发展史"></a>一： 操作系统发展史</h3><p>只有硬件没有软件的计算机系统被称之为“裸机”，我们很难用“裸机”来完成计算机日常的工作（如存储和运算），所以必须用特定的软件来控制硬件的工作。最靠近计算机硬件的软件是系统软件，其中最为重要的就是“操作系统”。“操作系统”是控制和管理整个计算机硬件和软件资源、实现资源分配和任务调配、为系统用户以及其他软件提供接口和环境的程序的集合。</p><h4 id="1-1-没有操作系统（手工操作）"><a href="#1-1-没有操作系统（手工操作）" class="headerlink" title="1.1 没有操作系统（手工操作）"></a>1.1 没有操作系统（手工操作）</h4><p>在计算机诞生之初没有操作系统的年代，人们先把程序纸带（或卡片）装上计算机，然后启动输入机把程序送入计算机，接着通过控制台开关启动程序运行。当程序执行完毕，打印机输出计算的结果，用户卸下并取走纸带（或卡片）。第二个用户上机，重复同样的步骤。在整个过程中用户独占机器，CPU等待手工操作，资源利用率极低。</p><h4 id="1-2-批处理系统"><a href="#1-2-批处理系统" class="headerlink" title="1.2 批处理系统"></a>1.2 批处理系统</h4><p>首先启动计算机上的一个监督程序，在监督程序的控制下，计算机能够自动的、成批的处理一个或多个用户的作业。完成一批作业后，监督程度又从输入机读取作业存入磁带机。按照上面的步骤重复处理任务。监督程序不停的处理各个作业，实现了作业的自动转接，减少了作业的建立时间和手工操作时间，提高了计算机资源的利用率。 批处理系统又可以分为单道批处理系统、多道批处理系统、联机批处理系统、脱机批处理系统。</p><h4 id="1-3-分时系统和实时系统"><a href="#1-3-分时系统和实时系统" class="headerlink" title="1.3 分时系统和实时系统"></a>1.3 分时系统和实时系统</h4><p>分时系统是把处理器的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。 若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时中断，把处理机让给另一作业使用，等待下一轮调度时再继续其运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的感觉是他独占了一台计算机。而每个用户可以通过自己的终端向系统发出各种操作控制命令，在充分的人机交互情况下，完成作业的运行。为了解决分时系统不能及时响应用户指令的情况，又出现了能够在在严格的时间范围内完成事件处理，及时响应随机外部事件的实时系统。</p><h4 id="1-4-通用操作系统"><a href="#1-4-通用操作系统" class="headerlink" title="1.4 通用操作系统"></a>1.4 通用操作系统</h4><ol><li><p>1960s：IBM的System/360系列的机器有了统一的操作系统OS/360。</p></li><li><p>1965年：AT&amp;T的贝尔实验室加入GE和MIT的合作计划开始开发MULTICS。</p></li><li><p>1969年：MULTICS项目失败，Ken Tompson赋闲在家，为了玩“Space Travel”游戏用汇编语言在当时已经被淘汰的PDP-7上开发了Unics。</p><blockquote><p>注：很难想象，Unix这么伟大的系统，居然是一个赋闲在家的程序员（关键是老婆回娘家还带上了孩子）在一台被淘汰的设备上为了玩游戏开发出来的。</p></blockquote></li><li><p>1970年~1971年：Ken Tompson和Dennis Ritchie用B语言在PDP-11上重写了Unics，并在Brian Kernighan的建议下将其更名为Unix。</p><p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/ken-and-dennis-pdp-11.png" srcset="/img/loading.gif" alt=""></p></li><li><p>1972年~1973年：Dennis Ritchie发明了C语言来取代可移植性较差的B语言，并开启了用C语言重写Unix的工作。</p></li><li><p>1974年：Unix推出了里程碑意义的第5版，几乎完全用C语言来实现。</p></li><li><p>1979年：从Unix第7版开始，AT&amp;T发布新的使用条款，将Unix私有化。</p></li><li><p>1987年：Andrew S. Tanenbaum教授为了能在课堂上为学生讲解操作系统运作的细节，决定在不使用任何AT&amp;T的源代码前提下，自行开发与Unix兼容的操作系统以避免版权上的争议，该系统被命名为Minix。</p><p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/andrew.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>1991年：Linus Torvalds就读于芬兰赫尔辛基大学期间，尝试在Minix上做一些开发工作，但因为Minix只是作为教学用途的操作系统，功能并不强大，为了方便在学校的新闻组和邮件系统中读写和下载文件，Linus编写了磁盘驱动程序和文件系统，这些东西形成了Linux系统内核的雏形。</p><p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/linus.png" srcset="/img/loading.gif" alt=""></p></li></ol><p>下图是Unix操作系统家族的图谱。</p><p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/history-of-unix.png" srcset="/img/loading.gif" alt=""></p><h3 id="二：-Linux概述"><a href="#二：-Linux概述" class="headerlink" title="二： Linux概述"></a>二： Linux概述</h3><p>Linux是一个通用操作系统。一个操作系统要负责任务调度、内存分配、处理外围设备I/O等操作。操作系统通常由内核（运行其他程序，管理像磁盘、打印机等硬件设备的核心程序）和系统程序（设备驱动、底层库、shell、服务程序等）两部分组成。</p><p>Linux内核是芬兰人Linus Torvalds开发的，于1991年9月发布。而Linux操作系统作为Internet时代的产物，它是由全世界许多开发者共同合作开发的，是一个自由的操作系统（注意自由和免费并不是同一个概念，想了解二者的差别可以<a href="https://www.debian.org/intro/free" target="_blank" rel="noopener">点击这里</a>）。</p><h3 id="三：-Linux系统优点"><a href="#三：-Linux系统优点" class="headerlink" title="三： Linux系统优点"></a>三： Linux系统优点</h3><ol><li>通用操作系统，不跟特定的硬件绑定。</li><li>用C语言编写，可移植性强，有内核编程接口。</li><li>支持多用户和多任务，支持安全的分层文件系统。</li><li>大量的实用程序，完善的网络功能以及强大的支持文档。</li><li>可靠的安全性和良好的稳定性，对开发者更友好。</li></ol><h3 id="四：-Linux系统发行版本"><a href="#四：-Linux系统发行版本" class="headerlink" title="四： Linux系统发行版本"></a>四： Linux系统发行版本</h3><ol><li><a href="https://www.redhat.com/en" target="_blank" rel="noopener">Redhat</a></li><li><a href="https://www.ubuntu.com/" target="_blank" rel="noopener">Ubuntu</a></li><li><a href="https://www.centos.org/" target="_blank" rel="noopener">CentOS</a></li><li><a href="https://getfedora.org/" target="_blank" rel="noopener">Fedora</a></li><li><a href="https://www.debian.org/" target="_blank" rel="noopener">Debian</a></li><li><a href="https://www.opensuse.org/" target="_blank" rel="noopener">openSUSE</a></li></ol><h3 id="五：-基础命令"><a href="#五：-基础命令" class="headerlink" title="五： 基础命令"></a>五： 基础命令</h3><p>Linux系统的命令通常都是如下所示的格式：</p><pre><code class="Shell">命令名称 [命名参数] [命令对象]</code></pre><ol><li><p>获取登录信息 - <strong>w</strong> / <strong>who</strong> / <strong>last</strong>/ <strong>lastb</strong>。</p><pre><code class="Shell">[root ~]# w 23:31:16 up 12:16,  2 users,  load average: 0.00, 0.01, 0.05USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHATroot     pts/0    182.139.66.250   23:03    4.00s  0.02s  0.00s wjackfrue pts/1    182.139.66.250   23:26    3:56   0.00s  0.00s -bash[root ~]# whoroot     pts/0        2018-04-12 23:03 (182.139.66.250)jackfrued pts/1        2018-04-12 23:26 (182.139.66.250)[root ~]# who am iroot     pts/0        2018-04-12 23:03 (182.139.66.250)[root ~]# who mom likesroot     pts/0        2018-04-12 23:03 (182.139.66.250)[root ~]# lastroot     pts/0        117.136.63.184   Sun May 26 18:57   still logged in   reboot   system boot  3.10.0-957.10.1. Mon May 27 02:52 - 19:10  (-7:-42)   root     pts/4        117.136.63.184   Sun May 26 18:51 - crash  (08:01)    root     pts/4        117.136.63.184   Sun May 26 18:49 - 18:49  (00:00)    root     pts/3        117.136.63.183   Sun May 26 18:35 - crash  (08:17)    root     pts/2        117.136.63.183   Sun May 26 18:34 - crash  (08:17)    root     pts/0        117.136.63.183   Sun May 26 18:10 - crash  (08:42)    </code></pre></li><li><p>查看自己使用的Shell - <strong>ps</strong>。</p><p>Shell也被称为“壳”或“壳程序”，它是用户与操作系统内核交流的翻译官，简单的说就是人与计算机交互的界面和接口。目前很多Linux系统默认的Shell都是bash（<u>B</u>ourne <u>A</u>gain <u>SH</u>ell），因为它可以使用tab键进行命令和路径补全、可以保存历史命令、可以方便的配置环境变量以及执行批处理操作。</p><pre><code class="Shell">[root ~]# ps  PID TTY          TIME CMD 3531 pts/0    00:00:00 bash 3553 pts/0    00:00:00 ps</code></pre></li><li><p>查看命令的说明和位置 - <strong>whatis</strong> / <strong>which</strong> / <strong>whereis</strong>。</p><pre><code class="Shell">[root ~]# whatis psps (1)        - report a snapshot of the current processes.[root ~]# whatis pythonpython (1)    - an interpreted, interactive, object-oriented programming language[root ~]# whereis psps: /usr/bin/ps /usr/share/man/man1/ps.1.gz[root ~]# whereis pythonpython: /usr/bin/python /usr/bin/python2.7 /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz[root ~]# which ps/usr/bin/ps[root ~]# which python/usr/bin/python</code></pre></li><li><p>清除屏幕上显示的内容 - <strong>clear</strong>。</p></li><li><p>查看帮助文档 - <strong>man</strong> / <strong>info</strong> / <strong>help</strong> / <strong>apropos</strong>。</p><pre><code class="Shell">[root@izwz97tbgo9lkabnat2lo8z ~]# ps --helpUsage: ps [options] Try &#39;ps --help &lt;simple|list|output|threads|misc|all&gt;&#39;  or &#39;ps --help &lt;s|l|o|t|m|a&gt;&#39; for additional help text.For more details see ps(1).[root@izwz97tbgo9lkabnat2lo8z ~]# man psPS(1)                                User Commands                                PS(1)NAME       ps - report a snapshot of the current processes.SYNOPSIS       ps [options]DESCRIPTION...</code></pre></li><li><p>查看系统和主机名 - <strong>uname</strong> / <strong>hostname</strong>。</p><pre><code class="Shell">[root@izwz97tbgo9lkabnat2lo8z ~]# unameLinux[root@izwz97tbgo9lkabnat2lo8z ~]# hostnameizwz97tbgo9lkabnat2lo8z[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat /etc/centos-releaseCentOS Linux release 7.6.1810 (Core)</code></pre><blockquote><p>说明：<code>cat</code>是连接文件内容并打印到标准输出的命令，后面会讲到该命令；<code>/etc</code>是Linux系统上的一个非常重要的目录，它保存了很多的配置文件；<code>centos-release</code>是该目录下的一个文件，因为我自己使用的Linux发行版本是CentOS 7.6，因此这里会有一个这样的文件。</p></blockquote></li><li><p>时间和日期 - <strong>date</strong> / <strong>cal</strong>。</p><pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# dateWed Jun 20 12:53:19 CST 2018[root@iZwz97tbgo9lkabnat2lo8Z ~]# cal      June 2018Su Mo Tu We Th Fr Sa                1  2 3  4  5  6  7  8  910 11 12 13 14 15 1617 18 19 20 21 22 2324 25 26 27 28 29 30[root@iZwz97tbgo9lkabnat2lo8Z ~]# cal 5 2017      May 2017Su Mo Tu We Th Fr Sa    1  2  3  4  5  6 7  8  9 10 11 12 1314 15 16 17 18 19 2021 22 23 24 25 26 2728 29 30 31</code></pre></li><li><p>重启和关机 - <strong>reboot</strong> / <strong>shutdown</strong>。</p><pre><code class="Shell">[root ~]# shutdown -h +5Shutdown scheduled for Sun 2019-05-26 19:34:27 CST, use &#39;shutdown -c&#39; to cancel.[root ~]# Broadcast message from root (Sun 2019-05-26 19:29:27 CST):The system is going down for power-off at Sun 2019-05-26 19:34:27 CST![root ~]# shutdown -cBroadcast message from root (Sun 2019-05-26 19:30:22 CST):The system shutdown has been cancelled at Sun 2019-05-26 19:31:22 CST![root ~]# shutdown -r 23:58Shutdown scheduled for Sun 2019-05-26 23:58:00 CST, use &#39;shutdown -c&#39; to cancel.[root ~]# shutdown -cBroadcast message from root (Sun 2019-05-26 19:31:06 CST):The system shutdown has been cancelled at Sun 2019-05-26 19:32:06 CST!</code></pre><blockquote><p>说明：在执行<code>shutdown</code>命令时会向登录系统的用户发出警告，可以在命令后面跟上警告消息来替换默认的警告消息，也可以在<code>-h</code>参数后通过<code>now</code>来表示立刻关机。</p></blockquote></li><li><p>退出登录 -  <strong>exit</strong> / <strong>logout</strong>。</p></li><li><p>查看历史命令 - <strong>history</strong>。</p><pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# history...452  ls453  cd Python-3.6.5/454  clear455  history[root@iZwz97tbgo9lkabnat2lo8Z ~]# !454</code></pre><blockquote><p>说明：查看到历史命令之后，可以用<code>!历史命令编号</code>来重新执行该命令；通过<code>history -c</code>可以清除历史命令。</p></blockquote></li></ol><h3 id="六：-实用程序"><a href="#六：-实用程序" class="headerlink" title="六： 实用程序"></a>六： 实用程序</h3><h4 id="6-1-文件和文件夹操作"><a href="#6-1-文件和文件夹操作" class="headerlink" title="6.1 文件和文件夹操作"></a>6.1 文件和文件夹操作</h4><ol><li><p>创建/删除空目录 - <strong>mkdir</strong> / <strong>rmdir</strong>。</p><pre><code class="Shell">[root ~]# mkdir abc[root ~]# mkdir -p xyz/abc[root ~]# rmdir abc</code></pre></li><li><p>创建/删除文件 - <strong>touch</strong> / <strong>rm</strong>。</p><pre><code class="Shell">[root ~]# touch readme.txt[root ~]# touch error.txt[root ~]# rm error.txtrm: remove regular empty file ‘error.txt’? y[root ~]# rm -rf xyz</code></pre><ul><li><code>touch</code>命令用于创建空白文件或修改文件时间。在Linux系统中一个文件有三种时间：<ul><li>更改内容的时间 - mtime。</li><li>更改权限的时间 - ctime。</li><li>最后访问时间 - atime。</li></ul></li><li><code>rm</code>的几个重要参数：<ul><li><code>-i</code>：交互式删除，每个删除项都会进行询问。</li><li><code>-r</code>：删除目录并递归的删除目录中的文件和目录。</li><li><code>-f</code>：强制删除，忽略不存在的文件，没有任何提示。</li></ul></li></ul></li><li><p>切换和查看当前工作目录 - <strong>cd</strong> / <strong>pwd</strong>。</p><blockquote><p>说明：<code>cd</code>命令后面可以跟相对路径（以当前路径作为参照）或绝对路径（以<code>/</code>开头）来切换到指定的目录，也可以用<code>cd ..</code>来返回上一级目录。请大家想一想，如果要返回到上上一级目录应该给<code>cd</code>命令加上什么样的参数呢？</p></blockquote></li><li><p>查看目录内容 - <strong>ls</strong>。</p><ul><li><code>-l</code>：以长格式查看文件和目录。</li><li><code>-a</code>：显示以点开头的文件和目录（隐藏文件）。</li><li><code>-R</code>：遇到目录要进行递归展开（继续列出目录下面的文件和目录）。</li><li><code>-d</code>：只列出目录，不列出其他内容。</li><li><code>-S</code> / <code>-t</code>：按大小/时间排序。</li></ul></li><li><p>查看文件内容 - <strong>cat</strong> / <strong>tac</strong> / <strong>head</strong> / <strong>tail</strong> / <strong>more</strong> / <strong>less</strong> / <strong>rev</strong> / <strong>od</strong>。</p><pre><code class="Shell">[root ~]# wget http://www.sohu.com/ -O sohu.html--2018-06-20 18:42:34--  http://www.sohu.com/Resolving www.sohu.com (www.sohu.com)... 14.18.240.6Connecting to www.sohu.com (www.sohu.com)|14.18.240.6|:80... connected.HTTP request sent, awaiting response... 200 OKLength: 212527 (208K) [text/html]Saving to: ‘sohu.html’100%[==================================================&gt;] 212,527     --.-K/s   in 0.03s2018-06-20 18:42:34 (7.48 MB/s) - ‘sohu.html’ saved [212527/212527][root ~]# cat sohu.html...[root ~]# head -10 sohu.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;搜狐&lt;/title&gt;&lt;meta name=&quot;Keywords&quot; content=&quot;搜狐,门户网站,新媒体,网络媒体,新闻,财经,体育,娱乐,时尚,汽车,房产,科技,图片,论坛,微博,博客,视频,电影,电视剧&quot;/&gt;&lt;meta name=&quot;Description&quot; content=&quot;搜狐网为用户提供24小时不间断的最新资讯，及搜索、邮件等网络服务。内容包括全球热点事件、突发新闻、时事评论、热播影视剧、体育赛事、行业动态、生活服务信息，以及论坛、博客、微博、我的搜狐等互动空间。&quot; /&gt;&lt;meta name=&quot;shenma-site-verification&quot; content=&quot;1237e4d02a3d8d73e96cbd97b699e9c3_1504254750&quot;&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;/&gt;[root ~]# tail -2 sohu.html&lt;/body&gt;&lt;/html&gt;[root ~]# less sohu.html...[root ~]# cat -n sohu.html | more...</code></pre><blockquote><p>说明：上面用到了一个名为<code>wget</code>的命令，它是一个网络下载器程序，可以从指定的URL下载资源。</p></blockquote></li><li><p>拷贝/移动文件 - <strong>cp</strong> / <strong>mv</strong>。</p><pre><code class="Shell">[root ~]# mkdir backup[root ~]# cp sohu.html backup/[root ~]# cd backup[root backup]# lssohu.html[root backup]# mv sohu.html sohu_index.html[root backup]# lssohu_index.html</code></pre></li><li><p>文件重命名 - <strong>rename</strong>。</p><pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# rename .htm .html *.htm</code></pre></li><li><p>查找文件和查找内容 - <strong>find</strong> / <strong>grep</strong>。</p><pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# find / -name &quot;*.html&quot;/root/sohu.html/root/backup/sohu_index.html[root@izwz97tbgo9lkabnat2lo8z ~]# find . -atime 7 -type f -print[root@izwz97tbgo9lkabnat2lo8z ~]# find . -type f -size +2k[root@izwz97tbgo9lkabnat2lo8z ~]# find . -type f -name &quot;*.swp&quot; -delete[root@iZwz97tbgo9lkabnat2lo8Z ~]# grep &quot;&lt;script&gt;&quot; sohu.html -n20:&lt;script&gt;[root@iZwz97tbgo9lkabnat2lo8Z ~]# grep -E \&lt;\/?script.*\&gt; sohu.html -n20:&lt;script&gt;22:&lt;/script&gt;24:&lt;script src=&quot;//statics.itc.cn/web/v3/static/js/es5-shim-08e41cfc3e.min.js&quot;&gt;&lt;/script&gt;25:&lt;script src=&quot;//statics.itc.cn/web/v3/static/js/es5-sham-1d5fa1124b.min.js&quot;&gt;&lt;/script&gt;26:&lt;script src=&quot;//statics.itc.cn/web/v3/static/js/html5shiv-21fc8c2ba6.js&quot;&gt;&lt;/script&gt;29:&lt;script type=&quot;text/javascript&quot;&gt;52:&lt;/script&gt;...</code></pre><blockquote><p>说明：<code>grep</code>在搜索字符串时可以使用正则表达式，如果需要使用正则表达式可以用<code>grep -E</code>或者直接使用<code>egrep</code>。</p></blockquote></li><li><p>创建链接和查看链接 - <strong>ln</strong> / <strong>readlink</strong>。</p><pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html-rw-r--r-- 1 root root 212131 Jun 20 19:15 sohu.html[root@iZwz97tbgo9lkabnat2lo8Z ~]# ln /root/sohu.html /root/backup/sohu_backup[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html-rw-r--r-- 2 root root 212131 Jun 20 19:15 sohu.html[root@iZwz97tbgo9lkabnat2lo8Z ~]# ln /root/sohu.html /root/backup/sohu_backup2[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html-rw-r--r-- 3 root root 212131 Jun 20 19:15 sohu.html[root@iZwz97tbgo9lkabnat2lo8Z ~]# ln -s /etc/centos-release sysinfo[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sysinfolrwxrwxrwx 1 root root 19 Jun 20 19:21 sysinfo -&gt; /etc/centos-release[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat sysinfoCentOS Linux release 7.4.1708 (Core)[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat /etc/centos-releaseCentOS Linux release 7.4.1708 (Core)</code></pre><blockquote><p>说明：链接可以分为硬链接和软链接（符号链接）。硬链接可以认为是一个指向文件数据的指针，就像Python中对象的引用计数，每添加一个硬链接，文件的对应链接数就增加1，只有当文件的链接数为0时，文件所对应的存储空间才有可能被其他文件覆盖。我们平常删除文件时其实并没有删除硬盘上的数据，我们删除的只是一个指针，或者说是数据的一条使用记录，所以类似于“文件粉碎机”之类的软件在“粉碎”文件时除了删除文件指针，还会在文件对应的存储区域填入数据来保证文件无法再恢复。软链接类似于Windows系统下的快捷方式，当软链接链接的文件被删除时，软链接也就失效了。</p></blockquote></li><li><p>压缩/解压缩和归档/解归档 - <strong>gzip</strong> / <strong>gunzip</strong> / <strong>xz</strong>。</p><pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# wget http://download.redis.io/releases/redis-4.0.10.tar.gz--2018-06-20 19:29:59--  http://download.redis.io/releases/redis-4.0.10.tar.gzResolving download.redis.io (download.redis.io)... 109.74.203.151Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80... connected.HTTP request sent, awaiting response... 200 OKLength: 1738465 (1.7M) [application/x-gzip]Saving to: ‘redis-4.0.10.tar.gz’100%[==================================================&gt;] 1,738,465   70.1KB/s   in 74s2018-06-20 19:31:14 (22.9 KB/s) - ‘redis-4.0.10.tar.gz’ saved [1738465/1738465][root@iZwz97tbgo9lkabnat2lo8Z ~]# ls redis*redis-4.0.10.tar.gz[root@iZwz97tbgo9lkabnat2lo8Z ~]# gunzip redis-4.0.10.tar.gz[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls redis*redis-4.0.10.tar</code></pre></li><li><p>归档和解归档 - <strong>tar</strong>。</p><pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# tar -xvf redis-4.0.10.tarredis-4.0.10/redis-4.0.10/.gitignoreredis-4.0.10/00-RELEASENOTESredis-4.0.10/BUGSredis-4.0.10/CONTRIBUTINGredis-4.0.10/COPYINGredis-4.0.10/INSTALLredis-4.0.10/MANIFESTOredis-4.0.10/Makefileredis-4.0.10/README.mdredis-4.0.10/deps/redis-4.0.10/deps/Makefileredis-4.0.10/deps/README.md...</code></pre><blockquote><p>说明：归档（也称为创建归档）和解归档都使用<code>tar</code>命令，通常创建归档需要<code>-cvf</code>三个参数，其中<code>c</code>表示创建（create），<code>v</code>表示显示创建归档详情（verbose），<code>f</code>表示指定归档的文件（file）；解归档需要加上<code>-xvf</code>参数，其中<code>x</code>表示抽取（extract），其他两个参数跟创建归档相同。</p></blockquote></li><li><p>将标准输入转成命令行参数 - <strong>xargs</strong>。</p><p>下面的命令会将查找当前路径下的html文件，然后通过<code>xargs</code>将这些文件作为参数传给<code>rm</code>命令，实现查找并删除文件的操作。</p><pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# find . -type f -name &quot;*.html&quot; | xargs rm -f</code></pre><p>下面的命令将a.txt文件中的多行内容变成一行输出到b.txt文件中，其中<code>&lt;</code>表示从a.txt中读取输入，<code>&gt;</code>表示将命令的执行结果输出到b.txt中。</p><pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# xargs &lt; a.txt &gt; b.txt</code></pre><blockquote><p>说明：这个命令就像上面演示的那样常在管道（实现进程间通信的一种方式）和重定向（重新指定输入输出的位置）操作中用到，后面的内容中会讲到管道操作和输入输出重定向操作。</p></blockquote></li><li><p>显示文件或目录 - <strong>basename</strong> / <strong>dirname</strong>。</p></li><li><p>其他相关工具。 </p><ul><li><strong>sort</strong> - 对内容排序</li><li><strong>uniq</strong> - 去掉相邻重复内容</li><li><strong>tr</strong> - 替换指定内容为新内容</li><li><strong>cut</strong> / <strong>paste</strong> - 剪切/黏贴内容</li><li><strong>split</strong> - 拆分文件</li><li><strong>file</strong> - 判断文件类型</li><li><strong>wc</strong> - 统计文件行数、单词数、字节数</li><li><strong>iconv</strong> - 编码转换</li></ul><pre><code class="Shell">[root ~]# cat foo.txtgrapeapplepitaya[root ~]# cat bar.txt100200300400[root ~]# paste foo.txt bar.txtgrape   100apple   200pitaya  300       400[root ~]# paste foo.txt bar.txt &gt; hello.txt[root ~]# cut -b 4-8 hello.txtpe      10le      20aya     30[root ~]# cat hello.txt | tr &#39;\t&#39; &#39;,&#39;grape,100apple,200pitaya,300,400[root ~]# split -l 100 sohu.html hello[root ~]# wget https://www.baidu.com/img/bd_logo1.png[root ~]# file bd_logo1.pngbd_logo1.png: PNG image data, 540 x 258, 8-bit colormap, non-interlaced[root ~]# wc sohu.html 2979   6355 212527 sohu.html[root ~]# wc -l sohu.html2979 sohu.html[root ~]# wget http://www.qq.com -O qq.html[root ~]# iconv -f gb2312 -t utf-8 qq.html</code></pre></li></ol><h4 id="6-2-管道和重定向"><a href="#6-2-管道和重定向" class="headerlink" title="6.2 管道和重定向"></a>6.2 管道和重定向</h4><ol><li><p>管道的使用 - <strong>|</strong>。</p><p>例子：查找当前目录下文件个数。</p><pre><code class="Shell">[root ~]# find ./ | wc -l6152</code></pre><p>例子：列出当前路径下的文件和文件夹，给每一项加一个编号。</p><pre><code class="Shell">[root ~]# ls | cat -n     1  dump.rdb     2  mongodb-3.6.5     3  Python-3.6.5     4  redis-3.2.11     5  redis.conf</code></pre><p>例子：查找record.log中包含AAA，但不包含BBB的记录的总数</p><pre><code class="Shell">[root ~]# cat record.log | grep AAA | grep -v BBB | wc -l</code></pre></li><li><p>输出重定向和错误重定向 - <strong>&gt;</strong> / <strong>&gt;&gt;</strong> / <strong>2&gt;</strong>。</p><pre><code class="Shell">[root ~]# cat readme.txtbananaapplegrapeapplegrapewatermelonpearpitaya[root ~]# cat readme.txt | sort | uniq &gt; result.txt[root ~]# cat result.txtapplebananagrapepearpitayawatermelon</code></pre></li><li><p>输入重定向 - <strong>&lt;</strong>。</p><pre><code class="Shell">[root ~]# echo &#39;hello, world!&#39; &gt; hello.txt[root ~]# wall &lt; hello.txt[root ~]#Broadcast message from root (Wed Jun 20 19:43:05 2018):hello, world![root ~]# echo &#39;I will show you some code.&#39; &gt;&gt; hello.txt[root ~]# wall &lt; hello.txt[root ~]#Broadcast message from root (Wed Jun 20 19:43:55 2018):hello, world!I will show you some code.</code></pre></li><li><p>多重定向 - <strong>tee</strong>。</p><p>下面的命令除了在终端显示命令<code>ls</code>的结果之外，还会追加输出到<code>ls.txt</code>文件中。</p><pre><code class="Shell">[root ~]# ls | tee -a ls.txt</code></pre></li></ol><h4 id="6-3-别名"><a href="#6-3-别名" class="headerlink" title="6.3 别名"></a>6.3 别名</h4><ol><li><p><strong>alias</strong></p><pre><code class="Shell">[root ~]# alias ll=&#39;ls -l&#39;[root ~]# alias frm=&#39;rm -rf&#39;[root ~]# ll...drwxr-xr-x  2 root       root   4096 Jun 20 12:52 abc...[root ~]# frm abc</code></pre></li><li><p><strong>unalias</strong></p><pre><code class="Shell">[root ~]# unalias frm[root ~]# frm sohu.html-bash: frm: command not found</code></pre></li></ol><h4 id="6-4-文本处理"><a href="#6-4-文本处理" class="headerlink" title="6.4 文本处理"></a>6.4 文本处理</h4><ol><li><p>字符流编辑器 - <strong>sed</strong>。</p><p>sed是操作、过滤和转换文本内容的工具。假设有一个名为fruit.txt的文件，内容如下所示。</p><pre><code class="Shell">[root ~]# cat -n fruit.txt      1  banana     2  grape     3  apple     4  watermelon     5  orange</code></pre><p>接下来，我们在第2行后面添加一个pitaya。</p><pre><code class="Shell">[root ~]# sed &#39;2a pitaya&#39; fruit.txt bananagrapepitayaapplewatermelonorange</code></pre><blockquote><p>注意：刚才的命令和之前我们讲过的很多命令一样并没有改变fruit.txt文件，而是将添加了新行的内容输出到终端中，如果想保存到fruit.txt中，可以使用输出重定向操作。</p></blockquote><p>在第2行前面插入一个waxberry。</p><pre><code class="Shell">[root ~]# sed &#39;2i waxberry&#39; fruit.txtbananawaxberrygrapeapplewatermelonorange</code></pre><p>删除第3行。</p><pre><code class="Shell">[root ~]# sed &#39;3d&#39; fruit.txtbananagrapewatermelonorange</code></pre><p>删除第2行到第4行。</p><pre><code class="Shell">[root ~]# sed &#39;2,4d&#39; fruit.txtbananaorange</code></pre><p>将文本中的字符a替换为@。</p><pre><code class="Shell">[root ~]# sed &#39;s#a#@#&#39; fruit.txt b@nanagr@pe@pplew@termelonor@nge</code></pre><p>将文本中的字符a替换为@，使用全局模式。</p><pre><code class="Shell">[root ~]# sed &#39;s#a#@#g&#39; fruit.txt b@n@n@gr@pe@pplew@termelonor@nge</code></pre><p>先cd目录，将后缀为.cfg的文件里面所有老内容替换为新内容。</p><pre><code class="Shell">sed -i &quot;s/老内容/新内容/g&quot; `find . -type f -name &quot;*.cfg&quot;`</code></pre></li><li><p>模式匹配和处理语言 - <strong>awk</strong>。</p><p>awk是一种编程语言，也是Linux系统中处理文本最为强大的工具，它的作者之一和现在的维护者就是之前提到过的Brian Kernighan（ken和dmr最亲密的伙伴）。通过该命令可以从文本中提取出指定的列、用正则表达式从文本中取出我们想要的内容、显示指定的行以及进行统计和运算，总之它非常强大。</p><p>假设有一个名为fruit2.txt的文件，内容如下所示。</p><pre><code class="Shell">[root ~]# cat fruit2.txt 1       banana      1202       grape       5003       apple       12304       watermelon  805       orange      400</code></pre><p>显示文件的第3行。</p><pre><code class="Shell">[root ~]# awk &#39;NR==3&#39; fruit2.txt 3       apple       1230</code></pre><p>显示文件的第2列。</p><pre><code class="Shell">[root ~]# awk &#39;{print $2}&#39; fruit2.txt bananagrapeapplewatermelonorange</code></pre><p>显示文件的最后一列。</p><pre><code class="Shell">[root ~]# awk &#39;{print $NF}&#39; fruit2.txt 120500123080400</code></pre><p>输出末尾数字大于等于300的行。</p><pre><code class="Shell">[root ~]# awk &#39;{if($3 &gt;= 300) {print $0}}&#39; fruit2.txt 2       grape       5003       apple       12305       orange      400</code></pre><p>上面展示的只是awk命令的冰山一角，更多的内容留给读者自己在实践中去探索。</p></li></ol><h3 id="七：-用户管理"><a href="#七：-用户管理" class="headerlink" title="七： 用户管理"></a>七： 用户管理</h3><ol><li><p>创建和删除用户 - <strong>useradd</strong> / <strong>userdel</strong>。</p><pre><code class="Shell">[root home]# useradd hellokitty[root home]# userdel hellokitty</code></pre><ul><li><code>-d</code> - 创建用户时为用户指定用户主目录</li><li><code>-g</code> - 创建用户时指定用户所属的用户组</li></ul></li><li><p>创建和删除用户组 - <strong>groupadd</strong> / <strong>groupdel</strong>。</p><blockquote><p>说明：用户组主要是为了方便对一个组里面所有用户的管理。</p></blockquote></li><li><p>修改密码 - <strong>passwd</strong>。</p><pre><code class="Shell">[root ~]# passwd hellokittyNew password: Retype new password: passwd: all authentication tokens updated successfully.</code></pre><blockquote><p>说明：输入密码和确认密码没有回显且必须一气呵成的输入完成（不能使用退格键），密码和确认密码需要一致。如果使用<code>passwd</code>命令时没有指定命令作用的对象，则表示要修改当前用户的密码。如果想批量修改用户密码，可以使用<code>chpasswd</code>命令。</p></blockquote><ul><li><code>-l</code> / <code>-u</code> - 锁定/解锁用户。</li><li><code>-d</code> - 清除用户密码。</li><li><code>-e</code> - 设置密码立即过期，用户登录时会强制要求修改密码。</li><li><code>-i</code> - 设置密码过期多少天以后禁用该用户。</li></ul></li><li><p>查看和修改密码有效期 - <strong>chage</strong>。</p><p>设置hellokitty用户100天后必须修改密码，过期前15天通知该用户，过期后15天禁用该用户。</p><pre><code class="Shell">chage -M 100 -W 15 -I 15 hellokitty</code></pre></li><li><p>切换用户 - <strong>su</strong>。</p><pre><code class="Shell">[root ~]# su hellokitty[hellokitty root]$</code></pre></li><li><p>以管理员身份执行命令 - <strong>sudo</strong>。</p><pre><code class="Shell">[hellokitty ~]$ ls /rootls: cannot open directory /root: Permission denied[hellokitty ~]$ sudo ls /root[sudo] password for hellokitty:</code></pre><blockquote><p><strong>说明</strong>：如果希望用户能够以管理员身份执行命令，用户必须要出现在sudoers名单中，sudoers文件在 <code>/etc</code>目录下，如果希望直接编辑该文件也可以使用下面的命令。</p></blockquote></li><li><p>编辑sudoers文件 - <strong>visudo</strong>。</p><p>这里使用的编辑器是vi，关于vi的知识在后面有讲解。该文件的部分内容如下所示：</p><pre><code>## Allow root to run any commands anywhere root    ALL=(ALL)   ALL## Allows members of the &#39;sys&#39; group to run networking, software, ## service management apps and more.# %sys ALL = NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS## Allows people in group wheel to run all commands%wheel  ALL=(ALL)   ALL## Same thing without a password# %wheel    ALL=(ALL)   NOPASSWD: ALL## Allows members of the users group to mount and unmount the## cdrom as root# %users  ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom## Allows members of the users group to shutdown this system# %users  localhost=/sbin/shutdown -h now</code></pre></li><li><p>显示用户与用户组的信息 - <strong>id</strong>。</p></li><li><p>给其他用户发消息 -<strong>write</strong> / <strong>wall</strong>。</p><p>发送方：</p><pre><code class="Shell">[root ~]# write hellokittyDinner is on me.Call me at 6pm.</code></pre><p>接收方：</p><pre><code class="Shell">[hellokitty ~]$ Message from root on pts/0 at 17:41 ...Dinner is on me.Call me at 6pm.EOF</code></pre></li><li><p>查看/设置是否接收其他用户发送的消息 - <strong>mesg</strong>。</p><pre><code class="Shell">[hellokitty ~]$ mesgis y[hellokitty ~]$ mesg n[hellokitty ~]$ mesgis n</code></pre></li></ol><h3 id="八：-文件系统"><a href="#八：-文件系统" class="headerlink" title="八： 文件系统"></a>八： 文件系统</h3><h4 id="8-1-文件和路径"><a href="#8-1-文件和路径" class="headerlink" title="8.1 文件和路径"></a>8.1 文件和路径</h4><ol><li>命名规则：文件名的最大长度与文件系统类型有关，一般情况下，文件名不应该超过255个字符，虽然绝大多数的字符都可以用于文件名，但是最好使用英文大小写字母、数字、下划线、点这样的符号。文件名中虽然可以使用空格，但应该尽可能避免使用空格，否则在输入文件名时需要用将文件名放在双引号中或者通过<code>\</code>对空格进行转义。</li><li>扩展名：在Linux系统下文件的扩展名是可选的，但是使用扩展名有助于对文件内容的理解。有些应用程序要通过扩展名来识别文件，但是更多的应用程序并不依赖文件的扩展名，就像<code>file</code>命令在识别文件时并不是依据扩展名来判定文件的类型。</li><li>隐藏文件：以点开头的文件在Linux系统中是隐藏文件（不可见文件）。</li></ol><h4 id="8-2-目录结构"><a href="#8-2-目录结构" class="headerlink" title="8.2 目录结构"></a>8.2 目录结构</h4><ol><li>/bin - 基本命令的二进制文件。</li><li>/boot - 引导加载程序的静态文件。</li><li>/dev - 设备文件。</li><li><strong>/etc</strong> - 配置文件。</li><li>/home - 普通用户主目录的父目录。</li><li>/lib - 共享库文件。</li><li>/lib64 - 共享64位库文件。</li><li>/lost+found - 存放未链接文件。</li><li>/media - 自动识别设备的挂载目录。</li><li>/mnt - 临时挂载文件系统的挂载点。</li><li>/opt - 可选插件软件包安装位置。</li><li>/proc -  内核和进程信息。</li><li><strong>/root</strong> - 超级管理员用户主目录。</li><li>/run - 存放系统运行时需要的东西。</li><li>/sbin - 超级用户的二进制文件。</li><li>/sys - 设备的伪文件系统。</li><li>/tmp - 临时文件夹。</li><li><strong>/usr</strong> - 用户应用目录。</li><li>/var - 变量数据目录。</li></ol><h4 id="8-3-访问权限"><a href="#8-3-访问权限" class="headerlink" title="8.3 访问权限"></a>8.3 访问权限</h4><ol><li><p><strong>chmod</strong> - 改变文件模式比特。</p><pre><code class="Shell">[root ~]# ls -l...-rw-r--r--  1 root       root 211878 Jun 19 16:06 sohu.html...[root ~]# chmod g+w,o+w sohu.html[root ~]# ls -l...-rw-rw-rw-  1 root       root 211878 Jun 19 16:06 sohu.html...[root ~]# chmod 644 sohu.html[root ~]# ls -l...-rw-r--r--  1 root       root 211878 Jun 19 16:06 sohu.html...</code></pre><blockquote><p>说明：通过上面的例子可以看出，用<code>chmod</code>改变文件模式比特有两种方式：一种是字符设定法，另一种是数字设定法。除了<code>chmod</code>之外，可以通过<code>umask</code>来设定哪些权限将在新文件的默认权限中被删除。</p></blockquote><p>长格式查看目录或文件时显示结果及其对应权限的数值如下表所示。</p><p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/file-mode.png" srcset="/img/loading.gif" alt=""></p></li><li><p><strong>chown</strong> - 改变文件所有者。</p><pre><code class="Shell"> [root ~]# ls -l ... -rw-r--r--  1 root root     54 Jun 20 10:06 readme.txt ... [root ~]# chown hellokitty readme.txt [root ~]# ls -l ... -rw-r--r--  1 hellokitty root     54 Jun 20 10:06 readme.txt ...</code></pre></li><li><p><strong>chgrp</strong> - 改变用户组。</p></li></ol><h4 id="8-4-磁盘管理"><a href="#8-4-磁盘管理" class="headerlink" title="8.4 磁盘管理"></a>8.4 磁盘管理</h4><ol><li><p>列出文件系统的磁盘使用状况 - <strong>df</strong>。</p><pre><code class="Shell">[root ~]# df -hFilesystem      Size  Used Avail Use% Mounted on/dev/vda1        40G  5.0G   33G  14% /devtmpfs        486M     0  486M   0% /devtmpfs           497M     0  497M   0% /dev/shmtmpfs           497M  356K  496M   1% /runtmpfs           497M     0  497M   0% /sys/fs/cgrouptmpfs           100M     0  100M   0% /run/user/0</code></pre></li><li><p>磁盘分区表操作 - <strong>fdisk</strong>。</p><pre><code class="Shell">[root ~]# fdisk -lDisk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x000a42f4   Device Boot      Start         End      Blocks   Id  System/dev/vda1   *        2048    83884031    41940992   83  LinuxDisk /dev/vdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytes</code></pre></li><li><p>磁盘分区工具 - <strong>parted</strong>。</p></li><li><p>格式化文件系统 - <strong>mkfs</strong>。</p><pre><code class="Shell">[root ~]# mkfs -t ext4 -v /dev/sdb</code></pre><ul><li><code>-t</code> - 指定文件系统的类型。</li><li><code>-c</code> - 创建文件系统时检查磁盘损坏情况。</li><li><code>-v</code> - 显示详细信息。</li></ul></li><li><p>文件系统检查 - <strong>fsck</strong>。</p></li><li><p>转换或拷贝文件 - <strong>dd</strong>。</p></li><li><p>挂载/卸载 - <strong>mount</strong> / <strong>umount</strong>。</p></li><li><p>创建/激活/关闭交换分区 - <strong>mkswap</strong> / <strong>swapon</strong> / <strong>swapoff</strong>。</p></li></ol><blockquote><p>说明：执行上面这些命令会带有一定的风险，如果不清楚这些命令的用法，最好不用随意使用，在使用的过程中，最好对照参考资料进行操作，并在操作前确认是否要这么做。</p></blockquote><h3 id="九：-编辑器-vim"><a href="#九：-编辑器-vim" class="headerlink" title="九： 编辑器 - vim"></a>九： 编辑器 - vim</h3><ol><li><p>启动vim。可以通过<code>vi</code>或<code>vim</code>命令来启动vim，启动时可以指定文件名来打开一个文件，如果没有指定文件名，也可以在保存的时候指定文件名。</p><pre><code class="Shell">[root ~]# vim guess.py</code></pre></li><li><p>命令模式、编辑模式和末行模式：启动vim进入的是命令模式（也称为Normal模式），在命令模式下输入英文字母<code>i</code>会进入编辑模式（Insert模式），屏幕下方出现<code>-- INSERT --</code>提示；在编辑模式下按下<code>Esc</code>会回到命令模式，此时如果输入英文<code>:</code>会进入末行模式，在末行模式下输入<code>q!</code>可以在不保存当前工作的情况下强行退出vim；在命令模式下输入<code>v</code>会进入可视模式（Visual模式），可以用光标选择一个区域再完成对应的操作。</p></li><li><p>保存和退出vim：在命令模式下输入<code>:</code> 进入末行模式，输入<code>wq</code>可以实现保存退出；如果想放弃编辑的内容输入<code>q!</code>强行退出，这一点刚才已经提到过了；在命令模式下也可以直接输入<code>ZZ</code>实现保存退出。如果只想保存文件不退出，那么可以在末行模式下输入<code>w</code>；可以在<code>w</code>后面输入空格再指定要保存的文件名。</p></li><li><p>光标操作。</p><ul><li>在命令模式下可以通过<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>来控制光标向左、下、上、右的方向移动，可以在字母前输入数字来表示移动的距离，例如：<code>10h</code>表示向左移动10个字符。</li><li>在命令模式下可以通过<code>Ctrl+y</code>和<code>Ctrl+e</code>来实现向上、向下滚动一行文本的操作，可以通过<code>Ctrl+f</code>和<code>Ctrl+b</code>来实现向前和向后翻页的操作。</li><li>在命令模式下可以通过输入英文字母<code>G</code>将光标移到文件的末尾，可以通过<code>gg</code>将光标移到文件的开始，也可以通过在<code>G</code>前输入数字来将光标移动到指定的行。</li></ul></li><li><p>文本操作。</p><ul><li>删除：在命令模式下可以用<code>dd</code>来删除整行；可以在<code>dd</code>前加数字来指定删除的行数；可以用<code>d$</code>来实现删除从光标处删到行尾的操作，也可以通过<code>d0</code>来实现从光标处删到行首的操作；如果想删除一个单词，可以使用<code>dw</code>；如果要删除全文，可以在输入<code>:%d</code>（其中<code>:</code>用来从命令模式进入末行模式）。</li><li>复制和粘贴：在命令模式下可以用<code>yy</code>来复制整行；可以在<code>yy</code>前加数字来指定复制的行数；可以通过<code>p</code>将复制的内容粘贴到光标所在的地方。</li><li>撤销和恢复：在命令模式下输入<code>u</code>可以撤销之前的操作；通过<code>Ctrl+r</code>可以恢复被撤销的操作。</li><li>对内容进行排序：在命令模式下输入<code>%!sort</code>。</li></ul></li><li><p>查找和替换。</p><ul><li>查找操作需要输入<code>/</code>进入末行模式并提供正则表达式来匹配与之对应的内容，例如：<code>/doc.*\.</code>，输入<code>n</code>来向前搜索，也可以输入<code>N</code>来向后搜索。</li><li>替换操作需要输入<code>:</code>进入末行模式并指定搜索的范围、正则表达式以及替换后的内容和匹配选项，例如：<code>:1,$s/doc.*/hello/gice</code>，其中：<ul><li><code>g</code> - global：全局匹配。</li><li><code>i</code> - ignore case：忽略大小写匹配。</li><li><code>c</code> - confirm：替换时需要确认。</li><li><code>e</code> - error：忽略错误。</li></ul></li></ul></li><li><p>参数设定：在输入<code>:</code>进入末行模式后可以对vim进行设定。</p><ul><li><p>设置Tab键的空格数：<code>set ts=4</code></p></li><li><p>设置显示/不显示行号：<code>set nu</code> / <code>set nonu</code></p></li><li><p>设置启用/关闭高亮语法：<code>syntax on</code> / <code>syntax off</code></p></li><li><p>设置显示标尺（光标所在的行和列）： <code>set ruler</code></p></li><li><p>设置启用/关闭搜索结果高亮：<code>set hls</code> / <code>set nohls</code></p><blockquote><p>说明：如果希望上面的这些设定在每次启动vim时都能自动生效，需要将这些设定写到用户主目录下的.vimrc文件中。</p></blockquote></li></ul></li><li><p>高级技巧</p><ul><li><p>比较多个文件。</p><pre><code class="Shell">[root ~]# vim -d foo.txt bar.txt</code></pre><p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/vim-diff.png" srcset="/img/loading.gif" alt=""></p></li><li><p>打开多个文件。</p><pre><code class="Shell">[root ~]# vim foo.txt bar.txt hello.txt</code></pre><p>启动vim后只有一个窗口显示的是foo.txt，可以在末行模式中输入<code>ls</code>查看到打开的三个文件，也可以在末行模式中输入<code>b &lt;num&gt;</code>来显示另一个文件，例如可以用<code>:b 2</code>将bar.txt显示出来，可以用<code>:b 3</code>将hello.txt显示出来。</p></li><li><p>拆分和切换窗口。</p><p>可以在末行模式中输入<code>sp</code>或<code>vs</code>来实现对窗口的水平或垂直拆分，这样我们就可以同时打开多个编辑窗口，通过按两次<code>Ctrl+w</code>就可以实现编辑窗口的切换，在一个窗口中执行退出操作只会关闭对应的窗口，其他的窗口继续保留。</p><p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/vim-multi-window.png" srcset="/img/loading.gif" alt=""></p></li><li><p>映射快捷键：在vim下可以将一些常用操作映射为快捷键来提升工作效率。</p><ul><li><p>例子1：在命令模式下输入<code>F4</code>执行从第一行开始删除10000行代码的操作。</p><p><code>:map &lt;F4&gt; gg10000dd</code>。</p><p>例子2：在编辑模式下输入<code>__main</code>直接补全为<code>if __name__ == &#39;__main__&#39;:</code>。</p><p><code>:inoremap __main if __name__ == &#39;__main__&#39;:</code></p></li></ul><blockquote><p>说明：上面例子2的<code>inoremap</code>中的<code>i</code>表示映射的键在编辑模式使用， <code>nore</code>表示不要递归，这一点非常重要，否则如果键对应的内容中又出现键本身，就会引发递归（相当于进入了死循环）。如果希望映射的快捷键每次启动vim时都能生效，需要将映射写到用户主目录下的.vimrc文件中。</p></blockquote></li><li><p>录制宏。</p><ul><li><p>在命令模式下输入<code>qa</code>开始录制宏（其中<code>a</code>是寄存器的名字，也可以是其他英文字母或0-9的数字）。</p></li><li><p>执行你的操作（光标操作、编辑操作等），这些操作都会被录制下来。</p></li><li><p>如果录制的操作已经完成了，按<code>q</code>结束录制。</p></li><li><p>通过<code>@a</code>（<code>a</code>是刚才使用的寄存器的名字）播放宏，如果要多次执行宏可以在前面加数字，例如<code>100@a</code>表示将宏播放100次。</p></li><li><p>可以试一试下面的例子来体验录制宏的操作，该例子来源于<a href="https://harttle.land/tags.html#Vim" target="_blank" rel="noopener">Harttle Land网站</a>，该网站上提供了很多关于vim的使用技巧，有兴趣的可以了解一下。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/vim-macro.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul></li></ol><h3 id="十：-软件安装和配置"><a href="#十：-软件安装和配置" class="headerlink" title="十： 软件安装和配置"></a>十： 软件安装和配置</h3><h4 id="10-1-使用包管理工具"><a href="#10-1-使用包管理工具" class="headerlink" title="10.1 使用包管理工具"></a>10.1 使用包管理工具</h4><ol><li><strong>yum</strong> - Yellowdog Updater Modified。<ul><li><code>yum search</code>：搜索软件包，例如<code>yum search nginx</code>。</li><li><code>yum list installed</code>：列出已经安装的软件包，例如<code>yum list installed | grep zlib</code>。</li><li><code>yum install</code>：安装软件包，例如<code>yum install nginx</code>。</li><li><code>yum remove</code>：删除软件包，例如<code>yum remove nginx</code>。</li><li><code>yum update</code>：更新软件包，例如<code>yum update</code>可以更新所有软件包，而<code>yum update tar</code>只会更新tar。</li><li><code>yum check-update</code>：检查有哪些可以更新的软件包。</li><li><code>yum info</code>：显示软件包的相关信息，例如<code>yum info nginx</code>。</li></ul></li><li><strong>rpm</strong> - Redhat Package Manager。<ul><li>安装软件包：<code>rpm -ivh &lt;packagename&gt;.rpm</code>。</li><li>移除软件包：<code>rpm -e &lt;packagename&gt;</code>。</li><li>查询软件包：<code>rpm -qa</code>，例如可以用<code>rpm -qa | grep mysql</code>来检查是否安装了MySQL相关的软件包。</li></ul></li></ol><p>下面以Nginx为例，演示如何使用yum安装软件。</p><pre><code class="Shell">[root ~]# yum -y install nginx...Installed:  nginx.x86_64 1:1.12.2-2.el7Dependency Installed:  nginx-all-modules.noarch 1:1.12.2-2.el7  nginx-mod-http-geoip.x86_64 1:1.12.2-2.el7  nginx-mod-http-image-filter.x86_64 1:1.12.2-2.el7  nginx-mod-http-perl.x86_64 1:1.12.2-2.el7  nginx-mod-http-xslt-filter.x86_64 1:1.12.2-2.el7  nginx-mod-mail.x86_64 1:1.12.2-2.el7  nginx-mod-stream.x86_64 1:1.12.2-2.el7Complete![root ~]# yum info nginxLoaded plugins: fastestmirrorLoading mirror speeds from cached hostfileInstalled PackagesName        : nginxArch        : x86_64Epoch       : 1Version     : 1.12.2Release     : 2.el7Size        : 1.5 MRepo        : installedFrom repo   : epelSummary     : A high performance web server and reverse proxy serverURL         : http://nginx.org/License     : BSDDescription : Nginx is a web server and a reverse proxy server for HTTP, SMTP, POP3 and            : IMAP protocols, with a strong focus on high concurrency, performance and low            : memory usage.[root ~]# nginx -vnginx version: nginx/1.12.2</code></pre><p>移除Nginx。</p><pre><code class="Shell">[root ~]# yum -y remove nginx</code></pre><p>下面以MySQL为例，演示如何使用rpm安装软件。要安装MySQL需要先到<a href="https://www.mysql.com/" target="_blank" rel="noopener">MySQL官方网站</a>下载对应的<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">RPM文件</a>，当然要选择和你使用的Linux系统对应的版本。MySQL现在是Oracle公司旗下的产品，在MySQL被收购后，MySQL的作者重新制作了一个MySQL的分支MariaDB，可以通过yum进行安装。</p><pre><code class="Shell">[root mysql]# lsmysql-community-client-5.7.22-1.el7.x86_64.rpmmysql-community-common-5.7.22-1.el7.x86_64.rpmmysql-community-libs-5.7.22-1.el7.x86_64.rpmmysql-community-server-5.7.22-1.el7.x86_64.rpm[root mysql]# yum -y remove mariadb-libs[root mysql]# yum -y install libaio[root mysql]#rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm...[root mysql]#rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm...[root mysql]#rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm...[root mysql]#rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm...</code></pre><blockquote><p>说明：由于MySQL和<a href="https://mariadb.org/" target="_blank" rel="noopener">MariaDB</a>的底层依赖库是有冲突的，所以上面我们首先用<code>yum</code>移除了名为mariadb-libs的依赖库并安装了名为libaio支持异步I/O操作的依赖库。关于MySQL和MariaDB之间的关系，可以阅读<a href="https://zh.wikipedia.org/wiki/MariaDB" target="_blank" rel="noopener">维基百科</a>上关于MariaDB的介绍。</p></blockquote><p>移除安装的MySQL。</p><pre><code class="Shell">[root ~]# rpm -qa | grep mysql | xargs rpm -e</code></pre><h4 id="10-2-下载解压配置环境变量"><a href="#10-2-下载解压配置环境变量" class="headerlink" title="10.2 下载解压配置环境变量"></a>10.2 下载解压配置环境变量</h4><p>下面以安装MongoDB为例，演示这类软件应该如何安装。</p><pre><code class="Shell">[root ~]# wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.5.tgz--2018-06-21 18:32:53--  https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.5.tgzResolving fastdl.mongodb.org (fastdl.mongodb.org)... 52.85.83.16, 52.85.83.228, 52.85.83.186, ...Connecting to fastdl.mongodb.org (fastdl.mongodb.org)|52.85.83.16|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 100564462 (96M) [application/x-gzip]Saving to: ‘mongodb-linux-x86_64-rhel70-3.6.5.tgz’100%[==================================================&gt;] 100,564,462  630KB/s   in 2m 9s2018-06-21 18:35:04 (760 KB/s) - ‘mongodb-linux-x86_64-rhel70-3.6.5.tgz’ saved [100564462/100564462][root ~]# gunzip mongodb-linux-x86_64-rhel70-3.6.5.tgz[root ~]# tar -xvf mongodb-linux-x86_64-rhel70-3.6.5.tarmongodb-linux-x86_64-rhel70-3.6.5/READMEmongodb-linux-x86_64-rhel70-3.6.5/THIRD-PARTY-NOTICESmongodb-linux-x86_64-rhel70-3.6.5/MPL-2mongodb-linux-x86_64-rhel70-3.6.5/GNU-AGPL-3.0mongodb-linux-x86_64-rhel70-3.6.5/bin/mongodumpmongodb-linux-x86_64-rhel70-3.6.5/bin/mongorestoremongodb-linux-x86_64-rhel70-3.6.5/bin/mongoexportmongodb-linux-x86_64-rhel70-3.6.5/bin/mongoimportmongodb-linux-x86_64-rhel70-3.6.5/bin/mongostatmongodb-linux-x86_64-rhel70-3.6.5/bin/mongotopmongodb-linux-x86_64-rhel70-3.6.5/bin/bsondumpmongodb-linux-x86_64-rhel70-3.6.5/bin/mongofilesmongodb-linux-x86_64-rhel70-3.6.5/bin/mongoreplaymongodb-linux-x86_64-rhel70-3.6.5/bin/mongoperfmongodb-linux-x86_64-rhel70-3.6.5/bin/mongodmongodb-linux-x86_64-rhel70-3.6.5/bin/mongosmongodb-linux-x86_64-rhel70-3.6.5/bin/mongomongodb-linux-x86_64-rhel70-3.6.5/bin/install_compass[root ~]# vim .bash_profile...PATH=$PATH:$HOME/bin:$HOME/mongodb-linux-x86_64-rhel70-3.6.5/binexport PATH...[root ~]# source .bash_profile[root ~]# mongod --versiondb version v3.6.5git version: a20ecd3e3a174162052ff99913bc2ca9a839d618OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013allocator: tcmallocmodules: nonebuild environment:    distmod: rhel70    distarch: x86_64    target_arch: x86_64[root ~]# mongo --versionMongoDB shell version v3.6.5git version: a20ecd3e3a174162052ff99913bc2ca9a839d618OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013allocator: tcmallocmodules: nonebuild environment:    distmod: rhel70    distarch: x86_64    target_arch: x86_64</code></pre><blockquote><p>说明：当然也可以通过yum来安装MongoDB，具体可以参照<a href="https://docs.mongodb.com/master/administration/install-on-linux/" target="_blank" rel="noopener">官方网站</a>上给出的说明。</p></blockquote><h4 id="10-3-源代码构建安装"><a href="#10-3-源代码构建安装" class="headerlink" title="10.3 源代码构建安装"></a>10.3 源代码构建安装</h4><ol><li><p>安装Python 3.6。</p><pre><code class="Shell">[root ~]# yum install gcc[root ~]# wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz[root ~]# gunzip Python-3.6.5.tgz[root ~]# tar -xvf Python-3.6.5.tar[root ~]# cd Python-3.6.5[root ~]# ./configure --prefix=/usr/local/python36 --enable-optimizations[root ~]# yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel[root ~]# make &amp;&amp; make install...[root ~]# ln -s /usr/local/python36/bin/python3.6 /usr/bin/python3[root ~]# python3 --versionPython 3.6.5[root ~]# python3 -m pip install -U pip[root ~]# pip3 --version</code></pre><blockquote><p>说明：上面在安装好Python之后还需要注册PATH环境变量，将Python安装路径下bin文件夹的绝对路径注册到PATH环境变量中。注册环境变量可以修改用户主目录下的.bash_profile或者/etc目录下的profile文件，二者的区别在于前者相当于是用户环境变量，而后者相当于是系统环境变量。</p></blockquote></li><li><p>安装Redis-3.2.12。</p><pre><code class="Shell">[root ~]# wget http://download.redis.io/releases/redis-3.2.12.tar.gz[root ~]# gunzip redis-3.2.12.tar.gz[root ~]# tar -xvf redis-3.2.12.tar[root ~]# cd redis-3.2.12[root ~]# make &amp;&amp; make install[root ~]# redis-server --versionRedis server v=3.2.12 sha=00000000:0 malloc=jemalloc-4.0.3 bits=64 build=5bc5cd3c03d6ceb6[root ~]# redis-cli --versionredis-cli 3.2.12</code></pre></li></ol><h3 id="十一：-配置服务"><a href="#十一：-配置服务" class="headerlink" title="十一： 配置服务"></a>十一： 配置服务</h3><p>我们可以Linux系统下安装和配置各种服务，也就是说我们可以把Linux系统打造成数据库服务器、Web服务器、缓存服务器、文件服务器、消息队列服务器等等。Linux下的大多数服务都被设置为守护进程（驻留在系统后台运行，但不会因为服务还在运行而导致Linux无法停止运行），所以我们安装的服务通常名字后面都有一个字母<code>d</code>，它是英文单词<code>daemon</code>的缩写，例如：防火墙服务叫firewalld，我们之前安装的MySQL服务叫mysqld，Apache服务器叫httpd等。在安装好服务之后，可以使用<code>systemctl</code>命令或<code>service</code>命令来完成对服务的启动、停止等操作，具体操作如下所示。</p><ol><li><p>启动防火墙服务。</p><pre><code class="Shell">[root ~]# systemctl start firewalld</code></pre></li><li><p>终止防火墙服务。</p><pre><code class="Shell">[root ~]# systemctl stop firewalld</code></pre></li><li><p>重启防火墙服务。</p><pre><code class="Shell">[root ~]# systemctl restart firewalld</code></pre></li><li><p>查看防火墙服务状态。</p><pre><code class="Shell"> [root ~]# systemctl status firewalld</code></pre></li><li><p>设置/禁用防火墙服务开机自启。</p><pre><code class="Shell">[root ~]# systemctl enable firewalldCreated symlink from /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service to /usr/lib/systemd/system/firewalld.service.Created symlink from /etc/systemd/system/multi-user.target.wants/firewalld.service to /usr/lib/systemd/system/firewalld.service.[root ~]# systemctl disable firewalldRemoved symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.</code></pre></li></ol><h3 id="十二：-计划任务"><a href="#十二：-计划任务" class="headerlink" title="十二： 计划任务"></a>十二： 计划任务</h3><ol><li><p>在指定的时间执行命令</p><ul><li><strong>at</strong> - 将任务排队，在指定的时间执行。</li><li><strong>atq</strong> - 查看待执行的任务队列。</li><li><strong>atrm</strong> - 从队列中删除待执行的任务。</li></ul><p>指定3天以后下午5点要执行的任务。</p><pre><code class="Shell">[root ~]# at 5pm+3daysat&gt; rm -f /root/*.htmlat&gt; &lt;EOT&gt;job 9 at Wed Jun  5 17:00:00 2019</code></pre><p>查看待执行的任务队列。</p><pre><code class="Shell">[root ~]# atq9       Wed Jun  5 17:00:00 2019 a root</code></pre><p>从队列中删除指定的任务。</p><pre><code class="Shell">[root ~]$ atrm 9</code></pre></li><li><p>计划任务表 - <strong>crontab</strong>。</p><pre><code class="Shell">[root ~]# crontab -e* * * * * echo &quot;hello, world!&quot; &gt;&gt; /root/hello.txt59 23 * * * rm -f /root/*.log</code></pre><blockquote><p>说明：输入<code>crontab -e</code>命令会打开vim来编辑Cron表达式并指定触发的任务，上面我们定制了两个计划任务，一个是每分钟向/root目录下的hello.txt中追加输出<code>hello, world!</code>；另一个是每天23时59分执行删除/root目录下以log为后缀名的文件。如果不知道Cron表达式如何书写，可以参照/etc/crontab文件中的提示（下面会讲到）或者用搜索引擎找一下“Cron表达式在线生成器”来生成Cron表达式。</p></blockquote><p>和crontab相关的文件在<code>/etc</code>目录下，通过修改<code>/etc</code>目录下的crontab文件也能够定制计划任务。</p><pre><code class="Shell">[root ~]# cd /etc[root etc]# ls -l | grep cron-rw-------.  1 root root      541 Aug  3  2017 anacrontabdrwxr-xr-x.  2 root root     4096 Mar 27 11:56 cron.ddrwxr-xr-x.  2 root root     4096 Mar 27 11:51 cron.daily-rw-------.  1 root root        0 Aug  3  2017 cron.denydrwxr-xr-x.  2 root root     4096 Mar 27 11:50 cron.hourlydrwxr-xr-x.  2 root root     4096 Jun 10  2014 cron.monthly-rw-r--r--   1 root root      493 Jun 23 15:09 crontabdrwxr-xr-x.  2 root root     4096 Jun 10  2014 cron.weekly[root etc]# vim crontab  1 SHELL=/bin/bash  2 PATH=/sbin:/bin:/usr/sbin:/usr/bin  3 MAILTO=root  4  5 # For details see man 4 crontabs  6  7 # Example of job definition:  8 # .---------------- minute (0 - 59)  9 # |  .------------- hour (0 - 23) 10 # |  |  .---------- day of month (1 - 31) 11 # |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ... 12 # |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat 13 # |  |  |  |  | 14 # *  *  *  *  * user-name  command to be executed</code></pre></li></ol><h3 id="十三：-网络访问和管理"><a href="#十三：-网络访问和管理" class="headerlink" title="十三： 网络访问和管理"></a>十三： 网络访问和管理</h3><ol><li><p>安全远程连接 - <strong>ssh</strong>。</p><pre><code class="Shell"> [root ~]$ ssh root@120.77.222.217 The authenticity of host &#39;120.77.222.217 (120.77.222.217)&#39; can&#39;t be established. ECDSA key fingerprint is SHA256:BhUhykv+FvnIL03I9cLRpWpaCxI91m9n7zBWrcXRa8w. ECDSA key fingerprint is MD5:cc:85:e9:f0:d7:07:1a:26:41:92:77:6b:7f:a0:92:65. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added &#39;120.77.222.217&#39; (ECDSA) to the list of known hosts. root@120.77.222.217&#39;s password: </code></pre></li><li><p>通过网络获取资源 - <strong>wget</strong>。</p><ul><li>-b 后台下载模式</li><li>-O 下载到指定的目录</li><li>-r 递归下载</li></ul></li><li><p>发送和接收邮件 - <strong>mail</strong>。</p></li><li><p>网络配置工具（旧） - <strong>ifconfig</strong>。</p><pre><code class="Shell">[root ~]# ifconfig eth0eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.18.61.250  netmask 255.255.240.0  broadcast 172.18.63.255        ether 00:16:3e:02:b6:46  txqueuelen 1000  (Ethernet)        RX packets 1067841  bytes 1296732947 (1.2 GiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 409912  bytes 43569163 (41.5 MiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions </code></pre></li><li><p>网络配置工具（新） - <strong>ip</strong>。</p><pre><code class="Shell">[root ~]# ip address1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000    link/ether 00:16:3e:02:b6:46 brd ff:ff:ff:ff:ff:ff    inet 172.18.61.250/20 brd 172.18.63.255 scope global eth0       valid_lft forever preferred_lft forever</code></pre></li><li><p>网络可达性检查 - <strong>ping</strong>。</p><pre><code class="Shell">[root ~]# ping www.baidu.com -c 3PING www.a.shifen.com (220.181.111.188) 56(84) bytes of data.64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=1 ttl=51 time=36.3 ms64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=2 ttl=51 time=36.4 ms64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=3 ttl=51 time=36.4 ms--- www.a.shifen.com ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2002msrtt min/avg/max/mdev = 36.392/36.406/36.427/0.156 ms</code></pre></li><li><p>显示或管理路由表 - <strong>route</strong>。</p></li><li><p>查看网络服务和端口 - <strong>netstat</strong> / <strong>ss</strong>。</p><pre><code class="Shell">[root ~]# netstat -nap | grep nginx</code></pre></li><li><p>网络监听抓包 - <strong>tcpdump</strong>。</p></li><li><p>安全文件拷贝 - <strong>scp</strong>。</p><pre><code class="Shell">[root ~]# scp root@1.2.3.4:/root/guido.jpg hellokitty@4.3.2.1:/home/hellokitty/pic.jpg</code></pre><p>scp中使用sshpass带密码传输文件</p><pre><code class="Shell">sshpass -p &#39;密码&#39; scp -r 用户名@ip:/home/file1 /home/file1</code></pre></li><li><p>文件同步工具 - <strong>rsync</strong>。</p><blockquote><p>说明：使用<code>rsync</code>可以实现文件的自动同步，这个对于文件服务器来说相当重要。关于这个命令的用法，我们在后面讲项目部署的时候为大家详细说明。</p></blockquote></li><li><p>安全文件传输 - <strong>sftp</strong>。</p><pre><code class="Shell">[root ~]# sftp root@1.2.3.4root@1.2.3.4&#39;s password:Connected to 1.2.3.4.sftp&gt;</code></pre><ul><li><p><code>help</code>：显示帮助信息。</p></li><li><p><code>ls</code>/<code>lls</code>：显示远端/本地目录列表。</p></li><li><p><code>cd</code>/<code>lcd</code>：切换远端/本地路径。</p></li><li><p><code>mkdir</code>/<code>lmkdir</code>：创建远端/本地目录。</p></li><li><p><code>pwd</code>/<code>lpwd</code>：显示远端/本地当前工作目录。</p></li><li><p><code>get</code>：下载文件。</p></li><li><p><code>put</code>：上传文件。</p></li><li><p><code>rm</code>：删除远端文件。</p></li><li><p><code>bye</code>/<code>exit</code>/<code>quit</code>：退出sftp。</p></li></ul></li></ol><h3 id="十四：-进程管理"><a href="#十四：-进程管理" class="headerlink" title="十四： 进程管理"></a>十四： 进程管理</h3><ol><li><p>查看进程 - <strong>ps</strong>。</p><pre><code class="Shell">[root ~]# ps -efUID        PID  PPID  C STIME TTY          TIME CMDroot         1     0  0 Jun23 ?        00:00:05 /usr/lib/systemd/systemd --switched-root --system --deserialize 21root         2     0  0 Jun23 ?        00:00:00 [kthreadd]...[root ~]# ps -ef | grep mysqldroot      4943  4581  0 22:45 pts/0    00:00:00 grep --color=auto mysqldmysql    25257     1  0 Jun25 ?        00:00:39 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid</code></pre></li><li><p>显示进程状态树 - <strong>pstree</strong>。</p><pre><code class="Shell"> [root ~]# pstree systemd─┬─AliYunDun───18*[{AliYunDun}]         ├─AliYunDunUpdate───3*[{AliYunDunUpdate}]         ├─2*[agetty]         ├─aliyun-service───2*[{aliyun-service}]         ├─atd         ├─auditd───{auditd}         ├─dbus-daemon         ├─dhclient         ├─irqbalance         ├─lvmetad         ├─mysqld───28*[{mysqld}]         ├─nginx───2*[nginx]         ├─ntpd         ├─polkitd───6*[{polkitd}]         ├─rsyslogd───2*[{rsyslogd}]         ├─sshd───sshd───bash───pstree         ├─systemd-journal         ├─systemd-logind         ├─systemd-udevd         └─tuned───4*[{tuned}]</code></pre></li><li><p>查找与指定条件匹配的进程 - <strong>pgrep</strong>。</p><pre><code class="Shell">[root ~]$ pgrep mysqld3584</code></pre></li><li><p>通过进程号终止进程 - <strong>kill</strong>。</p><pre><code class="Shell">[root ~]$ kill -l 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR111) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+338) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+843) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-758) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-263) SIGRTMAX-1  64) SIGRTMAX[root ~]# kill 1234[root ~]# kill -9 1234</code></pre><p>例子：用一条命令强制终止正在运行的Redis进程。</p><pre><code class="Shell">ps -ef | grep redis | grep -v grep | awk &#39;{print $2}&#39; | xargs kill</code></pre></li><li><p>通过进程名终止进程 - <strong>killall</strong> / <strong>pkill</strong>。</p><p> 结束名为mysqld的进程。</p><pre><code class="Shell"> [root ~]# pkill mysqld</code></pre><p> 结束hellokitty用户的所有进程。</p><pre><code class="Shell"> [root ~]# pkill -u hellokitty</code></pre><blockquote><p>说明：这样的操作会让hellokitty用户和服务器断开连接。</p></blockquote></li><li><p>将进程置于后台运行。</p><ul><li><code>Ctrl+Z</code> - 快捷键，用于停止进程并置于后台。</li><li><code>&amp;</code> - 将进程置于后台运行。</li></ul><pre><code class="Shell">[root ~]# mongod &amp;[root ~]# redis-server...^Z[4]+  Stopped                 redis-server</code></pre></li><li><p>查询后台进程 - <strong>jobs</strong>。</p><pre><code class="Shell">[root ~]# jobs[2]   Running                 mongod &amp;[3]-  Stopped                 cat[4]+  Stopped                 redis-server</code></pre></li><li><p>让进程在后台继续运行 - <strong>bg</strong>。</p><pre><code class="Shell">[root ~]# bg %4[4]+ redis-server &amp;[root ~]# jobs[2]   Running                 mongod &amp;[3]+  Stopped                 cat[4]-  Running                 redis-server &amp;</code></pre></li><li><p>将后台进程置于前台 - <strong>fg</strong>。</p><pre><code class="Shell"> [root ~]# fg %4 redis-server</code></pre><blockquote><p>说明：置于前台的进程可以使用<code>Ctrl+C</code>来终止它。</p></blockquote></li><li><p>调整程序/进程运行时优先级 - <strong>nice</strong> / <strong>renice</strong>。</p></li><li><p>用户登出后进程继续工作 - <strong>nohup</strong>。</p><pre><code class="Shell"> [root ~]# nohup ping www.baidu.com &gt; result.txt &amp;</code></pre></li><li><p>跟踪进程系统调用情况 - <strong>strace</strong>。</p><pre><code class="Shell"> [root ~]# pgrep mysqld 8803 [root ~]# strace -c -p 8803 strace: Process 8803 attached ^Cstrace: Process 8803 detached % time     seconds  usecs/call     calls    errors syscall ------ ----------- ----------- --------- --------- ----------------  99.18    0.005719        5719         1           restart_syscall   0.49    0.000028          28         1           mprotect   0.24    0.000014          14         1           clone   0.05    0.000003           3         1           mmap   0.03    0.000002           2         1           accept ------ ----------- ----------- --------- --------- ---------------- 100.00    0.005766                     5           total</code></pre><blockquote><p>说明：这个命令的用法和参数都比较复杂，建议大家在真正用到这个命令的时候再根据实际需要进行了解。</p></blockquote></li><li><p>查看当前运行级别 - <strong>runlevel</strong>。</p><pre><code class="Shell"> [root ~]# runlevel N 3</code></pre></li><li><p>实时监控进程占用资源状况 - <strong>top</strong>。</p><pre><code class="Shell"> [root ~]# top top - 23:04:23 up 3 days, 14:10,  1 user,  load average: 0.00, 0.01, 0.05 Tasks:  65 total,   1 running,  64 sleeping,   0 stopped,   0 zombie %Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st KiB Mem :  1016168 total,   191060 free,   324700 used,   500408 buff/cache KiB Swap:        0 total,        0 free,        0 used.   530944 avail Mem ...</code></pre><ul><li><code>-c</code> - 显示进程的整个路径。</li><li><code>-d</code> - 指定两次刷屏之间的间隔时间（秒为单位）。</li><li><code>-i</code> - 不显示闲置进程或僵尸进程。</li><li><code>-p</code> - 显示指定进程的信息。</li></ul></li></ol><h3 id="十五：-系统诊断"><a href="#十五：-系统诊断" class="headerlink" title="十五： 系统诊断"></a>十五： 系统诊断</h3><ol><li><p>系统启动异常诊断 - <strong>dmesg</strong>。</p></li><li><p>查看系统活动信息 - <strong>sar</strong>。</p><pre><code class="Shell">[root ~]# sar -u -r 5 10Linux 3.10.0-957.10.1.el7.x86_64 (izwz97tbgo9lkabnat2lo8z)      06/02/2019      _x86_64_        (2 CPU)06:48:30 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle06:48:35 PM     all      0.10      0.00      0.10      0.00      0.00     99.8006:48:30 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty06:48:35 PM   1772012   2108392     54.33    102816   1634528    784940     20.23    793328   1164704         0</code></pre><ul><li><code>-A</code> - 显示所有设备（CPU、内存、磁盘）的运行状况。</li><li><code>-u</code> - 显示所有CPU的负载情况。</li><li><code>-d</code> - 显示所有磁盘的使用情况。</li><li><code>-r</code> - 显示内存的使用情况。</li><li><code>-n</code> - 显示网络运行状态。</li></ul></li><li><p>查看内存使用情况 - <strong>free</strong>。</p><pre><code class="Shell">[root ~]# free              total        used        free      shared  buff/cache   availableMem:        1016168      323924      190452         356      501792      531800Swap:             0           0           0</code></pre></li><li><p>虚拟内存统计 - <strong>vmstat</strong>。</p><pre><code class="Shell">[root ~]# vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st 2  0      0 204020  79036 667532    0    0     5    18  101   58  1  0 99  0  0</code></pre></li><li><p>CPU信息统计 - <strong>mpstat</strong>。</p><pre><code class="Shell">[root ~]# mpstatLinux 3.10.0-957.5.1.el7.x86_64 (iZ8vba0s66jjlfmo601w4xZ)       05/30/2019      _x86_64_        (1 CPU)01:51:54 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle01:51:54 AM  all    0.71    0.00    0.17    0.04    0.00    0.00    0.00    0.00    0.00   99.07</code></pre></li><li><p>查看进程使用内存状况 - <strong>pmap</strong>。</p><pre><code class="Shell">[root ~]# ps  PID TTY          TIME CMD 4581 pts/0    00:00:00 bash 5664 pts/0    00:00:00 ps[root ~]# pmap 45814581:   -bash0000000000400000    884K r-x-- bash00000000006dc000      4K r---- bash00000000006dd000     36K rw--- bash00000000006e6000     24K rw---   [ anon ]0000000001de0000    400K rw---   [ anon ]00007f82fe805000     48K r-x-- libnss_files-2.17.so00007f82fe811000   2044K ----- libnss_files-2.17.so...</code></pre></li><li><p>报告设备CPU和I/O统计信息 - <strong>iostat</strong>。</p><pre><code class="Shell">[root ~]# iostatLinux 3.10.0-693.11.1.el7.x86_64 (iZwz97tbgo9lkabnat2lo8Z)      06/26/2018      _x86_64_       (1 CPU)avg-cpu:  %user   %nice %system %iowait  %steal   %idle           0.79    0.00    0.20    0.04    0.00   98.97Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtnvda               0.85         6.78        21.32    2106565    6623024vdb               0.00         0.01         0.00       2088          0</code></pre></li><li><p>显示所有PCI设备 - <strong>lspci</strong>。</p><pre><code class="Shell">[root ~]# lspci00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]00:01.2 USB controller: Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II] (rev 01)00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)00:02.0 VGA compatible controller: Cirrus Logic GD 544600:03.0 Ethernet controller: Red Hat, Inc. Virtio network device00:04.0 Communication controller: Red Hat, Inc. Virtio console00:05.0 SCSI storage controller: Red Hat, Inc. Virtio block device00:06.0 SCSI storage controller: Red Hat, Inc. Virtio block device00:07.0 Unclassified device [00ff]: Red Hat, Inc. Virtio memory balloon</code></pre></li><li><p>显示进程间通信设施的状态 - <strong>ipcs</strong>。</p><pre><code class="Shell">[root ~]# ipcs------ Message Queues --------key        msqid      owner      perms      used-bytes   messages    ------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      ------ Semaphore Arrays --------key        semid      owner      perms      nsems</code></pre></li></ol><h3 id="十六：-Shell编程"><a href="#十六：-Shell编程" class="headerlink" title="十六： Shell编程"></a>十六： Shell编程</h3><p>之前我们提到过，Shell是一个连接用户和操作系统的应用程序，它提供了人机交互的界面（接口），用户通过这个界面访问操作系统内核的服务。Shell脚本是一种为Shell编写的脚本程序，我们可以通过Shell脚本来进行系统管理，同时也可以通过它进行文件操作。总之，编写Shell脚本对于使用Linux系统的人来说，应该是一项标配技能。</p><p>互联网上有大量关于Shell脚本的相关知识，我不打算再此对Shell脚本做一个全面系统的讲解，我们通过下面的代码来感性的认识下Shell脚本就行了。</p><p>例子1：输入两个整数m和n，计算从m到n的整数求和的结果。</p><pre><code class="Shell">#!/usr/bin/bashprintf &#39;m = &#39;read mprintf &#39;n = &#39;read na=$msum=0while [ $a -le $n ]do    sum=$[ sum + a ]    a=$[ a + 1 ]doneecho &#39;结果: &#39;$sum</code></pre><p>例子2：自动创建文件夹和指定数量的文件。</p><pre><code class="Shell">#!/usr/bin/bashprintf &#39;输入文件名: &#39;read fileprintf &#39;输入文件数量(&lt;1000): &#39;read numif [ $num -ge 1000 ]then    echo &#39;文件数量不能超过1000&#39;else    if [ -e $dir -a -d $dir ]    then        rm -rf $dir    else        if [ -e $dir -a -f $dir ]        then            rm -f $dir        fi    fi    mkdir -p $dir    index=1    while [ $index -le $num ]    do        if [ $index -lt 10 ]        then            pre=&#39;00&#39;        elif [ $index -lt 100 ]        then            pre=&#39;0&#39;        else            pre=&#39;&#39;        fi        touch $dir&#39;/&#39;$file&#39;_&#39;$pre$index        index=$[ index + 1 ]    donefi</code></pre><p>例子3：自动安装指定版本的Redis。</p><pre><code class="Shell">#!/usr/bin/bashinstall_redis() {    if ! which redis-server &gt; /dev/null    then        cd /root        wget $1$2&#39;.tar.gz&#39; &gt;&gt; install.log        gunzip /root/$2&#39;.tar.gz&#39;        tar -xf /root/$2&#39;.tar&#39;        cd /root/$2        make &gt;&gt; install.log        make install &gt;&gt; install.log        echo &#39;安装完成&#39;    else        echo &#39;已经安装过Redis&#39;    fi}install_redis &#39;http://download.redis.io/releases/&#39; $1</code></pre><h3 id="十七：-相关资源"><a href="#十七：-相关资源" class="headerlink" title="十七： 相关资源"></a>十七： 相关资源</h3><ol><li><p>Linux命令行常用快捷键</p><table><thead><tr><th>快捷键</th><th>功能说明</th></tr></thead><tbody><tr><td>tab</td><td>自动补全命令或路径</td></tr><tr><td>Ctrl+a</td><td>将光标移动到命令行行首</td></tr><tr><td>Ctrl+e</td><td>将光标移动到命令行行尾</td></tr><tr><td>Ctrl+f</td><td>将光标向右移动一个字符</td></tr><tr><td>Ctrl+b</td><td>将光标向左移动一个字符</td></tr><tr><td>Ctrl+k</td><td>剪切从光标到行尾的字符</td></tr><tr><td>Ctrl+u</td><td>剪切从光标到行首的字符</td></tr><tr><td>Ctrl+w</td><td>剪切光标前面的一个单词</td></tr><tr><td>Ctrl+y</td><td>复制剪切命名剪切的内容</td></tr><tr><td>Ctrl+c</td><td>中断正在执行的任务</td></tr><tr><td>Ctrl+h</td><td>删除光标前面的一个字符</td></tr><tr><td>Ctrl+d</td><td>退出当前命令行</td></tr><tr><td>Ctrl+r</td><td>搜索历史命令</td></tr><tr><td>Ctrl+g</td><td>退出历史命令搜索</td></tr><tr><td>Ctrl+l</td><td>清除屏幕上所有内容在屏幕的最上方开启一个新行</td></tr><tr><td>Ctrl+s</td><td>锁定终端使之暂时无法输入内容</td></tr><tr><td>Ctrl+q</td><td>退出终端锁定</td></tr><tr><td>Ctrl+z</td><td>将正在终端执行的任务停下来放到后台</td></tr><tr><td>!!</td><td>执行上一条命令</td></tr><tr><td>!数字</td><td>执行数字对应的历史命令</td></tr><tr><td>!字母</td><td>执行最近的以字母打头的命令</td></tr><tr><td>!$ / Esc+.</td><td>获得上一条命令最后一个参数</td></tr><tr><td>Esc+b</td><td>移动到当前单词的开头</td></tr><tr><td>Esc+f</td><td>移动到当前单词的结尾</td></tr></tbody></table></li><li><p>man查阅命令手册的内容说明</p><table><thead><tr><th>手册中的标题</th><th>功能说明</th></tr></thead><tbody><tr><td>NAME</td><td>命令的说明和介绍</td></tr><tr><td>SYNOPSIS</td><td>使用该命令的基本语法</td></tr><tr><td>DESCRIPTION</td><td>使用该命令的详细描述，各个参数的作用，有时候这些信息会出现在OPTIONS中</td></tr><tr><td>OPTIONS</td><td>命令相关参数选项的说明</td></tr><tr><td>EXAMPLES</td><td>使用该命令的参考例子</td></tr><tr><td>EXIT STATUS</td><td>命令结束的退出状态码，通常0表示成功执行</td></tr><tr><td>SEE ALSO</td><td>和命令相关的其他命令或信息</td></tr><tr><td>BUGS</td><td>和命令相关的缺陷的描述</td></tr><tr><td>AUTHOR</td><td>该命令的作者介绍</td></tr></tbody></table></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文转载于GitHub项目&lt;a href=&quot;https://github.com/jackfrued/Python-100-Days&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python - 100天从新手到
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/"/>
    
    
      <category term="Linux" scheme="https://closer_laps.gitee.io/tags/Linux/"/>
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用正则表达式</title>
    <link href="https://closer_laps.gitee.io/2020/02/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://closer_laps.gitee.io/2020/02/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-02-23T06:55:45.000Z</published>
    <updated>2020-02-23T08:26:13.265Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文转载于GitHub项目<a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">Python - 100天从新手到大师</a></strong></p></blockquote><h3 id="一：-正则表达式相关知识"><a href="#一：-正则表达式相关知识" class="headerlink" title="一： 正则表达式相关知识"></a>一： 正则表达式相关知识</h3><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。</p><p>我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。</p><p>关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫<a href="https://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">《正则表达式30分钟入门教程》</a>，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。</p><table><thead><tr><th>符号</th><th>解释</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配任意字符</td><td>b.t</td><td>可以匹配bat / but / b#t / b1t等</td></tr><tr><td>\w</td><td>匹配字母/数字/下划线</td><td>b\wt</td><td>可以匹配bat / b1t / b_t等<br>但不能匹配b#t</td></tr><tr><td>\s</td><td>匹配空白字符（包括\r、\n、\t等）</td><td>love\syou</td><td>可以匹配love you</td></tr><tr><td>\d</td><td>匹配数字</td><td>\d\d</td><td>可以匹配01 / 23 / 99等</td></tr><tr><td>\b</td><td>匹配单词的边界</td><td>\bThe\b</td><td></td></tr><tr><td>^</td><td>匹配字符串的开始</td><td>^The</td><td>可以匹配The开头的字符串</td></tr><tr><td>$</td><td>匹配字符串的结束</td><td>.exe$</td><td>可以匹配.exe结尾的字符串</td></tr><tr><td>\W</td><td>匹配非字母/数字/下划线</td><td>b\Wt</td><td>可以匹配b#t / b@t等<br>但不能匹配but / b1t / b_t等</td></tr><tr><td>\S</td><td>匹配非空白字符</td><td>love\Syou</td><td>可以匹配love#you等<br>但不能匹配love you</td></tr><tr><td>\D</td><td>匹配非数字</td><td>\d\D</td><td>可以匹配9a / 3# / 0F等</td></tr><tr><td>\B</td><td>匹配非单词边界</td><td>\Bio\B</td><td></td></tr><tr><td>[]</td><td>匹配来自字符集的任意单一字符</td><td>[aeiou]</td><td>可以匹配任一元音字母字符</td></tr><tr><td>[^]</td><td>匹配不在字符集中的任意单一字符</td><td>[^aeiou]</td><td>可以匹配任一非元音字母字符</td></tr><tr><td>*</td><td>匹配0次或多次</td><td>\w*</td><td></td></tr><tr><td>+</td><td>匹配1次或多次</td><td>\w+</td><td></td></tr><tr><td>?</td><td>匹配0次或1次</td><td>\w?</td><td></td></tr><tr><td>{N}</td><td>匹配N次</td><td>\w{3}</td><td></td></tr><tr><td>{M,}</td><td>匹配至少M次</td><td>\w{3,}</td><td></td></tr><tr><td>{M,N}</td><td>匹配至少M次至多N次</td><td>\w{3,6}</td><td></td></tr><tr><td>|</td><td>分支</td><td>foo|bar</td><td>可以匹配foo或者bar</td></tr><tr><td>(?#)</td><td>注释</td><td></td><td></td></tr><tr><td>(exp)</td><td>匹配exp并捕获到自动命名的组中</td><td></td><td></td></tr><tr><td>(?&nbsp;&lt;name&gt;exp)</td><td>匹配exp并捕获到名为name的组中</td><td></td><td></td></tr><tr><td>(?:exp)</td><td>匹配exp但是不捕获匹配的文本</td><td></td><td></td></tr><tr><td>(?=exp)</td><td>匹配exp前面的位置</td><td>\b\w+(?=ing)</td><td>可以匹配I’m dancing中的danc</td></tr><tr><td>(?&lt;=exp)</td><td>匹配exp后面的位置</td><td>(?&lt;=\bdanc)\w+\b</td><td>可以匹配I love dancing and reading中的第一个ing</td></tr><tr><td>(?!exp)</td><td>匹配后面不是exp的位置</td><td></td><td></td></tr><tr><td>(?&lt;!exp)</td><td>匹配前面不是exp的位置</td><td></td><td></td></tr><tr><td>*?</td><td>重复任意次，但尽可能少重复</td><td>a.*b<br>a.*?b</td><td>将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串</td></tr><tr><td>+?</td><td>重复1次或多次，但尽可能少重复</td><td></td><td></td></tr><tr><td>??</td><td>重复0次或1次，但尽可能少重复</td><td></td><td></td></tr><tr><td>{M,N}?</td><td>重复M到N次，但尽可能少重复</td><td></td><td></td></tr><tr><td>{M,}?</td><td>重复M次以上，但尽可能少重复</td><td></td><td></td></tr></tbody></table><blockquote><p><strong>说明：</strong> 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\进行转义处理，例如想匹配小数点可以写成\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\(和\)，否则圆括号被视为正则表达式中的分组。</p></blockquote><h3 id="二：-Python对正则表达式的支持"><a href="#二：-Python对正则表达式的支持" class="headerlink" title="二： Python对正则表达式的支持"></a>二： Python对正则表达式的支持</h3><p>Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>compile(pattern, flags=0)</td><td>编译正则表达式返回正则表达式对象</td></tr><tr><td>match(pattern, string, flags=0)</td><td>用正则表达式匹配字符串 成功返回匹配对象 否则返回None</td></tr><tr><td>search(pattern, string, flags=0)</td><td>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None</td></tr><tr><td>split(pattern, string, maxsplit=0, flags=0)</td><td>用正则表达式指定的模式分隔符拆分字符串 返回列表</td></tr><tr><td>sub(pattern, repl, string, count=0, flags=0)</td><td>用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数</td></tr><tr><td>fullmatch(pattern, string, flags=0)</td><td>match函数的完全匹配（从字符串开头到结尾）版本</td></tr><tr><td>findall(pattern, string, flags=0)</td><td>查找字符串所有与正则表达式匹配的模式 返回字符串的列表</td></tr><tr><td>finditer(pattern, string, flags=0)</td><td>查找字符串所有与正则表达式匹配的模式 返回一个迭代器</td></tr><tr><td>purge()</td><td>清除隐式编译的正则表达式的缓存</td></tr><tr><td>re.I / re.IGNORECASE</td><td>忽略大小写匹配标记</td></tr><tr><td>re.M / re.MULTILINE</td><td>多行匹配标记</td></tr></tbody></table><blockquote><p><strong>说明：</strong> 上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。</p></blockquote><p>下面我们通过一系列的例子来告诉大家在Python中如何使用正则表达式。</p><h4 id="例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。"><a href="#例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。" class="headerlink" title="例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。"></a>例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。</h4><pre><code class="Python">&quot;&quot;&quot;验证输入用户名和QQ号是否有效并给出对应的提示信息要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0&quot;&quot;&quot;import redef main():    username = input(&#39;请输入用户名: &#39;)    qq = input(&#39;请输入QQ号: &#39;)    # match函数的第一个参数是正则表达式字符串或正则表达式对象    # 第二个参数是要跟正则表达式做匹配的字符串对象    m1 = re.match(r&#39;^[0-9a-zA-Z_]{6,20}$&#39;, username)    if not m1:        print(&#39;请输入有效的用户名.&#39;)    m2 = re.match(r&#39;^[1-9]\d{4,11}$&#39;, qq)    if not m2:        print(&#39;请输入有效的QQ号.&#39;)    if m1 and m2:        print(&#39;你输入的信息是有效的!&#39;)if __name__ == &#39;__main__&#39;:    main()</code></pre><blockquote><p><strong>提示：</strong> 上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\，例如表示数字的\d得书写成\\d，这样不仅写起来不方便，阅读的时候也会很吃力。</p></blockquote><h4 id="例子2：从一段文字中提取出国内手机号码。"><a href="#例子2：从一段文字中提取出国内手机号码。" class="headerlink" title="例子2：从一段文字中提取出国内手机号码。"></a>例子2：从一段文字中提取出国内手机号码。</h4><p>下面这张图是截止到2017年底，国内三家运营商推出的手机号段。</p><p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/tel-start-number.png" srcset="/img/loading.gif" alt="tel-start-number.png"></p><pre><code class="Python">import redef main():    # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字    pattern = re.compile(r&#39;(?&lt;=\D)1[34578]\d{9}(?=\D)&#39;)    sentence = &#39;&#39;&#39;    重要的事情说8130123456789遍，我的手机号是13512346789这个靓号，    不是15600998765，也是110或119，王大锤的手机号才是15600998765。    &#39;&#39;&#39;    # 查找所有匹配并保存到一个列表中    mylist = re.findall(pattern, sentence)    print(mylist)    print(&#39;--------华丽的分隔线--------&#39;)    # 通过迭代器取出匹配对象并获得匹配的内容    for temp in pattern.finditer(sentence):        print(temp.group())    print(&#39;--------华丽的分隔线--------&#39;)    # 通过search函数指定搜索位置找出所有匹配    m = pattern.search(sentence)    while m:        print(m.group())        m = pattern.search(sentence, m.end())if __name__ == &#39;__main__&#39;:    main()</code></pre><blockquote><p><strong>说明：</strong> 上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：<code>(?&lt;=\D)(1[38]\d{9}|14[57]\d{8}|15[0-35-9]\d{8}|17[678]\d{8})(?=\D)</code>，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。</p></blockquote><h4 id="例子3：替换字符串中的不良内容"><a href="#例子3：替换字符串中的不良内容" class="headerlink" title="例子3：替换字符串中的不良内容"></a>例子3：替换字符串中的不良内容</h4><pre><code class="Python">import redef main():    sentence = &#39;你丫是傻叉吗? 我操你大爷的. Fuck you.&#39;    purified = re.sub(&#39;[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔&#39;,                      &#39;*&#39;, sentence, flags=re.IGNORECASE)    print(purified)  # 你丫是*吗? 我*你大爷的. * you.if __name__ == &#39;__main__&#39;:    main()</code></pre><blockquote><p><strong>说明：</strong> re模块的正则表达式相关函数中都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用<a href="http://www.runoob.com/python/python-operators.html#ysf5" target="_blank" rel="noopener">按位或运算符</a>进行叠加，如<code>flags=re.I | re.M</code>。</p></blockquote><h4 id="例子4：拆分长字符串"><a href="#例子4：拆分长字符串" class="headerlink" title="例子4：拆分长字符串"></a>例子4：拆分长字符串</h4><pre><code class="Python">import redef main():    poem = &#39;窗前明月光，疑是地上霜。举头望明月，低头思故乡。&#39;    sentence_list = re.split(r&#39;[，。, .]&#39;, poem)    while &#39;&#39; in sentence_list:        sentence_list.remove(&#39;&#39;)    print(sentence_list)  # [&#39;窗前明月光&#39;, &#39;疑是地上霜&#39;, &#39;举头望明月&#39;, &#39;低头思故乡&#39;]if __name__ == &#39;__main__&#39;:    main()</code></pre><h3 id="三：-后话"><a href="#三：-后话" class="headerlink" title="三： 后话"></a>三： 后话</h3><p>如果要从事爬虫类应用的开发，那么正则表达式一定是一个非常好的助手，因为它可以帮助我们迅速的从网页代码中发现某种我们指定的模式并提取出我们需要的信息，当然对于初学者来收，要编写一个正确的适当的正则表达式可能并不是一件容易的事情（当然有些常用的正则表达式可以直接在网上找找），所以实际开发爬虫应用的时候，有很多人会选择<a href="https://www.crummy.com/software/BeautifulSoup/" target="_blank" rel="noopener">Beautiful Soup</a>或<a href="http://lxml.de/" target="_blank" rel="noopener">Lxml</a>来进行匹配和信息的提取，前者简单方便但是性能较差，后者既好用性能也好，但是安装稍嫌麻烦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文转载于GitHub项目&lt;a href=&quot;https://github.com/jackfrued/Python-100-Days&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python - 100天从新手到
      
    
    </summary>
    
    
      <category term="python" scheme="https://closer_laps.gitee.io/categories/python/"/>
    
      <category term="正则表达式" scheme="https://closer_laps.gitee.io/categories/python/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="python" scheme="https://closer_laps.gitee.io/tags/python/"/>
    
      <category term="正则表达式" scheme="https://closer_laps.gitee.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>python处理excle实例之字符串减法</title>
    <link href="https://closer_laps.gitee.io/2020/02/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/python%E5%A4%84%E7%90%86excle%E5%AE%9E%E4%BE%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%8F%E6%B3%95/"/>
    <id>https://closer_laps.gitee.io/2020/02/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/python%E5%A4%84%E7%90%86excle%E5%AE%9E%E4%BE%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%8F%E6%B3%95/</id>
    <published>2020-02-22T16:09:19.000Z</published>
    <updated>2020-03-05T11:58:40.568Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/python%2Bexcel.jpg" srcset="/img/loading.gif" alt="python+excel"></p><a id="more"></a><pre><code class="py">#!/usr/bin/python# -*- coding: utf-8 -*-from openpyxl import load_workbook# 求字符串A-Bdef str_A_cut_B(a, b):    if b:        for x in a:            if x in b:                a = a.replace(x, &quot;&quot;)    return a# 写入模式打开output.txt# f = open(&quot;output.txt&quot;, &quot;w&quot;)# 打开excel名为testwb = load_workbook(filename=&#39;test.xlsx&#39;)# 打开工作表Sheet1sheet = wb[&#39;Sheet1&#39;]for i in range(2, 36):    temp = &#39;C&#39; + str(i)    # 将temp单元格的内容存入str1    str1 = sheet[temp].value    str0 = &quot;张 朱 颜 赵 杨 施 胡 何 秦 刘 夏 鹏 李 唐 许 王 邓 顾&quot;    z = str_A_cut_B(str0, str1)    # 若单元格为空，换行输出    if str1:        # 输出格式        for j in range(len(z)):            print(z[j], end=&#39; &#39;)  # 不换行输出            # print(z[j], end=&#39; &#39;, file=f)        print(&#39;\n&#39;, end=&#39;&#39;)        # print(&#39;\n&#39;, end=&#39;&#39;, file=f)    else:        print(&#39;\n&#39;, end=&#39;&#39;)        # print(&#39;\n&#39;, end=&#39;&#39;, file=f)# f.close()</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/python%2Bexcel.jpg&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;python+excel&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://closer_laps.gitee.io/categories/python/"/>
    
      <category term="excel" scheme="https://closer_laps.gitee.io/categories/python/excel/"/>
    
    
      <category term="python" scheme="https://closer_laps.gitee.io/tags/python/"/>
    
      <category term="excel" scheme="https://closer_laps.gitee.io/tags/excel/"/>
    
  </entry>
  
  <entry>
    <title>如何在GitHub搜索开源项目</title>
    <link href="https://closer_laps.gitee.io/2020/02/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Github/%E5%A6%82%E4%BD%95%E5%9C%A8GitHub%E4%B8%8A%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    <id>https://closer_laps.gitee.io/2020/02/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Github/%E5%A6%82%E4%BD%95%E5%9C%A8GitHub%E4%B8%8A%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-02-20T07:30:07.000Z</published>
    <updated>2020-02-20T08:24:03.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：-如何使用搜索栏"><a href="#一：-如何使用搜索栏" class="headerlink" title="一： 如何使用搜索栏"></a>一： 如何使用搜索栏</h2><p>所有搜索需求用空格隔开。</p><p>搜索栏输入：</p><ol><li><p>搜索项目名里面包含python、项目readme里面包含python、描述里面包含python<br><code>in:name python</code>、<code>in:readme python</code>、<code>in:description 爬虫</code>/<code>in:des 爬虫</code><br>PS：description描述里面包含比较准确</p></li><li><p>stars数大于1000、forks数大于xxx<br><code>stars:&gt;1000</code>、<code>forks:&gt;xxx</code></p></li><li><p>指定编程语言<br><code>language:python</code></p></li><li><p>最后更新时间限定<br><code>pushed:&gt;2020-01-01</code></p></li><li><p>限定国内开发者<br><code>location:China</code></p></li></ol><h2 id="二：-chrome插件推荐"><a href="#二：-chrome插件推荐" class="headerlink" title="二： chrome插件推荐"></a>二： chrome插件推荐</h2><ul><li>Octotree</li><li>GitZip for github<br>双击你想下载的文件后面空白的地方，文件前方会出现√，右下角出现<code>Download checked items</code>即可下载。</li><li>英文不好的小伙伴推荐沙拉查词</li></ul><h2 id="三：-git-clone速度慢的解决方案"><a href="#三：-git-clone速度慢的解决方案" class="headerlink" title="三： git clone速度慢的解决方案"></a>三： git clone速度慢的解决方案</h2><p>登录<a href="https://gitee.com/" target="_blank" rel="noopener">Gitee</a> -&gt; 新建仓库 -&gt; 拉到最下的创建上面，点击导入已有仓库 -&gt; 填入你想git clone的GitHub仓库地址 -&gt; 本地，git clone。</p><h2 id="四：-参考视频"><a href="#四：-参考视频" class="headerlink" title="四： 参考视频"></a>四： 参考视频</h2><p><a href="https://www.bilibili.com/video/av75587104" target="_blank" rel="noopener">https://www.bilibili.com/video/av75587104</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一：-如何使用搜索栏&quot;&gt;&lt;a href=&quot;#一：-如何使用搜索栏&quot; class=&quot;headerlink&quot; title=&quot;一： 如何使用搜索栏&quot;&gt;&lt;/a&gt;一： 如何使用搜索栏&lt;/h2&gt;&lt;p&gt;所有搜索需求用空格隔开。&lt;/p&gt;
&lt;p&gt;搜索栏输入：&lt;/p&gt;
&lt;ol&gt;
&lt;l
      
    
    </summary>
    
    
    
      <category term="github" scheme="https://closer_laps.gitee.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu安装完以后的基础配置</title>
    <link href="https://closer_laps.gitee.io/2020/02/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/ubuntu%E5%AE%89%E8%A3%85%E5%AE%8C%E4%BB%A5%E5%90%8E%E7%9A%84%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <id>https://closer_laps.gitee.io/2020/02/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/ubuntu%E5%AE%89%E8%A3%85%E5%AE%8C%E4%BB%A5%E5%90%8E%E7%9A%84%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</id>
    <published>2020-02-17T03:00:33.000Z</published>
    <updated>2020-03-12T10:55:01.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>先试用ubuntu，打开软件目录 -&gt; 磁盘，右上角菜单。然后格式化磁盘;擦除 -&gt; 不要覆盖…(快速);分区 -&gt; 硬盘2T以下MBR/DOS、2T以上GPT</li><li>不要连接网络 -&gt; 正常安装 -&gt; 其他选项</li></ol><h2 id="一：-安装类型"><a href="#一：-安装类型" class="headerlink" title="一： 安装类型"></a>一： 安装类型</h2><ol><li>/boot分区（引导）-&gt;512MB-&gt;主分区-&gt;空间起始位置-&gt;Ext4日志文件系统-&gt;/boot。</li><li>/ 根分区（相当于windows的c盘）-&gt;102400MB-&gt;主分区-&gt;空间起始位置-&gt;XFS日志文件系统-&gt;/。</li><li>swap分区（桌面系统不分，服务器必分）-&gt;2048MB-&gt;逻辑分区-&gt;空间起始位置-&gt;交换空间。</li><li>/home分区（存储空间，剩余都给它）-&gt;max MB-&gt;主分区-&gt;空间起始位置-&gt;XFS日志文件系统-&gt;/home。</li><li>现在安装。</li></ol><h2 id="二：-基础配置"><a href="#二：-基础配置" class="headerlink" title="二： 基础配置"></a>二： 基础配置</h2><h3 id="2-1-设置root用户密码"><a href="#2-1-设置root用户密码" class="headerlink" title="2.1 设置root用户密码"></a>2.1 设置root用户密码</h3><p><code>sudo passwd root</code><br><code>su</code></p><a id="more"></a><h3 id="2-2-修改镜像源"><a href="#2-2-修改镜像源" class="headerlink" title="2.2 修改镜像源"></a>2.2 修改镜像源</h3><ol><li><code>sudo nano /etc/apt/sources.list</code></li><li>将原文件所有内容注释掉；</li><li>复制<a href="https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.2f191b11mRGGjV" target="_blank" rel="noopener">阿里巴巴镜像源</a></li><li>黏贴到终端，<code>ctrl</code>+<code>o</code>保存，回车确定,<code>ctrl</code>+<code>x</code>。</li></ol><h3 id="2-3-更新源和系统"><a href="#2-3-更新源和系统" class="headerlink" title="2.3 更新源和系统"></a>2.3 更新源和系统</h3><p><code>sudo apt update</code><br><code>sudo apt upgrade</code><br><code>sudo apt dist-upgrade</code><br><code>sudo apt autoremove</code>  # 清理不需要的旧组件<br><code>reboot</code>  # 重启</p><h3 id="2-4-安装输入法"><a href="#2-4-安装输入法" class="headerlink" title="2.4 安装输入法"></a>2.4 安装输入法</h3><ol><li>卸载自带ibus<br><code>sudo apt remove ibus</code></li><li>安装fcitx<br><code>sudo apt install fcitx-bin fcitx-table</code></li><li>安装Google拼音<br><code>sudo apt install fcitx-googlepinyin</code></li><li><code>sudo im-config</code>-&gt;确定-&gt;yes-&gt;选择fcitx,确定-&gt;reboot重启。</li></ol><h3 id="2-5-安装Google浏览器"><a href="#2-5-安装Google浏览器" class="headerlink" title="2.5 安装Google浏览器"></a>2.5 安装Google浏览器</h3><ol><li>打开 <a href="https://www.google.cn/intl/zh-CN/chrome/" target="_blank" rel="noopener">https://www.google.cn/intl/zh-CN/chrome/</a></li><li>下载-&gt;64位.deb-&gt;接受并安装。</li><li>在下载文件夹内打开终端。</li><li><code>sudo dpkg -i google-chrome-stable_current_amd64.deb</code></li></ol><h3 id="2-6-设置语言"><a href="#2-6-设置语言" class="headerlink" title="2.6 设置语言"></a>2.6 设置语言</h3><p>设置-&gt;区域和语言-&gt;管理已安装的语言-&gt;安装。</p><h3 id="2-7-安装vlc"><a href="#2-7-安装vlc" class="headerlink" title="2.7 安装vlc"></a>2.7 安装vlc</h3><p><code>sudo apt install vlc</code></p><h3 id="2-8-关闭ubuntu内部错误"><a href="#2-8-关闭ubuntu内部错误" class="headerlink" title="2.8 关闭ubuntu内部错误"></a>2.8 关闭ubuntu内部错误</h3><ol><li><code>sudo nano /etc/default/apport</code></li><li>enable=1改为0</li><li><code>ctrl</code>+<code>o</code>保存，回车确定,<code>ctrl</code>+<code>x</code>。</li></ol><h3 id="2-9-安装新立得软件包"><a href="#2-9-安装新立得软件包" class="headerlink" title="2.9 安装新立得软件包"></a>2.9 安装新立得软件包</h3><p><code>sudo apt install synaptic</code></p><h3 id="2-10-安装aria2和ariang及配置"><a href="#2-10-安装aria2和ariang及配置" class="headerlink" title="2.10 安装aria2和ariang及配置"></a>2.10 安装aria2和ariang及配置</h3><h4 id="2-10-1-安装aria2及其配置"><a href="#2-10-1-安装aria2及其配置" class="headerlink" title="2.10.1 安装aria2及其配置"></a>2.10.1 安装aria2及其配置</h4><p><code>sudo apt install aria2 -y</code></p><pre><code class="shell">mkdir /home/ubuntu/.aria2cd /home/ubuntu/.aria2touch aria2.conf aria2.session #创建配置文件与session文件vi /home/ubuntu/.aria2/aria2.conf</code></pre><p>aria2.conf配置文件如下</p><pre><code class="sh">dir=~/下载/disable-ipv6=true#打开rpc的目的是为了给web管理端用enable-rpc=truerpc-allow-origin-all=truerpc-listen-all=true#rpc-listen-port=6800#断点续传continue=trueinput-file=/home/ubuntu/.aria2/aria2.sessionsave-session=/home/ubuntu/.aria2/aria2.session#最大同时下载任务数max-concurrent-downloads=20save-session-interval=120# Http/FTP 相关connect-timeout=120#lowest-speed-limit=10K#同服务器连接数max-connection-per-server=10#max-file-not-found=2#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要min-split-size=10M#单文件最大线程数, 路由建议值: 5split=10check-certificate=false#http-no-cache=true</code></pre><p>后台运行aria2</p><p><code>aria2c --conf-path=/home/ubuntu/.aria2/aria2.conf -D</code></p><p>设置aria2开机自动启动</p><p><code>sudo vi /etc/rc.local</code></p><p>在最下面加入：</p><p><code>aria2c --conf-path=/home/ubuntu/.aria2/aria2.conf -D &amp;</code></p><h4 id="2-10-2-安装ariang及配置"><a href="#2-10-2-安装ariang及配置" class="headerlink" title="2.10.2 安装ariang及配置"></a>2.10.2 安装ariang及配置</h4><p><a href="http://ariang.mayswind.net/zh_Hans/" target="_blank" rel="noopener">参考官方文档</a></p><pre><code class="sh">sudo apt install nodejssudo apt install npmsudo apt install gulp</code></pre><p>然后<a href="https://github.com/mayswind/AriaNg/releases" target="_blank" rel="noopener">下载源码解压并cd进入解压的文件夹</a></p><p>然后安装单文件版</p><p><code>npm install</code><br><code>gulp clean build-bundle</code></p><h2 id="三：-常用软件安装"><a href="#三：-常用软件安装" class="headerlink" title="三： 常用软件安装"></a>三： 常用软件安装</h2><p>PS：deb文件如何安装？</p><ul><li><code>sudo dpkg -i 软件名</code> # 安装</li><li><code>sudo apt install -f</code> # 修复依赖</li><li><code>sudo dpkg -r 软件名</code> # 进行卸载</li></ul><p>安装git<br><code>sudo apt install git</code></p><p>生成公匙<br><code>ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;</code><br><code>cat ~/.ssh/id_rsa.pub</code><br>添加到github，gitee，coding</p><p>下载安装wps<br><code>sudo dpkg -i wps-office_11.1.0.9080_amd64.deb</code></p><p>下载安装lantern<br><code>sudo dpkg -i lantern-installer-preview-64-bit.deb</code></p><p>下载安装zoom<br><code>sudo dpkg -i zoom_amd64.deb</code></p><p>下载安装python3<br><code>tar zxvf Python-3.8.2.tgz</code><br><code>cd Python-3.8.2\</code><br><code>sudo apt install gcc</code><br><code>sudo apt install make</code><br><code>./configure</code><br><code>make</code><br><code>sudo make install</code><br><code>sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100</code> # 设置python2为默认<br><code>sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150</code> # 设置python3为默认<br><code>sudo update-alternatives --config python</code> # 选择默认的python版本<br><code>sudo apt install python3-pip</code> # 安装pip3<br><code>pip3 install -U pip -i https://pypi.tuna.tsinghua.edu.cn/simple</code> # 升级pip<br>如果这个升级命令出现问题 ，可以使用以下命令：<code>sudo easy_install --upgrade pip</code><br><code>pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code> # pip3设置清华源</p><p>下载安装vscode<br><code>sudo dpkg -i code_1.42.1-1581432938_amd64.deb</code><br><code>ctrl+shift+p，然后输入lang -&gt; 选择configure Display language，然后安装简体中文，然后重启vscode</code></p><p>下载安装百度网盘<br><code>sudo dpkg -i baidunetdisk_linux_3.0.1.2.deb</code></p><p>下载安装hexo<br><code>sudo apt install nodejs</code><br><code>sudo apt install npm</code><br><code>sudo npm install hexo-cli -g</code><br><code>sudo npm install</code></p><p>下载安装qBittorrent</p><ul><li>qBittorrent Stable # 稳定版<br> <code>sudo add-apt-repository ppa:qbittorrent-team/qbittorrent-stable</code></li><li>qBittorrent Unstable # 不稳定版<br> <code>sudo add-apt-repository ppa:qbittorrent-team/qbittorrent-unstable</code></li></ul><p><code>sudo apt-get update &amp;&amp; sudo apt-get install qbittorrent</code></p><h2 id="四：-参考视频"><a href="#四：-参考视频" class="headerlink" title="四： 参考视频"></a>四： 参考视频</h2><p><strong><a href="https://www.bilibili.com/video/av48233413" target="_blank" rel="noopener">https://www.bilibili.com/video/av48233413</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;先试用ubuntu，打开软件目录 -&amp;gt; 磁盘，右上角菜单。然后格式化磁盘;擦除 -&amp;gt; 不要覆盖…(快速);分区 -&amp;gt; 硬盘2T以下MBR/DOS、2T以上GPT&lt;/li&gt;
&lt;li&gt;不要连接网络 -&amp;gt; 正常安装 -&amp;gt; 其他选项&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;一：-安装类型&quot;&gt;&lt;a href=&quot;#一：-安装类型&quot; class=&quot;headerlink&quot; title=&quot;一： 安装类型&quot;&gt;&lt;/a&gt;一： 安装类型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;/boot分区（引导）-&amp;gt;512MB-&amp;gt;主分区-&amp;gt;空间起始位置-&amp;gt;Ext4日志文件系统-&amp;gt;/boot。&lt;/li&gt;
&lt;li&gt;/ 根分区（相当于windows的c盘）-&amp;gt;102400MB-&amp;gt;主分区-&amp;gt;空间起始位置-&amp;gt;XFS日志文件系统-&amp;gt;/。&lt;/li&gt;
&lt;li&gt;swap分区（桌面系统不分，服务器必分）-&amp;gt;2048MB-&amp;gt;逻辑分区-&amp;gt;空间起始位置-&amp;gt;交换空间。&lt;/li&gt;
&lt;li&gt;/home分区（存储空间，剩余都给它）-&amp;gt;max MB-&amp;gt;主分区-&amp;gt;空间起始位置-&amp;gt;XFS日志文件系统-&amp;gt;/home。&lt;/li&gt;
&lt;li&gt;现在安装。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;二：-基础配置&quot;&gt;&lt;a href=&quot;#二：-基础配置&quot; class=&quot;headerlink&quot; title=&quot;二： 基础配置&quot;&gt;&lt;/a&gt;二： 基础配置&lt;/h2&gt;&lt;h3 id=&quot;2-1-设置root用户密码&quot;&gt;&lt;a href=&quot;#2-1-设置root用户密码&quot; class=&quot;headerlink&quot; title=&quot;2.1 设置root用户密码&quot;&gt;&lt;/a&gt;2.1 设置root用户密码&lt;/h3&gt;&lt;p&gt;&lt;code&gt;sudo passwd root&lt;/code&gt;&lt;br&gt;&lt;code&gt;su&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/"/>
    
    
      <category term="Linux" scheme="https://closer_laps.gitee.io/tags/Linux/"/>
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>利用python实现Gitee Pages定时自动部署/自动签到</title>
    <link href="https://closer_laps.gitee.io/2020/02/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/%E5%88%A9%E7%94%A8python%E5%AE%9E%E7%8E%B0Gitee-Pages%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E3%80%81%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0/"/>
    <id>https://closer_laps.gitee.io/2020/02/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/%E5%88%A9%E7%94%A8python%E5%AE%9E%E7%8E%B0Gitee-Pages%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E3%80%81%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0/</id>
    <published>2020-02-16T12:01:45.000Z</published>
    <updated>2020-03-12T12:08:29.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：-前期准备"><a href="#一：-前期准备" class="headerlink" title="一： 前期准备"></a>一： 前期准备</h2><h3 id="1-1-基础环境"><a href="#1-1-基础环境" class="headerlink" title="1.1 基础环境"></a>1.1 基础环境</h3><ol><li>python3 + selenium + chrome浏览器。<br>如果有不懂的可以查阅<a href="https://python-selenium-zh.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">selenium-python中文文档</a></li><li>chrome-&gt;设置-&gt;关于chrome-&gt;查看版本（我的版本是 80.0.3987.106（正式版本） （64 位））。  </li><li>需要下载跟你的chrome版本一致的<a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">ChromeDriver可执行驱动</a><br>下载完解压放在python根目录(即跟python.exe放在一起)。<br><strong>如果上面的ChromeDriver网址打不开，可以使用<a href="https://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">ChromeDriver淘宝镜像</a></strong></li><li>最好有一台云主机，没有的话需要自己的电脑设定定时开机，定时任务，定时关机。  <a id="more"></a></li></ol><h3 id="1-2-安装环境"><a href="#1-2-安装环境" class="headerlink" title="1.2 安装环境"></a>1.2 安装环境</h3><ol><li>安装python3,不懂的请查阅我的相关blog文。</li><li>打开windows命令行，安装selenium<br><code>pip install selenium -i https://pypi.tuna.tsinghua.edu.cn/simple</code></li></ol><h3 id="1-3-获取cookie"><a href="#1-3-获取cookie" class="headerlink" title="1.3 获取cookie"></a>1.3 获取cookie</h3><p>首先登录gitee的Gitee Pages服务界面；</p><p>点击网页地址栏左边的小锁标志 -&gt; 选择Cookie；</p><p>右边弹出的窗口中展开gitee.com -&gt; 展开Cookie -&gt; 点击名为<code>gitee-session-n</code>的项目 -&gt; 下面的内容后面就是你的cookie；</p><p>记得要全部复制进去，替换掉下面源码的my_cookie里面的内容。</p><h2 id="二：-代码"><a href="#二：-代码" class="headerlink" title="二： 代码"></a>二： 代码</h2><h3 id="2-1-源码"><a href="#2-1-源码" class="headerlink" title="2.1 源码"></a>2.1 源码</h3><pre><code class="py">#!/usr/bin/python3# -*- coding: utf-8 -*-import timefrom selenium import webdriverfrom selenium.webdriver.common.alert import Alertfrom selenium.webdriver.chrome.options import Options# 将你的cookie内容替换掉下面的内容my_cookie = {&#39;domain&#39;: &#39;.gitee.com&#39;, &#39;httpOnly&#39;: True, &#39;name&#39;: &#39;gitee-session-n&#39;, &#39;path&#39;: &#39;/&#39;, &#39;secure&#39;: False,             &#39;value&#39;: &#39;内容&#39;}# 实例化一个启动参数对象options = Options()# 设置启动浏览器时窗口最大化运行# options.add_argument(&#39;--start-maximized&#39;)# 设置无界面模式运行浏览器options.add_argument(&#39;-headless&#39;)# 不加载图片, 提升速度prefs = {&quot;profile.managed_default_content_settings.images&quot;: 2}options.add_experimental_option(&quot;prefs&quot;, prefs)# 打开浏览器print(&#39;Launch browser&#39;)driver = webdriver.Chrome(chrome_options=options)# 删除缓存print(&#39;Delete cookies&#39;)driver.delete_all_cookies()# 访问网页print(&#39;Visit website&#39;)# 这里链接改为你的码云部署页面的链接driver.get(&quot;https://gitee.com/此处改为你的ID/此处改为你的ID/pages&quot;)time.sleep(5)# 加载cookieprint(&#39;Add cookie&#39;)driver.add_cookie(my_cookie)# 刷新print(&#39;Refresh&#39;)driver.refresh()time.sleep(5)# 点击更新按钮--通过xpath确定点击位置driver.find_element_by_xpath(&#39;//*[@id=&quot;pages-branch&quot;]/div[7]&#39;).click()time.sleep(3)# 确认更新提示框--这个函数的作用是确认提示框Alert(driver).accept()# 等待40秒更新time.sleep(40)# 这个print其实没事什么用,如果真的要测试脚本是否运行成功，可以用try来抛出异常print(&quot;success&quot;)# 脚本运行成功,退出浏览器driver.quit()# 写上更新日志# 我这里是写在D盘fp = open(&quot;D:\log.txt&quot;, &quot;a+&quot;)# linux写在/home# fp = open(&quot;/home/temp/log.log&quot;, &quot;a+&quot;)now_time = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())fp.write(&quot;auto update time:{0}\n&quot;.format(now_time))fp.close()</code></pre><p>把源码黏贴到<code>gitee.py</code>文件内，备用。</p><h3 id="2-2-注意事项"><a href="#2-2-注意事项" class="headerlink" title="2.2 注意事项"></a>2.2 注意事项</h3><ul><li><p>html的id属性、xpath可以通过在chrome的网页里面按F12 -&gt; 选择一个元素进行检查(快捷键Ctrl + Shift + C)查看，如图就是<code>百度一下</code>的div块元素属性。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/CopyFullXPath.png" srcset="/img/loading.gif" alt="CopyXPath"></p></li><li><p>python selenium模块的具体函数使用方法请参考官方文档。  </p></li><li><p>编写自动签到脚本也差不多同样的道理。</p></li></ul><h2 id="三：-添加定时任务自动部署"><a href="#三：-添加定时任务自动部署" class="headerlink" title="三： 添加定时任务自动部署"></a>三： 添加定时任务自动部署</h2><h3 id="3-1-Windows主机"><a href="#3-1-Windows主机" class="headerlink" title="3.1 Windows主机"></a>3.1 Windows主机</h3><ol><li>登录windows云主机，复制<code>gitee.py</code>到D盘根目录。</li><li>云主机内-&gt;右键我的电脑-&gt;管理-&gt;工具-&gt;任务计划程序-&gt;创建基本任务…添加任务每天执行一次，实在不会的请<a href="https://jingyan.baidu.com/article/154b463130041128ca8f41c7.html" target="_blank" rel="noopener">百度</a></li><li>在自己电脑上的话也可以设置定时开关机，并把如下代码添加到<a href="https://8hn9w5.coding-pages.com/2020/02/15/hexo/hexo%E4%B8%80%E9%94%AE%E4%B8%8A%E4%BC%A0%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC%E7%9A%84%E6%9E%84%E5%BB%BA/" target="_blank" rel="noopener">hexo一键上传部署脚本</a>的后面，每次定时git push后自动在gitee的pages界面部署。</li></ol><pre><code class="bat">@echo offd:python gitee.pyecho &quot;等待更新完成过后再关闭窗口&quot;timeout /t 180rem 上面的代码是等待3分钟。</code></pre><h3 id="3-2-Linux主机"><a href="#3-2-Linux主机" class="headerlink" title="3.2 Linux主机"></a>3.2 Linux主机</h3><ol><li>登录Linux云主机，复制<code>gitee.py</code>到<code>/home/temp/</code>目录。</li><li>添加Linux计划任务<br><code>crontab -e</code></li><li>选择1选项nano编辑，光标拉到最后面，复制如下代码;</li><li><code>10 6 * * * /home/temp/gitee.py start</code></li></ol><p>说明：</p><ul><li><a href="http://www.bejson.com/othertools/cron/" target="_blank" rel="noopener">crontab表达式在线生成</a></li><li>延迟0~1小时的话，直接在py或者sh文件中利用sleep及random命令设置。</li><li><code>crontab -l</code>查看当前已经保存的计划任务。</li></ul><h2 id="四：-参考文献"><a href="#四：-参考文献" class="headerlink" title="四： 参考文献"></a>四： 参考文献</h2><ul><li><a href="https://python-selenium-zh.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://python-selenium-zh.readthedocs.io/zh_CN/latest/</a></li><li><a href="https://blog.csdn.net/ydydyd00/article/details/80882183" target="_blank" rel="noopener">https://blog.csdn.net/ydydyd00/article/details/80882183</a></li><li><a href="https://jingyan.baidu.com/article/154b463130041128ca8f41c7.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/154b463130041128ca8f41c7.html</a></li><li><a href="https://jupitersh.gitee.io/2020/02/Preparation-for-Gitee-Auto-Update-by-Ptyhon/" target="_blank" rel="noopener">https://jupitersh.gitee.io/2020/02/Preparation-for-Gitee-Auto-Update-by-Ptyhon/</a></li></ul><p><strong>enjoy!</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：-前期准备&quot;&gt;&lt;a href=&quot;#一：-前期准备&quot; class=&quot;headerlink&quot; title=&quot;一： 前期准备&quot;&gt;&lt;/a&gt;一： 前期准备&lt;/h2&gt;&lt;h3 id=&quot;1-1-基础环境&quot;&gt;&lt;a href=&quot;#1-1-基础环境&quot; class=&quot;headerlink&quot; title=&quot;1.1 基础环境&quot;&gt;&lt;/a&gt;1.1 基础环境&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;python3 + selenium + chrome浏览器。&lt;br&gt;如果有不懂的可以查阅&lt;a href=&quot;https://python-selenium-zh.readthedocs.io/zh_CN/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;selenium-python中文文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;chrome-&amp;gt;设置-&amp;gt;关于chrome-&amp;gt;查看版本（我的版本是 80.0.3987.106（正式版本） （64 位））。  &lt;/li&gt;
&lt;li&gt;需要下载跟你的chrome版本一致的&lt;a href=&quot;http://chromedriver.storage.googleapis.com/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ChromeDriver可执行驱动&lt;/a&gt;&lt;br&gt;下载完解压放在python根目录(即跟python.exe放在一起)。&lt;br&gt;&lt;strong&gt;如果上面的ChromeDriver网址打不开，可以使用&lt;a href=&quot;https://npm.taobao.org/mirrors/chromedriver/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ChromeDriver淘宝镜像&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;最好有一台云主机，没有的话需要自己的电脑设定定时开机，定时任务，定时关机。
    
    </summary>
    
    
      <category term="python" scheme="https://closer_laps.gitee.io/categories/python/"/>
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/categories/python/hexo/"/>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/tags/hexo/"/>
    
      <category term="python" scheme="https://closer_laps.gitee.io/tags/python/"/>
    
      <category term="自动签到" scheme="https://closer_laps.gitee.io/tags/%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0/"/>
    
  </entry>
  
  <entry>
    <title>you-get下载视频</title>
    <link href="https://closer_laps.gitee.io/2020/02/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/you-get%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91/"/>
    <id>https://closer_laps.gitee.io/2020/02/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/you-get%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91/</id>
    <published>2020-02-16T03:13:57.000Z</published>
    <updated>2020-02-23T08:10:46.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：-简介"><a href="#一：-简介" class="headerlink" title="一： 简介"></a>一： 简介</h2><p>You-Get 乃一小小哒命令行程序，提供便利的方式来下载网络上的媒体信息，通过python来安装。<br>支持主流视频网站如：YouTube、Google+、bilibili哔哩哔哩、163/网易视频/网易云音乐、斗鱼、爱奇艺、Youku、AcFun等等</p><h2 id="二：-安装及其使用"><a href="#二：-安装及其使用" class="headerlink" title="二： 安装及其使用"></a>二： 安装及其使用</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p>1） 安装python3  <a id="more"></a><br>  安装教程这里推荐：<a href="http://www.runoob.com/python3/python3-install.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-install.html</a><br>  win下载地址：<a href="https://www.python.org/downloads/windows" target="_blank" rel="noopener">https://www.python.org/downloads/windows</a><br>  Linux下载地址：<a href="https://www.python.org/downloads/source" target="_blank" rel="noopener">https://www.python.org/downloads/source</a>  </p><p>2） 安装you-get<br>  然后打开win的cmd命令行、Linux为终端，输入以下命令：  </p><ul><li>升级pip<br><code>python -m pip install --upgrade pip -i https://pypi.tuna.tsinghua.edu.cn/simple</code></li><li>安装you-get<br><code>pip install you-get -i https://pypi.tuna.tsinghua.edu.cn/simple</code></li><li>升级you-get<br><code>pip install --upgrade you-get -i https://pypi.tuna.tsinghua.edu.cn/simple</code></li></ul><p>3） 安装<a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a><br>  FFmpeg用于转换视频格式、播放视频等，下载下来的视频有可能播放格式不支持，不需要也可不装。<br>  FFmpeg下载地址：<a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">https://www.ffmpeg.org/</a><br>  windows下载地址：<a href="https://ffmpeg.zeranoe.com/builds/" target="_blank" rel="noopener">https://ffmpeg.zeranoe.com/builds/</a><br>  ps：windows下载，选择默认选项即可</p><h3 id="2-2-下载"><a href="#2-2-下载" class="headerlink" title="2.2 下载"></a>2.2 下载</h3><h4 id="2-2-1-下载默认画质和格式"><a href="#2-2-1-下载默认画质和格式" class="headerlink" title="2.2.1 下载默认画质和格式"></a>2.2.1 下载默认画质和格式</h4><p><code>you-get https://www.bilibili.com/video/av77151622/</code>  </p><p>下载路径默认为文件所在当前路径。<br>所以要下载在指定路径需要先cd到指定路径。  </p><h4 id="2-2-2-下载指定画质和格式"><a href="#2-2-2-下载指定画质和格式" class="headerlink" title="2.2.2 下载指定画质和格式"></a>2.2.2 下载指定画质和格式</h4><p>1） 先用<code>-i</code>以查看所有可用画质与格式。<br>  <code>you-get -i https://www.bilibili.com/video/av77151622/</code><br>  最上面的标有<code>[ DASH(也可能是 DEFAULT ） ]</code>为默认画质。如认同，可下载。  </p><p>2） 或，您希望下载其他播放格式或者其他清晰度，请追加屏幕上面提示的参数，如本视频是:<br>  <code>you-get --format=flv720 https://www.bilibili.com/video/av77151622/</code>  </p><ul><li>目前，格式选择没有大规模铺开；默认选项为最高画质.  </li><li>如不希望you-get合并视频，使用<code>-n</code>。  </li><li>如YouTube视频带有字幕，将被一同下载，以SubRip格式保存.</li></ul><h4 id="2-2-3-下载其他内容"><a href="#2-2-3-下载其他内容" class="headerlink" title="2.2.3 下载其他内容"></a>2.2.3 下载其他内容</h4><p>1） 如你有URL，可以直接使用，如下载you-get:<br>  <code>you-get https://github.com/soimort/you-get/archive/master.zip</code>  </p><p>2） 或者, you-get将自动检查网页，下载一切有可能感兴趣的内容:<br>  <code>you-get http://kopasas.tumblr.com/post/69361932517</code></p><ul><li>此功能为测试性，远未完成。对于类似Tumblr和Blogger的大图有效，但是没有办法为所有网站建立通用格式.</li></ul><p>3） 在Google Videos搜索并下载<br>  you-get可以下载任何东西. 如果不是合法的URL, you-get将在Google查找并下载最相关视频. (可能不是最心仪的，但是很有可能)<br>  <code>you-get &quot;Richard Stallman eats&quot;</code>  </p><h4 id="2-2-4-暂停与恢复下载"><a href="#2-2-4-暂停与恢复下载" class="headerlink" title="2.2.4 暂停与恢复下载"></a>2.2.4 暂停与恢复下载</h4><p>可以使用<code>Ctrl</code>+<code>C</code> 暂停下载.<br>临时的<code>.download</code>文件将保存于输出目录。下次使用you-get传入相同参数时，下载将从上次继续开始. 如果下载已经完成 (临时的<code>.download</code> 扩展名消失), you-get将忽略下载.<br>用<code>-f</code>强行重下载. (注意: 将覆盖同名文件或临时文件!)  </p><h4 id="2-2-5-设置输出文件名或路径"><a href="#2-2-5-设置输出文件名或路径" class="headerlink" title="2.2.5 设置输出文件名或路径"></a>2.2.5 设置输出文件名或路径</h4><p>使用<code>-o</code> 设定路径为d:, <code>-O</code> 设定输出文件名为out:<br><code>you-get -o d:\ -O out https://www.bilibili.com/video/av77151622/</code><br>提示:</p><ul><li>如果原视频标题含有与系统不兼容字符，十分有效.</li><li>也可以帮助使用脚本批量下载于指定目录和文件名.</li></ul><h4 id="2-2-6-批量下载"><a href="#2-2-6-批量下载" class="headerlink" title="2.2.6 批量下载"></a>2.2.6 批量下载</h4><p>两种方法：</p><ol><li>把视频URL用空格隔开<br><code>you-get 视频A网址 视频B网址</code></li><li>用<code>--playlist</code><br><code>you-get --playlist https://www.bilibili.com/video/av5123229</code></li><li>下载视频的同时会下载xml格式弹幕，需要将其转换为ass格式，有一个工具可以帮你：<a href="https://github.com/ikde/danmu2ass/releases/download/v1.1/Danmu2Ass1.1.zip" target="_blank" rel="noopener">Danmu2Ass</a>。</li></ol><h3 id="2-3-观看视频"><a href="#2-3-观看视频" class="headerlink" title="2.3 观看视频"></a>2.3 观看视频</h3><p>使用 <code>-p</code> 将视频喂进播放器, 例如 mPlayer 或者 vlc,而不是下载:<br><code>you-get -p vlc &#39;https://www.youtube.com/watch?v=jNQXAC9IVRw&#39;</code><br>或者你想在浏览器中观看而不希望看广告或评论区:<br><code>you-get -p chromium &#39;https://www.youtube.com/watch?v=jNQXAC9IVRw&#39;</code>  </p><h2 id="三：-官方文档"><a href="#三：-官方文档" class="headerlink" title="三： 官方文档"></a>三： 官方文档</h2><p><a href="https://github.com/soimort/you-get/wiki/%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">官方中文文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：-简介&quot;&gt;&lt;a href=&quot;#一：-简介&quot; class=&quot;headerlink&quot; title=&quot;一： 简介&quot;&gt;&lt;/a&gt;一： 简介&lt;/h2&gt;&lt;p&gt;You-Get 乃一小小哒命令行程序，提供便利的方式来下载网络上的媒体信息，通过python来安装。&lt;br&gt;支持主流视频网站如：YouTube、Google+、bilibili哔哩哔哩、163/网易视频/网易云音乐、斗鱼、爱奇艺、Youku、AcFun等等&lt;/p&gt;
&lt;h2 id=&quot;二：-安装及其使用&quot;&gt;&lt;a href=&quot;#二：-安装及其使用&quot; class=&quot;headerlink&quot; title=&quot;二： 安装及其使用&quot;&gt;&lt;/a&gt;二： 安装及其使用&lt;/h2&gt;&lt;h3 id=&quot;2-1-安装&quot;&gt;&lt;a href=&quot;#2-1-安装&quot; class=&quot;headerlink&quot; title=&quot;2.1 安装&quot;&gt;&lt;/a&gt;2.1 安装&lt;/h3&gt;&lt;p&gt;1） 安装python3
    
    </summary>
    
    
      <category term="python" scheme="https://closer_laps.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://closer_laps.gitee.io/tags/python/"/>
    
      <category term="you-get" scheme="https://closer_laps.gitee.io/tags/you-get/"/>
    
  </entry>
  
  <entry>
    <title>python爬图攻略</title>
    <link href="https://closer_laps.gitee.io/2020/02/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/python%E7%88%AC%E5%9B%BE%E6%94%BB%E7%95%A5/"/>
    <id>https://closer_laps.gitee.io/2020/02/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/python%E7%88%AC%E5%9B%BE%E6%94%BB%E7%95%A5/</id>
    <published>2020-02-16T02:54:10.000Z</published>
    <updated>2020-02-23T08:10:41.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：-软件工具"><a href="#一：-软件工具" class="headerlink" title="一： 软件工具"></a>一： 软件工具</h2><h3 id="1-1-Python3"><a href="#1-1-Python3" class="headerlink" title="1.1 Python3"></a>1.1 Python3</h3><p>这里选择的是最新版 Python3<br>安装教程这里推荐：<a href="http://www.runoob.com/python3/python3-install.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-install.html</a><br>win下载地址：<a href="https://www.python.org/downloads/windows" target="_blank" rel="noopener">https://www.python.org/downloads/windows</a><br>Linux下载地址：<a href="https://www.python.org/downloads/source" target="_blank" rel="noopener">https://www.python.org/downloads/source</a>  <a id="more"></a></p><h3 id="1-2-PyCharm"><a href="#1-2-PyCharm" class="headerlink" title="1.2 PyCharm"></a>1.2 PyCharm</h3><p>可视化开发工具IDE：<a href="https://www.jetbrains.com/pycharm/download/" target="_blank" rel="noopener">https://www.jetbrains.com/pycharm/download/</a></p><h2 id="二：原理"><a href="#二：原理" class="headerlink" title="二：原理"></a>二：原理</h2><h3 id="2-1-实现步骤"><a href="#2-1-实现步骤" class="headerlink" title="2.1 实现步骤"></a>2.1 实现步骤</h3><p>以图片为例，其实很简单，分以下四步：</p><ul><li>获取首页的页码数，并创建与页码对应的文件夹</li><li>获取页面的栏目地址</li><li>进入栏目，获取栏目页码数(每个栏目下有多张图片，分页显示)</li><li>获取到栏目下对用标签容器中的图片并下载</li></ul><h3 id="2-2-注意事项"><a href="#2-2-注意事项" class="headerlink" title="2.2 注意事项"></a>2.2 注意事项</h3><p>这里以爬取某个网站的套路为例，详细见代码，这里主要说以下几点注意事项：  </p><p>1）导库，其实就类似于Java中框架或者是工具类，底层都被封装好了</p><p>安装第三方库：</p><pre><code class="py"># Win下直接装的 python3pip install BeautifulSoup4 -i https://pypi.tuna.tsinghua.edu.cn/simplepip install requests -i https://pypi.tuna.tsinghua.edu.cn/simple# Linux python2 python3 共存pip3 install BeautifulSoup4 -i https://pypi.tuna.tsinghua.edu.cn/simplepip3 install requests -i https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><p>导入第三方库：</p><pre><code class="py"># 导入requests库import requests# 导入文件操作库import os# bs4全名BeautifulSoup4，是编写python爬虫常用库之一，主要用来解析html标签。import bs4from bs4 import BeautifulSoup# 基础类库import sys# Python 3.x 解决中文编码问题import importlibimportlib.reload(sys)</code></pre><p>2）定义方法函数，一个爬虫可能会几百行，所以尽量不要写成一坨</p><pre><code class="py">def download(page_no, file_path):    # 这里写代码逻辑</code></pre><p>3）定义全局变量</p><pre><code class="py"># 给请求指定一个请求头来模拟chrome浏览器global headers # 告诉编译器这是全局变量 headers headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&#39;}# 函数内使用之前需要# 告诉编译器我在这个方法中使用的a是刚才定义的全局变量 headers ，而不是方法内部的局部变量。global headers</code></pre><p>4）防盗链</p><p>有些网站加入了防盗链，无所不能的 python  解决方案：</p><pre><code class="py">headers = {&#39;Referer&#39;: href}img = requests.get(url, headers=headers)</code></pre><p>5）切换版本</p><p>Linux服务器使用的是阿里云服务器（centos7.4），默认版本 python2，python3 自行安装</p><pre><code class="py">[root@AY140216131049Z mzitu]# python2 -VPython 2.7.5[root@AY140216131049Z mzitu]# python3 -VPython 3.7.1# 默认版本[root@AY140216131049Z mzitu]# python -VPython 2.7.5# 临时切换版本 &lt;whereis python&gt;[root@AY140216131049Z mzitu]# alias python=&#39;/usr/local/bin/python3.7&#39;[root@AY140216131049Z mzitu]# python -VPython 3.7.1</code></pre><p>6）异常捕获</p><p>在爬取的过程中可能存在异常页面，这里我们进行捕获，不影响后续操作：</p><pre><code class="py">try:    # 业务逻辑except Exception as e:   print(e)</code></pre><h3 id="2-3-执行脚本"><a href="#2-3-执行脚本" class="headerlink" title="2.3 执行脚本"></a>2.3 执行脚本</h3><pre><code class="py">python3 mzitu.py# 或者后台执行nohup python3 -u mzitu.py &gt; mzitu.log 2&gt;&amp;1 &amp;</code></pre><h2 id="三：-源码"><a href="#三：-源码" class="headerlink" title="三： 源码"></a>三： 源码</h2><h3 id="3-1-win下代码"><a href="#3-1-win下代码" class="headerlink" title="3.1 win下代码"></a>3.1 win下代码</h3><pre><code class="py">#coding=utf-8#!/usr/bin/python# 导入requests库import requests# 导入文件操作库import osimport bs4from bs4 import BeautifulSoupimport sysimport importlibimport randomimport timeimportlib.reload(sys)# 越多越好meizi_headers = [    &quot;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36&quot;,    &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36&quot;,    &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0&quot;,    &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/537.75.14&quot;,    &quot;Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Win64; x64; Trident/6.0)&quot;,    &#39;Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11&#39;,    &#39;Opera/9.25 (Windows NT 5.1; U; en)&#39;,    &#39;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&#39;,    &#39;Mozilla/5.0 (compatible; Konqueror/3.5; Linux) KHTML/3.5.5 (like Gecko) (Kubuntu)&#39;,    &#39;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.0.12) Gecko/20070731 Ubuntu/dapper-security Firefox/1.5.0.12&#39;,    &#39;Lynx/2.8.5rel.1 libwww-FM/2.14 SSL-MM/1.4.1 GNUTLS/1.2.9&#39;,    &quot;Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.7 (KHTML, like Gecko) Ubuntu/11.04 Chromium/16.0.912.77 Chrome/16.0.912.77 Safari/535.7&quot;,    &quot;Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:10.0) Gecko/20100101 Firefox/10.0&quot;,    &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&#39;]# 给请求指定一个请求头来模拟chrome浏览器global headersheaders = {&#39;User-Agent&#39;: random.choice(meizi_headers)}# 爬图网址mziTu = &#39;http://www.mzitu.com/&#39;# 定义图片存储位置global save_pathsave_path = &#39;D:\BeautifulPictures&#39;# 创建文件夹def createFile(file_path):    if os.path.exists(file_path) is False:        os.makedirs(file_path)    # 切换路径至上面创建的文件夹    os.chdir(file_path)# 下载文件def download(page_no, file_path):    global headers    res_sub = requests.get(page_no, headers=headers)    # 解析html    soup_sub = BeautifulSoup(res_sub.text, &#39;html.parser&#39;)    # 获取页面的栏目地址    all_a = soup_sub.find(&#39;div&#39;,class_=&#39;postlist&#39;).find_all(&#39;a&#39;,target=&#39;_blank&#39;)    count = 0    for a in all_a:        count = count + 1        if (count % 2) == 0:            headers = {&#39;User-Agent&#39;: random.choice(meizi_headers)}            print(&quot;内页第几页：&quot; + str(count))            # 提取href            href = a.attrs[&#39;href&#39;]            print(&quot;套图地址：&quot; + href)            res_sub_1 = requests.get(href, headers=headers)            soup_sub_1 = BeautifulSoup(res_sub_1.text, &#39;html.parser&#39;)            # ------ 这里最好使用异常处理 ------            try:                # 获取套图的最大数量                pic_max = soup_sub_1.find(&#39;div&#39;, class_=&#39;pagenavi&#39;).find_all(&#39;span&#39;)[6].text                print(&quot;套图数量：&quot; + pic_max)                for j in range(1, int(pic_max) + 1):                    # 单位为秒，1-3 随机数                    time.sleep(random.randint(1, 3))                    headers = {&#39;User-Agent&#39;: random.choice(meizi_headers)}                    # print(&quot;子内页第几页：&quot; + str(j))                    # j int类型需要转字符串                    href_sub = href + &quot;/&quot; + str(j)                    print(&quot;图片地址：&quot;+href_sub)                    res_sub_2 = requests.get(href_sub, headers=headers)                    soup_sub_2 = BeautifulSoup(res_sub_2.text, &quot;html.parser&quot;)                    img = soup_sub_2.find(&#39;div&#39;, class_=&#39;main-image&#39;).find(&#39;img&#39;)                    if isinstance(img, bs4.element.Tag):                        # 提取src                        url = img.attrs[&#39;src&#39;]                        array = url.split(&#39;/&#39;)                        file_name = array[len(array)-1]                        # 防盗链加入Referer                        headers = {&#39;User-Agent&#39;: random.choice(meizi_headers), &#39;Referer&#39;: url}                        img = requests.get(url, headers=headers)                        print(&#39;开始保存图片&#39;, img)                        f = open(file_name, &#39;ab&#39;)                        f.write(img.content)                        print(file_name, &#39;图片保存成功！&#39;)                        f.close()            except Exception as e:                print(e)# 主方法def main():    res = requests.get(mziTu, headers=headers)    # 使用自带的html.parser解析    soup = BeautifulSoup(res.text, &#39;html.parser&#39;)    # 创建文件夹    createFile(save_path)    # 获取首页总页数    img_max = soup.find(&#39;div&#39;, class_=&#39;nav-links&#39;).find_all(&#39;a&#39;)[3].text    # print(&quot;总页数:&quot;+img_max)    for i in range(1, int(img_max) + 1):        # 获取每页的URL地址        if i == 1:            page = mziTu        else:            page = mziTu + &#39;page/&#39; + str(i)        file = save_path + &#39;\\&#39; + str(i)        createFile(file)        # 下载每页的图片        print(&quot;套图页码：&quot; + page)        download(page, file)if __name__ == &#39;__main__&#39;:    main()</code></pre><h3 id="3-2-linux下代码"><a href="#3-2-linux下代码" class="headerlink" title="3.2 linux下代码"></a>3.2 linux下代码</h3><pre><code class="py">#coding=utf-8#!/usr/bin/python# 导入requests库import requests# 导入文件操作库import osimport bs4from bs4 import BeautifulSoupimport sysimport importlibimportlib.reload(sys)# 给请求指定一个请求头来模拟chrome浏览器global headersheaders = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&#39;}# 爬图地址mziTu = &#39;http://www.mzitu.com/&#39;# 定义存储位置global save_pathsave_path = ​&#39;/mnt/data/mzitu&#39;# 创建文件夹def createFile(file_path):    if os.path.exists(file_path) is False:        os.makedirs(file_path)    # 切换路径至上面创建的文件夹    os.chdir(file_path)# 下载文件def download(page_no, file_path):    global headers    res_sub = requests.get(page_no, headers=headers)    # 解析html    soup_sub = BeautifulSoup(res_sub.text, &#39;html.parser&#39;)    # 获取页面的栏目地址    all_a = soup_sub.find(&#39;div&#39;,class_=&#39;postlist&#39;).find_all(&#39;a&#39;,target=&#39;_blank&#39;)    count = 0    for a in all_a:        count = count + 1        if (count % 2) == 0:            print(&quot;内页第几页：&quot; + str(count))            # 提取href            href = a.attrs[&#39;href&#39;]            print(&quot;套图地址：&quot; + href)            res_sub_1 = requests.get(href, headers=headers)            soup_sub_1 = BeautifulSoup(res_sub_1.text, &#39;html.parser&#39;)            # ------ 这里最好使用异常处理 ------            try:                # 获取套图的最大数量                pic_max = soup_sub_1.find(&#39;div&#39;,class_=&#39;pagenavi&#39;).find_all(&#39;span&#39;)[6].text                print(&quot;套图数量：&quot; + pic_max)                for j in range(1, int(pic_max) + 1):                    # print(&quot;子内页第几页：&quot; + str(j))                    # j int类型需要转字符串                    href_sub = href + &quot;/&quot; + str(j)                    print(href_sub)                    res_sub_2 = requests.get(href_sub, headers=headers)                    soup_sub_2 = BeautifulSoup(res_sub_2.text, &quot;html.parser&quot;)                    img = soup_sub_2.find(&#39;div&#39;, class_=&#39;main-image&#39;).find(&#39;img&#39;)                    if isinstance(img, bs4.element.Tag):                        # 提取src                        url = img.attrs[&#39;src&#39;]                        array = url.split(&#39;/&#39;)                        file_name = array[len(array)-1]                        # print(file_name)                        # 防盗链加入Referer                        headers = {&#39;Referer&#39;: href}                        img = requests.get(url, headers=headers)                        # print(&#39;开始保存图片&#39;)                        f = open(file_name, &#39;ab&#39;)                        f.write(img.content)                        # print(file_name, &#39;图片保存成功！&#39;)                        f.close()            except Exception as e:                print(e)# 主方法def main():    res = requests.get(mziTu, headers=headers)    # 使用自带的html.parser解析    soup = BeautifulSoup(res.text, &#39;html.parser&#39;)    # 创建文件夹    createFile(save_path)    # 获取首页总页数    img_max = soup.find(&#39;div&#39;, class_=&#39;nav-links&#39;).find_all(&#39;a&#39;)[3].text    # print(&quot;总页数:&quot;+img_max)    for i in range(1, int(img_max) + 1):        # 获取每页的URL地址        if i == 1:            page = mziTu        else:            page = mziTu + &#39;page/&#39; + str(i)        file = save_path + &#39;/&#39; + str(i)        createFile(file)        # 下载每页的图片        print(&quot;套图页码：&quot; + page)        download(page, file)if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="四：-参考文献"><a href="#四：-参考文献" class="headerlink" title="四： 参考文献"></a>四： 参考文献</h2><p><a href="https://gitee.com/52itstyle/Python" target="_blank" rel="noopener">小柒2012 / 从零学Python / Day01</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：-软件工具&quot;&gt;&lt;a href=&quot;#一：-软件工具&quot; class=&quot;headerlink&quot; title=&quot;一： 软件工具&quot;&gt;&lt;/a&gt;一： 软件工具&lt;/h2&gt;&lt;h3 id=&quot;1-1-Python3&quot;&gt;&lt;a href=&quot;#1-1-Python3&quot; class=&quot;headerlink&quot; title=&quot;1.1 Python3&quot;&gt;&lt;/a&gt;1.1 Python3&lt;/h3&gt;&lt;p&gt;这里选择的是最新版 Python3&lt;br&gt;安装教程这里推荐：&lt;a href=&quot;http://www.runoob.com/python3/python3-install.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.runoob.com/python3/python3-install.html&lt;/a&gt;&lt;br&gt;win下载地址：&lt;a href=&quot;https://www.python.org/downloads/windows&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.python.org/downloads/windows&lt;/a&gt;&lt;br&gt;Linux下载地址：&lt;a href=&quot;https://www.python.org/downloads/source&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.python.org/downloads/source&lt;/a&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://closer_laps.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://closer_laps.gitee.io/tags/python/"/>
    
      <category term="爬图" scheme="https://closer_laps.gitee.io/tags/%E7%88%AC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>hexo一键上传部署脚本的构建</title>
    <link href="https://closer_laps.gitee.io/2020/02/15/hexo/hexo%E4%B8%80%E9%94%AE%E4%B8%8A%E4%BC%A0%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC%E7%9A%84%E6%9E%84%E5%BB%BA/"/>
    <id>https://closer_laps.gitee.io/2020/02/15/hexo/hexo%E4%B8%80%E9%94%AE%E4%B8%8A%E4%BC%A0%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC%E7%9A%84%E6%9E%84%E5%BB%BA/</id>
    <published>2020-02-15T05:27:09.000Z</published>
    <updated>2020-02-18T11:59:38.583Z</updated>
    
    <content type="html"><![CDATA[<ol><li>windows先右键新建一个文本文档，后缀改为<code>git push hexo.bat</code>；Linux新建一个<code>git push hexo.sh</code>文档;</li><li>注意：编码要是windows默认编码GBK；Linux上是UTF-8；</li><li>然后复制黏贴，话不多说，直接上代码。  <a id="more"></a></li></ol><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><pre><code class="bat">@echo offcd G:\code\hexoREM 改为hexo根目录echo &quot;当前目录是： G:\code\hexo&quot;REM 改为hexo根目录echo &quot;正在add... ...&quot;git add source/ REM 只添加了blog文件目录，需要的可自行添加...echo;echo &quot;add complete.&quot;echo;echo;echo &quot;正在commit... ...&quot;set now=%date% %time%echo %now%git commit -m &quot;blog update at %now%&quot;echo;echo &quot;commit complete.&quot;echo;echo;echo &quot;正在将更改提交到远程git服务器... ...&quot;git push githuborigin hexo &amp;&amp; git push giteeorigin hexo &amp;&amp; git push codingorigin hexoecho;echo &quot;git push complete.&quot;echo;echo;echo &quot;正在部署blog... ...&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo decho;echo &quot;部署 complete.&quot;echo;echo;pause</code></pre><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>先提升权限，<code>chmod +x ./git\ push\ hexo.sh</code>。</p><pre><code class="sh">cd /home/zs/文档/hexo/closer_laps# 改为hexo根目录echo &quot;当前目录是： /home/zs/文档/hexo/closer_laps&quot;# 改为hexo根目录echo &quot;正在add... ...&quot;git add source/ echo;echo &quot;add complete.&quot;echo;echo;echo &quot;正在commit... ...&quot;now=`date &#39;+%Y-%m-%d %H:%M:%S&#39;`echo &quot;$now&quot;git commit -m &quot;blog update at $now&quot;echo;echo &quot;commit complete.&quot;echo;echo;echo &quot;正在push... ...&quot;git push githuborigin hexo &amp;&amp; git push giteeorigin hexo &amp;&amp; git push codingorigin hexoecho;echo &quot;git push complete.&quot;echo;echo;echo &quot;正在部署blog... ...&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo decho;echo &quot;部署 complete.&quot;echo;echo;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;windows先右键新建一个文本文档，后缀改为&lt;code&gt;git push hexo.bat&lt;/code&gt;；Linux新建一个&lt;code&gt;git push hexo.sh&lt;/code&gt;文档;&lt;/li&gt;
&lt;li&gt;注意：编码要是windows默认编码GBK；Linux上是UTF-8；&lt;/li&gt;
&lt;li&gt;然后复制黏贴，话不多说，直接上代码。
    
    </summary>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/tags/hexo/"/>
    
      <category term="一键部署" scheme="https://closer_laps.gitee.io/tags/%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>同时在Github、Gitee、Coding上部署Hexo</title>
    <link href="https://closer_laps.gitee.io/2020/02/14/hexo/%E5%90%8C%E6%97%B6%E5%9C%A8Github%E3%80%81Gitee%E3%80%81Coding%E4%B8%8A%E9%83%A8%E7%BD%B2Hexo/"/>
    <id>https://closer_laps.gitee.io/2020/02/14/hexo/%E5%90%8C%E6%97%B6%E5%9C%A8Github%E3%80%81Gitee%E3%80%81Coding%E4%B8%8A%E9%83%A8%E7%BD%B2Hexo/</id>
    <published>2020-02-14T11:21:14.000Z</published>
    <updated>2020-02-15T05:14:00.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、创建托管仓库"><a href="#一、创建托管仓库" class="headerlink" title="一、创建托管仓库"></a>一、创建托管仓库</h2><ul><li><p>GitHub <a href="https://github.com" target="_blank" rel="noopener">https://github.com</a><br>与用户名相同，格式为YouID.github.io</p></li><li><p>Gitee <a href="https://gitee.com" target="_blank" rel="noopener">https://gitee.com</a><br>与用户名相同，格式为YouID</p></li><li><p>Coding <a href="https://coding.net" target="_blank" rel="noopener">https://coding.net</a><br>与用户名相同，格式为YouID.coding.me</p><a id="more"></a></li></ul><h2 id="二、在Github、Gitee、Coding上添加SSH，并push"><a href="#二、在Github、Gitee、Coding上添加SSH，并push" class="headerlink" title="二、在Github、Gitee、Coding上添加SSH，并push"></a>二、在Github、Gitee、Coding上添加SSH，并push</h2><ol><li>获取id_rsa.pub文件内的公匙;具体如何获取请百度<code>id_rsa.pub</code></li><li>在 Github、Gitee、Coding平台 - 设置 - 添加SSH Keys。</li><li>将博客分支master和分支hexo里的内容push到仓库，并设定hexo为主分支（hexo分支的好处请参考<a href="https://closer_laps.gitee.io/2019/12/09/hexo/hexo%20%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/"> hexo 多客户端上更新博客</a>）。</li></ol><h2 id="三、开启Pages服务并绑定域名"><a href="#三、开启Pages服务并绑定域名" class="headerlink" title="三、开启Pages服务并绑定域名"></a>三、开启Pages服务并绑定域名</h2><ul><li>GitHub 进入托管的仓库 -&gt; Settings -&gt; Options 往下拉-&gt;GitHub Pages</li><li>Gitee 进入托管的仓库 -&gt; 服务-&gt; Gitee Pages (绑定域名需要升级Gitee Pro，普通版每次部署更新需要手动点更新！！！)</li><li>Coding 进入托管的仓库 -&gt; Pages服务 -&gt; 设置</li></ul><h2 id="四、Hexo推送设置"><a href="#四、Hexo推送设置" class="headerlink" title="四、Hexo推送设置"></a>四、Hexo推送设置</h2><p>在博客根目录下，打开<code>_config.yml</code>,deploy设置如下所示</p><pre><code class="yml">deploy:  type: git  repo:        github: git@github.com:YouID/YouID.github.io.git        gitee: git@gitee.com:YouID/YouID.git        coding: git@e.coding.net:YouID/YouID.coding.me.git  branch: master</code></pre><h2 id="五：将本地仓库和远程仓库连接"><a href="#五：将本地仓库和远程仓库连接" class="headerlink" title="五：将本地仓库和远程仓库连接"></a>五：将本地仓库和远程仓库连接</h2><ul><li><p>GitHub<br><code>git remote add githuborigin git@github.com:YouID/YouID.github.io.git</code></p></li><li><p>Gitee<br><code>git remote add giteeorigin git@gitee.com:YouID/YouID.git</code>  </p></li><li><p>Coding<br><code>git remote add codingorigin git@e.coding.net:YouID/YouID.coding.me.git</code></p></li></ul><p>输入<code>git remote -v</code>，成功的话会显示3个你关联的远程库：<code>codingorigin</code>、<code>githuborigin</code>、<code>giteeorigin</code>。如下：</p><pre><code>codingorigin    git@e.coding.net:YouID/YouID.coding.me.git (fetch)codingorigin    git@e.coding.net:YouID/YouID.coding.me.git (push)giteeorigin     git@gitee.com:YouID/YouID.git (fetch)giteeorigin     git@gitee.com:YouID/YouID.git (push)githuborigin  git@github.com:YouID/YouID.github.io.git (fetch)githuborigin  git@github.com:YouID/YouID.github.io.git (push)</code></pre><h2 id="六、一键部署必杀命令"><a href="#六、一键部署必杀命令" class="headerlink" title="六、一键部署必杀命令"></a>六、一键部署必杀命令</h2><p><code>git add source/ &amp;&amp; git commit -m &quot;blog update&quot; &amp;&amp; git push githuborigin hexo &amp;&amp; git push giteeorigin hexo &amp;&amp; git push codingorigin hexo &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; exit</code><br>把所有命令用<code>&amp;&amp;</code>串起来，有一个失败就会停止；成功，最后一条命令就会退出终端。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、创建托管仓库&quot;&gt;&lt;a href=&quot;#一、创建托管仓库&quot; class=&quot;headerlink&quot; title=&quot;一、创建托管仓库&quot;&gt;&lt;/a&gt;一、创建托管仓库&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GitHub &lt;a href=&quot;https://github.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com&lt;/a&gt;&lt;br&gt;与用户名相同，格式为YouID.github.io&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Gitee &lt;a href=&quot;https://gitee.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gitee.com&lt;/a&gt;&lt;br&gt;与用户名相同，格式为YouID&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Coding &lt;a href=&quot;https://coding.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://coding.net&lt;/a&gt;&lt;br&gt;与用户名相同，格式为YouID.coding.me&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/tags/hexo/"/>
    
      <category term="多平台部署" scheme="https://closer_laps.gitee.io/tags/%E5%A4%9A%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>如何在markdown中优雅的编辑数学公式</title>
    <link href="https://closer_laps.gitee.io/2020/02/12/hexo/%E5%A6%82%E4%BD%95%E5%9C%A8markdown%E4%B8%AD%E4%BC%98%E9%9B%85%E7%9A%84%E7%BC%96%E8%BE%91%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <id>https://closer_laps.gitee.io/2020/02/12/hexo/%E5%A6%82%E4%BD%95%E5%9C%A8markdown%E4%B8%AD%E4%BC%98%E9%9B%85%E7%9A%84%E7%BC%96%E8%BE%91%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</id>
    <published>2020-02-12T11:46:23.000Z</published>
    <updated>2020-02-19T15:36:05.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>下载IDE软件vscode，安装插件<code>Markdown Preview Enhanced</code>(简称MPE)。</p><p><a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/" target="_blank" rel="noopener">MPE官方使用文档</a>。  </p><h2 id="hexo博客中使用-KaTeX-来渲染数学表达式"><a href="#hexo博客中使用-KaTeX-来渲染数学表达式" class="headerlink" title="hexo博客中使用 KaTeX 来渲染数学表达式"></a>hexo博客中使用 KaTeX 来渲染数学表达式</h2><ol><li>在Next主题配置下面开启mathjax。（不知道怎么开启的小伙伴请查询官方文档或者github）</li><li>在博客需要用到公式的md文件的头文件中添加一句：<code>mathjax: true</code>。</li></ol><h2 id="上下标及标记"><a href="#上下标及标记" class="headerlink" title="上下标及标记"></a>上下标及标记</h2><a id="more"></a><ol><li>默认下的分隔符：<br><code>$...$</code> 或者<code>\(...\)</code>中的数学表达式将会在行内显示。<br><code>$$...$$</code> 或者 <code>\[...\]</code> 或者 <code>```math</code> 中的数学表达式将会在块内显示。  </li><li>公式两边用<code>$</code>符号标记为公式，如:<br><code>$a^2$</code>显示为$a^2$<br><code>$H_2O$</code>显示为$H_2O$<br><code>==marked==</code>显示为==marked==  </li></ol><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p>Markdown Preview Enhanced 使用 KaTeX 来渲染数学表达式。  </p><p>如这个公式：$f(x)=\int_{-\infty}^\infty\widehat f\xi,e^{2\pi i\xi x},d\xi$  </p><p>想要正确地写出它的文本形式可不容易：<br><code>f(x)=\int_{-\infty}^\infty\widehat f\xi\,e^{2\pi i\xi x}\,d\xi</code>  </p><p>如果仅仅为了写个公式，就去学LaTeX语法，那没有十天半月的肯定不行。这个时候，你需要一个<a href="http://www.wiris.com/editor/demo/en/developers#output-formats" target="_blank" rel="noopener">可视化公式编辑器</a>的神器，它可以让我们可视化地编辑公式，然后自动得到它的LaTeX文本：<br><img src="https://www.liaoxuefeng.com/files/attachments/1280023417847873/l" srcset="/img/loading.gif" alt="使用说明">  </p><p>在线转换地址1：<a href="http://www.wiris.com/editor/demo/en/developers#output-formats" target="_blank" rel="noopener">http://www.wiris.com/editor/demo/en/developers#output-formats</a></p><p>在线转换地址2：<a href="https://latex.91maths.com/" target="_blank" rel="noopener">https://latex.91maths.com/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IDE&quot;&gt;&lt;a href=&quot;#IDE&quot; class=&quot;headerlink&quot; title=&quot;IDE&quot;&gt;&lt;/a&gt;IDE&lt;/h2&gt;&lt;p&gt;下载IDE软件vscode，安装插件&lt;code&gt;Markdown Preview Enhanced&lt;/code&gt;(简称MPE)。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MPE官方使用文档&lt;/a&gt;。  &lt;/p&gt;
&lt;h2 id=&quot;hexo博客中使用-KaTeX-来渲染数学表达式&quot;&gt;&lt;a href=&quot;#hexo博客中使用-KaTeX-来渲染数学表达式&quot; class=&quot;headerlink&quot; title=&quot;hexo博客中使用 KaTeX 来渲染数学表达式&quot;&gt;&lt;/a&gt;hexo博客中使用 KaTeX 来渲染数学表达式&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在Next主题配置下面开启mathjax。（不知道怎么开启的小伙伴请查询官方文档或者github）&lt;/li&gt;
&lt;li&gt;在博客需要用到公式的md文件的头文件中添加一句：&lt;code&gt;mathjax: true&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;上下标及标记&quot;&gt;&lt;a href=&quot;#上下标及标记&quot; class=&quot;headerlink&quot; title=&quot;上下标及标记&quot;&gt;&lt;/a&gt;上下标及标记&lt;/h2&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/categories/hexo/"/>
    
    
      <category term="数学公式" scheme="https://closer_laps.gitee.io/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    
      <category term="markdown语法" scheme="https://closer_laps.gitee.io/tags/markdown%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
