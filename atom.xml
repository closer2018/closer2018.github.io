<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>closer的自留地</title>
  
  <subtitle>just do it!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://closer_laps.gitee.io/"/>
  <updated>2019-12-25T11:28:41.608Z</updated>
  <id>https://closer_laps.gitee.io/</id>
  
  <author>
    <name>closer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大话数据结构第五章 串</title>
    <link href="https://closer_laps.gitee.io/2019/12/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC5%E7%AB%A0%20%E4%B8%B2/"/>
    <id>https://closer_laps.gitee.io/2019/12/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC5%E7%AB%A0%20%E4%B8%B2/</id>
    <published>2019-12-25T11:26:12.000Z</published>
    <updated>2019-12-25T11:28:41.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5-1-5-2-串的定义"><a href="#5-1-5-2-串的定义" class="headerlink" title="5.1-5.2 串的定义"></a>5.1-5.2 串的定义</h2><p>串（string）是由零个或多个字符组成的有限序列，又名叫字符串。<br>一般记为s=“a1a2……an”（n&gt;0），其中，s是串的名称，用双引号（有些书中也用单引号）括起来的字符序列是串的值，注意单引号不属于串的内容。ai（1≤i≤n）可以是字母、数字或其他字符，i就是该字符在串中的位置。串中的字符数目n称为串的长度，定义中谈到“有限”是指长度n是一个有限的数值。零个字符的串称为空串（null string），它的长度为零，可以直接用两双引号“”””表示，也可以用希腊字母“Φ”来表示。所谓的序列，说明串的相邻字符之间具有前驱和后继的关系。<br>还有一些概念需要解释：  </p><a id="more"></a><ul><li>空格串，是只包含空格的串。注意它与空串的区别，空格串是有内容有长度的，而且可以不止一个空格。</li><li>子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。</li><li>子串在主串中的位置就是子串的第一个字符在主串中的序号。</li></ul><p>开头我所提到的“over”、“end”、“lie”其实可以认为是“over”、“friend”、“believe”这些单词字符串的子串。  </p><h2 id="5-3-串的比较"><a href="#5-3-串的比较" class="headerlink" title="5.3 串的比较"></a>5.3 串的比较</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;5-1-5-2-串的定义&quot;&gt;&lt;a href=&quot;#5-1-5-2-串的定义&quot; class=&quot;headerlink&quot; title=&quot;5.1-5.2 串的定义&quot;&gt;&lt;/a&gt;5.1-5.2 串的定义&lt;/h2&gt;&lt;p&gt;串（string）是由零个或多个字符组成的有限序列，又名叫字符串。&lt;br&gt;一般记为s=“a1a2……an”（n&amp;gt;0），其中，s是串的名称，用双引号（有些书中也用单引号）括起来的字符序列是串的值，注意单引号不属于串的内容。ai（1≤i≤n）可以是字母、数字或其他字符，i就是该字符在串中的位置。串中的字符数目n称为串的长度，定义中谈到“有限”是指长度n是一个有限的数值。零个字符的串称为空串（null string），它的长度为零，可以直接用两双引号“”””表示，也可以用希腊字母“Φ”来表示。所谓的序列，说明串的相邻字符之间具有前驱和后继的关系。&lt;br&gt;还有一些概念需要解释：  &lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="https://closer_laps.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>hexo next主题导航栏图标显示问号解决方案</title>
    <link href="https://closer_laps.gitee.io/2019/12/10/hexo/hexo-next%E4%B8%BB%E9%A2%98%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA%E9%97%AE%E5%8F%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://closer_laps.gitee.io/2019/12/10/hexo/hexo-next%E4%B8%BB%E9%A2%98%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA%E9%97%AE%E5%8F%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2019-12-10T02:46:08.000Z</published>
    <updated>2019-12-10T02:52:14.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>导航栏图标显示问号，当修改<code>hexo\themes\next\_config.yml</code>主题配置文件后，图标显示正常，但是点击链接不能打开相应主页、标签页、归档页…<br>经研究，应该把menu下面的不同页面的/后面的空格删掉，即可。<br>具体配置如下：  </p><a id="more"></a><pre><code class="yml">menu:  home: /|| home                  #主页  archives: /archives/|| archive  #归档  categories: /categories/|| th   #分类  tags: /tags/|| tags             #标签  about: /about/|| user           #关于我  #search: /search  #schedule: /schedule/ || calendar  #sitemap: /sitemap.xml || sitemap  #commonweal: /404.html# Enable/Disable menu icons.menu_icons:  enable: true  # Icon Mapping.  home: home  archives: archive  categories: th  tags: tags  about: user  #commonweal: heartbeat  #search: search</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;导航栏图标显示问号，当修改&lt;code&gt;hexo\themes\next\_config.yml&lt;/code&gt;主题配置文件后，图标显示正常，但是点击链接不能打开相应主页、标签页、归档页…&lt;br&gt;经研究，应该把menu下面的不同页面的/后面的空格删掉，即可。&lt;br&gt;具体配置如下：  &lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo 多客户端上更新博客</title>
    <link href="https://closer_laps.gitee.io/2019/12/09/hexo/hexo%20%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/"/>
    <id>https://closer_laps.gitee.io/2019/12/09/hexo/hexo%20%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-12-09T10:08:25.000Z</published>
    <updated>2019-12-25T11:32:32.286Z</updated>
    
    <content type="html"><![CDATA[<p><code>git add source/ &amp;&amp; git commit -m &quot;博客更新&quot; &amp;&amp; git push origin hexo &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; exit</code></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>静态网页文件存放在<code>master主分支</code>，个人文件存放在<code>hexo分支</code>。  </p><h2 id="一、本地电脑设置"><a href="#一、本地电脑设置" class="headerlink" title="一、本地电脑设置"></a>一、本地电脑设置</h2><p>先新建一个hexo文件夹，在git bash下cd进入hexo文件夹。</p><ol><li><code>git init</code></li><li><code>git checkout -b hexo</code> //新建hexo分支并切换到hexo</li><li>将原来博客文件夹里面的<code>_config.yml</code>，<code>theme/</code>，<code>source/</code>，<code>scaffolds/</code>，<code>package.json</code>，<code>.gitignore</code>，共6个文件/文件夹 拷贝到hexo文件夹下面。<br>需要拷贝的文件如下:  <a id="more"></a></li></ol><ul><li>_config.yml（站点配置）；</li><li>theme文件夹里面的主题；</li><li>source文件夹；</li><li>scaffolds文件夹（文章的模板）；</li><li>package.json（说明使用哪些包）；</li><li>.gitignore（限定在提交的时候哪些文件可以忽略）；  </li><li><strong>注意：不要<code>hexo init</code>去整体初始化，因为需要的文件我们已经拷贝过来了。</strong>  </li></ul><ol start="4"><li>将theme文件夹里面的你的主题文件夹下的.git文件夹删除。</li><li><code>git add scaffolds/ source/ themes .gitignore _config.yml package.json</code><br><code>git commit -m &quot;init&quot;</code>  </li><li><code>git remote add origin git@github.com:你的ID/你的仓库名字</code>  //添加本地hexo和远程仓库的关联  </li><li>登录github，将分支仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为hexo，Update保存。 </li><li><code>git push origin hexo</code>  //上传更新</li></ol><h2 id="二、另外一台电脑上配置"><a href="#二、另外一台电脑上配置" class="headerlink" title="二、另外一台电脑上配置"></a>二、另外一台电脑上配置</h2><ol><li>官网下载安装：  </li></ol><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">安装 Node.js；</a></li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">安装 Git。</a></li></ul><ol start="2"><li>新建hexo目录，cd进入。</li><li><code>git clone https://github.com/你的ID/你的ID.github.io.git</code>  //克隆到本地</li><li>将新电脑生成的ssh key添加到gitHub账户上。<br>需要配置 git。</li></ol><ul><li><code>git config --global user.email &quot;xxx@qq.com&quot;</code> 引号内的<a href="mailto:xxx@qq.com">xxx@qq.com</a>改为你github注册并且验证的邮箱；</li><li><code>git config --global user.name &quot;xxxx&quot;</code>   引号内的xxxx改为你的 github 用户名；</li><li><code>ssh-keygen</code> 会出现下面的内容，一直按Enter键就行；</li><li>打开用户目录下的 <code>.ssh</code>目录下面生成 <code>id_rsa(私钥)id_rsa.pub(公钥)</code>两个文件，打开<code>id_rsa.pub</code>，复制里面的内容,到 github: <code>Settings -&gt; SSH and GPG keys -&gt; SSH keys -&gt; New SSH key -&gt; (填写)Title -&gt; (粘贴)Key -&gt; Add SSH Key</code>；</li><li>测试 <code>ssh -T git@github.com</code>，输出 <strong>You’ve successfully authenticated</strong> 表示添加key 成功。</li></ul><ol start="5"><li><code>npm install hexo-cli -g</code> //安装hexo</li><li><code>npm install</code> //安装依赖包  </li></ol><ul><li>如果出现报错<code>ERROR Try runing: &#39;npm install hexo --save</code>则执行命令<code>npm install hexo --save</code>，如果没有，则忽略。</li></ul><h2 id="三、发布博客"><a href="#三、发布博客" class="headerlink" title="三、发布博客"></a>三、发布博客</h2><ol><li>cd进入博客目录</li><li><code>git pull origin hexo</code> //保证和分支同步</li><li><code>hexo n &quot;新建博客&quot;</code></li><li><code>git add source/</code>      //因为博客文件是在source文件夹下面的</li><li><code>git commit -m &quot;博客更新&quot;</code></li><li><code>git push origin hexo</code>//长传更新</li><li><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>//部署博客</li></ol><p>至此，多终端发布博客已经配置完成。</p><h2 id="四、更新主题"><a href="#四、更新主题" class="headerlink" title="四、更新主题"></a>四、更新主题</h2><p>配置好主题文件后，执行：<br><code>git add scaffolds/ source/ themes .gitignore _config.yml package.json</code><br><code>git commit -m &quot;更新主题&quot;</code><br><code>git push origin hexo</code>  //上传更新</p><h2 id="五、快速上传部署命令"><a href="#五、快速上传部署命令" class="headerlink" title="五、快速上传部署命令"></a>五、快速上传部署命令</h2><p>只更新博客内容，可以从上述第 三 大步第 4 步后可以这样子发布：<br><code>git add source/ &amp;&amp; git commit -m &quot;博客更新&quot; &amp;&amp; git push origin hexo &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; exit</code><br>把所有命令用<code>&amp;&amp;</code>串起来，有一个失败就会停止；成功，最后一条命令就会退出终端。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;git add source/ &amp;amp;&amp;amp; git commit -m &amp;quot;博客更新&amp;quot; &amp;amp;&amp;amp; git push origin hexo &amp;amp;&amp;amp; hexo clean &amp;amp;&amp;amp; hexo g &amp;amp;&amp;amp; hexo d &amp;amp;&amp;amp; exit&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;静态网页文件存放在&lt;code&gt;master主分支&lt;/code&gt;，个人文件存放在&lt;code&gt;hexo分支&lt;/code&gt;。  &lt;/p&gt;
&lt;h2 id=&quot;一、本地电脑设置&quot;&gt;&lt;a href=&quot;#一、本地电脑设置&quot; class=&quot;headerlink&quot; title=&quot;一、本地电脑设置&quot;&gt;&lt;/a&gt;一、本地电脑设置&lt;/h2&gt;&lt;p&gt;先新建一个hexo文件夹，在git bash下cd进入hexo文件夹。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;git init&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout -b hexo&lt;/code&gt; //新建hexo分支并切换到hexo&lt;/li&gt;
&lt;li&gt;将原来博客文件夹里面的&lt;code&gt;_config.yml&lt;/code&gt;，&lt;code&gt;theme/&lt;/code&gt;，&lt;code&gt;source/&lt;/code&gt;，&lt;code&gt;scaffolds/&lt;/code&gt;，&lt;code&gt;package.json&lt;/code&gt;，&lt;code&gt;.gitignore&lt;/code&gt;，共6个文件/文件夹 拷贝到hexo文件夹下面。&lt;br&gt;需要拷贝的文件如下:
    
    </summary>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/tags/hexo/"/>
    
      <category term="多客户端" scheme="https://closer_laps.gitee.io/tags/%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>hexo配置文件设置</title>
    <link href="https://closer_laps.gitee.io/2019/12/09/hexo/hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE/"/>
    <id>https://closer_laps.gitee.io/2019/12/09/hexo/hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE/</id>
    <published>2019-12-08T16:15:17.000Z</published>
    <updated>2019-12-10T03:49:03.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo配置文件设置"><a href="#hexo配置文件设置" class="headerlink" title="hexo配置文件设置"></a>hexo配置文件设置</h2><p>hexo配置文件<code>_config.yml</code>基本配置</p><a id="more"></a><pre><code class="yml"># Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 网站title: closer的个人博客subtitle: welcome!description: 非专业初学者码农一枚keywords:author: closerlanguage: zh-Hans #语言timezone: &#39;&#39;# URL 网址## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: https://closer_laps.gitee.io/root: / #根目录位置，如果只是github pages的子目录需要更改permalink: :year/:month/:day/:title/permalink_defaults:# Directory #文件结构 默认即可source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: langskip_render:# Writing #编辑博文的选项new_post_name: :title.md # File name of new postsdefault_layout: postauto_spacing: falsetitlecase: false # 把标题转换为 title case external_link:  enable: true # Open external links in new tab  field: site # Apply to the whole site  exclude: &#39;&#39;filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写 render_drafts: false #显示草稿 post_asset_folder: false #启动 Asset 文件夹 relative_link: false #把链接改为与根目录的相对位址 future: true #显示未来的文章 highlight:  #代码块的设置  enable: false  #开启代码块高亮  auto_detect: false #如果未指定语言，则启用自动检测  line_number: true #显示行数  tab_replace: &#39;&#39; #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs # Home page setting# path: Root path for your blogs index page. (default = &#39;&#39;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator:  path: &#39;&#39;  per_page: 10  order_by: -date# Category &amp; Tag #分类 &amp; 标签default_category: uncategorizedcategory_map:tag_map:# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# Date / Time format #日期显示格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD #日期格式 time_format: HH:mm:ss #时间格式## Use post&#39;s date for updated date unless set in front-matteruse_date_for_updated: false# Pagination #分页器## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能) 10pagination_dir: page #分页目录 # Include / Exclude file(s)## include:/exclude: options only apply to the &#39;source/&#39; folderinclude:exclude:ignore:# Extensions #拓展## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: next #主题更换# Deployment #部署参数## Docs: http://hexo.io/docs/deployment.htmldeploy:  type: git  repo: https://github.com/closer2018/closer2018.github.io.git  #repo: https://gitee.com/closer_laps/closer_laps.git  branch: master# 搜索设置search:  path: search.xml  field: post  format: html  limit: 10000</code></pre><p>以上就是配置文件的基础设置。</p><h2 id="更换主题NexT"><a href="#更换主题NexT" class="headerlink" title="更换主题NexT"></a>更换主题NexT</h2><p>Hexo安装主题的方式非常简单，只需要将主题文件放置于站点目录的themes下，然后修改下配置文件即可。这里我以NexT主题为例。<br>在git bash操作下cd至博客根目录，执行如下代码：  </p><p><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p><p>等待下载完成后，修改根目录下_config.yml文件的theme字段为next即可启用NexT主题，十分简单便捷。<br>其它具体设置可参照<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT官方文档</a>。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>cd至blog根目录。  </p><pre><code class="yml">npm install hexo-generator-searchdb --save  #搜索插件npm install --save hexo-generator-feed   #RSS插件npm install hexo-wordcount --save   #字符统计及阅读时长估计npm install hexo-generator-sitemap --save  #博客添加网站地图sitemapnpm install hexo-generator-index-pin-top --save   #置顶插件</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;hexo配置文件设置&quot;&gt;&lt;a href=&quot;#hexo配置文件设置&quot; class=&quot;headerlink&quot; title=&quot;hexo配置文件设置&quot;&gt;&lt;/a&gt;hexo配置文件设置&lt;/h2&gt;&lt;p&gt;hexo配置文件&lt;code&gt;_config.yml&lt;/code&gt;基本配置&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/categories/hexo/"/>
    
    
      <category term="hexo配置文件" scheme="https://closer_laps.gitee.io/tags/hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>hexo上传部署命令</title>
    <link href="https://closer_laps.gitee.io/2019/12/01/hexo/hexo%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://closer_laps.gitee.io/2019/12/01/hexo/hexo%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-11-30T16:00:00.000Z</published>
    <updated>2019-12-10T02:18:32.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo上传部署三连杀命令-先cd进入git目录"><a href="#hexo上传部署三连杀命令-先cd进入git目录" class="headerlink" title="hexo上传部署三连杀命令(先cd进入git目录)"></a>hexo上传部署三连杀命令(先<code>cd</code>进入git目录)</h2><pre><code class="bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><a id="more"></a><h3 id="我们运行测试时，经常用到的有三个命令"><a href="#我们运行测试时，经常用到的有三个命令" class="headerlink" title="我们运行测试时，经常用到的有三个命令"></a>我们运行测试时，经常用到的有三个命令</h3><pre><code class="bash">hexo clean #用来清理缓存文件hexo g      #生成文件hexo  d   #上传到服务器</code></pre><h4 id="本地检测时运行"><a href="#本地检测时运行" class="headerlink" title="本地检测时运行"></a>本地检测时运行</h4><pre><code class="bash">hexo s</code></pre><p>然后打开浏览器，输入localhost:4000，就能看到博客了。<br>这样说明本地环境搭建完成。</p><h3 id="特别感谢B站up主CodeSheep的帮助和细心指导"><a href="#特别感谢B站up主CodeSheep的帮助和细心指导" class="headerlink" title="特别感谢B站up主CodeSheep的帮助和细心指导"></a>特别感谢<a href="https://space.bilibili.com/384068749/" target="_blank" rel="noopener">B站up主CodeSheep</a>的帮助和细心指导</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;hexo上传部署三连杀命令-先cd进入git目录&quot;&gt;&lt;a href=&quot;#hexo上传部署三连杀命令-先cd进入git目录&quot; class=&quot;headerlink&quot; title=&quot;hexo上传部署三连杀命令(先cd进入git目录)&quot;&gt;&lt;/a&gt;hexo上传部署三连杀命令(先&lt;code&gt;cd&lt;/code&gt;进入git目录)&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;hexo clean &amp;amp;&amp;amp; hexo g &amp;amp;&amp;amp; hexo d&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构第三章 线性表</title>
    <link href="https://closer_laps.gitee.io/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC3%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://closer_laps.gitee.io/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC3%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2019-11-27T16:00:00.000Z</published>
    <updated>2019-12-25T10:45:37.919Z</updated>
    
    <content type="html"><![CDATA[<p>线性表：零个或多个数据元素的有限序列。</p><h2 id="3-1-3-2线性表的定义"><a href="#3-1-3-2线性表的定义" class="headerlink" title="3.1-3.2线性表的定义"></a>3.1-3.2线性表的定义</h2><p>线性表（List）：零个或多个数据元素的有限序列。</p><p>若将线性表记为（a_1，…，a_(i−1)，a_i，a_(i+1)，…，a_n），则表中a_(i−1) 领先于a_i，a_i 领先于a_(i+1)，称a_(i−1) 是a_i 的直接前驱元素，a_(i+1) 是a_i 的直接后继元素。当i=1，2，…，n-1时，a_i 有且仅有一个直接后继，当i=2，3，…，n时，a_i 有且仅有一个直接前驱。<br>如图3-2-1所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.2.1.GIF?raw=true" alt="3-2-1"></p><p>所以线性表元素的个数n（n&gt;0）定义为线性表的长度，当n=0时，称为空表。<br>在较复杂的线性表中，一个数据元素可以由若干个数据项组成。</p><a id="more"></a><h2 id="3-3线性表的抽象数据类型"><a href="#3-3线性表的抽象数据类型" class="headerlink" title="3.3线性表的抽象数据类型"></a>3.3线性表的抽象数据类型</h2><p>线性表的抽象数据类型定义如下：</p><pre><code class="c">ADT线性表（List）Data    线性表的数据对象集合为{a1，a2…，an），每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。Operation    InitList（*L）；初始化操作，建立一个空的线性表L。    ListEmpty（L）；若线性表为空，返回true，否则返回false。    ClearList（*L）；将线性表清空。    GetElem（L，i，*e）；将线性表L中的第i个位置元素值返回给e。    LocateElem（L，e）；在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。    ListInsert（*L，i，e）；在线性表L中的第i个位置插入新元素e。    ListDelete（*L，i，*e）；删除线性表L中第i个位置元素，并用e返回其值。    ListLength（L）；返回线性表L的元素个数。endADT</code></pre><h3 id="3-3-1两个线性表集合的并集操作"><a href="#3-3-1两个线性表集合的并集操作" class="headerlink" title="3.3.1两个线性表集合的并集操作"></a>3.3.1两个线性表集合的并集操作</h3><p>要使得集合A=AUB。说白了，就是把存在集合B中但并不存在A中的数据元素插入到A中即可。<br>仔细分析一下这个操作，发现我们只要循环集合B中的每个元素，判断当前元素是否存在A中，若不存在，则插入到A中即可。思路应该是很容易想到的。<br>我们假设La表示集合A，Lb表示集合B，则实现的代码如下：</p><pre><code class="c">    /*将所有的在线性表Lb中但不在La中的数据元素插入到La中*/    void unionL(SqList *La, SqList Lb)    {        int La_len, Lb_len, i;        ElemType e;                          /*声明与La和Lb相同的数据元素e*/        La_len = ListLength(*La);                /*求线性表的长度*/        Lb_len = ListLength(Lb);        for (i = 1; i &lt;= Lb_len; i++)        {            GetElem(Lb, i, &amp;e);           /*取Lb中第i个数据元素赋给e*/            if (!LocateElem(*La, e))           /*La中不存在和e相同数据元素*/                ListInsert(La, ++La_len, e);          /*插入*/        }    }</code></pre><h2 id="3-4线性表的顺序存储结构"><a href="#3-4线性表的顺序存储结构" class="headerlink" title="3.4线性表的顺序存储结构"></a>3.4线性表的顺序存储结构</h2><h3 id="3-4-1顺序存储定义"><a href="#3-4-1顺序存储定义" class="headerlink" title="3.4.1顺序存储定义"></a>3.4.1顺序存储定义</h3><p>线性表的两种物理结构的第一种——顺序存储结构。<br>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p><h3 id="3-4-2顺序存储方式"><a href="#3-4-2顺序存储方式" class="headerlink" title="3.4.2顺序存储方式"></a>3.4.2顺序存储方式</h3><p>可以用C语言（其他语言也相同）的一维数组来实现顺序存储结构。<br>线性表的顺序存储的结构代码如下</p><pre><code class="c">    #define MAXSIZE 20/*存储空间初始分配量*/    typedef int Elemrype;  /*Elemrype 类型根据实际情况而定，这里假设为int*/    typedef struct    {        ElemType data[MAXSIZE];/*数组存储数据元素，最大值为MAXSIZE*/        int length;  /*线性表当前长度*/    }SqList;</code></pre><p>这里，我们就发现描述顺序存储结构需要三个属性：<br>    • 存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。<br>    • 线性表的最大存储容量：数组长度MaxSize。<br>    • 线性表的当前长度：length。</p><h3 id="3-4-3数据长度与线性表长度区别"><a href="#3-4-3数据长度与线性表长度区别" class="headerlink" title="3.4.3数据长度与线性表长度区别"></a>3.4.3数据长度与线性表长度区别</h3><p>数组的长度是存放线性表的存储空间的长度，存储分配后这个量是一般是不变的。<br>线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。<br>在任意时刻，线性表的长度应该小于等于数组的长度。</p><h3 id="3-4-4地址计算方法"><a href="#3-4-4地址计算方法" class="headerlink" title="3.4.4地址计算方法"></a>3.4.4地址计算方法</h3><p>存储器中的每个存储单元都有自己的编号，这个编号称为地址。<br>假设占用的是c个存储单元，那么线性表中第i+1个数据元素的存储位置和第i个数据元素的存储位置满足下列关系（LOC表示获得存储位置的函数）。<br>    LOC（a_(i+1)）=LOC（a_i）+c<br>所以对于第i个数据元素ai的存储位置可以由a1推算得出：<br>    LOC（a_i）=LOC（a_1）+（i-1）*c</p><h2 id="3-5顺序存储结构的插入与删除"><a href="#3-5顺序存储结构的插入与删除" class="headerlink" title="3.5顺序存储结构的插入与删除"></a>3.5顺序存储结构的插入与删除</h2><h3 id="3-5-1获得元素操作"><a href="#3-5-1获得元素操作" class="headerlink" title="3.5.1获得元素操作"></a>3.5.1获得元素操作</h3><p>我们要实现GetElem操作，即将线性表L中的第i个位置元素值返回。只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。</p><pre><code class="c">    #define OK 1    #define ERROR 0    #define TRUE 1    #define FALSE 0    typedef int Status;          /* Status是函数的类型,其值是函数结果状态代码，如OK等 */    /* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */    /* 操作结果：用e返回L中第i个数据元素的值,注意i是指位置，第1个位置的数组是从0开始 */    Status GetElem(SqList L, int i, ElemType *e)    {        if (L.length == 0 || i&lt;1 || i&gt;L.length)            return ERROR;        *e = L.data[i - 1];        return OK;    }</code></pre><h3 id="3-5-2插入操作"><a href="#3-5-2插入操作" class="headerlink" title="3.5.2插入操作"></a>3.5.2插入操作</h3><p>插入算法的思路：<br>    • 如果插入位置不合理，抛出异常；<br>    • 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；<br>    • 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；<br>    • 将要插入元素填入位置i处；<br>    • 表长加1。<br>实现代码如下：</p><pre><code class="c">    /* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */    /* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */    Status ListInsert(SqList *L, int i, ElemType e)    {        int k;        if (L-&gt;length == MAXSIZE)  /* 顺序线性表已经满 */            return ERROR;        if (i&lt;1 || i&gt;L-&gt;length + 1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */            return ERROR;        if (i &lt;= L-&gt;length)        /* 若插入数据位置不在表尾 */        {            for (k = L-&gt;length - 1; k &gt;= i - 1; k--)  /* 将要插入位置之后的数据元素向后移动一位 */                L-&gt;data[k + 1] = L-&gt;data[k];        }        L-&gt;data[i - 1] = e;          /* 将新元素插入 */        L-&gt;length++;        return OK;    }</code></pre><h3 id="3-5-3删除操作"><a href="#3-5-3删除操作" class="headerlink" title="3.5.3删除操作"></a>3.5.3删除操作</h3><p>删除算法的思路：<br>    • 如果删除位置不合理，抛出异常；<br>    • 取出删除元素；<br>    • 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；<br>    • 表长减1。<br>实现代码如下：</p><pre><code class="c">    /* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */    /* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */    Status ListDelete(SqList *L, int i, ElemType *e)    {        int k;        if (L-&gt;length == 0)               /* 线性表为空 */            return ERROR;        if (i&lt;1 || i&gt;L-&gt;length)         /* 删除位置不正确 */            return ERROR;        *e = L-&gt;data[i - 1];        if (i &lt; L-&gt;length)                /* 如果删除不是最后位置 */        {            for (k = i; k &lt; L-&gt;length; k++)/* 将删除位置后继元素前移 */                L-&gt;data[k - 1] = L-&gt;data[k];        }        L-&gt;length--;        return OK;    }</code></pre><p>线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O（1）；而插入或删除时，时间复杂度都是O（n）。</p><h3 id="3-5-4线性表顺序存储结构的优缺点"><a href="#3-5-4线性表顺序存储结构的优缺点" class="headerlink" title="3.5.4线性表顺序存储结构的优缺点"></a>3.5.4线性表顺序存储结构的优缺点</h3><p>线性表的顺序存储结构的优缺点如图3-5-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.5.3.GIF?raw=true" alt="3-5-3"></p><h3 id="3-6线性表的链式存储结构"><a href="#3-6线性表的链式存储结构" class="headerlink" title="3.6线性表的链式存储结构"></a>3.6线性表的链式存储结构</h3><h3 id="3-6-2线性表链式存储结构定义"><a href="#3-6-2线性表链式存储结构定义" class="headerlink" title="3.6.2线性表链式存储结构定义"></a>3.6.2线性表链式存储结构定义</h3><p>为了表示每个数据元素a_i 与其直接后继数据元素a_(i+1) 之间的逻辑关系，对数据元素a1来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素a_i 的存储映像，称为结点（Node）。<br>n个结点（a_i 的存储映像）链结成一个链表，即为线性表（a_1，a_2，…，a_n）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。<br>我们把链表中第一个结点的存储位置叫做头指针,线性链表的最后一个结点指针为“空”（通常用NULL或“^”符号表示）。<br>有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息。</p><h3 id="3-6-3头指针与头结点的异同"><a href="#3-6-3头指针与头结点的异同" class="headerlink" title="3.6.3头指针与头结点的异同"></a>3.6.3头指针与头结点的异同</h3><p><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.6.3.GIF?raw=true" alt="3-6-3"></p><h3 id="3-6-4线性表链式存储结构代码描述"><a href="#3-6-4线性表链式存储结构代码描述" class="headerlink" title="3.6.4线性表链式存储结构代码描述"></a>3.6.4线性表链式存储结构代码描述</h3><pre><code class="c">//线性表的单链表存储结构typedef struct Node{    ElemType data;    struct Node *next;}Node;typedef struct Node *LinkList;/* 定义LinkList */</code></pre><p>节点Node是由存放数据元素的数据域和存放后继节点地址的指针域组成。  </p><h2 id="3-7单链表的读取"><a href="#3-7单链表的读取" class="headerlink" title="3.7单链表的读取"></a>3.7单链表的读取</h2><p>获得链表第i个的数据的算法思路：  </p><ol><li>声明一个结点p指向链表第一个结点，初始化j从1开始;  </li><li>当<code>j&lt;i</code>时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1;  </li><li>若到链表末尾p为空，则说明第i个元素不存在;  </li><li>否则查找成功，返回结点p的数据。  </li></ol><p>实现代码算法如下：</p><pre><code class="c">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) *//* 操作结果：用e返回L中第i个数据元素的值 */Status GetElem(LinkList L,int i,ElemType *e){    int j;    LinkList p;  /* 声明一结点p */    p = L-&gt;next;  /* 让p指向链表L的第一个结点 */    j = 1;        /*  j为计数器 */    while (p &amp;&amp; j&lt;i)  /* p不为空或者计数器j还没有等于i时，循环继续 */    {        p = p-&gt;next;  /* 让p指向下一个结点 */        ++j;    }    if ( !p || j&gt;i )        return ERROR;  /*  第i个元素不存在 */    *e = p-&gt;data;   /*  取第i个元素的数据 */    return OK;}</code></pre><p>这个算法的最坏情况时间复杂度为O(n)。  </p><h2 id="3-8-单链表的插入和删除"><a href="#3-8-单链表的插入和删除" class="headerlink" title="3.8 单链表的插入和删除"></a>3.8 单链表的插入和删除</h2><h3 id="3-8-1-单链表的插入"><a href="#3-8-1-单链表的插入" class="headerlink" title="3.8.1 单链表的插入"></a>3.8.1 单链表的插入</h3><p><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.8.1.GIF?raw=true" alt="图3-8-1"><br>假设上一个结点是p，下一个结点是p-&gt;next,现在要把结点s插入这两个结点中去。只需要2行代码：<br><code>s-&gt;next=p-&gt;next;//先让s的指针域指向p-&gt;next</code><br><code>p-&gt;next=s;//把s的地址赋给p的指针域</code></p><p>ps:这两句顺序不能交换。<br>如果先<code>p-&gt;next=s</code>;再<code>s-&gt;next=p-&gt;next</code>;就等于<code>s-&gt;next=s</code>;<br>所以这2句如论如何都不能反，这点初学者一定要注意。  </p><p>单链表第i个数据插入结点的算法思路：</p><ol><li>声明一结点p指向链表第一个结点，初始化j从1开始;</li><li>当j&lt;1时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1;</li><li>若到链表末尾p为空，则说明第i个元素不存在;</li><li>否则查找成功，在系统中生成一个空结点s;</li><li>将数据元素e赋值给<code>s-&gt;data</code>;</li><li>单链表的插入标准语句<code>s-&gt;next=p-&gt;next;p-&gt;next=s;</code>;</li><li>返回成功;  </li></ol><p>实现代码算法如下:</p><pre><code class="c">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， *//* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */Status ListInsert(LinkList *L,int i,ElemType e){    int j;    LinkList p,s;    p = *L;    j = 1;    while (p &amp;&amp; j &lt; i)     /* 寻找第i个结点 */    {        p = p-&gt;next;        ++j;    }    if (!p || j &gt; i)        return ERROR;   /* 第i个元素不存在 */    s = (LinkList)malloc(sizeof(Node));  /*  生成新结点(C语言标准函数) */    s-&gt;data = e;      s-&gt;next = p-&gt;next;      /* 将p的后继结点赋值给s的后继  */    p-&gt;next = s;          /* 将s赋值给p的后继 */    return OK;}</code></pre><h3 id="3-8-2-单链表的删除"><a href="#3-8-2-单链表的删除" class="headerlink" title="3.8.2 单链表的删除"></a>3.8.2 单链表的删除</h3><p><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.8.5.GIF?raw=true" alt="3-8-5"><br>要删除节点q，其实就是要让<code>p-&gt;next=q-&gt;next</code>;<br>单链表第i个数据删除结点的算法思路：</p><ol><li>声明一结点p指向链表第一个结点，初始化j从1开始</li><li>当<code>j&lt;i</code>时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；</li><li>若到链表末尾p为空，则说明第i个元素不存在；</li><li>否则查找成功，将欲删除的结点<code>p-&gt;next</code>赋值给q；</li><li>单链表的删除标准语句<code>p-&gt;next=q-&gt;next</code>；</li><li>将q结点中的数据赋值给e，作为返回；</li><li>释放q结点；</li><li>返回成功。  </li></ol><p>实现代码算法如下：</p><pre><code class="c">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) *//* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */Status ListDelete(LinkList *L,int i,ElemType *e){    int j;    LinkList p,q;    p = *L;    j = 1;    while (p-&gt;next &amp;&amp; j &lt; i)    /* 遍历寻找第i个元素 */    {        p = p-&gt;next;        ++j;    }    if (!(p-&gt;next) || j &gt; i)        return ERROR;           /* 第i个元素不存在 */    q = p-&gt;next;              //q结点指向要删除的结点（即要删除的结点地址赋值给q）    p-&gt;next = q-&gt;next;            /* 将q的后继(第三个结点)赋值给p的后继 */    *e = q-&gt;data;               /* 将q结点中的数据给e */    free(q);                    /* 让系统回收此结点，释放内存 */    return OK;}</code></pre><p>分析一下刚才我们讲解的单链表插入和删除算法，我们很容易推导出：它们的时间复杂度都是O（n）。<br>显然，对于<strong>插入或删除数据越频繁的操作，单链表的效率优势就越是明显</strong>。</p><h2 id="3-9单链表的整表创建"><a href="#3-9单链表的整表创建" class="headerlink" title="3.9单链表的整表创建"></a>3.9单链表的整表创建</h2><p>单链表整表创建的算法思路：</p><ol><li>声明一结点p和计数器变量i；</li><li>初始化一空链表L；</li><li>让L的头结点的指针指向NULL，即建立一个带头结点的单链表；</li><li>循环：<ul><li>生成一新结点赋值给p；</li><li>随机生成一数字赋值给p的数据域p&gt;data；  </li><li>将p插入到头结点与前一新结点之间。  </li></ul></li></ol><p>实现头插法的代码算法如下(这段算法代码里,我们用插队的办法，始终让新结点在第一的位置。这种算法简称为头插法)：</p><pre><code class="c">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */void CreateListHead(LinkList *L, int n){    LinkList p;    int i;    srand(time(0));                         /* 初始化随机数种子 */    *L = (LinkList)malloc(sizeof(Node));    (*L)-&gt;next = NULL;                      /*  先建立一个带头结点的单链表 */    for (i=0; i&lt;n; i++)    {        p = (LinkList)malloc(sizeof(Node)); /*  生成新结点 */        p-&gt;data = rand()%100+1;             /*  随机生成100以内的数字 */        p-&gt;next = (*L)-&gt;next;        (*L)-&gt;next = p;                        /*  插入到表头 */    }}</code></pre><p>事实上，我们一般插队都是放在最后的。如果我们把每次的新结点都插在终端结点的后面，这种算法称之为尾插法。  </p><p>实现尾插法代码算法如下：</p><pre><code class="c">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */void CreateListTail(LinkList *L, int n){    LinkList p,r;    int i;    srand(time(0));                      /* 初始化随机数种子 */    *L = (LinkList)malloc(sizeof(Node)); /* L为整个线性表 */    r=*L;                                /* r为指向尾部的结点 */    for (i=0; i&lt;n; i++)    {        p = (Node *)malloc(sizeof(Node)); /*  生成新结点 */        p-&gt;data = rand()%100+1;           /*  随机生成100以内的数字 */        r-&gt;next=p;                        /* 将表尾终端结点的指针指向新结点 */        r = p;                            /* 将当前的新结点定义为表尾终端结点 */    }    r-&gt;next = NULL;                       /* 表示当前链表结束 */}</code></pre><p>PS：这里需解释一下，<code>r-&gt;next=p</code>的意思，其实就是将刚才的表尾终端结点r的指针指向新结点p，如图3-9-2所示，当中①位置的连线就是表示这个意思。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.9.2.GIF?raw=true" alt="3-9-2"><br><code>r=p</code>的意思请看图3-9-3，就是本来r是a_(i-1)元素的结点，现在它已经不是最后的结点了，现在最后的结点是a_i，所以应该将p结点这个最后的结点赋值给r。此时r又是最终的尾结点了。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.9.3.GIF?raw=true" alt="3-9-3">  </p><p>循环结束后，那么应该让这个链表的指针域置空，因此有了<code>r-&gt;next=NULL</code>，以便以后遍历时可以确认其是尾部。  </p><h2 id="3-10单链表的整表删除"><a href="#3-10单链表的整表删除" class="headerlink" title="3.10单链表的整表删除"></a>3.10单链表的整表删除</h2><p>单链表整表删除的算法思路如下：</p><ol><li>声明一结点p和q；</li><li>将第一个结点赋值给p；</li><li>循环：<ul><li>将下一结点赋值给q；</li><li>释放p；将q赋值给p。  </li></ul></li></ol><p>实现代码算法如下：  </p><pre><code class="c">/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */Status ClearList(LinkList *L){    LinkList p,q;    p=(*L)-&gt;next;           /*  p指向第一个结点 */    while(p)                /*  没到表尾 */    {        q=p-&gt;next;   //下一个结点地址赋值给临时结点q        free(p);     //释放p结点内存        p=q;         //临时结点q的地址赋值给p，使p能够指向继续指向下一个结点    }    (*L)-&gt;next=NULL;        /* 头结点指针域为空 */    return OK;}</code></pre><h2 id="3-11单链表结构与顺序存储结构优缺点"><a href="#3-11单链表结构与顺序存储结构优缺点" class="headerlink" title="3.11单链表结构与顺序存储结构优缺点"></a>3.11单链表结构与顺序存储结构优缺点</h2><p>简单地对单链表结构和顺序存储结构做对比,如图3-11-1：<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.11.1.GIF?raw=true" alt="3-11-1">  </p><p>通过上面的对比，我们可以得出一些经验性的结论：</p><ul><li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。</li><li>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。  </li></ul><p>总之，线性表的顺序存储结构和单链表结构各有其优缺点，不能简单的说哪个好，哪个不好，需要根据实际情况，来综合平衡采用哪种数据结构更能满足和达到需求和性能。  </p><h2 id="3-12静态链表"><a href="#3-12静态链表" class="headerlink" title="3.12静态链表"></a>3.12静态链表</h2><p>静态链表是由数组组成。<br>我们让数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下标都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而游标cur相当于单链表中的next 指针，存放该元素的后继在数组中的下标。<br>我们把这种用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。<br>静态链表的结构定义如下：  </p><pre><code class="c">/* 线性表的静态链表存储结构 */typedef struct{    ElemType data;    int cur;  /* 游标(Cursor) ，为0时表示无指向 */} Component,StaticLinkList[MAXSIZE];</code></pre><p>另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据。我们通常把未被使用的数组元素称为备用链表。而数组第一个元素，即<strong>下标为0的元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标</strong>，相当于单链表中的头结点作用，当整个链表为空时，则为0<sup>2</sup>。如图3-12-1所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.12.1.GIF?raw=true" alt="3-12-1">  </p><p>初始化数组状态，代码如下：  </p><pre><code class="c">/* 将一维数组space中各分量链成一个备用链表，space[0].cur为头指针，&quot;0&quot;表示空指针 */Status InitList(StaticLinkList space){    int i;    for (i=0; i&lt;MAXSIZE-1; i++)          space[i].cur = i+1;    space[MAXSIZE-1].cur = 0; /* 目前静态链表为空，最后一个元素的cur为0 */    return OK;}</code></pre><h3 id="3-12-1静态链表的插入操作"><a href="#3-12-1静态链表的插入操作" class="headerlink" title="3.12.1静态链表的插入操作"></a>3.12.1静态链表的插入操作</h3><p>在静态链表中，需要我们自己实现结点的申请和释放这2个函数，才可以做插入和删除的操作。<br>为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。  </p><pre><code class="c">/* 若备用空间链表非空，则返回分配的结点下标，否则返回0 */int Malloc_SSL(StaticLinkList space){    int i = space[0].cur;                   /* 当前数组第一个元素的cur存的值 */                                            /* 就是要返回的第一个备用空闲的下标 */    if (space[0]. cur)        space[0]. cur = space[i].cur;       /* 由于要拿出一个分量来使用了， */                                            /* 所以我们就得把它的下一个 */                                            /* 分量用来做备用 */    return i;}</code></pre><p>这段代码有意思，它的作用就是返回一个下标值，这个值就是数组头元素的cur存的第一个空闲的下标,同时把这个空闲的下标给<code>spcae[0].cur</code>，之后就可以继续分配新的空闲分量，实现类似mallbc（）函数的作用。<br>插入操作的实现代码如下：  </p><pre><code class="c">/*  在L中第i个元素之前插入新的数据元素e   */Status ListInsert(StaticLinkList L, int i, ElemType e){      int j, k, l;    k = MAXSIZE - 1;   /* 注意k首先是最后一个元素的下标 */    if (i &lt; 1 || i &gt; ListLength(L) + 1)        return ERROR;    j = Malloc_SSL(L);   /* 获得空闲分量的下标 */    if (j)    {        L[j].data = e;   /* 将数据赋值给此分量的data */        for(l = 1; l &lt;= i - 1; l++)   /* 找到第i个元素之前的位置 */           k = L[k].cur;        L[j].cur = L[k].cur;    /* 把第i个元素之前的cur赋值给新元素的cur */        L[k].cur = j;           /* 把新元素的下标赋值给第i个元素之前元素的ur */        return OK;    }    return ERROR;}</code></pre><h3 id="3-12-2静态链表的删除操作"><a href="#3-12-2静态链表的删除操作" class="headerlink" title="3.12.2静态链表的删除操作"></a>3.12.2静态链表的删除操作</h3><p>删除元素时，实现的代码如下：  </p><pre><code class="c">/*  删除在L中第i个数据元素   */Status ListDelete(StaticLinkList L, int i){    int j, k;    if (i &lt; 1 || i &gt; ListLength(L))        return ERROR;    k = MAXSIZE - 1;    for (j = 1; j &lt;= i - 1; j++)        k = L[k].cur;    j = L[k].cur;    L[k].cur = L[j].cur;    Free_SSL(L, j);    return OK;}</code></pre><p>释放结点的函数代码如下：  </p><pre><code class="c">/*  将下标为k的空闲结点回收到备用链表 */void Free_SSL(StaticLinkList space, int k){      space[k].cur = space[0].cur;    /* 把第一个元素的cur值赋给要删除的分量cur */    space[0].cur = k;               /* 把要删除的分量下标赋值给第一个元素的cur */}</code></pre><p>返回静态链表长度的代码实现如下：  </p><pre><code class="c">/* 初始条件：静态链表L已存在。操作结果：返回L中数据元素个数 */int ListLength(StaticLinkList L){    int j=0;    int i=L[MAXSIZE-1].cur;    while(i)    {        i=L[i].cur;        j++;    }    return j;}</code></pre><h3 id="3-12-3静态链表优缺点"><a href="#3-12-3静态链表优缺点" class="headerlink" title="3.12.3静态链表优缺点"></a>3.12.3静态链表优缺点</h3><p>总结一下静态链表的优缺点（见图3-12-5）：<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.12.5.GIF?raw=true" alt="3-12-5"><br>总的来说，静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。尽管大家不一定会用得上，但这样的思考方式是非常巧妙的，应该理解其思想，以备不时之需。  </p><h2 id="3-13循环链表"><a href="#3-13循环链表" class="headerlink" title="3.13循环链表"></a>3.13循环链表</h2><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。<br>其实循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断<code>p-&gt;next</code>是否为空，现在则是<code>p-&gt;next</code>不等于头结点，则循环未结束。<br>在单链表中，我们有了头结点时，我们可以用O（1）的时间访问第一个结点，但如果想要用O（1）的时间访问到最后一个结点，则需要改造一下这个循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表（如图3-13-5）。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.5.GIF?raw=true" alt="3-13-5"><br>从上图可以看出，终端结点用尾指针rear指示，则查找终端结点是O（1），而开始结点，其实就是<code>rear-&gt;next-&gt;next</code>，其时间复杂也为O（1）。<br>举个程序的例子，要将两个循环链表合并成一个表时，有了尾指针就非常简单了。比如下面的这两个循环链表，它们的尾指针分别是rearA和rearB，如图3-13-6所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.6.GIF?raw=true" alt="3-13-6"><br>要想把它们合并，只需要如下的操作即可，如图3-13-7所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.7.GIF?raw=true" alt="3-13-7"><br>具体代码如下：  </p><pre><code class="c">p=rearA-&gt;next;     /*保存A表的头结点，即①*/rearA-&gt;next=rearB-&gt;next-&gt;next;     /*将本是指向B表的第一个结点（不是头结点）赋值给reaA-&gt;next,即②*/rearB-&gt;next=p;/*将原A表的头结点赋值给rearB-&gt;next，即③**/free(p);/*释放p*/</code></pre><h2 id="3-14双向链表"><a href="#3-14双向链表" class="headerlink" title="3.14双向链表"></a>3.14双向链表</h2><p>双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。<br>所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。  </p><pre><code class="c">/*线性表的双向链表存储结构*/typedef struct DulNode{    ElemType data；    struct DuLNode *prior；/*直接前驱指针*/    struct DuLNode *next；/*直接后继指针*/}DulNode，*DuLinkList；</code></pre><p>既然单链表也可以有循环链表，那么双向链表当然也可以是循环表。<br>双向链表的循环带头结点的空链表如图3-14-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.3.GIF?raw=true" alt="3-14-3"><br>非空的循环的带头结点的双向链表如图3-14-4所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.4.GIF?raw=true" alt="3-14-4"><br>PS：双向链表在插入和删除时，需要更改两个指针变量。<br>插入操作时，其实并不复杂，不过<strong>顺序很重要，千万不能写反了</strong>。<br>我们现在假设存储元素e的结点为s，要实现将结点s插入到结点p和<code>p-&gt;next</code>之间需要下面几步，如图3-14-5所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.5.GIF?raw=true" alt="3-14-5">  </p><pre><code class="c">s-&gt;prior=p;/*把p赋值给s的前驱，如图中①*/s-&gt;next=p-&gt;next;/*把p-&gt;next赋值给s的后继，如图中②*/p-&gt;next-&gt;prior=s;/*把s赋值给p-&gt;next的前驱，如图中③*/p-&gt;next=s;/*把s赋值给p的后继，如图中④*/</code></pre><p>关键在于它们的顺序，由于第2步和第3步都用到了<code>p-&gt;next</code>。如果第4步先执行，则会使得<code>p-&gt;next</code>提前变成了s，使得插入的工作完不成。所以我们不妨把上面这张图在理解的基础上记忆，顺序是先搞定s的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。  </p><p>若要删除结点p，只需要下面两步骤，如图3-14-6所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.6.GIF?raw=true" alt="3-14-6">  </p><pre><code class="c">p-&gt;prior-&gt;next=p-&gt;next；/*把p-&gt;next赋值给p-&gt;prior的后继，如图中①*/p-&gt;next-&gt;prior=p-&gt;prior；/*把p-&gt;prior 赋值给p-&gt;next的前驱，如图中②*/free（p）；/*释放结点*/</code></pre><h2 id="3-15总结回顾"><a href="#3-15总结回顾" class="headerlink" title="3.15总结回顾"></a>3.15总结回顾</h2><p>这一章，主要讲的是线性表。<br>先谈了它的定义，线性表是零个或多个具有相同类型的数据元素的有限序列。然后谈了线性表的抽象数据类型，如它的一些基本操作。<br>之后我们就线性表的两大结构做了讲述，先讲的是比较容易的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。通常我们都是用数组来实现这一结构。<br>后来是我们的重点，由顺序存储结构的插入和删除操作不方便，引出了链式存储结构。它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。然后我们分别就链式存储结构的不同形式，如单链表、循环链表和双向链表做了讲解，另外我们还讲了若不使用指针如何处理链表结构的静态链表方法。<br>总的来说，线性表的这两种结构（如图3-15-1所示）是后面其他数据结构的基础，把它们学明白了，对后面的学习有着至关重要的作用。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.15.1.GIF?raw=true" alt="3-15-1">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性表：零个或多个数据元素的有限序列。&lt;/p&gt;
&lt;h2 id=&quot;3-1-3-2线性表的定义&quot;&gt;&lt;a href=&quot;#3-1-3-2线性表的定义&quot; class=&quot;headerlink&quot; title=&quot;3.1-3.2线性表的定义&quot;&gt;&lt;/a&gt;3.1-3.2线性表的定义&lt;/h2&gt;&lt;p&gt;线性表（List）：零个或多个数据元素的有限序列。&lt;/p&gt;
&lt;p&gt;若将线性表记为（a_1，…，a_(i−1)，a_i，a_(i+1)，…，a_n），则表中a_(i−1) 领先于a_i，a_i 领先于a_(i+1)，称a_(i−1) 是a_i 的直接前驱元素，a_(i+1) 是a_i 的直接后继元素。当i=1，2，…，n-1时，a_i 有且仅有一个直接后继，当i=2，3，…，n时，a_i 有且仅有一个直接前驱。&lt;br&gt;如图3-2-1所示。&lt;br&gt;&lt;img src=&quot;https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.2.1.GIF?raw=true&quot; alt=&quot;3-2-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;所以线性表元素的个数n（n&amp;gt;0）定义为线性表的长度，当n=0时，称为空表。&lt;br&gt;在较复杂的线性表中，一个数据元素可以由若干个数据项组成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="https://closer_laps.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线性表" scheme="https://closer_laps.gitee.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构第四章 栈与队列</title>
    <link href="https://closer_laps.gitee.io/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC4%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>https://closer_laps.gitee.io/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC4%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2019-11-27T16:00:00.000Z</published>
    <updated>2019-12-25T11:09:18.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-1-4-2-栈的定义"><a href="#4-1-4-2-栈的定义" class="headerlink" title="4.1-4.2 栈的定义"></a>4.1-4.2 栈的定义</h2><h3 id="4-2-1-栈的定义"><a href="#4-2-1-栈的定义" class="headerlink" title="4.2.1 栈的定义"></a>4.2.1 栈的定义</h3><p><strong>栈是限定仅在表尾进行插入和删除操作的线性表。</strong><br>我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简尔LIFO结构。<br>它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。<br>栈的插入操作，叫作进栈，也称压栈、入栈(push)。<br>栈的删除操作，叫作出栈，也有的叫作弹栈(pop)。  </p><h2 id="4-3-栈的抽象数据类型"><a href="#4-3-栈的抽象数据类型" class="headerlink" title="4.3 栈的抽象数据类型"></a>4.3 栈的抽象数据类型</h2><a id="more"></a><pre><code class="c">ADT 栈(stack)Data    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。Operation    InitStack(*s)：初始化操作，建立一个空栈s。    Destroystack(*s)：若楼存在，则销毁它。    Clearstack(*s)：将栽清空。    StackEmpty(S)：若为空，返回true，否则返回false。    GetTop(s，*e)：若栽存在且非空，用e返回s的栽顶元素。    Push(*s，e)：若栈S存在，插入新元素e到栈S中并成为栈顶元素。    Pop(*S，*e)：删除栈S中栈顶元素，并用e返回其值。    StackLength(s)：返回栈s的元素个数。endADT</code></pre><h2 id="4-4-栈的顺序存储结构及实现"><a href="#4-4-栈的顺序存储结构及实现" class="headerlink" title="4.4 栈的顺序存储结构及实现"></a>4.4 栈的顺序存储结构及实现</h2><h3 id="4-4-1-栈的顺序存储结构"><a href="#4-4-1-栈的顺序存储结构" class="headerlink" title="4.4.1 栈的顺序存储结构"></a>4.4.1 栈的顺序存储结构</h3><p>栈是线性表的特例，那么栈的顺序存储其实也是线性表顺序存储的简化，我们简称为顺序栈。线性表是用数组来实现的。<br>我们定义一个top变量来指示栈顶元素在数组中的位置，它可以来回移动，意味着栈顶的top可以变大变小，但无论如何游标不能超出栈的长度。同理，若存储栈的长度为StackSize，则栈顶位置top必须小于Stacksize。当栈存在一个元素时，top等于0，因此通常把空栈的判定条件定为top等于-1。</p><p>栈的结构定义：  </p><pre><code class="c">typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int *//* 顺序栈结构 */typedef struct{        SElemType data[MAXSIZE];        int top; /* 用于栈顶指针 */}SqStack;</code></pre><p>若现在有一个栈，Stacksize是5，则栈普通情况、空栈和栈满的情况示意图如图4-4-2所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-4-2.JPG?raw=true" alt="4-4-2">  </p><h3 id="4-4-2-栈的顺序存储结构——进栈操作"><a href="#4-4-2-栈的顺序存储结构——进栈操作" class="headerlink" title="4.4.2 栈的顺序存储结构——进栈操作"></a>4.4.2 栈的顺序存储结构——进栈操作</h3><p>对于栈的插入，即进栈操作，其实就是在栈顶插入一个元素。<br>进栈操作push，其代码如下：  </p><pre><code class="c">/* 插入元素e为新的栈顶元素 */Status Push(SqStack *S,SElemType e){        if(S-&gt;top == MAXSIZE -1) /* 栈满 */        {            return ERROR;        }        S-&gt;top++;   /* 栈顶指针增加一 */        S-&gt;data[S-&gt;top]=e;  /* 将新插入元素赋值给栈顶空间 */        return OK;}</code></pre><h3 id="4-4-3-栈的顺序存储结构——出栈操作"><a href="#4-4-3-栈的顺序存储结构——出栈操作" class="headerlink" title="4.4.3 栈的顺序存储结构——出栈操作"></a>4.4.3 栈的顺序存储结构——出栈操作</h3><p>出栈操作pop，代码如下：  </p><pre><code class="c">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */Status Pop(SqStack *S,SElemType *e){        if(S-&gt;top==-1)                return ERROR;        *e=S-&gt;data[S-&gt;top]; /* 将要删除的栈顶元素赋值给e */        S-&gt;top--;   /* 栈顶指针减一 */        return OK;}</code></pre><p>两者没有涉及到任何循环语句，因此时间复杂度均是O(1)。  </p><h2 id="4-5-两栈共享空间"><a href="#4-5-两栈共享空间" class="headerlink" title="4.5 两栈共享空间"></a>4.5 两栈共享空间</h2><p>如果我们有两个相同类型的栈，我们为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。这又何必呢？我们完全可以用一个数组来存储两个栈，只不过需要点小技巧。<br>数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为栈的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。<br>其实关键思路是：它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。<br>从这里也就可以分析出来，栈1为空时，就是top1等于-1时；而当top2等于n时，即是栈2为空时，那什么时候栈满呢？<br>想想极端的情况，若栈2是空栈，栈1的top1等于n-1时，就是栈1满了。反之，当栈1为空栈时，top2等于0时，为栈2满。但更多的情况，其实就是我刚才说的，两个栈见面之时，也就是两个指针之间相差1时，即top1+1==top2为栈满。<br>两栈共享空间的结构的代码如下：</p><pre><code class="c">/* 两栈共享空间结构 */typedef struct{    SElemType data[MAXSIZE];    int top1;    /* 栈1栈顶指针 */    int top2;    /* 栈2栈顶指针 */}SqDoubleStack;</code></pre><p>对于两栈共享空间的push方法，我们除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber。插入元素的代码如下：</p><pre><code class="c">/* 插入元素e为新的栈顶元素 */Status Push(SqDoubleStack *S, SElemType e, int stackNumber){    if (S-&gt;top1 + 1 == S-&gt;top2)    /* 栈已满，不能再push新元素了 */        return ERROR;    if (stackNumber == 1)            /* 栈1有元素进栈 */        S-&gt;data[++S-&gt;top1] = e; /* 若是栈1则先top1+1后给数组元素赋值。 */    else if (stackNumber == 2)    /* 栈2有元素进栈 */        S-&gt;data[--S-&gt;top2] = e; /* 若是栈2则先top2-1后给数组元素赋值。 */    return OK;}</code></pre><p>因为在开始已经判断了是否有栈满的情况，所以后面的top1+1或top2-1是不担心溢出问题的。<br>对于两栈共享空间的pop方法，参数就只是判断栈1栈2的参数stackNumber，代码如下：</p><pre><code class="c">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */Status Pop(SqDoubleStack *S, SElemType *e, int stackNumber){    if (stackNumber == 1)    {        if (S-&gt;top1 == -1)            return ERROR; /* 说明栈1已经是空栈，溢出 */        *e = S-&gt;data[S-&gt;top1--]; /* 将栈1的栈顶元素出栈 */    }    else if (stackNumber == 2)    {        if (S-&gt;top2 == MAXSIZE)            return ERROR; /* 说明栈2已经是空栈，溢出 */        *e = S-&gt;data[S-&gt;top2++]; /* 将栈2的栈顶元素出栈 */    }    return OK;}</code></pre><p>事实上，使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。就像买卖股票一样，你买入时，一定是有一个你不知道的人在做卖出操作。有人赚钱，就一定是有人赔钱。这样使用两栈共享空间存储方法才有比较大的意义。否则两个栈都在不停地增长，那很快就会因栈满而溢出了。  </p><h2 id="4-6-栈的链式存储结构及实现"><a href="#4-6-栈的链式存储结构及实现" class="headerlink" title="4.6 栈的链式存储结构及实现"></a>4.6 栈的链式存储结构及实现</h2><h3 id="4-6-1-栈的链式存储结构"><a href="#4-6-1-栈的链式存储结构" class="headerlink" title="4.6.1 栈的链式存储结构"></a>4.6.1 栈的链式存储结构</h3><p>栈的链式存储结构，简称为链栈。<br>链栈的结构代码如下：  </p><pre><code class="c">/* 链栈结构 */typedef struct StackNode{    SElemType data;    struct StackNode *next;}StackNode,*LinkStackPtr;typedef struct LinkStack{    LinkStackPtr top;    int count;}LinkStack;</code></pre><h3 id="4-6-2-栈的链式存储结构-进栈操作"><a href="#4-6-2-栈的链式存储结构-进栈操作" class="headerlink" title="4.6.2 栈的链式存储结构-进栈操作"></a>4.6.2 栈的链式存储结构-进栈操作</h3><p>对于链栈的进栈push操作，假设元素值为e的新结点是s，top为栈顶指针，示意图如图4-6-2所示代码如下。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-6-2.JPG?raw=true" alt="4-6-2">  </p><pre><code class="c">/* 插入元素e为新的栈顶元素 */Status Push(LinkStack *S,SElemType e){    LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode));     s-&gt;data=e;    s-&gt;next=S-&gt;top;/* 把当前的栈顶元素赋值给新结点的直接后继，见图中① */    S-&gt;top=s;         /* 将新的结点s赋值给栈顶指针，见图中② */    S-&gt;count++;    return OK;}</code></pre><h3 id="4-6-3-栈的链式存储结构——出栈操作"><a href="#4-6-3-栈的链式存储结构——出栈操作" class="headerlink" title="4.6.3 栈的链式存储结构——出栈操作"></a>4.6.3 栈的链式存储结构——出栈操作</h3><p>至于链栈的出栈pop操作，也是很简单的三句操作。假设变量p用来存储要删除的栈顶结点，将栈顶指针下移一位，最后释放p即可，如图4-6-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-6-3.JPG?raw=true" alt="4-6-3">  </p><pre><code class="c">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */Status Pop(LinkStack *S,SElemType *e){        LinkStackPtr p;        if(StackEmpty(*S))                return ERROR;        *e=S-&gt;top-&gt;data;        p=S-&gt;top;               /* 将栈顶结点赋值给p，见图中③ */        S-&gt;top=S-&gt;top-&gt;next;    /* 使得栈顶指针下移一位，指向后一结点，见图中④ */        free(p);                    /* 释放结点p */        S-&gt;count--;        return OK;}</code></pre><p>链栈的进栈push和出栈pop操作都很简单，时间复杂度均是O(1)。<br>对比一下顺序栈与链栈，它们在时间复杂度上是一样的，均为O(1)。对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以它们的区别是如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。  </p><h2 id="4-7-栈的作用"><a href="#4-7-栈的作用" class="headerlink" title="4.7 栈的作用"></a>4.7 栈的作用</h2><p>栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。  </p><h2 id="4-8-栈的应用——递归"><a href="#4-8-栈的应用——递归" class="headerlink" title="4.8 栈的应用——递归"></a>4.8 栈的应用——递归</h2><h3 id="4-8-1-4-8-2递归定义"><a href="#4-8-1-4-8-2递归定义" class="headerlink" title="4.8.1-4.8.2递归定义"></a>4.8.1-4.8.2递归定义</h3><p>我们<strong>把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数</strong>。<br>当然，写递归程序最怕的就是陷入永不结束的无穷递归中，所以，<strong>每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出</strong>。  </p><h2 id="4-9-栈的应用——四则运算表达式求值"><a href="#4-9-栈的应用——四则运算表达式求值" class="headerlink" title="4.9 栈的应用——四则运算表达式求值"></a>4.9 栈的应用——四则运算表达式求值</h2><h3 id="4-9-1-后缀-逆波兰-表示法定义"><a href="#4-9-1-后缀-逆波兰-表示法定义" class="headerlink" title="4.9.1 后缀(逆波兰)表示法定义"></a>4.9.1 后缀(逆波兰)表示法定义</h3><p>栈的现实应用也很多，我们再来重点讲一个比较常见的应用：数学表达式的求值。<br>一种不需要括号的后缀表达法，我们也把它称为逆波兰(Reverse Polish Notation，RPN)表示。<br>我们先来看看，对于“<code>9+(3-1)×3+10÷2</code>”，如果要用后缀表示法应该是：“<code>9 3 1-3*+10 2/+</code>”，这样的表达式称为后缀表达式，叫后缀的原因在于<strong>所有的符号都是在要运算数字的后面出现</strong>。  </p><h3 id="4-9-2-后缀表达式计算结果"><a href="#4-9-2-后缀表达式计算结果" class="headerlink" title="4.9.2 后缀表达式计算结果"></a>4.9.2 后缀表达式计算结果</h3><p>后缀表达式：<code>9 3 1-3*+10 2/+</code><br>规则：<strong>从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</strong>  </p><h3 id="4-9-3-中缀表达式转后缀表达式"><a href="#4-9-3-中缀表达式转后缀表达式" class="headerlink" title="4.9.3 中缀表达式转后缀表达式"></a>4.9.3 中缀表达式转后缀表达式</h3><p>我们把平时所用的标准四则运算表达式，即“<code>9+(3-1)×3+10÷2</code>”叫做中缀表达式。因为所有的运算符号都在两数字的中间。<br>中缀表达式“<code>9+(3-1)×3+10÷2</code>”转化为后缀表达式“<code>9 3 1-3*+10 2/+</code>”。<br>规则：<strong>从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号(乘除优先加减)则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</strong>  </p><h2 id="4-10-队列的定义"><a href="#4-10-队列的定义" class="headerlink" title="4.10 队列的定义"></a>4.10 队列的定义</h2><p>队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。  </p><h2 id="4-11-队列的抽象数据类型"><a href="#4-11-队列的抽象数据类型" class="headerlink" title="4.11 队列的抽象数据类型"></a>4.11 队列的抽象数据类型</h2><pre><code class="c">ADT 队列(Queue)Data    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。Operation    InitQueue(*Q)：初始化操作，建立一个空队列Q。    DestroyQueue(*Q)：若队列Q存在，则销毁它。    ClearQueue(*Q)：将队列Q清空。    QueueEmpty(Q)：若队列Q为空，返回true，否则返回false。    GetHead(Q，*e)：若队列Q存在且非空，用e返回队列Q的队头元素。    EnQueue(*Q，e)：若队列Q存在，插入新元素e到队列Q中并成为队尾元素。    DeQueue(*Q，*e)：删除队列Q中队头元素，并用e返回其值。    QueueLength(Q)：返回队列Q的元素个数endADT</code></pre><h2 id="4-12-循环队列"><a href="#4-12-循环队列" class="headerlink" title="4.12 循环队列"></a>4.12 循环队列</h2><h3 id="4-12-1-队列顺序存储的不足"><a href="#4-12-1-队列顺序存储的不足" class="headerlink" title="4.12.1 队列顺序存储的不足"></a>4.12.1 队列顺序存储的不足</h3><p>入队的时间复杂度为O(1)。<br>与栈不同的是，队列元素的出列是在队头，即下标为0的位置，那也就意味着，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为0的位置不为空，此时时间复杂度为出队的时间复杂度为O(n)，效率太低。<br>如果队列前面的位置空的，后面的位置排满了，那么新进的元素可以排到前面，这就引进了循环队列的概念。<br>为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列是空队列。  </p><h3 id="4-12-2-循环队列定义"><a href="#4-12-2-循环队列定义" class="headerlink" title="4.12.2 循环队列定义"></a>4.12.2 循环队列定义</h3><p>队列中头尾相接的顺序存储结构称为循环队列。<br>此时问题又出来了，空队列时，front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？</p><ol><li>办法一是设置一个标志变量flag，当<code>front==rear</code>，且flag=0时为队列空，当<code>front==rear</code>，且flag=1时为队列满。</li><li>办法二是当队列空时，条件就是<code>front=rear</code>，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。<br>我们重点来讨论第二种方法，由于rear可能比front大，也可能比front小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的最大尺寸为QueueSize，那么队列满的条件是“<code>(rear+1)%QueueSize==front</code>”(取模“%”的目的就是为了整合rear与front大小为一个问题)。<br>通用的计算队列长度公式为：<code>(rear-front+QueueSize)%QueueSize</code>。<br>循环队列的顺序存储结构代码如下：</li></ol><pre><code class="c">typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int *//* 循环队列的顺序存储结构 */typedef struct{    QElemType data[MAXSIZE];    int front;      /* 头指针 */    int rear;       /* 尾指针，若队列不空，指向队列尾元素的下一个位置 */}SqQueue;</code></pre><p>循环队列的初始化代码如下：</p><pre><code class="c">/* 初始化一个空队列Q */Status InitQueue(SqQueue *Q){    Q-&gt;front = 0;    Q-&gt;rear = 0;    return  OK;}</code></pre><p>循环队列求队列长度代码如下：</p><pre><code class="c">/* 返回Q的元素个数，也就是队列的当前长度 */int QueueLength(SqQueue Q){    return  (Q.rear - Q.front + MAXSIZE) % MAXSIZE;}</code></pre><p>循环队列的入队列操作代码如下：</p><pre><code class="c">/* 若队列未满，则插入元素e为Q新的队尾元素 */Status EnQueue(SqQueue *Q, QElemType e){    if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front)    /* 队列满的判断 */        return ERROR;    Q-&gt;data[Q-&gt;rear] = e;               /* 将元素e赋值给队尾 */    Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE;/* rear指针向后移一位置， */                                      /* 若到最后则转到数组头部 */    return  OK;}</code></pre><p>循环队列的出队列操作代码如下：</p><pre><code class="c">/* 若队列不空，则删除Q中队头元素，用e返回其值 */Status DeQueue(SqQueue *Q, QElemType *e){    if (Q-&gt;front == Q-&gt;rear)            /* 队列空的判断 */        return ERROR;    *e = Q-&gt;data[Q-&gt;front];                /* 将队头元素赋值给e */    Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;    /* front指针向后移一位置 */                                    /* 若到最后则转到数组头部 */    return  OK;}</code></pre><h2 id="4-13-队列的链式存储结构及实现"><a href="#4-13-队列的链式存储结构及实现" class="headerlink" title="4.13 队列的链式存储结构及实现"></a>4.13 队列的链式存储结构及实现</h2><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。<br>为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点，如图4-13-1所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-1.JPG?raw=true" alt="4-13-1"><br>空队列时，front和rear都指向头结点，如图4-13-2所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-2.JPG?raw=true" alt="4-13-2"><br>链队列的结构为：  </p><pre><code class="c">typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */typedef struct QNode    /* 结点结构 */{    QElemType data;    struct QNode *next;}QNode, *QueuePtr;typedef struct            /* 队列的链表结构 */{    QueuePtr front, rear; /* 队头、队尾指针 */}LinkQueue;</code></pre><h3 id="4-13-1-队列的链式存储结构——入队操作"><a href="#4-13-1-队列的链式存储结构——入队操作" class="headerlink" title="4.13.1 队列的链式存储结构——入队操作"></a>4.13.1 队列的链式存储结构——入队操作</h3><p>入队操作时，其实就是在链表尾部插入结点，如图4-13-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-3.JPG?raw=true" alt="4-13-3"><br>入队代码如下：</p><pre><code class="c">/* 插入元素e为Q的新的队尾元素 */Status EnQueue(LinkQueue *Q, QElemType e){    QueuePtr s = (QueuePtr)malloc(sizeof(QNode));    if (!s) /* 存储分配失败 */        exit(OVERFLOW);    s-&gt;data = e;    s-&gt;next = NULL;    Q-&gt;rear-&gt;next = s;    /* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */    Q-&gt;rear = s;        /* 把当前的s设置为队尾结点，rear指向s，见图中② */    return OK;}</code></pre><h3 id="4-13-2-队列的链式存储结构——出队操作"><a href="#4-13-2-队列的链式存储结构——出队操作" class="headerlink" title="4.13.2 队列的链式存储结构——出队操作"></a>4.13.2 队列的链式存储结构——出队操作</h3><p>出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将rear指向头结点，如图4-13-4所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-4.JPG?raw=true" alt="4-13-4">  </p><p>出队代码如下：</p><pre><code class="c">/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */Status DeQueue(LinkQueue *Q, QElemType *e){    QueuePtr p;    if (Q-&gt;front == Q-&gt;rear)        return ERROR;    p = Q-&gt;front-&gt;next;        /* 将欲删除的队头结点暂存给p，见图中① */    *e = p-&gt;data;                /* 将欲删除的队头结点的值赋值给e */    Q-&gt;front-&gt;next = p-&gt;next;/* 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中② */    if (Q-&gt;rear == p)/* 空队列的时候 */ /* 若队头就是队尾，则删除后将rear指向头结点，见图中③ */        Q-&gt;rear = Q-&gt;front;    free(p);    return OK;}</code></pre><p>对于循环队列与链队列的比较，可以从两方面来考虑，从时间上，其实它们的基本操作都是常数时间，即都为O(1)的，不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。对于空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。<br>总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。  </p><h2 id="4-14-总结回顾"><a href="#4-14-总结回顾" class="headerlink" title="4.14 总结回顾"></a>4.14 总结回顾</h2><p>这一章讲的是栈和队列，它们都是特殊的线性表，只不过对插入和删除操作做了限制。<br>栈(stack)是限定仅在表尾进行插入和删除操作的线性表。<br>队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。因此它们各自有各自的技巧来解决这个问题。<br>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。<br>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。<br>它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同如图4-14-1所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-14-1.JPG?raw=true" alt="4-14-1">  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;4-1-4-2-栈的定义&quot;&gt;&lt;a href=&quot;#4-1-4-2-栈的定义&quot; class=&quot;headerlink&quot; title=&quot;4.1-4.2 栈的定义&quot;&gt;&lt;/a&gt;4.1-4.2 栈的定义&lt;/h2&gt;&lt;h3 id=&quot;4-2-1-栈的定义&quot;&gt;&lt;a href=&quot;#4-2-1-栈的定义&quot; class=&quot;headerlink&quot; title=&quot;4.2.1 栈的定义&quot;&gt;&lt;/a&gt;4.2.1 栈的定义&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;栈是限定仅在表尾进行插入和删除操作的线性表。&lt;/strong&gt;&lt;br&gt;我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简尔LIFO结构。&lt;br&gt;它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。&lt;br&gt;栈的插入操作，叫作进栈，也称压栈、入栈(push)。&lt;br&gt;栈的删除操作，叫作出栈，也有的叫作弹栈(pop)。  &lt;/p&gt;
&lt;h2 id=&quot;4-3-栈的抽象数据类型&quot;&gt;&lt;a href=&quot;#4-3-栈的抽象数据类型&quot; class=&quot;headerlink&quot; title=&quot;4.3 栈的抽象数据类型&quot;&gt;&lt;/a&gt;4.3 栈的抽象数据类型&lt;/h2&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="https://closer_laps.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈和队列" scheme="https://closer_laps.gitee.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
