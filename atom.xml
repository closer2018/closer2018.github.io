<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>closer的自留地</title>
  
  <subtitle>just do it!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://closer_laps.gitee.io/"/>
  <updated>2019-12-10T01:35:31.052Z</updated>
  <id>https://closer_laps.gitee.io/</id>
  
  <author>
    <name>closer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo 多客户端上更新博客</title>
    <link href="https://closer_laps.gitee.io/2019/12/09/hexo/hexo%20%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/"/>
    <id>https://closer_laps.gitee.io/2019/12/09/hexo/hexo%20%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-12-09T10:08:25.000Z</published>
    <updated>2019-12-10T01:35:31.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>静态网页文件存放在<code>master主分支</code>，个人文件存放在<code>hexo分支</code>。  </p><h2 id="一、本地电脑设置"><a href="#一、本地电脑设置" class="headerlink" title="一、本地电脑设置"></a>一、本地电脑设置</h2><p>先新建一个hexo文件夹，在git bash下cd进入hexo文件夹。</p><ol><li><code>git init</code></li><li><code>git checkout -b hexo</code> //新建hexo分支并切换到hexo</li><li>将原来博客文件夹里面的<code>_config.yml</code>，<code>theme/</code>，<code>source/</code>，<code>scaffolds/</code>，<code>package.json</code>，<code>.gitignore</code>，共6个文件/文件夹 拷贝到hexo文件夹下面。<br>需要拷贝的文件如下:  </li></ol><ul><li>_config.yml（站点配置）；</li><li>theme文件夹里面的主题；</li><li>source文件夹；</li><li>scaffolds文件夹（文章的模板）；</li><li>package.json（说明使用哪些包）；</li><li>.gitignore（限定在提交的时候哪些文件可以忽略）；  </li><li><strong>注意：不要<code>hexo init</code>去整体初始化，因为需要的文件我们已经拷贝过来了。</strong>  </li></ul><ol start="4"><li>将theme文件夹里面的你的主题文件夹下的.git文件夹删除。</li><li><code>git add scaffolds/ source/ themes .gitignore _config.yml package.json</code><br><code>git commit -m &quot;init&quot;</code>  </li><li><code>git remote add origin git@github.com:你的ID/你的仓库名字</code>  //添加本地hexo和远程仓库的关联  </li><li>登录github，将分支仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为hexo，Update保存。 </li><li><code>git push origin hexo</code>  //上传更新</li></ol><h2 id="二、另外一台电脑上配置"><a href="#二、另外一台电脑上配置" class="headerlink" title="二、另外一台电脑上配置"></a>二、另外一台电脑上配置</h2><ol><li>官网下载安装：  </li></ol><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">安装 Node.js；</a></li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">安装 Git。</a></li></ul><ol start="2"><li>新建hexo目录，cd进入。</li><li><code>git clone https://github.com/你的ID/你的ID.github.io.git</code>  //克隆到本地</li><li>将新电脑生成的ssh key添加到gitHub账户上。<br>需要配置 git。</li></ol><ul><li><code>git config --global user.email &quot;xxx@qq.com&quot;</code> 引号内的<a href="mailto:xxx@qq.com">xxx@qq.com</a>改为你github注册并且验证的邮箱；</li><li><code>git config --global user.name &quot;xxxx&quot;</code>   引号内的xxxx改为你的 github 用户名；</li><li><code>ssh-keygen</code> 会出现下面的内容，一直按Enter键就行；</li><li>打开用户目录下的 <code>.ssh</code>目录下面生成 <code>id_rsa(私钥)id_rsa.pub(公钥)</code>两个文件，打开<code>id_rsa.pub</code>，复制里面的内容,到 github: <code>Settings -&gt; SSH and GPG keys -&gt; SSH keys -&gt; New SSH key -&gt; (填写)Title -&gt; (粘贴)Key -&gt; Add SSH Key</code>；</li><li>测试 <code>ssh -T git@github.com</code>，输出 <strong>You’ve successfully authenticated</strong> 表示添加key 成功。</li></ul><ol start="5"><li><code>npm install hexo-cli -g</code> //安装hexo</li><li><code>npm install</code> //安装依赖包  </li></ol><ul><li>如果出现报错<code>ERROR Try runing: &#39;npm install hexo --save</code>则执行命令<code>npm install hexo --save</code>，如果没有，则忽略。</li></ul><h2 id="三、发布博客"><a href="#三、发布博客" class="headerlink" title="三、发布博客"></a>三、发布博客</h2><ol><li>cd进入博客目录</li><li><code>git pull origin hexo</code> //保证和分支同步</li><li><code>hexo n &quot;新建博客&quot;</code></li><li><code>git add source/</code>      //因为博客文件是在source文件夹下面的</li><li><code>git commit -m &quot;博客更新&quot;</code></li><li><code>git push origin hexo</code>//长传更新</li><li><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>//部署博客</li></ol><p>至此，多终端发布博客已经配置完成。</p><h2 id="四、更新主题"><a href="#四、更新主题" class="headerlink" title="四、更新主题"></a>四、更新主题</h2><p>配置好主题文件后，执行：<br><code>git add scaffolds/ source/ themes .gitignore _config.yml package.json</code><br><code>git commit -m &quot;更新主题&quot;</code><br><code>git push origin hexo</code>  //上传更新</p><h2 id="五、快速上传部署命令"><a href="#五、快速上传部署命令" class="headerlink" title="五、快速上传部署命令"></a>五、快速上传部署命令</h2><p>只更新博客内容，可以从上述第 三 大步第 4 步后可以这样子发布：<br><code>git add source/ &amp;&amp; git commit -m &quot;博客更新&quot; &amp;&amp; git push origin hexo &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; exit</code><br>把所有命令用<code>&amp;&amp;</code>串起来，有一个失败就会停止；成功，最后一条命令就会退出终端。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;静态网页文件存放在&lt;code&gt;master主分支&lt;/code&gt;，个人文件存放在&lt;code&gt;hexo分支&lt;/code&gt;。  &lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/tags/hexo/"/>
    
      <category term="多客户端" scheme="https://closer_laps.gitee.io/tags/%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>hexo配置文件设置</title>
    <link href="https://closer_laps.gitee.io/2019/12/09/hexo/hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE/"/>
    <id>https://closer_laps.gitee.io/2019/12/09/hexo/hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE/</id>
    <published>2019-12-08T16:15:17.000Z</published>
    <updated>2019-12-09T04:04:06.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo配置文件设置"><a href="#hexo配置文件设置" class="headerlink" title="hexo配置文件设置"></a>hexo配置文件设置</h2><p>hexo配置文件<code>_config.yml</code>基本配置</p><pre><code class="yml"># Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 网站title: closer的个人博客subtitle: welcome!description: 非专业初学者码农一枚keywords:author: closerlanguage: zh-Hans #语言timezone: &#39;&#39;# URL 网址## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: https://closer_laps.gitee.io/root: / #根目录位置，如果只是github pages的子目录需要更改permalink: :year/:month/:day/:title/permalink_defaults:# Directory #文件结构 默认即可source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: langskip_render:# Writing #编辑博文的选项new_post_name: :title.md # File name of new postsdefault_layout: postauto_spacing: falsetitlecase: false # 把标题转换为 title case external_link:  enable: true # Open external links in new tab  field: site # Apply to the whole site  exclude: &#39;&#39;filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写 render_drafts: false #显示草稿 post_asset_folder: false #启动 Asset 文件夹 relative_link: false #把链接改为与根目录的相对位址 future: true #显示未来的文章 highlight:  #代码块的设置  enable: false  #开启代码块高亮  auto_detect: false #如果未指定语言，则启用自动检测  line_number: true #显示行数  tab_replace: &#39;&#39; #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs # Home page setting# path: Root path for your blogs index page. (default = &#39;&#39;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator:  path: &#39;&#39;  per_page: 10  order_by: -date# Category &amp; Tag #分类 &amp; 标签default_category: uncategorizedcategory_map:tag_map:# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# Date / Time format #日期显示格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD #日期格式 time_format: HH:mm:ss #时间格式## Use post&#39;s date for updated date unless set in front-matteruse_date_for_updated: false# Pagination #分页器## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能) 10pagination_dir: page #分页目录 # Include / Exclude file(s)## include:/exclude: options only apply to the &#39;source/&#39; folderinclude:exclude:ignore:# Extensions #拓展## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: next #主题更换# Deployment #部署参数## Docs: http://hexo.io/docs/deployment.htmldeploy:  type: git  repo: https://github.com/closer2018/closer2018.github.io.git  #repo: https://gitee.com/closer_laps/closer_laps.git  branch: master# 搜索设置search:  path: search.xml  field: post  format: html  limit: 10000</code></pre><p>以上就是配置文件的基础设置。</p><h2 id="更换主题NexT"><a href="#更换主题NexT" class="headerlink" title="更换主题NexT"></a>更换主题NexT</h2><p>Hexo安装主题的方式非常简单，只需要将主题文件放置于站点目录的themes下，然后修改下配置文件即可。这里我以NexT主题为例。<br>在git bash操作下cd至博客根目录，执行如下代码：  </p><p><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p><p>等待下载完成后，修改根目录下_config.yml文件的theme字段为next即可启用NexT主题，十分简单便捷。<br>其它具体设置可参照<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT官方文档</a>。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>cd至blog根目录。  </p><pre><code class="yml">npm install hexo-generator-searchdb --save  #搜索插件npm install --save hexo-generator-feed   #RSS插件npm install hexo-wordcount --save   #字符统计及阅读时长估计npm install hexo-generator-sitemap --save  #博客添加网站地图sitemap</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;hexo配置文件设置&quot;&gt;&lt;a href=&quot;#hexo配置文件设置&quot; class=&quot;headerlink&quot; title=&quot;hexo配置文件设置&quot;&gt;&lt;/a&gt;hexo配置文件设置&lt;/h2&gt;&lt;p&gt;hexo配置文件&lt;code&gt;_config.yml&lt;/code&gt;基本配置&lt;/
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/categories/hexo/"/>
    
    
      <category term="hexo配置文件" scheme="https://closer_laps.gitee.io/tags/hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>hexo上传部署命令</title>
    <link href="https://closer_laps.gitee.io/2019/12/01/hexo/hexo%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://closer_laps.gitee.io/2019/12/01/hexo/hexo%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-11-30T16:00:00.000Z</published>
    <updated>2019-12-08T16:32:43.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo上传部署三连杀命令-先cd进入git目录"><a href="#hexo上传部署三连杀命令-先cd进入git目录" class="headerlink" title="hexo上传部署三连杀命令(先cd进入git目录)"></a>hexo上传部署三连杀命令(先<code>cd</code>进入git目录)</h2><pre><code class="bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><h3 id="我们运行测试时，经常用到的有三个命令"><a href="#我们运行测试时，经常用到的有三个命令" class="headerlink" title="我们运行测试时，经常用到的有三个命令"></a>我们运行测试时，经常用到的有三个命令</h3><pre><code class="bash">hexo clean #用来清理缓存文件hexo g      #生成文件hexo  d   #上传到服务器</code></pre><h4 id="本地检测时运行"><a href="#本地检测时运行" class="headerlink" title="本地检测时运行"></a>本地检测时运行</h4><pre><code class="bash">hexo s</code></pre><p>然后打开浏览器，输入localhost:4000，就能看到博客了。<br>这样说明本地环境搭建完成。</p><h3 id="特别感谢B站up主CodeSheep的帮助和细心指导"><a href="#特别感谢B站up主CodeSheep的帮助和细心指导" class="headerlink" title="特别感谢B站up主CodeSheep的帮助和细心指导"></a>特别感谢<a href="https://space.bilibili.com/384068749/" target="_blank" rel="noopener">B站up主CodeSheep</a>的帮助和细心指导</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;hexo上传部署三连杀命令-先cd进入git目录&quot;&gt;&lt;a href=&quot;#hexo上传部署三连杀命令-先cd进入git目录&quot; class=&quot;headerlink&quot; title=&quot;hexo上传部署三连杀命令(先cd进入git目录)&quot;&gt;&lt;/a&gt;hexo上传部署三连杀命令
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构第三章</title>
    <link href="https://closer_laps.gitee.io/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC3%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://closer_laps.gitee.io/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC3%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2019-11-27T16:00:00.000Z</published>
    <updated>2019-12-08T16:32:13.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3章-线性表"><a href="#第3章-线性表" class="headerlink" title="第3章 线性表"></a>第3章 线性表</h1><p>线性表：零个或多个数据元素的有限序列。</p><h2 id="3-1-3-2线性表的定义"><a href="#3-1-3-2线性表的定义" class="headerlink" title="3.1-3.2线性表的定义"></a>3.1-3.2线性表的定义</h2><p>线性表（List）：零个或多个数据元素的有限序列。</p><p>若将线性表记为（a_1，…，a_(i−1)，a_i，a_(i+1)，…，a_n），则表中a_(i−1) 领先于a_i，a_i 领先于a_(i+1)，称a_(i−1) 是a_i 的直接前驱元素，a_(i+1) 是a_i 的直接后继元素。当i=1，2，…，n-1时，a_i 有且仅有一个直接后继，当i=2，3，…，n时，a_i 有且仅有一个直接前驱。<br>如图3-2-1所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.2.1.GIF?raw=true" alt="3-2-1"></p><p>所以线性表元素的个数n（n&gt;0）定义为线性表的长度，当n=0时，称为空表。<br>在较复杂的线性表中，一个数据元素可以由若干个数据项组成。</p><h2 id="3-3线性表的抽象数据类型"><a href="#3-3线性表的抽象数据类型" class="headerlink" title="3.3线性表的抽象数据类型"></a>3.3线性表的抽象数据类型</h2><p>线性表的抽象数据类型定义如下：</p><pre><code class="c">ADT线性表（List）Data    线性表的数据对象集合为{a1，a2…，an），每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。Operation    InitList（*L）；初始化操作，建立一个空的线性表L。    ListEmpty（L）；若线性表为空，返回true，否则返回false。    ClearList（*L）；将线性表清空。    GetElem（L，i，*e）；将线性表L中的第i个位置元素值返回给e。    LocateElem（L，e）；在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。    ListInsert（*L，i，e）；在线性表L中的第i个位置插入新元素e。    ListDelete（*L，i，*e）；删除线性表L中第i个位置元素，并用e返回其值。    ListLength（L）；返回线性表L的元素个数。endADT</code></pre><h3 id="3-3-1两个线性表集合的并集操作"><a href="#3-3-1两个线性表集合的并集操作" class="headerlink" title="3.3.1两个线性表集合的并集操作"></a>3.3.1两个线性表集合的并集操作</h3><p>要使得集合A=AUB。说白了，就是把存在集合B中但并不存在A中的数据元素插入到A中即可。<br>仔细分析一下这个操作，发现我们只要循环集合B中的每个元素，判断当前元素是否存在A中，若不存在，则插入到A中即可。思路应该是很容易想到的。<br>我们假设La表示集合A，Lb表示集合B，则实现的代码如下：</p><pre><code class="c">    /*将所有的在线性表Lb中但不在La中的数据元素插入到La中*/    void unionL(SqList *La, SqList Lb)    {        int La_len, Lb_len, i;        ElemType e;                          /*声明与La和Lb相同的数据元素e*/        La_len = ListLength(*La);                /*求线性表的长度*/        Lb_len = ListLength(Lb);        for (i = 1; i &lt;= Lb_len; i++)        {            GetElem(Lb, i, &amp;e);           /*取Lb中第i个数据元素赋给e*/            if (!LocateElem(*La, e))           /*La中不存在和e相同数据元素*/                ListInsert(La, ++La_len, e);          /*插入*/        }    }</code></pre><h2 id="3-4线性表的顺序存储结构"><a href="#3-4线性表的顺序存储结构" class="headerlink" title="3.4线性表的顺序存储结构"></a>3.4线性表的顺序存储结构</h2><h3 id="3-4-1顺序存储定义"><a href="#3-4-1顺序存储定义" class="headerlink" title="3.4.1顺序存储定义"></a>3.4.1顺序存储定义</h3><p>线性表的两种物理结构的第一种——顺序存储结构。<br>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p><h3 id="3-4-2顺序存储方式"><a href="#3-4-2顺序存储方式" class="headerlink" title="3.4.2顺序存储方式"></a>3.4.2顺序存储方式</h3><p>可以用C语言（其他语言也相同）的一维数组来实现顺序存储结构。<br>线性表的顺序存储的结构代码如下</p><pre><code class="c">    #define MAXSIZE 20/*存储空间初始分配量*/    typedef int Elemrype;  /*Elemrype 类型根据实际情况而定，这里假设为int*/    typedef struct    {        ElemType data[MAXSIZE];/*数组存储数据元素，最大值为MAXSIZE*/        int length;  /*线性表当前长度*/    }SqList;</code></pre><p>这里，我们就发现描述顺序存储结构需要三个属性：<br>    • 存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。<br>    • 线性表的最大存储容量：数组长度MaxSize。<br>    • 线性表的当前长度：length。</p><h3 id="3-4-3数据长度与线性表长度区别"><a href="#3-4-3数据长度与线性表长度区别" class="headerlink" title="3.4.3数据长度与线性表长度区别"></a>3.4.3数据长度与线性表长度区别</h3><p>数组的长度是存放线性表的存储空间的长度，存储分配后这个量是一般是不变的。<br>线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。<br>在任意时刻，线性表的长度应该小于等于数组的长度。</p><h3 id="3-4-4地址计算方法"><a href="#3-4-4地址计算方法" class="headerlink" title="3.4.4地址计算方法"></a>3.4.4地址计算方法</h3><p>存储器中的每个存储单元都有自己的编号，这个编号称为地址。<br>假设占用的是c个存储单元，那么线性表中第i+1个数据元素的存储位置和第i个数据元素的存储位置满足下列关系（LOC表示获得存储位置的函数）。<br>    LOC（a_(i+1)）=LOC（a_i）+c<br>所以对于第i个数据元素ai的存储位置可以由a1推算得出：<br>    LOC（a_i）=LOC（a_1）+（i-1）*c</p><h2 id="3-5顺序存储结构的插入与删除"><a href="#3-5顺序存储结构的插入与删除" class="headerlink" title="3.5顺序存储结构的插入与删除"></a>3.5顺序存储结构的插入与删除</h2><h3 id="3-5-1获得元素操作"><a href="#3-5-1获得元素操作" class="headerlink" title="3.5.1获得元素操作"></a>3.5.1获得元素操作</h3><p>我们要实现GetElem操作，即将线性表L中的第i个位置元素值返回。只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。</p><pre><code class="c">    #define OK 1    #define ERROR 0    #define TRUE 1    #define FALSE 0    typedef int Status;          /* Status是函数的类型,其值是函数结果状态代码，如OK等 */    /* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */    /* 操作结果：用e返回L中第i个数据元素的值,注意i是指位置，第1个位置的数组是从0开始 */    Status GetElem(SqList L, int i, ElemType *e)    {        if (L.length == 0 || i&lt;1 || i&gt;L.length)            return ERROR;        *e = L.data[i - 1];        return OK;    }</code></pre><h3 id="3-5-2插入操作"><a href="#3-5-2插入操作" class="headerlink" title="3.5.2插入操作"></a>3.5.2插入操作</h3><p>插入算法的思路：<br>    • 如果插入位置不合理，抛出异常；<br>    • 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；<br>    • 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；<br>    • 将要插入元素填入位置i处；<br>    • 表长加1。<br>实现代码如下：</p><pre><code class="c">    /* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */    /* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */    Status ListInsert(SqList *L, int i, ElemType e)    {        int k;        if (L-&gt;length == MAXSIZE)  /* 顺序线性表已经满 */            return ERROR;        if (i&lt;1 || i&gt;L-&gt;length + 1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */            return ERROR;        if (i &lt;= L-&gt;length)        /* 若插入数据位置不在表尾 */        {            for (k = L-&gt;length - 1; k &gt;= i - 1; k--)  /* 将要插入位置之后的数据元素向后移动一位 */                L-&gt;data[k + 1] = L-&gt;data[k];        }        L-&gt;data[i - 1] = e;          /* 将新元素插入 */        L-&gt;length++;        return OK;    }</code></pre><h3 id="3-5-3删除操作"><a href="#3-5-3删除操作" class="headerlink" title="3.5.3删除操作"></a>3.5.3删除操作</h3><p>删除算法的思路：<br>    • 如果删除位置不合理，抛出异常；<br>    • 取出删除元素；<br>    • 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；<br>    • 表长减1。<br>实现代码如下：</p><pre><code class="c">    /* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */    /* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */    Status ListDelete(SqList *L, int i, ElemType *e)    {        int k;        if (L-&gt;length == 0)               /* 线性表为空 */            return ERROR;        if (i&lt;1 || i&gt;L-&gt;length)         /* 删除位置不正确 */            return ERROR;        *e = L-&gt;data[i - 1];        if (i &lt; L-&gt;length)                /* 如果删除不是最后位置 */        {            for (k = i; k &lt; L-&gt;length; k++)/* 将删除位置后继元素前移 */                L-&gt;data[k - 1] = L-&gt;data[k];        }        L-&gt;length--;        return OK;    }</code></pre><p>线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O（1）；而插入或删除时，时间复杂度都是O（n）。</p><h3 id="3-5-4线性表顺序存储结构的优缺点"><a href="#3-5-4线性表顺序存储结构的优缺点" class="headerlink" title="3.5.4线性表顺序存储结构的优缺点"></a>3.5.4线性表顺序存储结构的优缺点</h3><p>线性表的顺序存储结构的优缺点如图3-5-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.5.3.GIF?raw=true" alt="3-5-3"></p><h3 id="3-6线性表的链式存储结构"><a href="#3-6线性表的链式存储结构" class="headerlink" title="3.6线性表的链式存储结构"></a>3.6线性表的链式存储结构</h3><h3 id="3-6-2线性表链式存储结构定义"><a href="#3-6-2线性表链式存储结构定义" class="headerlink" title="3.6.2线性表链式存储结构定义"></a>3.6.2线性表链式存储结构定义</h3><p>为了表示每个数据元素a_i 与其直接后继数据元素a_(i+1) 之间的逻辑关系，对数据元素a1来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素a_i 的存储映像，称为结点（Node）。<br>n个结点（a_i 的存储映像）链结成一个链表，即为线性表（a_1，a_2，…，a_n）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。<br>我们把链表中第一个结点的存储位置叫做头指针,线性链表的最后一个结点指针为“空”（通常用NULL或“^”符号表示）。<br>有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息。</p><h3 id="3-6-3头指针与头结点的异同"><a href="#3-6-3头指针与头结点的异同" class="headerlink" title="3.6.3头指针与头结点的异同"></a>3.6.3头指针与头结点的异同</h3><p><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.6.3.GIF?raw=true" alt="3-6-3"></p><h3 id="3-6-4线性表链式存储结构代码描述"><a href="#3-6-4线性表链式存储结构代码描述" class="headerlink" title="3.6.4线性表链式存储结构代码描述"></a>3.6.4线性表链式存储结构代码描述</h3><pre><code class="c">//线性表的单链表存储结构typedef struct Node{    ElemType data;    struct Node *next;}Node;typedef struct Node *LinkList;/* 定义LinkList */</code></pre><p>节点Node是由存放数据元素的数据域和存放后继节点地址的指针域组成。  </p><h2 id="3-7单链表的读取"><a href="#3-7单链表的读取" class="headerlink" title="3.7单链表的读取"></a>3.7单链表的读取</h2><p>获得链表第i个的数据的算法思路：  </p><ol><li>声明一个结点p指向链表第一个结点，初始化j从1开始;  </li><li>当<code>j&lt;i</code>时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1;  </li><li>若到链表末尾p为空，则说明第i个元素不存在;  </li><li>否则查找成功，返回结点p的数据。  </li></ol><p>实现代码算法如下：</p><pre><code class="c">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) *//* 操作结果：用e返回L中第i个数据元素的值 */Status GetElem(LinkList L,int i,ElemType *e){    int j;    LinkList p;  /* 声明一结点p */    p = L-&gt;next;  /* 让p指向链表L的第一个结点 */    j = 1;        /*  j为计数器 */    while (p &amp;&amp; j&lt;i)  /* p不为空或者计数器j还没有等于i时，循环继续 */    {        p = p-&gt;next;  /* 让p指向下一个结点 */        ++j;    }    if ( !p || j&gt;i )        return ERROR;  /*  第i个元素不存在 */    *e = p-&gt;data;   /*  取第i个元素的数据 */    return OK;}</code></pre><p>这个算法的最坏情况时间复杂度为O(n)。  </p><h2 id="3-8-单链表的插入和删除"><a href="#3-8-单链表的插入和删除" class="headerlink" title="3.8 单链表的插入和删除"></a>3.8 单链表的插入和删除</h2><h3 id="3-8-1-单链表的插入"><a href="#3-8-1-单链表的插入" class="headerlink" title="3.8.1 单链表的插入"></a>3.8.1 单链表的插入</h3><p><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.8.1.GIF?raw=true" alt="图3-8-1"><br>假设上一个结点是p，下一个结点是p-&gt;next,现在要把结点s插入这两个结点中去。只需要2行代码：<br><code>s-&gt;next=p-&gt;next;//先让s的指针域指向p-&gt;next</code><br><code>p-&gt;next=s;//把s的地址赋给p的指针域</code></p><p>ps:这两句顺序不能交换。<br>如果先<code>p-&gt;next=s</code>;再<code>s-&gt;next=p-&gt;next</code>;就等于<code>s-&gt;next=s</code>;<br>所以这2句如论如何都不能反，这点初学者一定要注意。  </p><p>单链表第i个数据插入结点的算法思路：</p><ol><li>声明一结点p指向链表第一个结点，初始化j从1开始;</li><li>当j&lt;1时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1;</li><li>若到链表末尾p为空，则说明第i个元素不存在;</li><li>否则查找成功，在系统中生成一个空结点s;</li><li>将数据元素e赋值给<code>s-&gt;data</code>;</li><li>单链表的插入标准语句<code>s-&gt;next=p-&gt;next;p-&gt;next=s;</code>;</li><li>返回成功;  </li></ol><p>实现代码算法如下:</p><pre><code class="c">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， *//* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */Status ListInsert(LinkList *L,int i,ElemType e){    int j;    LinkList p,s;    p = *L;    j = 1;    while (p &amp;&amp; j &lt; i)     /* 寻找第i个结点 */    {        p = p-&gt;next;        ++j;    }    if (!p || j &gt; i)        return ERROR;   /* 第i个元素不存在 */    s = (LinkList)malloc(sizeof(Node));  /*  生成新结点(C语言标准函数) */    s-&gt;data = e;      s-&gt;next = p-&gt;next;      /* 将p的后继结点赋值给s的后继  */    p-&gt;next = s;          /* 将s赋值给p的后继 */    return OK;}</code></pre><h3 id="3-8-2-单链表的删除"><a href="#3-8-2-单链表的删除" class="headerlink" title="3.8.2 单链表的删除"></a>3.8.2 单链表的删除</h3><p><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.8.5.GIF?raw=true" alt="3-8-5"><br>要删除节点q，其实就是要让<code>p-&gt;next=q-&gt;next</code>;<br>单链表第i个数据删除结点的算法思路：</p><ol><li>声明一结点p指向链表第一个结点，初始化j从1开始</li><li>当<code>j&lt;i</code>时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；</li><li>若到链表末尾p为空，则说明第i个元素不存在；</li><li>否则查找成功，将欲删除的结点<code>p-&gt;next</code>赋值给q；</li><li>单链表的删除标准语句<code>p-&gt;next=q-&gt;next</code>；</li><li>将q结点中的数据赋值给e，作为返回；</li><li>释放q结点；</li><li>返回成功。  </li></ol><p>实现代码算法如下：</p><pre><code class="c">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) *//* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */Status ListDelete(LinkList *L,int i,ElemType *e){    int j;    LinkList p,q;    p = *L;    j = 1;    while (p-&gt;next &amp;&amp; j &lt; i)    /* 遍历寻找第i个元素 */    {        p = p-&gt;next;        ++j;    }    if (!(p-&gt;next) || j &gt; i)        return ERROR;           /* 第i个元素不存在 */    q = p-&gt;next;              //q结点指向要删除的结点（即要删除的结点地址赋值给q）    p-&gt;next = q-&gt;next;            /* 将q的后继(第三个结点)赋值给p的后继 */    *e = q-&gt;data;               /* 将q结点中的数据给e */    free(q);                    /* 让系统回收此结点，释放内存 */    return OK;}</code></pre><p>分析一下刚才我们讲解的单链表插入和删除算法，我们很容易推导出：它们的时间复杂度都是O（n）。<br>显然，对于<strong>插入或删除数据越频繁的操作，单链表的效率优势就越是明显</strong>。</p><h2 id="3-9单链表的整表创建"><a href="#3-9单链表的整表创建" class="headerlink" title="3.9单链表的整表创建"></a>3.9单链表的整表创建</h2><p>单链表整表创建的算法思路：</p><ol><li>声明一结点p和计数器变量i；</li><li>初始化一空链表L；</li><li>让L的头结点的指针指向NULL，即建立一个带头结点的单链表；</li><li>循环：<ul><li>生成一新结点赋值给p；</li><li>随机生成一数字赋值给p的数据域p&gt;data；  </li><li>将p插入到头结点与前一新结点之间。  </li></ul></li></ol><p>实现头插法的代码算法如下(这段算法代码里,我们用插队的办法，始终让新结点在第一的位置。这种算法简称为头插法)：</p><pre><code class="c">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */void CreateListHead(LinkList *L, int n){    LinkList p;    int i;    srand(time(0));                         /* 初始化随机数种子 */    *L = (LinkList)malloc(sizeof(Node));    (*L)-&gt;next = NULL;                      /*  先建立一个带头结点的单链表 */    for (i=0; i&lt;n; i++)    {        p = (LinkList)malloc(sizeof(Node)); /*  生成新结点 */        p-&gt;data = rand()%100+1;             /*  随机生成100以内的数字 */        p-&gt;next = (*L)-&gt;next;        (*L)-&gt;next = p;                        /*  插入到表头 */    }}</code></pre><p>事实上，我们一般插队都是放在最后的。如果我们把每次的新结点都插在终端结点的后面，这种算法称之为尾插法。  </p><p>实现尾插法代码算法如下：</p><pre><code class="c">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */void CreateListTail(LinkList *L, int n){    LinkList p,r;    int i;    srand(time(0));                      /* 初始化随机数种子 */    *L = (LinkList)malloc(sizeof(Node)); /* L为整个线性表 */    r=*L;                                /* r为指向尾部的结点 */    for (i=0; i&lt;n; i++)    {        p = (Node *)malloc(sizeof(Node)); /*  生成新结点 */        p-&gt;data = rand()%100+1;           /*  随机生成100以内的数字 */        r-&gt;next=p;                        /* 将表尾终端结点的指针指向新结点 */        r = p;                            /* 将当前的新结点定义为表尾终端结点 */    }    r-&gt;next = NULL;                       /* 表示当前链表结束 */}</code></pre><p>PS：这里需解释一下，<code>r-&gt;next=p</code>的意思，其实就是将刚才的表尾终端结点r的指针指向新结点p，如图3-9-2所示，当中①位置的连线就是表示这个意思。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.9.2.GIF?raw=true" alt="3-9-2"><br><code>r=p</code>的意思请看图3-9-3，就是本来r是a_(i-1)元素的结点，现在它已经不是最后的结点了，现在最后的结点是a_i，所以应该将p结点这个最后的结点赋值给r。此时r又是最终的尾结点了。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.9.3.GIF?raw=true" alt="3-9-3">  </p><p>循环结束后，那么应该让这个链表的指针域置空，因此有了<code>r-&gt;next=NULL</code>，以便以后遍历时可以确认其是尾部。  </p><h2 id="3-10单链表的整表删除"><a href="#3-10单链表的整表删除" class="headerlink" title="3.10单链表的整表删除"></a>3.10单链表的整表删除</h2><p>单链表整表删除的算法思路如下：</p><ol><li>声明一结点p和q；</li><li>将第一个结点赋值给p；</li><li>循环：<ul><li>将下一结点赋值给q；</li><li>释放p；将q赋值给p。  </li></ul></li></ol><p>实现代码算法如下：  </p><pre><code class="c">/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */Status ClearList(LinkList *L){    LinkList p,q;    p=(*L)-&gt;next;           /*  p指向第一个结点 */    while(p)                /*  没到表尾 */    {        q=p-&gt;next;   //下一个结点地址赋值给临时结点q        free(p);     //释放p结点内存        p=q;         //临时结点q的地址赋值给p，使p能够指向继续指向下一个结点    }    (*L)-&gt;next=NULL;        /* 头结点指针域为空 */    return OK;}</code></pre><h2 id="3-11单链表结构与顺序存储结构优缺点"><a href="#3-11单链表结构与顺序存储结构优缺点" class="headerlink" title="3.11单链表结构与顺序存储结构优缺点"></a>3.11单链表结构与顺序存储结构优缺点</h2><p>简单地对单链表结构和顺序存储结构做对比,如图3-11-1：<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.11.1.GIF?raw=true" alt="3-11-1">  </p><p>通过上面的对比，我们可以得出一些经验性的结论：</p><ul><li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。</li><li>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。  </li></ul><p>总之，线性表的顺序存储结构和单链表结构各有其优缺点，不能简单的说哪个好，哪个不好，需要根据实际情况，来综合平衡采用哪种数据结构更能满足和达到需求和性能。  </p><h2 id="3-12静态链表"><a href="#3-12静态链表" class="headerlink" title="3.12静态链表"></a>3.12静态链表</h2><p>静态链表是由数组组成。<br>我们让数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下标都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而游标cur相当于单链表中的next 指针，存放该元素的后继在数组中的下标。<br>我们把这种用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。<br>静态链表的结构定义如下：  </p><pre><code class="c">/* 线性表的静态链表存储结构 */typedef struct{    ElemType data;    int cur;  /* 游标(Cursor) ，为0时表示无指向 */} Component,StaticLinkList[MAXSIZE];</code></pre><p>另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据。我们通常把未被使用的数组元素称为备用链表。而数组第一个元素，即<strong>下标为0的元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标</strong>，相当于单链表中的头结点作用，当整个链表为空时，则为0<sup>2</sup>。如图3-12-1所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.12.1.GIF?raw=true" alt="3-12-1">  </p><p>初始化数组状态，代码如下：  </p><pre><code class="c">/* 将一维数组space中各分量链成一个备用链表，space[0].cur为头指针，&quot;0&quot;表示空指针 */Status InitList(StaticLinkList space){    int i;    for (i=0; i&lt;MAXSIZE-1; i++)          space[i].cur = i+1;    space[MAXSIZE-1].cur = 0; /* 目前静态链表为空，最后一个元素的cur为0 */    return OK;}</code></pre><h3 id="3-12-1静态链表的插入操作"><a href="#3-12-1静态链表的插入操作" class="headerlink" title="3.12.1静态链表的插入操作"></a>3.12.1静态链表的插入操作</h3><p>在静态链表中，需要我们自己实现结点的申请和释放这2个函数，才可以做插入和删除的操作。<br>为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。  </p><pre><code class="c">/* 若备用空间链表非空，则返回分配的结点下标，否则返回0 */int Malloc_SSL(StaticLinkList space){    int i = space[0].cur;                   /* 当前数组第一个元素的cur存的值 */                                            /* 就是要返回的第一个备用空闲的下标 */    if (space[0]. cur)        space[0]. cur = space[i].cur;       /* 由于要拿出一个分量来使用了， */                                            /* 所以我们就得把它的下一个 */                                            /* 分量用来做备用 */    return i;}</code></pre><p>这段代码有意思，它的作用就是返回一个下标值，这个值就是数组头元素的cur存的第一个空闲的下标,同时把这个空闲的下标给<code>spcae[0].cur</code>，之后就可以继续分配新的空闲分量，实现类似mallbc（）函数的作用。<br>插入操作的实现代码如下：  </p><pre><code class="c">/*  在L中第i个元素之前插入新的数据元素e   */Status ListInsert(StaticLinkList L, int i, ElemType e){      int j, k, l;    k = MAXSIZE - 1;   /* 注意k首先是最后一个元素的下标 */    if (i &lt; 1 || i &gt; ListLength(L) + 1)        return ERROR;    j = Malloc_SSL(L);   /* 获得空闲分量的下标 */    if (j)    {        L[j].data = e;   /* 将数据赋值给此分量的data */        for(l = 1; l &lt;= i - 1; l++)   /* 找到第i个元素之前的位置 */           k = L[k].cur;        L[j].cur = L[k].cur;    /* 把第i个元素之前的cur赋值给新元素的cur */        L[k].cur = j;           /* 把新元素的下标赋值给第i个元素之前元素的ur */        return OK;    }    return ERROR;}</code></pre><h3 id="3-12-2静态链表的删除操作"><a href="#3-12-2静态链表的删除操作" class="headerlink" title="3.12.2静态链表的删除操作"></a>3.12.2静态链表的删除操作</h3><p>删除元素时，实现的代码如下：  </p><pre><code class="c">/*  删除在L中第i个数据元素   */Status ListDelete(StaticLinkList L, int i){    int j, k;    if (i &lt; 1 || i &gt; ListLength(L))        return ERROR;    k = MAXSIZE - 1;    for (j = 1; j &lt;= i - 1; j++)        k = L[k].cur;    j = L[k].cur;    L[k].cur = L[j].cur;    Free_SSL(L, j);    return OK;}</code></pre><p>释放结点的函数代码如下：  </p><pre><code class="c">/*  将下标为k的空闲结点回收到备用链表 */void Free_SSL(StaticLinkList space, int k){      space[k].cur = space[0].cur;    /* 把第一个元素的cur值赋给要删除的分量cur */    space[0].cur = k;               /* 把要删除的分量下标赋值给第一个元素的cur */}</code></pre><p>返回静态链表长度的代码实现如下：  </p><pre><code class="c">/* 初始条件：静态链表L已存在。操作结果：返回L中数据元素个数 */int ListLength(StaticLinkList L){    int j=0;    int i=L[MAXSIZE-1].cur;    while(i)    {        i=L[i].cur;        j++;    }    return j;}</code></pre><h3 id="3-12-3静态链表优缺点"><a href="#3-12-3静态链表优缺点" class="headerlink" title="3.12.3静态链表优缺点"></a>3.12.3静态链表优缺点</h3><p>总结一下静态链表的优缺点（见图3-12-5）：<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.12.5.GIF?raw=true" alt="3-12-5"><br>总的来说，静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。尽管大家不一定会用得上，但这样的思考方式是非常巧妙的，应该理解其思想，以备不时之需。  </p><h2 id="3-13循环链表"><a href="#3-13循环链表" class="headerlink" title="3.13循环链表"></a>3.13循环链表</h2><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。<br>其实循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断<code>p-&gt;next</code>是否为空，现在则是<code>p-&gt;next</code>不等于头结点，则循环未结束。<br>在单链表中，我们有了头结点时，我们可以用O（1）的时间访问第一个结点，但如果想要用O（1）的时间访问到最后一个结点，则需要改造一下这个循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表（如图3-13-5）。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.5.GIF?raw=true" alt="3-13-5"><br>从上图可以看出，终端结点用尾指针rear指示，则查找终端结点是O（1），而开始结点，其实就是<code>rear-&gt;next-&gt;next</code>，其时间复杂也为O（1）。<br>举个程序的例子，要将两个循环链表合并成一个表时，有了尾指针就非常简单了。比如下面的这两个循环链表，它们的尾指针分别是rearA和rearB，如图3-13-6所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.6.GIF?raw=true" alt="3-13-6"><br>要想把它们合并，只需要如下的操作即可，如图3-13-7所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.7.GIF?raw=true" alt="3-13-7"><br>具体代码如下：  </p><pre><code class="c">p=rearA-&gt;next;     /*保存A表的头结点，即①*/rearA-&gt;next=rearB-&gt;next-&gt;next;     /*将本是指向B表的第一个结点（不是头结点）赋值给reaA-&gt;next,即②*/rearB-&gt;next=p;/*将原A表的头结点赋值给rearB-&gt;next，即③**/free(p);/*释放p*/</code></pre><h2 id="3-14双向链表"><a href="#3-14双向链表" class="headerlink" title="3.14双向链表"></a>3.14双向链表</h2><p>双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。<br>所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。  </p><pre><code class="c">/*线性表的双向链表存储结构*/typedef struct DulNode{    ElemType data；    struct DuLNode *prior；/*直接前驱指针*/    struct DuLNode *next；/*直接后继指针*/}DulNode，*DuLinkList；</code></pre><p>既然单链表也可以有循环链表，那么双向链表当然也可以是循环表。<br>双向链表的循环带头结点的空链表如图3-14-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.3.GIF?raw=true" alt="3-14-3"><br>非空的循环的带头结点的双向链表如图3-14-4所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.4.GIF?raw=true" alt="3-14-4"><br>PS：双向链表在插入和删除时，需要更改两个指针变量。<br>插入操作时，其实并不复杂，不过<strong>顺序很重要，千万不能写反了</strong>。<br>我们现在假设存储元素e的结点为s，要实现将结点s插入到结点p和<code>p-&gt;next</code>之间需要下面几步，如图3-14-5所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.5.GIF?raw=true" alt="3-14-5">  </p><pre><code class="c">s-&gt;prior=p;/*把p赋值给s的前驱，如图中①*/s-&gt;next=p-&gt;next;/*把p-&gt;next赋值给s的后继，如图中②*/p-&gt;next-&gt;prior=s;/*把s赋值给p-&gt;next的前驱，如图中③*/p-&gt;next=s;/*把s赋值给p的后继，如图中④*/</code></pre><p>关键在于它们的顺序，由于第2步和第3步都用到了<code>p-&gt;next</code>。如果第4步先执行，则会使得<code>p-&gt;next</code>提前变成了s，使得插入的工作完不成。所以我们不妨把上面这张图在理解的基础上记忆，顺序是先搞定s的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。  </p><p>若要删除结点p，只需要下面两步骤，如图3-14-6所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.6.GIF?raw=true" alt="3-14-6">  </p><pre><code class="c">p-&gt;prior-&gt;next=p-&gt;next；/*把p-&gt;next赋值给p-&gt;prior的后继，如图中①*/p-&gt;next-&gt;prior=p-&gt;prior；/*把p-&gt;prior 赋值给p-&gt;next的前驱，如图中②*/free（p）；/*释放结点*/</code></pre><h2 id="3-15总结回顾"><a href="#3-15总结回顾" class="headerlink" title="3.15总结回顾"></a>3.15总结回顾</h2><p>这一章，主要讲的是线性表。<br>先谈了它的定义，线性表是零个或多个具有相同类型的数据元素的有限序列。然后谈了线性表的抽象数据类型，如它的一些基本操作。<br>之后我们就线性表的两大结构做了讲述，先讲的是比较容易的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。通常我们都是用数组来实现这一结构。<br>后来是我们的重点，由顺序存储结构的插入和删除操作不方便，引出了链式存储结构。它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。然后我们分别就链式存储结构的不同形式，如单链表、循环链表和双向链表做了讲解，另外我们还讲了若不使用指针如何处理链表结构的静态链表方法。<br>总的来说，线性表的这两种结构（如图3-15-1所示）是后面其他数据结构的基础，把它们学明白了，对后面的学习有着至关重要的作用。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.15.1.GIF?raw=true" alt="3-15-1">  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第3章-线性表&quot;&gt;&lt;a href=&quot;#第3章-线性表&quot; class=&quot;headerlink&quot; title=&quot;第3章 线性表&quot;&gt;&lt;/a&gt;第3章 线性表&lt;/h1&gt;&lt;p&gt;线性表：零个或多个数据元素的有限序列。&lt;/p&gt;
&lt;h2 id=&quot;3-1-3-2线性表的定义&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="https://closer_laps.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线性表" scheme="https://closer_laps.gitee.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构第四章</title>
    <link href="https://closer_laps.gitee.io/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC4%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>https://closer_laps.gitee.io/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC4%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2019-11-27T16:00:00.000Z</published>
    <updated>2019-12-08T16:31:55.346Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="https://closer_laps.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈和队列" scheme="https://closer_laps.gitee.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
