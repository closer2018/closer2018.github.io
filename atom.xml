<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>closer的自留地</title>
  
  <subtitle>身处黑暗，心向光明</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://closer_laps.gitee.io/"/>
  <updated>2020-01-29T12:40:32.217Z</updated>
  <id>https://closer_laps.gitee.io/</id>
  
  <author>
    <name>closer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大话数据结构第八章 查找</title>
    <link href="https://closer_laps.gitee.io/2020/01/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC8%E7%AB%A0%20%E6%9F%A5%E6%89%BE/"/>
    <id>https://closer_laps.gitee.io/2020/01/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC8%E7%AB%A0%20%E6%9F%A5%E6%89%BE/</id>
    <published>2020-01-29T12:34:03.000Z</published>
    <updated>2020-01-29T12:40:32.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="8-1-8-2"><a href="#8-1-8-2" class="headerlink" title="8.1-8.2"></a>8.1-8.2</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;8-1-8-2&quot;&gt;&lt;a href=&quot;#8-1-8-2&quot; class=&quot;headerlink&quot; title=&quot;8.1-8.2&quot;&gt;&lt;/a&gt;8.1-8.2&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="https://closer_laps.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>缪雪峰MySQL教程</title>
    <link href="https://closer_laps.gitee.io/2020/01/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/MySQL/%E7%BC%AA%E9%9B%AA%E5%B3%B0MySQL%E6%95%99%E7%A8%8B/"/>
    <id>https://closer_laps.gitee.io/2020/01/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/MySQL/%E7%BC%AA%E9%9B%AA%E5%B3%B0MySQL%E6%95%99%E7%A8%8B/</id>
    <published>2020-01-24T09:07:37.000Z</published>
    <updated>2020-01-26T13:36:11.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-：MySQL执行外部sql脚本文件的命令"><a href="#一-：MySQL执行外部sql脚本文件的命令" class="headerlink" title="一 ：MySQL执行外部sql脚本文件的命令"></a>一 ：MySQL执行外部sql脚本文件的命令</h1><p>sql脚本是包含一到多个sql命令的sql语句，我们可以将这些sql脚本放在一个文本文件中（我们称之为“sql脚本文件”），然后通过相关的命令执行这个sql脚本文件。基本步骤如下：  </p><h2 id="1-1-创建包含sql命令的sql脚本文件"><a href="#1-1-创建包含sql命令的sql脚本文件" class="headerlink" title="1.1 创建包含sql命令的sql脚本文件"></a>1.1 创建包含sql命令的sql脚本文件</h2><p>文件中包含一些列的sql语句，每条语句最后以;结尾，文件内容示例如下：<br>–创建表，使用“–”进行注释</p><pre><code class="sql">create table 表名称(                     Guid Varchar(38) not null primary key,    Title Varchar(255),       ) TYPE=InnoDB;</code></pre><a id="more"></a><ul><li>在表A中增加字段Status<br><code>alter table A add Status TinyInt default &#39;0&#39;;</code></li><li>在表A上创建索引<br><code>create index XX_TaskId_1 on A(Id_);</code></li><li>在A表中添加一条记录<br><code>Insert into A (Id,ParentId, Name) values(1,0,&#39;名称&#39;);</code></li><li>添加、修改、删除数据后，有可能需要提交事务<br><code>Commit;</code></li></ul><h2 id="1-2-执行sql脚本文件"><a href="#1-2-执行sql脚本文件" class="headerlink" title="1.2 执行sql脚本文件"></a>1.2 执行sql脚本文件</h2><h3 id="1-2-1-方法一-：使用cmd命令执行-windows下，unix或linux在的其控制台下"><a href="#1-2-1-方法一-：使用cmd命令执行-windows下，unix或linux在的其控制台下" class="headerlink" title="1.2.1 方法一 ：使用cmd命令执行(windows下，unix或linux在的其控制台下)"></a>1.2.1 方法一 ：使用cmd命令执行(windows下，unix或linux在的其控制台下)</h3><p>【Mysql的bin目录】\mysql –u用户名 –p密码 –D数据库&lt;【sql脚本文件路径全名】，示例：<br><code>D:\mysql\bin\mysql –uroot –p123456 -Dtest&lt;d:\test\ss.sql</code><br>注意：<br>A、如果在sql脚本文件中使用了use 数据库，则-D数据库选项可以忽略<br>B、如果【Mysql的bin目录】中包含空格，则需要使用“”包含，如：<code>“C:\Program Files\mysql\bin\mysql” –u用户名 –p密码 –D数据库&lt;【sql脚本文件路径全名】</code></p><h3 id="1-2-2-方法二-：进入mysql的控制台后，使用source命令执行"><a href="#1-2-2-方法二-：进入mysql的控制台后，使用source命令执行" class="headerlink" title="1.2.2 方法二 ：进入mysql的控制台后，使用source命令执行"></a>1.2.2 方法二 ：进入mysql的控制台后，使用source命令执行</h3><p>Mysql&gt;source 【sql脚本文件的路径全名】 或 Mysql&gt;. 【sql脚本文件的路径全名】，示例：<code>source d:\test\ss.sql</code> 或者 <code>\. d:\test\ss.sql</code></p><h1 id="二：关系数据库概述"><a href="#二：关系数据库概述" class="headerlink" title="二：关系数据库概述"></a>二：关系数据库概述</h1><p>数据库按照数据结构来组织、存储和管理数据，实际上，数据库一共有三种模型：  </p><ul><li>层次模型</li><li>网状模型</li><li>关系模型</li></ul><p>随着时间的推移和市场竞争，最终，基于<strong>关系模型</strong>的关系数据库获得了绝对市场份额。  </p><h2 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h2><p>对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：  </p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>INT</td><td>整型</td><td>4字节整数类型，范围约+/-21亿</td></tr><tr><td>BIGINT</td><td>长整型</td><td>8字节整数类型，范围约+/-922亿亿</td></tr><tr><td>REAL</td><td>浮点型</td><td>4字节浮点数，范围约+/-1038</td></tr><tr><td>DOUBLE</td><td>浮点型</td><td>8字节浮点数，范围约+/-10308</td></tr><tr><td>DECIMAL(M,N)</td><td>高精度小数</td><td>由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算</td></tr><tr><td>CHAR(N)</td><td>定长字符串</td><td>存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串</td></tr><tr><td>VARCHAR(N)</td><td>变长字符串</td><td>存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串</td></tr><tr><td>BOOLEAN</td><td>布尔类型</td><td>存储True或者False</td></tr><tr><td>DATE</td><td>日期类型</td><td>存储日期，例如，2018-06-22</td></tr><tr><td>TIME</td><td>时间类型</td><td>存储时间，例如，12:20:59</td></tr><tr><td>DATETIME</td><td>日期和时间类型</td><td>存储日期+时间，例如，2018-06-22 12:20:59</td></tr></tbody></table><h2 id="2-1-1-SQL-DML-和-DDL"><a href="#2-1-1-SQL-DML-和-DDL" class="headerlink" title="2.1.1 SQL DML 和 DDL"></a>2.1.1 <strong>SQL DML 和 DDL</strong></h2><p>总的来说，可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。<br>SQL (结构化查询语言)是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。<br>查询和更新指令构成了 SQL 的 DML 部分：  </p><ol><li>SELECT - 从数据库表中获取数据</li><li>UPDATE - 更新数据库表中的数据</li><li>DELETE - 从数据库表中删除数据</li><li>INSERT INTO - 向数据库表中插入数据</li></ol><p>SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。<br>SQL 中最重要的 DDL 语句:  </p><ol><li>CREATE DATABASE - 创建新数据库</li><li>ALTER DATABASE - 修改数据库</li><li>CREATE TABLE - 创建新表</li><li>ALTER TABLE - 变更（改变）数据库表</li><li>DROP TABLE - 删除表</li><li>CREATE INDEX - 创建索引（搜索键）</li><li>DROP INDEX - 删除索引</li></ol><h2 id="2-2-安装MySQL"><a href="#2-2-安装MySQL" class="headerlink" title="2.2 安装MySQL"></a>2.2 安装MySQL</h2><p>要在Windows或Mac上安装MySQL，首先从MySQL官方网站下载最新的MySQL Community Server版本：<br><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">MySQL官方网站</a><br>选择对应的操作系统版本，下载安装即可。在安装过程中，MySQL会自动创建一个root用户，并提示输入root口令。<br>要在Linux上安装MySQL，可以使用发行版的包管理器。例如，Debian和Ubuntu用户可以简单地通过命令<code>apt-get install mysql-server</code>安装最新的MySQL版本。  </p><h2 id="2-3-运行MySQL"><a href="#2-3-运行MySQL" class="headerlink" title="2.3 运行MySQL"></a>2.3 运行MySQL</h2><p>MySQL安装后会自动在后台运行。为了验证MySQL安装是否正确，我们需要通过mysql这个命令行程序来连接MySQL服务器。<br>在命令提示符下输入mysql -u root -p，然后输入口令，如果一切正确，就会连接到MySQL服务器，同时提示符变为mysql&gt;。<br>输入exit退出MySQL命令行。注意，MySQL服务器仍在后台运行。  </p><h1 id="三：-关系模型"><a href="#三：-关系模型" class="headerlink" title="三： 关系模型"></a>三： 关系模型</h1><p>我们已经知道，关系数据库是建立在关系模型上的。而关系模型本质上就是若干个存储数据的二维表，可以把它们看作很多Excel表。<br>表的每一行称为记录（Record），记录是一个逻辑意义上的数据。<br>表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。<br>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL。注意NULL表示字段数据不存在。一个整型字段如果为NULL不表示它的值为0，同样的，一个字符串型字段为NULL也不表示它的值为空串’’。  </p><blockquote><p>通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。  </p></blockquote><p>在关系数据库中，关系是通过主键和外键来维护的。</p><h2 id="3-1-主键"><a href="#3-1-主键" class="headerlink" title="3.1 主键"></a>3.1 主键</h2><p>在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。<br>每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。<br><strong>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为主键。</strong><br>对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。<br>由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。<br>所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。<br>因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。<br>作为主键最好是完全业务无关的字段，我们一般把这个字段命名为id。常见的可作为id字段的类型有：  </p><ul><li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li><li>全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li></ul><p>对于大部分应用来说，通常自增类型的主键就能满足需求。  </p><blockquote><p>PS:如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。  </p></blockquote><p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为<strong>联合主键</strong>。<br>对于联合主键，允许一列有重复，只要不是所有主键列都重复即可。<br>没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。  </p><p><strong>小结</strong><br><strong>主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用<code>BIGINT自增</code>或者<code>GUID类型</code>。主键也不应该允许<code>NULL</code>。可以使用多个列作为联合主键，但联合主键并不常用。</strong></p><h2 id="3-2-外键"><a href="#3-2-外键" class="headerlink" title="3.2 外键"></a>3.2 外键</h2><p>由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个<code>classes</code>的记录可以对应多个<code>students</code>表的记录。<br>为了表达这种一对多的关系，我们需要在<code>students</code>表中加入一列<code>class_id</code>，让它的值与<code>classes</code>表的某条记录相对应。<br>这样，我们就可以根据<code>class_id</code>这个列直接定位出一个<code>students</code>表的记录应该对应到<code>classes</code>的哪条记录。<br>在<code>students</code>表中，通过<code>class_id</code>的字段，可以把数据与另一张表关联起来，这种列称为外键。<br>外键并不是通过列名实现的，而是通过定义外键约束实现的：</p><pre><code class="sql">ALTER TABLE studentsADD CONSTRAINT fk_class_idFOREIGN KEY (class_id)REFERENCES classes (id);</code></pre><p>其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的id列（即<code>classes</code>表的主键）。<br>通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果<code>classes</code>表不存在id=99的记录，<code>students</code>表就无法插入<code>class_id=99</code>的记录。<br>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，<code>class_id</code>仅仅是一个普通的列，只是它起到了外键的作用而已。<br>要删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</p><pre><code class="sql">ALTER TABLE studentsDROP FOREIGN KEY fk_class_id;</code></pre><blockquote><p>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。  </p></blockquote><p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。<br>多对多关系实际上是通过两个一对多关系实现的，即<strong>通过一个中间表，关联两个一对多关系，就形成了多对多关系</strong>。<br>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。  目的是把经常读取和不经常读取的字段分开，提高查询速度，以获得更高的性能。  </p><p><strong>小结</strong><br><strong>关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。</strong></p><h2 id="3-3-索引"><a href="#3-3-索引" class="headerlink" title="3.3 索引"></a>3.3 索引</h2><p>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。<br>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。<br>如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引：</p><pre><code class="sql">ALTER TABLE studentsADD INDEX idx_score (score);</code></pre><p>使用<code>ADD INDEX idx_score (score)</code>就创建了一个名称为<code>idx_score</code>，使用列<code>score</code>的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：</p><pre><code class="sql">ALTER TABLE studentsADD INDEX idx_name_score (name, score);</code></pre><p>索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如<code>gender</code>列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。<br>可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。<br>对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。  </p><p><strong>小结</strong><br><strong>通过对数据库表创建索引，可以提高查询速度。</strong><br><strong>通过创建唯一索引，可以保证某一列的值具有唯一性。</strong><br><strong>数据库索引对于用户和应用程序来说都是透明的。</strong></p><h1 id="四：-查询数据"><a href="#四：-查询数据" class="headerlink" title="四： 查询数据"></a>四： 查询数据</h1><p>在关系数据库中，最常用的操作就是查询。</p><h2 id="4-1-基本查询"><a href="#4-1-基本查询" class="headerlink" title="4.1 基本查询"></a>4.1 基本查询</h2><p>要查询数据库表的数据，我们使用如下的SQL语句：<br><code>SELECT * FROM &lt;表名&gt;</code><br>假设表名是<code>students</code>，要查询<code>students</code>表的所有行，我们用如下SQL语句：<br><code>SELECT * FROM students;</code>。<br>使用<code>SELECT * FROM students</code>时，<code>SELECT</code>是关键字，表示将要执行一个查询，<code>*</code>表示“所有列”，<code>FROM</code>表示将要从哪个表查询，本例中是<code>students</code>表。<br>该SQL将查询出<code>students</code>表的所有数据。注意：查询结果也是一个二维表，它包含列名和每一行的数据。  </p><p>在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。<br>关键词 DISTINCT 用于返回唯一不同的值。语法：</p><pre><code class="sql">SELECT DISTINCT 列名称 FROM 表名称</code></pre><p><strong>小结</strong><br><strong>使用<code>SELECT(选择、挑选、选拔)</code>查询的基本语句<code>SELECT * FROM &lt;表名&gt;</code>可以查询一个表的所有行和所有列的数据。<code>SELECT</code>查询的结果是一个二维表。</strong>  </p><h2 id="4-2-条件查询"><a href="#4-2-条件查询" class="headerlink" title="4.2 条件查询"></a>4.2 条件查询</h2><p><code>SELECT</code>语句可以通过<code>WHERE（到哪里）</code>条件来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成<code>WHERE</code>条件就是:<br><code>SELECT * FROM students WHERE score &gt;= 80;</code>。<br>其中，<code>WHERE</code>关键字后面的<code>score &gt;= 80</code>就是条件。<code>score</code>是列名，该列存储了学生的成绩，因此，<code>score &gt;= 80</code>就筛选出了指定条件的记录：<br><code>SELECT * FROM students WHERE score &gt;= 80;</code>。<br>因此，条件查询的语法就是：<br><code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;</code>  </p><p>条件表达式可以用<code>&lt;条件1&gt; AND &lt;条件2&gt;</code>表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来：</p><ul><li>条件1：根据score列的数据判断：score &gt;= 80；</li><li>条件2：根据gender列的数据判断：gender = ‘M’，注意gender列存储的是字符串，需要用单引号括起来。</li></ul><p>就可以写出<code>WHERE</code>条件：<br><code>SELECT * FROM students WHERE score &gt;= 80 AND gender = &#39;M&#39;;</code>。<br>第二种条件是&lt;条件1&gt; OR &lt;条件2&gt;，表示满足条件1或者满足条件2。例如：<br><code>SELECT * FROM students WHERE score &gt;= 80 OR gender = &#39;M&#39;;</code><br>第三种条件是NOT &lt;条件&gt;，表示“不符合该条件”的记录。例如：<br><code>SELECT * FROM students WHERE NOT class_id = 2;</code>表示不是2班的学生。<br>要组合三个或者更多的条件，就需要用小括号()表示如何进行条件运算。例如，编写一个复杂的条件：分数在80以下或者90以上，并且是男生：<br><code>SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = &#39;M&#39;;</code><br>如果不加括号，条件运算按照<code>NOT、AND、OR</code>的优先级进行，即<code>NOT</code>优先级最高，其次是<code>AND</code>，最后是<code>OR</code>。加上括号可以改变优先级。  </p><p>常用的条件表达式：  </p><table><thead><tr><th>条件</th><th>表达式举例1</th><th>表达式举例2</th><th>说明</th></tr></thead><tbody><tr><td>使用=判断相等</td><td>score = 80</td><td>name = ‘abc’</td><td>字符串需要用单引号括起来</td></tr><tr><td>使用&gt;判断大于</td><td>score &gt; 80</td><td>name &gt; ‘abc’</td><td>字符串比较根据ASCII码，中文字符比较根据数据库设置</td></tr><tr><td>使用&gt;=判断大于或相等</td><td>score &gt;= 80</td><td>name &gt;= ‘abc’</td><td></td></tr><tr><td>使用&lt;判断小于</td><td>score &lt; 80</td><td>name &lt;= ‘abc’</td><td></td></tr><tr><td>使用&lt;=判断小于或相等</td><td>score &lt;= 80</td><td>name &lt;= ‘abc’</td><td></td></tr><tr><td>使用&lt;&gt;判断不相等</td><td>score &lt;&gt; 80</td><td>name &lt;&gt; ‘abc’</td><td></td></tr><tr><td>使用LIKE判断相似</td><td>name LIKE ‘ab%’</td><td>name LIKE ‘%bc%’</td><td>%表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’</td></tr></tbody></table><p><strong>小结</strong><br><strong>通过WHERE条件查询，可以筛选出符合指定条件的记录，而不是整个表的所有记录。</strong></p><h2 id="4-3-投影查询"><a href="#4-3-投影查询" class="headerlink" title="4.3 投影查询"></a>4.3 投影查询</h2><p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用<code>SELECT 列1, 列2, 列3 FROM ...</code>，让结果集仅包含指定列。这种操作称为投影查询。<br>例如，从<code>students</code>表中返回<code>id、score和name</code>这三列：<br><code>SELECT id, score, name FROM students;</code><br>这样返回的结果集就只包含了我们指定的列，并且，结果集的列的顺序和原表可以不一样。  </p><p>使用<code>SELECT 列1, 列2, 列3 FROM ...</code>时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code>。</p><p>例如，以下<code>SELECT</code>语句将列名<code>score</code>重命名为<code>points</code>，而<code>id</code>和<code>name</code>列名保持不变：<code>SELECT id, score points, name FROM students;</code><br>投影查询同样可以接<code>WHERE</code>条件，实现复杂的查询：<br><code>SELECT id, score points, name FROM students WHERE gender = &#39;M&#39;;</code>  </p><p><strong>小结</strong><br><strong>使用<code>SELECT *</code>表示查询表的所有列，使用<code>SELECT 列1, 列2, 列3</code>则可以仅返回指定列，这种操作称为投影。<code>SELECT</code>语句可以对结果集的列进行重命名。</strong>  </p><h2 id="4-4-排序"><a href="#4-4-排序" class="headerlink" title="4.4 排序"></a>4.4 排序</h2><p>可以加上<code>ORDER BY</code>子句。可以按照成绩从低到高进行排序：<br><code>SELECT id, name, gender, score FROM students ORDER BY score;</code><br>如果要反过来，按照成绩从高到底排序，我们可以加上DESC表示“倒序”：<br><code>SELECT id, name, gender, score FROM students ORDER BY score DESC;</code><br>如果score列有相同的数据，要进一步排序，可以继续添加列名。例如，使用ORDER BY score DESC, gender表示先按score列倒序，如果有相同分数的，再按gender列排序：<br><code>SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;</code><br>默认的排序规则是<code>ASC</code>：“升序”，即从小到大。<code>ASC</code>可以省略，即<code>ORDER BY score ASC</code>和<code>ORDER BY score</code>效果一样。<br>如果有<code>WHERE</code>子句，那么<code>ORDER BY</code>子句要放到<code>WHERE</code>子句后面。例如，查询一班的学生成绩，并按照倒序排序：</p><pre><code class="sql">SELECT id, name, gender, scoreFROM studentsWHERE class_id = 1ORDER BY score DESC;</code></pre><p>这样，结果集仅包含符合WHERE条件的记录，并按照ORDER BY的设定排序。<br><strong>小结</strong><br><strong>使用ORDER BY可以对结果集进行排序；可以对多列进行升序、倒序排序。</strong>  </p><h2 id="4-5-分页查询"><a href="#4-5-分页查询" class="headerlink" title="4.5 分页查询"></a>4.5 分页查询</h2><p>要实现分页功能，实际上就是从结果集中显示第1<del>100条记录作为第1页，显示第101</del>200条记录作为第2页，以此类推。<br>因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>子句实现。我们先把所有学生按照成绩从高到低进行排序，我们把结果集分页，每页3条记录。要获取第1页的记录，可以使用<code>LIMIT 3 OFFSET 0</code>：  </p><pre><code class="sql">SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 0;</code></pre><p>上述查询<code>LIMIT 3 OFFSET 0</code>表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。<br>如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3：<code>LIMIT 3 OFFSET 3;</code><br>LIMIT 3表示的意思是“最多3条记录”。  </p><p>可见，分页查询的关键在于，首先要确定每页需要显示的结果数量pageSize（这里是3），然后根据当前页的索引pageIndex（从1开始），确定LIMIT和OFFSET应该设定的值：</p><ul><li>LIMIT总是设定为pageSize；</li><li>OFFSET计算公式为pageSize * (pageIndex - 1)。</li></ul><p>这样就能正确查询出第N页的记录集。</p><blockquote><p>PS:OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集。<br>OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。<br>在MySQL中，<code>LIMIT 15 OFFSET 30</code>还可以简写成<code>LIMIT 30, 15</code>。<br>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>分页时，随着N越来越大，查询效率也会越来越低。  </p></blockquote><p><strong>小结</strong><br><strong>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>可以对结果集进行分页，每次查询返回结果集的一部分；分页查询需要先确定每页的数量和当前页数，然后确定LIMIT和OFFSET的值。</strong></p><h2 id="4-6-聚合查询"><a href="#4-6-聚合查询" class="headerlink" title="4.6 聚合查询"></a>4.6 聚合查询</h2><h3 id="4-6-1-聚合函数"><a href="#4-6-1-聚合函数" class="headerlink" title="4.6.1 聚合函数"></a>4.6.1 聚合函数</h3><p>对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。<br>仍然以查询students表一共有多少条记录为例，我们可以使用SQL内置的COUNT()函数查询：<br><code>SELECT COUNT(*) FROM students;</code><br><code>COUNT(*)</code>表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是<code>COUNT(*)</code>。<br>通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果：<br><code>SELECT COUNT(*) num FROM students;</code><br><code>COUNT(*)</code>和<code>COUNT(id)</code>实际上是一样的效果。另外注意，聚合查询同样可以使用WHERE条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等：<br><code>SELECT COUNT(*) boys FROM students WHERE gender = &#39;M&#39;;</code><br>除了COUNT()函数外，SQL还提供了如下聚合函数：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SUM</td><td>计算某一列的合计值，该列必须为数值类型</td></tr><tr><td>AVG</td><td>计算某一列的平均值，该列必须为数值类型</td></tr><tr><td>MAX</td><td>计算某一列的最大值</td></tr><tr><td>MIN</td><td>计算某一列的最小值</td></tr></tbody></table><p>注意，MAX()和MIN()函数并不限于数值类型。如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。<br>要统计男生的平均成绩，我们用下面的聚合查询：<br><code>SELECT AVG(score) average FROM students WHERE gender = &#39;M&#39;;</code><br>要特别注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL。<br>通过聚合查询获得总页数:<br><code>SELECT CEILING(COUNT(*) / 3) FROM students;</code>  </p><h3 id="4-6-2-分组聚合"><a href="#4-6-2-分组聚合" class="headerlink" title="4.6.2 分组聚合"></a>4.6.2 分组聚合</h3><p>对于聚合查询，SQL还提供了“分组聚合”的功能。我们观察下面的聚合查询：<br><code>SELECT COUNT(*) num FROM students GROUP BY class_id;</code><br>执行这个查询，COUNT()的结果不再是一个，而是3个，这是因为，<code>GROUP(组) BY</code>子句指定了按class_id分组，因此，执行该SELECT语句时，会把class_id相同的列先分组，再分别计算，因此，得到了3行结果。<br>但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把class_id列也放入结果集中：<br><code>SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;</code>这下结果集就可以一目了然地看出各个班级的学生人数。<br>也可以使用多个列进行分组。例如，我们想统计各班的男生和女生人数：<br><code>SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;</code><br><strong>小结</strong><br><strong>使用SQL提供的聚合查询，我们可以方便地计算总数、合计值、平均值、最大值和最小值；聚合查询也可以添加WHERE条件。</strong></p><h2 id="4-7-多表查询"><a href="#4-7-多表查询" class="headerlink" title="4.7 多表查询"></a>4.7 多表查询</h2><p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：<code>SELECT * FROM &lt;表1&gt; &lt;表2&gt;</code>。<br>例如，同时从students表和classes表的“乘积”，即查询数据，可以这么写：<code>SELECT * FROM students, classes;</code><br>这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。<br>这种多表查询又称<strong>笛卡尔查询</strong>，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。  </p><p>上述查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理。要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名：</p><pre><code class="sql">SELECT    students.id sid,    students.name,    students.gender,    students.score,    classes.id cid,    classes.name cnameFROM students, classes;</code></pre><p>注意，多表查询时，要使用<code>表名.列名</code>这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用<code>表名.列名</code>这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：</p><pre><code class="sql">SELECT    s.id sid,    s.name,    s.gender,    s.score,    c.id cid,    c.name cnameFROM students s, classes c;</code></pre><p>注意到FROM子句给表设置别名的语法是<code>FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;</code>。这样我们用别名s和c分别表示students表和classes表。<br>多表查询也是可以添加WHERE条件的：</p><pre><code class="sql">SELECT    s.id sid,    s.name,    s.gender,    s.score,    c.id cid,    c.name cnameFROM students s, classes cWHERE s.gender = &#39;M&#39; AND c.id = 1;</code></pre><p><strong>小结</strong><br><strong>使用多表查询可以获取M x N行记录；多表查询的结果集可能非常巨大，要小心使用。</strong></p><h2 id="4-8-连接查询"><a href="#4-8-连接查询" class="headerlink" title="4.8 连接查询"></a>4.8 连接查询</h2><p>连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。<br>例如，我们想要选出students表的所有学生信息，可以用一条简单的SELECT语句完成：  </p><pre><code class="sql">SELECT s.id, s.name, s.class_id, s.gender, s.score FROM students s;</code></pre><p>但是，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有class_id列，缺少对应班级的name列。<br>现在问题来了，存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。<br>这时，连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现：  </p><pre><code class="sql">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.scoreFROM students sINNER JOIN classes cON s.class_id = c.id;</code></pre><p>注意INNER JOIN查询的写法是：</p><ol><li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li><li>再确定需要连接的表，使用<code>INNER(里面的) JOIN &lt;表2&gt;</code>的语法；</li><li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示students表的class_id列与classes表的id列相同的行需要连接；</li><li>可选：加上WHERE子句、ORDER BY等子句。</li></ol><p>那什么是内连接（INNER JOIN）呢？先别着急，有内连接（INNER JOIN）就有外连接（OUTER JOIN）。我们把内连接查询改成外连接查询，看看效果：</p><pre><code class="SQL">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.scoreFROM students sRIGHT OUTER JOIN classes cON s.class_id = c.id;</code></pre><p>执行上述RIGHT OUTER JOIN可以看到，和INNER JOIN相比，RIGHT OUTER JOIN多了一行，多出来的一行是“四班”，但是，学生相关的列如name、gender、score都为NULL。<br>这也容易理解，因为根据ON条件<code>s.class_id = c.id</code>，classes表的id=4的行正是“四班”，但是，students表中并不存在class_id=4的行。<br>有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是：  </p><ul><li>INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件<code>s.class_id = c.id</code>返回的结果集仅包含1，2，3。</li><li>RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。</li><li>LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的class_name是NULL。</li></ul><p>对于这么多种JOIN查询，到底什么使用应该用哪种呢？其实我们用图来表示结果集就一目了然了。假设查询语句是：<br><code>SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2;</code><br>我们把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录：<br><img src="https://www.liaoxuefeng.com/files/attachments/1246892164662976/l" alt="inner-join"><br>LEFT OUTER JOIN是选出左表存在的记录：<br><img src="https://www.liaoxuefeng.com/files/attachments/1246893588481376/l" alt="left-outer-join"><br>RIGHT OUTER JOIN是选出右表存在的记录：<br><img src="https://www.liaoxuefeng.com/files/attachments/1246893609222688/l" alt="right-outer-join"><br>FULL OUTER JOIN则是选出左右表都存在的记录：<br><img src="https://www.liaoxuefeng.com/files/attachments/1246893632359424/l" alt="full-outer-join">  </p><p><strong>小结</strong><br><strong>JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上；  INNER JOIN是最常用的一种JOIN查询，它的语法是<code>SELECT ... FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件...&gt;</code>；  JOIN查询仍然可以使用WHERE条件和ORDER BY排序。</strong></p><h1 id="五：-修改数据"><a href="#五：-修改数据" class="headerlink" title="五： 修改数据"></a>五： 修改数据</h1><p>关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。其中，对于查询，我们已经详细讲述了SELECT语句的详细用法。<br>而对于增、删、改，对应的SQL语句分别是：</p><ul><li>INSERT：插入新记录；</li><li>UPDATE：更新已有记录；</li><li>DELETE：删除已有记录。</li></ul><h2 id="5-1-INSERT"><a href="#5-1-INSERT" class="headerlink" title="5.1 INSERT"></a>5.1 INSERT</h2><p>当我们需要向数据库表中插入一条新记录时，就必须使用<code>INSERT</code>语句。<br>INSERT语句的基本语法是：<br><code>INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</code><br>例如，我们向students表插入一条新记录，先列举出需要插入的字段名称，然后在VALUES子句中依次写出对应字段的值：<br><code>INSERT INTO students (class_id, name, gender, score) VALUES (2, &#39;大牛&#39;, &#39;M&#39;, 80);</code><br>注意到我们并没有列出id字段，也没有列出id字段对应的值，这是因为id字段是一个自增主键，它的值可以由数据库自己推算出来。此外，如果一个字段有默认值，那么在INSERT语句中也可以不出现。<br>要注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。也就是说，可以写:<br><code>INSERT INTO students (score, gender, name, class_id) ...</code>，但是对应的VALUES就得变成<code>(80, &#39;M&#39;, &#39;大牛&#39;, 2)</code>。<br>还可以一次性添加多条记录，只需要在VALUES子句中指定多个记录值，每个记录是由(…)包含的一组值：  </p><pre><code class="sql">INSERT INTO students (class_id, name, gender, score) VALUES  (1, &#39;大宝&#39;, &#39;M&#39;, 87),  (2, &#39;二宝&#39;, &#39;M&#39;, 81);--SELECT * FROM students;</code></pre><p><strong>小结</strong><br><strong>使用INSERT，我们就可以一次向一个表中插入一条或多条记录。</strong></p><h2 id="5-2-UPDATE"><a href="#5-2-UPDATE" class="headerlink" title="5.2 UPDATE"></a>5.2 UPDATE</h2><p>如果要更新数据库表中的记录，我们就必须使用UPDATE语句。<br>UPDATE语句的基本语法是：<br><code>UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;</code><br>例如，我们想更新students表id=1的记录的name和score这两个字段：<br><code>UPDATE students SET name=&#39;大牛&#39;, score=66 WHERE id=1;</code><br>注意到UPDATE语句的WHERE条件和SELECT语句的WHERE条件其实是一样的，因此完全可以一次更新多条记录：<br><code>UPDATE students SET name=&#39;小牛&#39;, score=77 WHERE id&gt;=5 AND id&lt;=7;</code><br>在UPDATE语句中，更新字段时可以使用表达式。例如，把所有80分以下的同学的成绩加10分：<br><code>UPDATE students SET score=score+10 WHERE score&lt;80;</code><br>其中，SET score=score+10就是给当前行的score字段的值加上了10。<br>如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新。<br>最后，要特别小心的是，UPDATE语句可以没有WHERE条件，例如：<br><code>UPDATE students SET score=60;</code><br>这时，整个表的所有记录都会被更新。所以，在执行UPDATE语句时要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新。<br>在使用MySQL这类真正的关系数据库时，UPDATE语句会返回更新的行数以及WHERE条件匹配的行数。  </p><p><strong>小结</strong><br><strong>使用UPDATE，我们就可以一次更新表中的一条或多条记录。</strong></p><h2 id="5-3-DELETE"><a href="#5-3-DELETE" class="headerlink" title="5.3 DELETE"></a>5.3 DELETE</h2><p>如果要删除数据库表中的记录，我们可以使用DELETE语句。<br>DELETE语句的基本语法是：<br><code>DELETE FROM &lt;表名&gt; WHERE ...;</code><br>例如，我们想删除students表中id=1的记录，就需要这么写：<br><code>DELETE FROM students WHERE id=1;</code><br>注意到DELETE语句的WHERE条件也是用来筛选需要删除的行，因此和UPDATE类似，DELETE语句也可以一次删除多条记录：<br><code>DELETE FROM students WHERE id&gt;=5 AND id&lt;=7;</code><br>如果WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除。<br>最后，要特别小心的是，和UPDATE类似，不带WHERE条件的DELETE语句会删除整个表的数据：<br><code>DELETE FROM students;</code><br>这时，整个表的所有记录都会被删除。所以，在执行DELETE语句时也要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用DELETE删除。<br>在使用MySQL这类真正的关系数据库时，DELETE语句也会返回删除的行数以及WHERE条件匹配的行数。  </p><p><strong>小结</strong><br><strong>使用DELETE，我们就可以一次删除表中的一条或多条记录。</strong></p><h1 id="六：-MySQL"><a href="#六：-MySQL" class="headerlink" title="六： MySQL"></a>六： MySQL</h1><p>安装完MySQL后，除了MySQL Server，即真正的MySQL服务器外，还附赠一个MySQL Client程序。MySQL Client是一个命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行。<br>打开命令提示符，输入命令<code>mysql -u root -p</code>，提示输入口令。填入MySQL的root口令，如果正确，就连上了MySQL Server，同时提示符变为mysql&gt;：<br>输入exit断开与MySQL Server的连接并返回到命令提示符。</p><blockquote><p>MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。</p></blockquote><p>在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是127.0.0.1:3306。<br>也可以只安装MySQL Client，然后连接到远程MySQL Server。假设远程MySQL Server的IP地址是10.0.1.99，那么就使用-h指定IP或域名：<br><code>mysql -h 10.0.1.99 -u root -p 密码</code>  </p><p><strong>小结</strong><br><strong>命令行程序mysql实际上是MySQL客户端，真正的MySQL服务器程序是mysqld，在后台运行。</strong></p><h2 id="6-1-管理MySQL"><a href="#6-1-管理MySQL" class="headerlink" title="6.1 管理MySQL"></a>6.1 管理MySQL</h2><p>要管理MySQL，可以使用可视化图形界面<a href="https://dev.mysql.com/downloads/workbench/" target="_blank" rel="noopener">MySQL Workbench</a>。<br>MySQL Workbench可以用可视化的方式查询、创建和修改数据库表，但是，归根到底，MySQL Workbench是一个图形客户端，它对MySQL的操作仍然是发送SQL语句并执行。因此，本质上，MySQL Workbench和MySQL Client命令行都是客户端，和MySQL交互，唯一的接口就是SQL。<br>因此，MySQL提供了大量的SQL语句用于管理。虽然可以使用MySQL Workbench图形界面来直接管理MySQL，但是，很多时候，通过SSH远程连接时，只能使用SQL命令，所以，了解并掌握常用的SQL管理操作是必须的。  </p><h3 id="6-1-1-数据库"><a href="#6-1-1-数据库" class="headerlink" title="6.1.1 数据库"></a>6.1.1 数据库</h3><p>在一个运行MySQL的服务器上，实际上可以创建多个数据库（Database）。要列出所有数据库，使用命令：  </p><pre><code class="sql">SHOW DATABASES;</code></pre><p>其中，<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>和<code>sys</code>四个是系统库，不要去改动它们。其他的是用户创建的数据库。<br>要创建一个新数据库，使用命令：  </p><pre><code class="sql">CREATE DATABASE test;</code></pre><p>要删除一个数据库，使用命令：  </p><pre><code class="sql">DROP DATABASE test;</code></pre><p><em>注意：删除一个数据库将导致该数据库的所有表全部被删除。</em><br>对一个数据库进行操作时，要首先将其切换为当前数据库：  </p><pre><code class="sql">USE test;</code></pre><h3 id="6-1-2-表"><a href="#6-1-2-表" class="headerlink" title="6.1.2 表"></a>6.1.2 表</h3><p>列出当前数据库的所有表，使用命令：  </p><pre><code class="sql">SHOW TABLES;</code></pre><p>要查看一个表的结构，使用命令：  </p><pre><code class="sql">DESC students;</code></pre><p>还可以使用以下命令查看创建表的SQL语句：  </p><pre><code class="sql">SHOW CREATE TABLE students;</code></pre><p>创建表使用CREATE TABLE语句，而删除表使用DROP TABLE语句：  </p><pre><code class="sql">DROP TABLE students;</code></pre><p>修改表就比较复杂。如果要给students表新增一列birth，使用：  </p><pre><code class="sql">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</code></pre><p>要修改birth列，例如把列名改为birthday，类型改为VARCHAR(20)：</p><pre><code class="sql">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</code></pre><p>要删除列，使用：</p><pre><code class="sql">ALTER TABLE students DROP COLUMN birthday;</code></pre><h3 id="6-1-3-退出MySQL"><a href="#6-1-3-退出MySQL" class="headerlink" title="6.1.3 退出MySQL"></a>6.1.3 退出MySQL</h3><p>使用EXIT命令退出MySQL：<br><code>EXIT</code><br>注意EXIT仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。  </p><h2 id="6-2-实用SQL语句"><a href="#6-2-实用SQL语句" class="headerlink" title="6.2 实用SQL语句"></a>6.2 实用SQL语句</h2><p>在编写SQL时，灵活运用一些技巧，可以大大简化程序逻辑。  </p><p><strong>一. 插入或替换</strong><br>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用<code>REPLACE</code>语句，这样就不必先查询，再决定是否先删除再插入：<br><code>REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</code><br>若id=1的记录不存在，REPLACE语句将插入新记录，否则，当前id=1的记录将被删除，然后再插入新记录。  </p><p><strong>二. 插入或更新</strong><br>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用<code>INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code>语句：<br><code>INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99) ON DUPLICATE KEY UPDATE name=&#39;小明&#39;, gender=&#39;F&#39;, score=99;</code><br>若id=1的记录不存在，INSERT语句将插入新记录，否则，当前id=1的记录将被更新，更新的字段由UPDATE指定。  </p><p><strong>三. 插入或忽略</strong><br>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用<code>INSERT IGNORE INTO ...</code>语句：<br><code>INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</code><br>若id=1的记录不存在，INSERT语句将插入新记录，否则，不执行任何操作。  </p><p><strong>四. 快照</strong><br>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合CREATE TABLE和SELECT：  </p><pre><code class="sql">-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:  CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id=1;</code></pre><p>新创建的表结构和SELECT使用的表结构完全一致。</p><p><strong>五. 写入查询结果集</strong><br>如果查询结果集需要写入到表中，可以结合INSERT和SELECT，将SELECT语句的结果集直接插入到指定表中。<br>例如，创建一个统计成绩的表statistics，记录各班的平均成绩：  </p><pre><code class="sql">CREATE TABLE statistics (    id BIGINT NOT NULL AUTO_INCREMENT,    class_id BIGINT NOT NULL,    average DOUBLE NOT NULL,    PRIMARY KEY (id));</code></pre><p>然后，我们就可以用一条语句写入各班的平均成绩：  </p><pre><code class="sql">INSERT INTO statistics (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id;</code></pre><p>确保INSERT语句的列和SELECT语句的列能一一对应，就可以在statistics表中直接保存查询的结果：  </p><pre><code class="sql">SELECT * FROM statistics;</code></pre><p><strong>六. 强制使用指定索引</strong><br>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引。例如：  </p><pre><code class="sql">SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC;</code></pre><p>指定索引的前提是索引idx_class_id必须存在。  </p><h1 id="七-事务"><a href="#七-事务" class="headerlink" title="七: 事务"></a>七: 事务</h1><p>在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：  </p><pre><code class="sql">-- 从id=1的账户给id=2的账户转账100元-- 第一步：将id=1的A账户余额减去100UPDATE accounts SET balance = balance - 100 WHERE id = 1;-- 第二步：将id=2的B账户余额加上100UPDATE accounts SET balance = balance + 100 WHERE id = 2;</code></pre><p>这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。<br>这种把<strong>多条语句作为一个整体进行操作的功能，被称为数据库事务</strong>。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。<br>可见，数据库事务具有ACID这4个特性：</p><ol><li>A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li><li>C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；</li><li>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；</li><li>D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li></ol><p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为隐式事务。<br>要手动把多条SQL语句作为一个事务执行，使用<code>BEGIN</code>开启一个事务，使用<code>COMMIT</code>提交一个事务，这种事务被称为<strong>显式事务</strong>，例如，把上述的转账操作作为一个显式事务：</p><pre><code class="sql">BEGIN;UPDATE accounts SET balance = balance - 100 WHERE id = 1;UPDATE accounts SET balance = balance + 100 WHERE id = 2;COMMIT;</code></pre><p>很显然多条SQL语句要想作为一个事务执行，就必须使用显式事务。<br>COMMIT是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果COMMIT语句执行失败了，整个事务也会失败。<br>有些时候，我们希望主动让事务失败，这时，可以用ROLLBACK回滚事务，整个事务会失败：  </p><pre><code class="sql">BEGIN;UPDATE accounts SET balance = balance - 100 WHERE id = 1;UPDATE accounts SET balance = balance + 100 WHERE id = 2;ROLLBACK;</code></pre><p>数据库事务是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以。  </p><p><strong>隔离级别</strong></p><p>对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。<br>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：  </p><table><thead><tr><th>Isolation Level</th><th>脏读（Dirty Read）</th><th>不可重复读（Non Repeatable Read）</th><th>幻读（Phantom Read）</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Read Committed</td><td>-</td><td>Yes</td><td>Yes</td></tr><tr><td>Repeatable Read</td><td>-</td><td>-</td><td>Yes</td></tr><tr><td>Serializable</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>我们会依次介绍4种隔离级别的数据一致性问题。  </p><p><strong>小结</strong><br><strong>数据库事务具有ACID特性，用来保证多条SQL的全部执行。</strong></p><h2 id="7-1-Read-Uncommitted"><a href="#7-1-Read-Uncommitted" class="headerlink" title="7.1 Read Uncommitted"></a>7.1 Read Uncommitted</h2><p>Read Uncommitted是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。<br>我们来看一个例子。首先，我们准备好students表的数据，该表仅一行记录。<br>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p><table><thead><tr><th>时刻</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td><td>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td></tr><tr><td>2</td><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>3</td><td>UPDATE students SET name = ‘Bob’ WHERE id = 1;</td><td></td></tr><tr><td>4</td><td></td><td>SELECT * FROM students WHERE id = 1;</td></tr><tr><td>5</td><td>ROLLBACK;</td><td></td></tr><tr><td>6</td><td></td><td>SELECT * FROM students WHERE id = 1;</td></tr><tr><td>7</td><td></td><td>COMMIT;</td></tr></tbody></table><p>当事务A执行完第3步时，它更新了id=1的记录，但并未提交，而事务B在第4步读取到的数据就是未提交的数据。<br>随后，事务A在第5步进行了回滚，事务B再次读取id=1的记录，发现和上一次读取到的数据不一致，这就是脏读。<br>可见，在Read Uncommitted隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据。  </p><h2 id="7-2-Read-Committed"><a href="#7-2-Read-Committed" class="headerlink" title="7.2 Read Committed"></a>7.2 Read Committed</h2><p>在Read Committed隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。<br>不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。<br>我们仍然先准备好students表的数据，然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：  </p><table><thead><tr><th>时刻</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td><td>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td></tr><tr><td>2</td><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>3</td><td></td><td>SELECT * FROM students WHERE id = 1;</td></tr><tr><td>4</td><td>UPDATE students SET name = ‘Bob’ WHERE id = 1;</td><td></td></tr><tr><td>5</td><td>COMMIT;</td><td></td></tr><tr><td>6</td><td></td><td>SELECT * FROM students WHERE id = 1;</td></tr><tr><td>7</td><td></td><td>COMMIT;</td></tr></tbody></table><p>当事务B第一次执行第3步的查询时，得到的结果是Alice，随后，由于事务A在第4步更新了这条记录并提交，所以，事务B在第6步再次执行同样的查询时，得到的结果就变成了Bob，因此，在Read Committed隔离级别下，事务不可重复读同一条记录，因为很可能读到的结果不一致。  </p><h2 id="7-3-Repeatable-Read"><a href="#7-3-Repeatable-Read" class="headerlink" title="7.3 Repeatable Read"></a>7.3 Repeatable Read</h2><p>在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。<br>幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。<br>我们仍然先准备好students表的数据，然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：  </p><table><thead><tr><th>时刻</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td><td>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td></tr><tr><td>2</td><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>3</td><td></td><td>SELECT * FROM students WHERE id = 99;</td></tr><tr><td>4</td><td>INSERT INTO students (id, name) VALUES (99, ‘Bob’);</td><td></td></tr><tr><td>5</td><td>COMMIT;</td><td></td></tr><tr><td>6</td><td></td><td>SELECT * FROM students WHERE id = 99;</td></tr><tr><td>7</td><td></td><td>UPDATE students SET name = ‘Alice’ WHERE id = 99;</td></tr><tr><td>8</td><td></td><td>SELECT * FROM students WHERE id = 99;</td></tr><tr><td>9</td><td></td><td>COMMIT;</td></tr></tbody></table><p>事务B在第3步第一次读取id=99的记录时，读到的记录为空，说明不存在id=99的记录。随后，事务A在第4步插入了一条id=99的记录并提交。事务B在第6步再次读取id=99的记录时，读到的记录仍然为空，但是，事务B在第7步试图更新这条不存在的记录时，竟然成功了，并且，事务B在第8步再次读取id=99的记录时，记录出现了。<br>可见，幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。  </p><h2 id="7-4-Serializable"><a href="#7-4-Serializable" class="headerlink" title="7.4 Serializable"></a>7.4 Serializable</h2><p>Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。<br>虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。  </p><p><strong>默认隔离级别</strong><br><strong>如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read。</strong>  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-：MySQL执行外部sql脚本文件的命令&quot;&gt;&lt;a href=&quot;#一-：MySQL执行外部sql脚本文件的命令&quot; class=&quot;headerlink&quot; title=&quot;一 ：MySQL执行外部sql脚本文件的命令&quot;&gt;&lt;/a&gt;一 ：MySQL执行外部sql脚本文件的命令&lt;/h1&gt;&lt;p&gt;sql脚本是包含一到多个sql命令的sql语句，我们可以将这些sql脚本放在一个文本文件中（我们称之为“sql脚本文件”），然后通过相关的命令执行这个sql脚本文件。基本步骤如下：  &lt;/p&gt;
&lt;h2 id=&quot;1-1-创建包含sql命令的sql脚本文件&quot;&gt;&lt;a href=&quot;#1-1-创建包含sql命令的sql脚本文件&quot; class=&quot;headerlink&quot; title=&quot;1.1 创建包含sql命令的sql脚本文件&quot;&gt;&lt;/a&gt;1.1 创建包含sql命令的sql脚本文件&lt;/h2&gt;&lt;p&gt;文件中包含一些列的sql语句，每条语句最后以;结尾，文件内容示例如下：&lt;br&gt;–创建表，使用“–”进行注释&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;sql&quot;&gt;create table 表名称
(                   
  Guid Varchar(38) not null primary key,  
  Title Varchar(255),       

) TYPE=InnoDB;&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="MySQL" scheme="https://closer_laps.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构第七章 图</title>
    <link href="https://closer_laps.gitee.io/2020/01/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC7%E7%AB%A0%20%E5%9B%BE/"/>
    <id>https://closer_laps.gitee.io/2020/01/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC7%E7%AB%A0%20%E5%9B%BE/</id>
    <published>2020-01-08T05:05:04.000Z</published>
    <updated>2020-01-29T12:30:54.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-1-7-2-图的定义"><a href="#7-1-7-2-图的定义" class="headerlink" title="7.1-7.2 图的定义"></a>7.1-7.2 图的定义</h2><p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。<br>对于图的定义，我们需要明确几个注意的地方。</p><ul><li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，<strong>在图中数据元素，我们则称之为顶点（Vertex）</strong>。</li><li>线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。我们根本不认为一张空白纸算作画的。同样，在图结构中，不允许没有顶点。在定义中，若V是顶点的集合，则强调了顶点集合V有穷非空。</li><li>线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。<a id="more"></a><h3 id="7-2-1-各种图定义"><a href="#7-2-1-各种图定义" class="headerlink" title="7.2.1 各种图定义"></a>7.2.1 各种图定义</h3></li></ul><p><strong>无向边：若顶点vi到vj之间的边没有方向，则称这条边为无向边（Edge），用无序偶对（ViVj）来表示</strong>。<br>如果图中任意两个顶点之间的边都是无向边，则称该图为无向图（Undirected graphs）。<br>有向边：若从顶点Vi到Vj的边有方向，则称这条边为有向边，也称为弧（Arc）。<br>用有序偶&lt;vi，vj&gt;来表示，vi称为弧尾（Tail），vj称为弧头（Head）。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图（Directed graphs）。图7-2-3就是一个有向图。连接顶点A到D的有向边就是弧，A是弧尾，D是弧头，&lt;A，D&gt;表示弧，注意不能写成&lt;D，A&gt;。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-2-3.JPG?raw=true" alt="7-2-3"><br>对于图7-2-3中的有向图G2来说，G2=(V2,{E2})，其中顶点集合V2={A.B，C，D}；弧集合E2={&lt;A，D&gt;，&lt;B，A&gt;，&lt;C，A&gt;，&lt;B，C&gt;}。<br>看清楚了，无向边用小括号“（）”表示，而有向边则是用尖括号“&lt;&gt;”表示。<br>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。<br><strong>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图</strong>。含有n个顶点的无向完全图有（nx(n-1)）/2条边。<br><strong>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图</strong>。含有n个顶点的有向完全图有n×（n-1）条边。<br><strong>有很少条边或弧的图称为稀疏图，反之称为稠密图</strong>。<br>有些图的边或弧具有与它相关的数字，这种<strong>与图的边或弧相关的数叫做权（Weight）</strong>。这些权可以表示从一个顶点到另一个顶点的距离或耗费。<strong>这种带权的图通常称为网（Network）</strong>。图7-2-7就是一张带权的图，即标识中国四大城市的直线距离的网，此图中的权就是两地的距离。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-2-7.JPG?raw=true" alt="7-2-7"><br>假设有两个图G=（V，{E}）和G’=（V’,{E’}），如果V’⊆V且E’⊆E，则称G’为G的子图（SubGraph）。  </p><h3 id="7-2-2-图的顶点与边间关系"><a href="#7-2-2-图的顶点与边间关系" class="headerlink" title="7.2.2 图的顶点与边间关系"></a>7.2.2 图的顶点与边间关系</h3><p>对于无向图G=（V,{E}），如果边（v,v’）∈E，则称顶点v和v’互为邻接点（Adjacent），即v和v’相邻接。边（v，v’）依附（incident）于顶点v和v’，或者说（v,v’）与顶点v和v’相关联。顶点v的度（Degree）是和v相关联的边的数目，记为TD（v）。<br>对于有向图G=（V,{E}），如果弧&lt;v,v’&gt;∈E，则称顶点v邻接到顶点v’，顶点v’邻接自顶点v。弧&lt;v，v’&gt;和顶点v，v’相关联。以顶点v为头的弧的数目称为v的入度（InDegree），记为ID（v）；以v为尾的弧的数目称为v的出度（OutDegree），记为OD（v）；顶点v的度为TD（v）=ID（v）+OD（v）。<br>无向图G=（V，{E}）中从顶点v到顶点v’的路径（Path）是一个顶点序列（v=v<sub>i,0</sub>,v<sub>i,1</sub>,…,v<sub>i,m</sub>=v’），其中（v<sub>i,j-1</sub>，v<sub>i,j</sub>）∈E，1≤j≤m。<br>树中根结点到任意结点的路径是唯一的，但是图中顶点与顶点之间的路径却是不唯一的。<br><strong>路径的长度是路径上的边或弧的数目。</strong><br>第一个顶点到最后一个顶点相同的路径称为回路或环（Cycle）。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。  </p><h3 id="7-2-3-连通图相关术语"><a href="#7-2-3-连通图相关术语" class="headerlink" title="7.2.3 连通图相关术语"></a>7.2.3 连通图相关术语</h3><p>在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。如果对于图中任意两个顶点v<sub>i</sub>、v<sub>j</sub>∈E，v<sub>i</sub>和v<sub>j</sub>都是连通的，则称G是连通图（Connected Graph）。<br><strong>无向图中的极大连通子图称为连通分量</strong>。注意连通分量的概念，它强调：</p><ul><li>要是子图；</li><li>子图要是连通的；</li><li>连通子图含有极大顶点数；</li><li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</li></ul><p><strong>在有向图G中，如果对于每一对v<sub>i</sub>、v<sub>j</sub>∈V、v<sub>i</sub>≠v<sub>j</sub>，从v<sub>i</sub>到v<sub>j</sub>和从v<sub>j</sub>到v<sub>i</sub>都存在路径，则称G是强连通图。有向图中的极大强连通子图称做有向图的强连通分量</strong>。<br><strong>所谓的一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边</strong>。<br>如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树。<br>一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。  </p><h3 id="7-2-4-图的定义与术语总结"><a href="#7-2-4-图的定义与术语总结" class="headerlink" title="7.2.4 图的定义与术语总结"></a>7.2.4 图的定义与术语总结</h3><p>术语终于介绍得差不多了，可能有不少同学有些头晕，我们再来整理一下。<br>图按照有无方向分为无向图和有向图。无向图由顶点和边构成，有向图由顶点和弧构成。弧有弧尾和弧头之分。<br>图按照边或弧的多少分稀疏图和稠密图。如果任意两个顶点之间都存在边叫完全图，有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图。<br>图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度，有向图顶点分为入度和出度。<br>图上的边或弧上带权则称为网。<br>图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复叫简单路径。若任意两顶点都是连通的，则图就是连通图，有向则称强连通图。图中有子图，若子图极大连通则就是连通分量，有向的则称强连通分量。<br>无向图中连通且n个顶点n-1条边叫生成树。有向图中一顶点入度为0其余顶点入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林。  </p><h2 id="7-3-图的抽象数据类型"><a href="#7-3-图的抽象数据类型" class="headerlink" title="7.3 图的抽象数据类型"></a>7.3 图的抽象数据类型</h2><pre><code class="c">ADT图（Graph）Data  顶点的有穷非空集合和边的集合。Operation  CreateGraph（*G，V，VR）：按照顶点集V和边弧集VR的定义构造图G。  DestroyGraph（*G）：图G存在则销毁。  LocateVex（G，u）：若图G中存在顶点u，则返回图中的位置。  GetVex（G，v）：返回图G中顶点v的值。  PutVex（G，v，value）：将图G中顶点v赋值value。  FirstAdjVex（G，*v）：返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。  NextAdjVex（G，v，*w）：返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后一个邻接点则返回“空”。  InsertVex（*G，v）：在图G中增添新顶点v。  DeleteVex（*G，v）：删除图G中顶点v及其相关的弧。  InsertArc（*G，V，w）：在图G中增添弧&lt;v，w&gt;，若G是无向图，还需要增添对称弧&lt;w，v&gt;。  DeleteArc（*G，V，w）：在图G中删除弧&lt;v，w&gt;，若G是无向图，则还删除对称弧&lt;w，v&gt;。  DFSTraverse（G）：对图G中进行深度优先遍历，在遍历过程对每个顶点调用。  HFSTraverse（G）：对图G中进行广度优先遍历，在遍历过程对每个顶点调用。endADT</code></pre><h2 id="7-4-图的存储结构"><a href="#7-4-图的存储结构" class="headerlink" title="7.4 图的存储结构"></a>7.4 图的存储结构</h2><p>前辈们提供了五种不同的存储结构。</p><h3 id="7-4-1-邻接矩阵"><a href="#7-4-1-邻接矩阵" class="headerlink" title="7.4.1 邻接矩阵"></a>7.4.1 邻接矩阵</h3><p><strong>图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息</strong>。<br>无向图的边数组构成的是一个对称矩阵。<br>有了这个矩阵，我们就可以很容易地知道图中的信息。</p><ol><li>我们要判定任意两顶点是否有边无边就非常容易了。</li><li>我们要知道某个顶点的度，其实就是这个顶点vi在邻接矩阵中第i行（或第i列）的元素之和。比如顶点v1的度就是1+0+1+0=2。</li><li>求顶点vi的所有邻接点就是将矩阵中第i行元素扫描一遍，arc[i][j]为1就是邻接点。</li></ol><p>在图的术语中，我们提到了网的概念，也就是每条边上带有权的图叫做网。那么这些权值就需要存下来，如何处理这个矩阵来适应这个需求呢？我们有办法。<br>设图G是网图，有n个顶点，则邻接矩阵是一个n×n的方阵，定义为：<br>arc[i][j]=</p><ol><li>W<sub>ij</sub>,若（v<sub>i</sub>，v<sub>j</sub>）∈E或&lt;v<sub>i</sub>,v<sub>j</sub>&gt;∈E</li><li>0,若i=j</li><li>∞，反之</li></ol><p>这里W<sub>ij</sub>表示（v<sub>i</sub>，v<sub>j</sub>）或&lt;v<sub>i</sub>,v<sub>j</sub>&gt;上的权值。∞表示一个计算机允许的、大于所有边上权值的值，也就是一个不可能的极限值。<br>如图7-4-4左图就是一个有向网图，右图就是它的邻接矩阵。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-4.JPG?raw=true" alt="7-4-4">  </p><p>图的邻接矩阵存储的结构，代码如下。</p><pre><code class="c">typedef char VertexType; /* 顶点类型应由用户定义  */typedef int EdgeType; /* 边上的权值类型应由用户定义 */#define MAXVEX 100 /* 最大顶点数，应由用户定义 */#define INFINITY 65535typedef struct{    VertexType vexs[MAXVEX]; /* 顶点表 */    EdgeType arc[MAXVEX][MAXVEX];/* 邻接矩阵，可看作边表 */    int numVertexes, numEdges; /* 图中当前的顶点数和边数  */}MGraph;</code></pre><p>有了这个结构定义，我们构造一个图，其实就是给顶点表和边表输入数据的过程。我们来看看无向网图的创建代码。</p><pre><code class="c">/* 建立无向网图的邻接矩阵表示 */void CreateMGraph(MGraph *G){    int i, j, k, w;    printf(&quot;输入顶点数和边数:\n&quot;);    scanf(&quot;%d,%d&quot;, &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges); /* 输入顶点数和边数 */    for (i = 0; i &lt; G-&gt;numVertexes; i++) /* 读入顶点信息,建立顶点表 */        scanf(&amp;G-&gt;vexs[i]);    for (i = 0; i &lt; G-&gt;numVertexes; i++)        for (j = 0; j &lt; G-&gt;numVertexes; j++)            G-&gt;arc[i][j] = INFINITY;    /* 邻接矩阵初始化 */    for (k = 0; k &lt; G-&gt;numEdges; k++) /* 读入numEdges条边，建立邻接矩阵 */    {        printf(&quot;输入边(vi,vj)上的下标i，下标j和权w:\n&quot;);        scanf(&quot;%d,%d,%d&quot;, &amp;i, &amp;j, &amp;w); /* 输入边(vi,vj)上的权w */        G-&gt;arc[i][j] = w;        G-&gt;arc[j][i] = G-&gt;arc[i][j]; /* 因为是无向图，矩阵对称 */    }}</code></pre><p>从代码中也可以得到，n个顶点和e条边的无向网图的创建，时间复杂度为0（n+n<sup>2</sup>+e），其中对邻接矩阵Garc的初始化耗费了O（n<sup>2</sup>）的时间。</p><h3 id="7-4-2-邻接表"><a href="#7-4-2-邻接表" class="headerlink" title="7.4.2 邻接表"></a>7.4.2 邻接表</h3><p>将结点存入数组，并对结点的数组进行链式存储，不管有多少结点，也不会存在空间浪费问题。我们把这种数组与链表相结合的存储方法称为邻接表（Adjacency List）。<br>邻接表的处理办法是这样。</p><ol><li>图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。</li><li>图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。</li></ol><p>例如图7-4-6所示的就是一个无向图的邻接表结构。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-6.JPG?raw=true" alt="7-4-6"><br>从图中我们知道，顶点表的各个结点由data和firstedge两个域表示，data是数据域，存储顶点的信息，firstedge是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由adjvex和next两个域组成。adjvex是邻接点域，存储某顶点的邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针。比如v1顶点与v0、v2互为邻接点，则在v1的边表中，adjvex分别为v0的0和v2的2。<br>若是有向图，邻接表结构是类似的，比如图7-4-7中第一幅图的邻接表就是第二幅图。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-7.JPG?raw=true" alt="7-4-7"><br>但要注意的是有向图由于有方向，我们是以顶点为弧尾来存储边表的，这样很容易就可以得到每个顶点的出度。但也有时为了便于确定顶点的入度或以顶点为弧头的弧，我们可以建立一个有向图的逆邻接表，即对每个顶点vi都建立一个链接为vi为弧头的表。如图7-4-7的第三幅图所示。<br>对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可。<br>有了这些结构的图，下面关于结点定义的代码就很好理解了。  </p><pre><code class="c">typedef char VertexType; /* 顶点类型应由用户定义 */typedef int EdgeType; /* 边上的权值类型应由用户定义 */typedef struct EdgeNode /* 边表结点  */{    int adjvex;    /* 邻接点域,存储该顶点对应的下标 */    EdgeType info;        /* 用于存储权值,对于非网图可以不需要 */    struct EdgeNode *next; /* 链域,指向下一个邻接点 */}EdgeNode;typedef struct VertexNode /* 顶点表结点 */{    VertexType data; /* 顶点域,存储顶点信息 */    EdgeNode *firstedge;/* 边表头指针 */}VertexNode, AdjList[MAXVEX];typedef struct{    AdjList adjList;    int numNodes,numEdges; /* 图中当前顶点数和边数 */}GraphAdjList;</code></pre><p>对于邻接表的创建，也就是顺理成章之事。无向图的邻接表创建代码如下。</p><pre><code class="c">/* 建立图的邻接表结构 */void  CreateALGraph(GraphAdjList *G){    int i,j,k;    EdgeNode *e;    printf(&quot;输入顶点数和边数:\n&quot;);    scanf(&quot;%d,%d&quot;,&amp;G-&gt;numNodes,&amp;G-&gt;numEdges); /* 输入顶点数和边数 */    for(i = 0;i &lt; G-&gt;numNodes;i++) /* 读入顶点信息,建立顶点表 */    {        scanf(&amp;G-&gt;adjList[i].data);     /* 输入顶点信息 */        G-&gt;adjList[i].firstedge=NULL;     /* 将边表置为空表 */    }    for(k = 0;k &lt; G-&gt;numEdges;k++)/* 建立边表 */    {        printf(&quot;输入边(vi,vj)上的顶点序号:\n&quot;);        scanf(&quot;%d,%d&quot;,&amp;i,&amp;j); /* 输入边(vi,vj)上的顶点序号 */        e=(EdgeNode *)malloc(sizeof(EdgeNode)); /* 向内存申请空间,生成边表结点 */        e-&gt;adjvex=j;                    /* 邻接序号为j */        e-&gt;next=G-&gt;adjList[i].firstedge;    /* 将e的指针指向当前顶点上指向的结点 */        G-&gt;adjList[i].firstedge=e;        /* 将当前顶点的指针指向e */        e=(EdgeNode *)malloc(sizeof(EdgeNode)); /* 向内存申请空间,生成边表结点 */        e-&gt;adjvex=i;                    /* 邻接序号为i */        e-&gt;next=G-&gt;adjList[j].firstedge;    /* 将e的指针指向当前顶点上指向的结点 */        G-&gt;adjList[j].firstedge=e;        /* 将当前顶点的指针指向e */    }}</code></pre><p>这里代码，是应用了我们在单链表创建中讲解到的头插法，由于对于无向图，一条边对应都是两个顶点，所以在循环中，一次就针对i和j分别进行了插入。本算法的时间复杂度，对于n个顶点e条边来说，很容易得出是O（n+e）。</p><h3 id="7-4-3-十字链表"><a href="#7-4-3-十字链表" class="headerlink" title="7.4.3 十字链表"></a>7.4.3 十字链表</h3><p>有向图的一种存储方法：十字链表是邻接表与逆邻接表的结合。<br>我们重新定义顶点表结点结构如表7-4-1所示。<br>表7-4-1<br>data|firstin|firstout<br>-|-|-<br>其中firstin表示入边表头指针，指向该顶点的入边表中第一个结点，firstout表示出边表头指针，指向该顶点的出边表中的第一个结点。<br>重新定义的边表结点结构如表7-4-2所示。<br>表7-4-2<br>tailvex|headvex|headlink|taillink<br>-|-|-|-<br>其中tailvex是指弧起点在顶点表的下标，headvex是指弧终点在顶点表中的下标，headlink是指入边表指针域，指向终点相同的下一条边，taillink是指边表指针域，指向起点相同的下一条边。如果是网，还可以再增加一个weight域来存储权值。<br>比如图7-4-10，顶点依然是存入一个一维数组{v0，v1，v2，v3}，实线箭头指针的图示完全与图7-4-7的邻接表相同。就以顶点v0来说，firstout 指向的是出边表中的第一个结点v3。所以v0边表结点的headvex=3，而tailvex其实就是当前顶点v0的下标0，由于v0只有一个出边顶点，所以headlink和taillink都是空。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-10.JPG?raw=true" alt="7-4-10"><br>我们重点需要来解释虚线箭头的含义，它其实就是此图的逆邻接表的表示。对于v0来说，它有两个顶点v1和v2的入边。因此v0的firstin指向顶点v1的边表结点中headvex为0的结点，如图7-4-10右图中的①。接着由入边结点的headlink指向下一个入边顶点v2，如图中的②。对于顶点v1，它有一个入边顶点v2，所以它的firstin指向顶点v2的边表结点中headvex为1的结点，如图中的③。顶点v2和v3也是同样有一个入边顶点，如图中④和⑤。<br>十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以vi为尾的弧，也容易找到以vi为头的弧，因而容易求得顶点的出度和入度。而且它除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的，因此，在有向图的应用中，十字链表是非常好的数据结构模型。  </p><h3 id="7-4-4-邻接多重表"><a href="#7-4-4-邻接多重表" class="headerlink" title="7.4.4 邻接多重表"></a>7.4.4 邻接多重表</h3><p>仿照十字链表的方式，对边表结点的结构进行一些改造，可以优化无向图的邻接表的便操作。<br>重新定义的边表结点结构如表7-4-3所示。<br>ivex|ilink|jvex|jlink<br>-|-|-|-<br>其中<strong>ivex和jvex是与某条边依附的两个顶点在顶点表中下标。ilink 指向依附顶点ivex的下一条边，jlink 指向依附顶点jvex的下一条边。这就是邻接多重表结构</strong>。<br>我们来看结构示意图的绘制过程，理解了它是如何连线的，也就理解邻接多重表构造原理了。如图7-4-12所示，左图告诉我们它有4个顶点和5条边，显然，我们就应该先将4个顶点和5条边的边表结点画出来。由于是无向图，所以ivex是0、jvex是1还是反过来都是无所谓的，不过为了绘图方便，都将ivex值设置得与一旁的顶点下标相同。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-12.JPG?raw=true" alt="7-4-12"><br>我们开始连线，如图7-4-13。首先连线的①②③④就是将顶点的firstedge指向一条边，顶点下标要与ivex的值相同，这很好理解。接着，由于顶点v0的（v0，v1）边的邻边有（v0，v3）和（v0，v2）。因此⑤⑥的连线就是满足指向下一条依附于顶点v0的边的目标，注意ilink指向的结点的jvex一定要和它本身的ivex的值相同。同样的道理，连线⑦就是指（v1,v0）这条边，它是相当于顶点v1指向（v1，v2）边后的下一条。v2有三条边依附，所以在③之后就有了⑧⑨。连线⑩的就是顶点v3在连线④之后的下一条边。左图一共有5条边，所以右图有10条连线，完全符合预期。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-13.JPG?raw=true" alt="7-4-13"><br>到这里，大家应该可以明白，邻接多重表与邻接表的差别，仅仅是在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。这样对边的操作就方便多了，若要删除左图的（v0，v2）这条边，只需要将右图的⑥⑨的链接指向改为^即可。由于各种基本操作的实现也和邻接表是相似的，这里我们就不讲解代码了。</p><h3 id="7-4-5-边集数组"><a href="#7-4-5-边集数组" class="headerlink" title="7.4.5 边集数组"></a>7.4.5 边集数组</h3><p>边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标（begin）、终点下标（end）和权（weight）组成。</p><h2 id="7-5-图的遍历"><a href="#7-5-图的遍历" class="headerlink" title="7.5 图的遍历"></a>7.5 图的遍历</h2><p>从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历（Traversing Graph）。<br>对于图的遍历来说，如何避免因回路陷入死循环，就需要科学地设计遍历方案，通常有两种遍历次序方案：它们是深度优先遍历和广度优先遍历。  </p><h3 id="7-5-1-深度优先遍历"><a href="#7-5-1-深度优先遍历" class="headerlink" title="7.5.1 深度优先遍历"></a>7.5.1 深度优先遍历</h3><p>深度优先遍历（Depth_FirstSearch），也有称为深度优先搜索，简称为DFS。<br>深度优先遍历其实就是一个递归的过程，就像是一棵树的前序遍历，从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。<br>若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。<br>如果我们用的是邻接矩阵的方式，则代码如下：</p><pre><code class="c">typedef int Boolean; /* Boolean是布尔类型,其值是TRUE或FALSE */Boolean visited[MAXVEX]; /* 访问标志的数组 *//* 邻接矩阵的深度优先递归算法 */void DFS(MGraph G, int i){    int j;    visited[i] = TRUE;    printf(&quot;%c &quot;, G.vexs[i]);/* 打印顶点，也可以其它操作 */    for(j = 0; j &lt; G.numVertexes; j++)        if(G.arc[i][j] == 1 &amp;&amp; !visited[j])            DFS(G, j);/* 对为访问的邻接顶点递归调用 */}/* 邻接矩阵的深度遍历操作 */void DFSTraverse(MGraph G){    int i;    for(i = 0; i &lt; G.numVertexes; i++)        visited[i] = FALSE; /* 初始所有顶点状态都是未访问过状态 */    for(i = 0; i &lt; G.numVertexes; i++)        if(!visited[i]) /* 对未访问过的顶点调用DFS，若是连通图，只会执行一次 */            DFS(G, i);}</code></pre><p>代码的执行过程，其实就是我们刚才迷宫找寻所有顶点的过程。<br>如果图结构是邻接表结构，其DFSTraverse函数的代码是几乎相同的，只是在递归函数中因为将数组换成了链表而有不同，代码如下。  </p><pre><code class="c">/* 邻接表的深度优先递归算法 */void DFS(GraphAdjList GL, int i){    EdgeNode *p;    visited[i] = TRUE;    printf(&quot;%c &quot;,GL-&gt;adjList[i].data);/* 打印顶点,也可以其它操作 */    p = GL-&gt;adjList[i].firstedge;    while(p)    {        if(!visited[p-&gt;adjvex])            DFS(GL, p-&gt;adjvex);/* 对为访问的邻接顶点递归调用 */        p = p-&gt;next;    }}/* 邻接表的深度遍历操作 */void DFSTraverse(GraphAdjList GL){    int i;    for(i = 0; i &lt; GL-&gt;numVertexes; i++)        visited[i] = FALSE; /* 初始所有顶点状态都是未访问过状态 */    for(i = 0; i &lt; GL-&gt;numVertexes; i++)        if(!visited[i]) /* 对未访问过的顶点调用DFS,若是连通图,只会执行一次 */             DFS(GL, i);}</code></pre><p>对比两个不同存储结构的深度优先遍历算法，对于n个顶点e条边的图来说，邻接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此都需要O(n<sup>2</sup>)的时间。而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是O（n+e）。显然对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。  </p><h3 id="7-5-2-广度优先遍历"><a href="#7-5-2-广度优先遍历" class="headerlink" title="7.5.2 广度优先遍历"></a>7.5.2 广度优先遍历</h3><p>广度优先遍历（Breadth_First_Search），又称为广度优先搜索，简称BFS。<br>如果说图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树的层序遍历了。我们将图7-5-3的第一幅图稍微变形，变形原则是顶点A放置在最上第一层，让与它有边的顶点B、F为第二层，再让与B和F有边的顶点C、I、G、E为第三层，再将这四个顶点有边的D、H放在第四层，如图7-5-3的第二幅图所示。<br>此时在视觉上感觉图的形状发生了变化，其实顶点和边的关系还是完全相同的。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-5-3.JPG?raw=true" alt="7-5-3"><br>有了这个讲解，我们来看代码就非常容易了。以下是邻接矩阵结构的广度优先遍历算法。  </p><pre><code class="c">/* 邻接矩阵的广度遍历算法 */void BFSTraverse(MGraph G){    int i, j;    Queue Q;    for(i = 0; i &lt; G.numVertexes; i++)        visited[i] = FALSE;    InitQueue(&amp;Q);        /* 初始化一辅助用的队列 */    for(i = 0; i &lt; G.numVertexes; i++)  /* 对每一个顶点做循环 */    {        if (!visited[i])    /* 若是未访问过就处理 */        {            visited[i]=TRUE;        /* 设置当前顶点访问过 */            printf(&quot;%c &quot;, G.vexs[i]);/* 打印顶点，也可以其它操作 */            EnQueue(&amp;Q,i);        /* 将此顶点入队列 */            while(!QueueEmpty(Q))    /* 若当前队列不为空 */            {                DeQueue(&amp;Q,&amp;i);/* 将队对元素出队列，赋值给i */                for(j=0;j&lt;G.numVertexes;j++)                 {                    /* 判断其它顶点若与当前顶点存在边且未访问过  */                    if(G.arc[i][j] == 1 &amp;&amp; !visited[j])                    {                        visited[j]=TRUE;            /* 将找到的此顶点标记为已访问 */                        printf(&quot;%c &quot;, G.vexs[j]);    /* 打印顶点 */                        EnQueue(&amp;Q,j);                /* 将找到的此顶点入队列  */                    }                }            }        }    }}</code></pre><p>对于邻接表的广度优先遍历，代码与邻接矩阵差异不大，代码如下。</p><pre><code class="c">/* 邻接表的广度遍历算法 */void BFSTraverse(GraphAdjList GL){    int i;    EdgeNode *p;    Queue Q;    for(i = 0; i &lt; GL-&gt;numVertexes; i++)        visited[i] = FALSE;    InitQueue(&amp;Q);    for(i = 0; i &lt; GL-&gt;numVertexes; i++)    {        if (!visited[i])        {            visited[i]=TRUE;            printf(&quot;%c &quot;,GL-&gt;adjList[i].data);/* 打印顶点,也可以其它操作 */            EnQueue(&amp;Q,i);            while(!QueueEmpty(Q))            {                DeQueue(&amp;Q,&amp;i);                p = GL-&gt;adjList[i].firstedge;    /* 找到当前顶点的边表链表头指针 */                while(p)                {                    if(!visited[p-&gt;adjvex])    /* 若此顶点未被访问 */                     {                        visited[p-&gt;adjvex]=TRUE;                        printf(&quot;%c &quot;,GL-&gt;adjList[p-&gt;adjvex].data);                        EnQueue(&amp;Q,p-&gt;adjvex);    /* 将此顶点入队列 */                    }                    p = p-&gt;next;    /* 指针指向下一个邻接点 */                }            }        }    }}</code></pre><p>对比图的深度优先遍历与广度优先遍历算法，你会发现，它们在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同。可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。<br>不过如果图顶点和边非常多，不能在短时间内遍历完成，遍历的目的是为了寻找合适的顶点，那么选择哪种遍历就要仔细斟酌了。深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况。  </p><h2 id="7-6-最小生成树"><a href="#7-6-最小生成树" class="headerlink" title="7.6 最小生成树"></a>7.6 最小生成树</h2><p>我们把构造连通网的最小代价生成树称为最小生成树（Minimum Cost Spanning Tree）。</p><h3 id="7-6-1-普里姆（Prim）算法"><a href="#7-6-1-普里姆（Prim）算法" class="headerlink" title="7.6.1 普里姆（Prim）算法"></a>7.6.1 普里姆（Prim）算法</h3><p>普里姆（Prim）算法代码如下，左侧数字为行号。其中INFINITY为权值极大值，不妨是65535，MAXVEX为顶点个数最大值，此处大于等于9即可。现在假设我们自己就是计算机，在调用MiniSpanTree_Prim函数，输入上述的邻接矩阵后，看看它是如何运行并打印出最小生成树的。  </p><pre><code class="c">/* Prim算法生成最小生成树  */void MiniSpanTree_Prim(MGraph G){    int min, i, j, k;    int adjvex[MAXVEX];        /* 保存相关顶点下标 */    int lowcost[MAXVEX];    /* 保存相关顶点间边的权值 */    lowcost[0] = 0;/* 初始化第一个权值为0，即v0加入生成树 */            /* lowcost的值为0，在这里就是此下标的顶点已经加入生成树 */    adjvex[0] = 0;            /* 初始化第一个顶点下标为0 */    for(i = 1; i &lt; G.numVertexes; i++)    /* 循环除下标为0外的全部顶点 */    {        lowcost[i] = G.arc[0][i];    /* 将v0顶点与之有边的权值存入数组 */        adjvex[i] = 0;                    /* 初始化都为v0的下标 */    }    for(i = 1; i &lt; G.numVertexes; i++)    {        min = INFINITY;    /* 初始化最小权值为∞， */                        /* 通常设置为不可能的大数字如32767、65535等 */        j = 1;k = 0;        while(j &lt; G.numVertexes)    /* 循环全部顶点 */        {            if(lowcost[j]!=0 &amp;&amp; lowcost[j] &lt; min)/* 如果权值不为0且权值小于min */            {                min = lowcost[j];    /* 则让当前权值成为最小值 */                k = j;            /* 将当前最小值的下标存入k */            }            j++;        }        printf(&quot;(%d, %d)\n&quot;, adjvex[k], k);/* 打印当前顶点边中权值最小的边 */        lowcost[k] = 0;/* 将当前顶点的权值设置为0,表示此顶点已经完成任务 */        for(j = 1; j &lt; G.numVertexes; j++)    /* 循环所有顶点 */        {            if(lowcost[j]!=0 &amp;&amp; G.arc[k][j] &lt; lowcost[j])            {/* 如果下标为k顶点各边权值小于此前这些顶点未被加入生成树权值 */                lowcost[j] = G.arc[k][j];/* 将较小的权值存入lowcost相应位置 */                adjvex[j] = k;                /* 将下标为k的顶点存入adjvex */            }        }    }}</code></pre><p>假设N=（P,{E}）是连通网，TE是N上最小生成树中边的集合。算法从U={u0}（u0∈V），TE={}开始。重复执行下述操作：在所有u∈U，v∈V-U的边（u，v）∈E中找一条代价最小的边（u0，v0）并入集合TE，同时v0并入U，直至U=V为止。此时TE中必有n-1条边，则T=（V.{TE}）为N的最小生成树。<br>由算法代码中的循环嵌套可得知此算法的时间复杂度为O(n<sup>2</sup>)。</p><h3 id="7-6-2-克鲁斯卡尔（Kruskal）算法"><a href="#7-6-2-克鲁斯卡尔（Kruskal）算法" class="headerlink" title="7.6.2 克鲁斯卡尔（Kruskal）算法"></a>7.6.2 克鲁斯卡尔（Kruskal）算法</h3><p>现在我们来换一种思考方式，普里姆（Prim）算法是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树的。<br>同样的思路，我们也可以直接就以边为目标去构建，因为权值是在边上，直接去找最小权值的边来构建生成树也是很自然的想法，只不过构建时要考虑是否会形成环路而已。此时我们就用到了图的存储结构中的边集数组结构。以下是edge边集数组结构的定义代码：  </p><pre><code class="c">typedef struct{    int begin;    int end;    int weight;}Edge;   /* 对边集数组Edge结构的定义 */</code></pre><p>我们将图7-6-3的邻接矩阵通过程序转化为图7-6-7的右图的边集数组，并且对它们按权值从小到大排序。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-6-7.JPG?raw=true" alt="7-6-7"><br>于是克鲁斯卡尔（Kruskal）算法代码如下，左侧数字为行号。其中MAXEDGE为边数量的极大值，此处大于等于15即可，MAXVEX为顶点个数最大值，此处大于等于9即可。现在假设我们自己就是计算机，在调用MiniSpanTree_Kruskal函数，输入图7-6-3右图的邻接矩阵后，看看它是如何运行并打印出最小生成树的。  </p><pre><code class="c">/* 查找连线顶点的尾部下标 */int Find(int *parent, int f){    while ( parent[f] &gt; 0)    {        f = parent[f];    }    return f;}/* Kruskal算法生成最小生成树 */void MiniSpanTree_Kruskal(MGraph G){    int i, j, n, m;    int k = 0;    int parent[MAXVEX];/* 定义一数组用来判断边与边是否形成环路 */    Edge edges[MAXEDGE];/* 定义边集数组,edge的结构为begin,end,weight,均为整型 */    /* 用来构建边集数组并排序********************* */    for ( i = 0; i &lt; G.numVertexes-1; i++)    {        for (j = i + 1; j &lt; G.numVertexes; j++)        {            if (G.arc[i][j]&lt;INFINITY)            {                edges[k].begin = i;                edges[k].end = j;                edges[k].weight = G.arc[i][j];                k++;            }        }    }    sort(edges, &amp;G);    /* ******************************************* */    for (i = 0; i &lt; G.numVertexes; i++)        parent[i] = 0;    /* 初始化数组值为0 */    printf(&quot;打印最小生成树：\n&quot;);    for (i = 0; i &lt; G.numEdges; i++)    /* 循环每一条边 */    {        n = Find(parent,edges[i].begin);        m = Find(parent,edges[i].end);        if (n != m) /* 假如n与m不等，说明此边没有与现有的生成树形成环路 */        {            parent[n] = m;    /* 将此边的结尾顶点放入下标为起点的parent中。 */                            /* 表示此顶点已经在生成树集合中 */            printf(&quot;(%d, %d) %d\n&quot;, edges[i].begin, edges[i].end, edges[i].weight);        }    }}</code></pre><p>好了，我们来把克鲁斯卡尔（Kruskal）算法的实现定义归纳一下结束这一节的讲解。<br>假设N=（V,{E}）是连通网，则令最小生成树的初始状态为只有n个顶点而无边的非连通图T={V，{}}，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。依次类推，直至T中所有顶点都在同一连通分量上为止。<br>此算法的Find函数由边数e决定，时间复杂度为O（loge），而外面有一个for 循环e次。所以克鲁斯卡尔算法的时间复杂度为O（eloge）。<br>对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以对于稀疏图有很大的优势；而普里姆算法对于稠密图，即边数非常多的情况会更好一些。  </p><h2 id="7-7-最短路径"><a href="#7-7-最短路径" class="headerlink" title="7.7 最短路径"></a>7.7 最短路径</h2><p>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。  </p><h3 id="7-7-1-迪杰斯特拉（Djkstra）算法"><a href="#7-7-1-迪杰斯特拉（Djkstra）算法" class="headerlink" title="7.7.1 迪杰斯特拉（Djkstra）算法"></a>7.7.1 迪杰斯特拉（Djkstra）算法</h3><p>迪杰斯特拉（Dijkstra）算法并不是一下子就求出了v0到Vn的最短路径，而是一步步求出它们之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到你要的结果。  </p><pre><code class="c">#define MAXVEX 20#define INFINITY 65535typedef int Patharc[MAXVEX];    /* 用于存储最短路径下标的数组 */typedef int ShortPathTable[MAXVEX]; /* 用于存储到各点最短路径的权值和 *//* Dijkstra算法，求有向网G的v0顶点到其余顶点v的最短路径P[v]及带权长度D[v] *//* P[v]的值为前驱顶点下标,D[v]表示v0到v的最短路径长度和 */  void ShortestPath_Dijkstra(MGraph G, int v0, Patharc *P, ShortPathTable *D){    int v,w,k,min;    int final[MAXVEX];/* final[w]=1表示求得顶点v0至vw的最短路径 */    for(v=0; v&lt;G.numVertexes; v++)    /* 初始化数据 */    {        final[v] = 0;            /* 全部顶点初始化为未知最短路径状态 */        (*D)[v] = G.arc[v0][v];/* 将与v0点有连线的顶点加上权值 */        (*P)[v] = -1;                /* 初始化路径数组P为-1  */    }    (*D)[v0] = 0;  /* v0至v0路径为0 */      final[v0] = 1;    /* v0至v0不需要求路径 */    /* 开始主循环，每次求得v0到某个v顶点的最短路径 */    for(v=1; v&lt;G.numVertexes; v++)    {        min=INFINITY;    /* 当前所知离v0顶点的最近距离 */        for(w=0; w&lt;G.numVertexes; w++) /* 寻找离v0最近的顶点 */        {            if(!final[w] &amp;&amp; (*D)[w]&lt;min)            {                k=w;                min = (*D)[w];    /* w顶点离v0顶点更近 */            }        }        final[k] = 1;    /* 将目前找到的最近的顶点置为1 */        for(w=0; w&lt;G.numVertexes; w++) /* 修正当前最短路径及距离 */        {            /* 如果经过v顶点的路径比现在这条路径的长度短的话 */            if(!final[w] &amp;&amp; (min+G.arc[k][w]&lt;(*D)[w]))            { /*  说明找到了更短的路径，修改D[w]和P[w] */                (*D)[w] = min + G.arc[k][w];  /* 修改当前路径长度 */                (*P)[w]=k;            }        }    }}</code></pre><p>此算法的时间复杂度为O（n<sup>2</sup>）。  </p><h3 id="7-7-2-弗洛伊德（Floyd）算法"><a href="#7-7-2-弗洛伊德（Floyd）算法" class="headerlink" title="7.7.2 弗洛伊德（Floyd）算法"></a>7.7.2 弗洛伊德（Floyd）算法</h3><pre><code class="c">typedef int Patharc[MAXVEX][MAXVEX];typedef int ShortPathTable[MAXVEX][MAXVEX];/* Floyd算法，求网图G中各顶点v到其余顶点w的最短路径P[v][w]及带权长度D[v][w]。 */void ShortestPath_Floyd(MGraph G, Patharc *P, ShortPathTable *D){    int v,w,k;    for(v=0; v&lt;G.numVertexes; ++v) /* 初始化D与P */      {        for(w=0; w&lt;G.numVertexes; ++w)          {            (*D)[v][w]=G.arc[v][w];    /* D[v][w]值即为对应点间的权值 */            (*P)[v][w]=w;                /* 初始化P */        }    }    for(k=0; k&lt;G.numVertexes; ++k)    {        for(v=0; v&lt;G.numVertexes; ++v)          {            for(w=0; w&lt;G.numVertexes; ++w)            {                if ((*D)[v][w]&gt;(*D)[v][k]+(*D)[k][w])                {/* 如果经过下标为k顶点路径比原两点间路径更短 */                    (*D)[v][w]=(*D)[v][k]+(*D)[k][w];/* 将当前两点间权值设为更小的一个 */                    (*P)[v][w]=(*P)[v][k];/* 路径设置为经过下标为k的顶点 */                }            }        }    }}</code></pre><p>求最短路径的显示代码可以这样写：  </p><pre><code class="c">    for(v=0; v&lt;G.numVertexes; ++v)    {        for(w=v+1; w&lt;G.numVertexes; w++)          {            printf(&quot;v%d-v%d weight: %d &quot;,v,w,D[v][w]);            k=P[v][w];                /* 获得第一个路径顶点下标 */            printf(&quot; path: %d&quot;,v);    /* 打印源点 */            while(k!=w)                /* 如果路径顶点下标不是终点 */            {                printf(&quot; -&gt; %d&quot;,k);    /* 打印路径顶点 */                k=P[k][w];            /* 获得下一个路径顶点下标 */            }            printf(&quot; -&gt; %d\n&quot;,w);    /* 打印终点 */        }        printf(&quot;\n&quot;);    }</code></pre><p>再次回过头来看看弗洛伊德（Floyd）算法，它的代码简洁到就是一个二重循环初始化加一个三重循环权值修正，就完成了所有顶点到所有顶点的最短路径计算。几乎就如同是我们在学习C语言循环嵌套的样例代码而已。如此简单的实现，真是巧妙之极，在我看来，这是非常漂亮的算法，不知道你们是否喜欢？很可惜由于它的三重循环，因此也是O（n<sup>3</sup>）时间复杂度。如果你面临需要求所有顶点至所有顶点的最短路径问题时，弗洛伊德（Floyd）算法应该是不错的选择。  </p><h2 id="7-8-拓扑排序"><a href="#7-8-拓扑排序" class="headerlink" title="7.8 拓扑排序"></a>7.8 拓扑排序</h2><p>说了两个有环的图应用，现在我们来谈谈无环的图应用。无环，即是图中没有回路的意思。  </p><h3 id="7-8-1-拓扑排序介绍"><a href="#7-8-1-拓扑排序介绍" class="headerlink" title="7.8.1 拓扑排序介绍"></a>7.8.1 拓扑排序介绍</h3><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网（Activity On Vertex Network）。<br>设G=（V，E）是一个具有n个顶点的有向图，V中的顶点序列v1，V2，……，Vn，满足若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必在顶点vj之前。则我们称这样的顶点序列为一个拓扑序列。<br><strong>所谓拓扑排序，其实就是对一个有向图构造拓扑序列的过程。</strong>构造时会有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环（回路）的AOV网；如果输出顶点数少了，哪怕是少了一个，也说明这个网存在环（回路），不是AOV网。  </p><h3 id="7-8-2-拓扑排序算法"><a href="#7-8-2-拓扑排序算法" class="headerlink" title="7.8.2 拓扑排序算法"></a>7.8.2 拓扑排序算法</h3><p>对AOV网进行拓扑排序的基本思路是：从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AOV网中不存在入度为0的顶点为止。<br>首先我们需要确定一下这个图需要使用的数据结构。前面求最小生成树和最短路径时，我们用的都是邻接矩阵，但由于拓扑排序的过程中，需要删除顶点，显然用邻接表会更加方便。因此我们需要为AOV网建立一个邻接表。考虑到算法过程中始终要查找入度为0的顶点，我们在原来顶点表结点结构中，增加一个入度域in，结构如表7-8-1所示，其中in就是入度的数字。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-8-1.JPG?raw=true" alt="7-8-1"><br>因此对于图7-8-2的第一幅图AOV网，我们可以得到如第二幅图的邻接表数据结构。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-8-2.JPG?raw=true" alt="7-8-2"><br>在拓扑排序算法中，涉及的结构代码如下:</p><pre><code class="c">typedef struct EdgeNode /* 边表结点  */{    int adjvex;    /* 邻接点域，存储该顶点对应的下标 */    int weight;        /* 用于存储权值，对于非网图可以不需要 */    struct EdgeNode *next; /* 链域，指向下一个邻接点 */}EdgeNode;typedef struct VertexNode /* 顶点表结点 */{    int in;    /* 顶点入度 */    int data; /* 顶点域，存储顶点信息 */    EdgeNode *firstedge;/* 边表头指针 */}VertexNode, AdjList[MAXVEX];typedef struct{    AdjList adjList;    int numVertexes,numEdges; /* 图中当前顶点数和边数 */}graphAdjList,*GraphAdjList;</code></pre><p>在算法中，我还需要辅助的数据结构一栈，用来存储处理过程中入度为0的顶点，目的是为了避免每个查找时都要去遍历顶点表找有没有入度为0的顶点。<br>现在我们来看代码:  </p><pre><code class="c">/* 拓扑排序，若GL无回路，则输出拓扑排序序列并返回1，若有回路返回0。 */Status TopologicalSort(GraphAdjList GL){    EdgeNode *e;    int i,k,gettop;    int top=0;  /* 用于栈指针下标  */    int count=0;/* 用于统计输出顶点的个数  */    int *stack;    /* 建栈将入度为0的顶点入栈  */    stack=(int *)malloc(GL-&gt;numVertexes * sizeof(int) );    for(i = 0; i&lt;GL-&gt;numVertexes; i++)        if(0 == GL-&gt;adjList[i].in) /* 将入度为0的顶点入栈 */            stack[++top]=i;    while(top!=0)    {        gettop=stack[top--];  /* 出栈 */        printf(&quot;%d -&gt; &quot;,GL-&gt;adjList[gettop].data);        count++;        /* 输出i号顶点，并计数 */        for(e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next)        {/* 对此顶点弧表遍历 */            k=e-&gt;adjvex;            if( !(--GL-&gt;adjList[k].in) )  /* 将k号顶点的邻接点的入度减1，如果减1后为0，则入栈 */                stack[++top]=k;        }    }    printf(&quot;\n&quot;);    if(count &lt; GL-&gt;numVertexes)/* 如果 count小于顶点数，说明存在环 */        return ERROR;    else        return OK;}</code></pre><p>分析整个算法，对一个具有n个顶点e条弧的AOV网来说，扫描顶点表，将入度为0的顶点入栈的时间复杂为O（n），而之后的while循环中，每个顶点进一次栈，出一次栈，入度减1的操作共执行了e次，所以整个算法的时间复杂度为O（n+e）。  </p><h2 id="7-9-关键路径"><a href="#7-9-关键路径" class="headerlink" title="7.9 关键路径"></a>7.9 关键路径</h2><p>在前面讲了AOV网的基础上，我们来介绍一个新的概念。在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为AOE网（Activity On Edge Network）。<br>我们把AOE网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点。<br>我们把路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动。<br>如果我们需要缩短整个工期，去改进轮子的生产效率，哪怕改动成0.1也是无益于整个工期的变化，只有缩短关键路径上的关键活动时间才可以减少整个工期长度。<br>那么现在的问题就是如何找出关键路径。  </p><h3 id="7-9-1-关键路径算法原理"><a href="#7-9-1-关键路径算法原理" class="headerlink" title="7.9.1 关键路径算法原理"></a>7.9.1 关键路径算法原理</h3><p>我们只需要找到所有活动的最早开始时间和最晚开始时间，并且比较它们，如果相等就意味着此活动是关键活动，活动间的路径为关键路径。如果不等，则就不是。<br>为此，我们需要定义如下几个参数。</p><ol><li>事件的最早发生时间etv（earliest time of vertex）：即顶点vk的最早发生时间。</li><li>事件的最晚发生时间ltv（latest time of vertex）：即顶点Vk的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期。</li><li>活动的最早开工时间ete（earliest time ofedge）：即弧ak的最早发生时间。</li><li>活动的最晚开工时间lte（latest time of edge）：即弧ak的最晚发生时间，也就是不推迟工期的最晚开工时间。  </li></ol><p>我们是由1和2可以求得3和4，然后再根据ete[k]是否与lte[k]相等来判断ak是否是关键活动。  </p><h3 id="7-9-2-关键路径算法"><a href="#7-9-2-关键路径算法" class="headerlink" title="7.9.2 关键路径算法"></a>7.9.2 关键路径算法</h3><p>我们将图7-9-2的AOE网转化为邻接表结构如图7-9-4所示，注意与拓扑排序时邻接表结构不同的地方在于，这里弧链表增加了weight域，用来存储弧的权值。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-9-4.JPG?raw=true" alt="7-9-4"><br>求事件的最早发生时间etv的过程，就是我们从头至尾找拓扑序列的过程，因此，在求关键路径之前，需要先调用一次拓扑序列算法的代码来计算etv和拓扑序列列表。为此，我们首先在程序开始处声明几个全局变量。  </p><pre><code class="c">int *etv,*ltv; /* 事件最早发生时间和最迟发生时间数组，全局变量 */int *stack2;   /* 用于存储拓扑序列的栈 */int top2;      /* 用于stack2的指针 */</code></pre><p>其中stack2用来存储拓扑序列，以便后面求关键路径时使用。<br>下面是改进过的求拓扑序列算法。  </p><pre><code class="c">/* 拓扑排序,用于关键路径计算 */Status TopologicalSort(GraphAdjList GL){    /* 若GL无回路，则输出拓扑排序序列并返回1，若有回路返回0。 */    EdgeNode *e;    int i,k,gettop;    int top=0;  /* 用于栈指针下标  */    int count=0;/* 用于统计输出顶点的个数 */    int *stack;    /* 建栈将入度为0的顶点入栈  */    stack=(int *)malloc(GL-&gt;numVertexes * sizeof(int) );    for(i = 0; i&lt;GL-&gt;numVertexes; i++)        if(0 == GL-&gt;adjList[i].in) /* 将入度为0的顶点入栈 */            stack[++top]=i;    top2=0;         /* 初始化为0 */    etv=(int *)malloc(GL-&gt;numVertexes * sizeof(int) ); /* 事件最早发生时间数组 */    for(i=0; i&lt;GL-&gt;numVertexes; i++)        etv[i]=0;    /* 初始化为0 */    stack2=(int *)malloc(GL-&gt;numVertexes * sizeof(int) );/* 初始化拓扑序列栈 */    printf(&quot;TopologicalSort:\t&quot;);    while(top!=0)    {        gettop=stack[top--];        printf(&quot;%d -&gt; &quot;,GL-&gt;adjList[gettop].data);        count++;        /* 输出i号顶点，并计数 */        stack2[++top2]=gettop;        /* 将弹出的顶点序号压入拓扑序列的栈 */        for(e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next)        {            k=e-&gt;adjvex;            if( !(--GL-&gt;adjList[k].in) )        /* 将i号顶点的邻接点的入度减1，如果减1后为0，则入栈 */                stack[++top]=k;            if((etv[gettop] + e-&gt;weight)&gt;etv[k])    /* 求各顶点事件的最早发生时间etv值 */                etv[k] = etv[gettop] + e-&gt;weight;        }    }    if(count &lt; GL-&gt;numVertexes)        return ERROR;    else        return OK;}</code></pre><p>下面我们来看求关键路径的算法代码。</p><pre><code class="c">/* 求关键路径,GL为有向网，输出G的各项关键活动 */void CriticalPath(GraphAdjList GL){    EdgeNode *e;    int i,gettop,k,j;    int ete,lte;  /* 声明活动最早发生时间和最迟发生时间变量 */    TopologicalSort(GL);   /* 求拓扑序列，计算数组etv和stack2的值 */    ltv=(int *)malloc(GL-&gt;numVertexes*sizeof(int));/* 事件最早发生时间数组 */    for(i=0; i&lt;GL-&gt;numVertexes; i++)        ltv[i]=etv[GL-&gt;numVertexes-1];    /* 初始化 */    while(top2!=0)    /* 出栈是求ltv */    {        gettop=stack2[top2--];        for(e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next)        {/* 求各顶点事件的最迟发生时间ltv值 */            k=e-&gt;adjvex;            if(ltv[k] - e-&gt;weight &lt; ltv[gettop])                ltv[gettop] = ltv[k] - e-&gt;weight;        }    }    for(j=0; j&lt;GL-&gt;numVertexes; j++)        /* 求ete,lte和关键活动 */    {        for(e = GL-&gt;adjList[j].firstedge; e; e = e-&gt;next)        {            k=e-&gt;adjvex;            ete = etv[j];        /* 活动最早发生时间 */            lte = ltv[k] - e-&gt;weight; /* 活动最迟发生时间 */            if(ete == lte)    /* 两者相等即在关键路径上 */                printf(&quot;&lt;v%d - v%d&gt; length: %d \n&quot;,GL-&gt;adjList[j].data,GL-&gt;adjList[k].data,e-&gt;weight);        }    }}</code></pre><p>最终求关键路径算法的时间复杂度依然是O（n+e）。<br>实践证明，通过这样的算法对于工程的前期工期估算和中期的计划调整都有很大的帮助。不过注意，本例是唯一一条关键路径，这并不等于不存在多条关键路径的有向无环图。如果是多条关键路径，则单是提高一条关键路径上的关键活动的速度并不能导致整个工程缩短工期，而必须提高同时在几条关键路径上的活动的速度。这就像仅仅是有事业的成功，而没有健康的身体以及快乐的生活，是根本谈不上幸福的人生一样，三者缺一不可。  </p><h2 id="7-10-总结回顾"><a href="#7-10-总结回顾" class="headerlink" title="7.10 总结回顾"></a>7.10 总结回顾</h2><p>图是计算机科学中非常常用的一类数据结构，有许许多多的计算问题都是用图来定义的。由于图也是最复杂的数据结构，对它讲解时，涉及到数组、链表、栈、队列、树等之前学的几乎所有数据结构。因此从某种角度来说，学好了图，基本就等于理解了数据结构这门课的精神。<br>我们在图的定义这一节，介绍了一大堆定义和术语，一开始可能会有些迷茫，不过一回生二回熟，多读几遍，基本都可以理解并记住它们的特征，在图的定义这一节的末尾，我们已经有所总结，这里就不再赘述了。<br>图的存储结构我们一共讲了五种，如图7-10-1所示，其中比较重要的是邻接矩阵和邻接表，它们分别代表着边集是用数组还是链表的方式存储。十字链表是邻接矩阵的一种升级，而邻接多重表则是邻接表的升级。边集数组更多考虑的是对边的关注。用什么存储结构需要具体问题具体分析，通常稠密图，或读存数据较多，结构修改较少的图，用邻接矩阵要更合适，反之则应该考虑邻接表。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-10-1.JPG?raw=true" alt="7-10-1"><br>图的遍历分为深度和广度两种，各有优缺点，就像人在追求卓越时，是着重深度还是看重广度，总是很难说得清楚。<br>图的应用是我们这一章浓墨重彩的一部分，一共谈了三种应用：最小生成树、最短路径和有向无环图的应用。<br>最小生成树，我们讲了两种算法：普里姆（Prim）算法和克鲁斯卡尔（Kruskal）算法。普里姆算法像是走一步看一步的思维方式，逐步生成最小生成树。而克鲁斯卡尔算法则更有全局意识，直接从图中最短权值的边入手，找寻最后的答案。<br>最短路径的现实应用非常多，我们也介绍了两种算法。迪杰斯特拉（Dijkstra）算法更强调单源顶点查找路径的方式，比较符合我们正常的思路，容易理解原理，但算法代码相对复杂。而弗洛伊德（Floyd）算法则完全抛开了单点的局限思维方式，巧妙地应用矩阵的变换，用最清爽的代码实现了多顶点间最短路径求解的方案，原理理解有难度，但算法编写很简洁。<br>有向无环图时常应用于工程规划中，对于整个工程或系统来说，我们一方面关心的是工程能否顺利进行的问题，通过拓扑排序的方式，我们可以有效地分析出一个有向图是否存在环，如果不存在，那它的拓扑序列是什么？另一方面关心的是整个工程完成所必须的最短时间问题，利用求关键路径的算法，可以得到最短完成工程的工期以及关键的活动有哪些。  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;7-1-7-2-图的定义&quot;&gt;&lt;a href=&quot;#7-1-7-2-图的定义&quot; class=&quot;headerlink&quot; title=&quot;7.1-7.2 图的定义&quot;&gt;&lt;/a&gt;7.1-7.2 图的定义&lt;/h2&gt;&lt;p&gt;图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。&lt;br&gt;对于图的定义，我们需要明确几个注意的地方。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性表中我们把数据元素叫元素，树中将数据元素叫结点，&lt;strong&gt;在图中数据元素，我们则称之为顶点（Vertex）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。我们根本不认为一张空白纸算作画的。同样，在图结构中，不允许没有顶点。在定义中，若V是顶点的集合，则强调了顶点集合V有穷非空。&lt;/li&gt;
&lt;li&gt;线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="https://closer_laps.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构第六章 树</title>
    <link href="https://closer_laps.gitee.io/2019/12/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC6%E7%AB%A0%20%E6%A0%91/"/>
    <id>https://closer_laps.gitee.io/2019/12/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC6%E7%AB%A0%20%E6%A0%91/</id>
    <published>2019-12-28T14:34:58.000Z</published>
    <updated>2020-01-08T05:07:35.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6-1-6-2-树的定义"><a href="#6-1-6-2-树的定义" class="headerlink" title="6.1-6.2 树的定义"></a>6.1-6.2 树的定义</h2><p><strong>树(Tree)是n(n≥0)个结点的有限集。n=0时称为空树。在任意一棵非空树中：1)有且仅有一个特定的称为根(Root)的结点；2)当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。</strong><br>对于树的定义还需要强调两点：  </p><ol><li>n&gt;0时根结点是唯一的，不可能存在多个根结点，数据结构中的树是只能有一个根结点。</li><li>m&gt;0时，子树的个数没有限制，但它们一定是互不相交的。  <a id="more"></a><h3 id="6-2-1-结点分类"><a href="#6-2-1-结点分类" class="headerlink" title="6.2.1 结点分类"></a>6.2.1 结点分类</h3></li></ol><p>树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。如图6-2-4所示，因为这棵树结点的度的最大值是结点D的度为3，所以树的度也为3。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-2-4.JPG?raw=true" alt="6-2-4">  </p><h3 id="6-2-2-结点间关系"><a href="#6-2-2-结点间关系" class="headerlink" title="6.2.2 结点间关系"></a>6.2.2 结点间关系</h3><p>结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）。同一个双亲的孩子之间互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。  </p><h3 id="6-2-3-树的其他相关概念"><a href="#6-2-3-树的其他相关概念" class="headerlink" title="6.2.3 树的其他相关概念"></a>6.2.3 树的其他相关概念</h3><p>结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。其双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度。<br>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。<br>森林（Forest）是m（m&gt;0）棵互不相交的树的集合。<br>对比线性表与树的结构，它们有很大的不同，如图6-2-7所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-2-7.JPG?raw=true" alt="6-2-7"></p><h2 id="6-3-树的抽象数据类型"><a href="#6-3-树的抽象数据类型" class="headerlink" title="6.3 树的抽象数据类型"></a>6.3 树的抽象数据类型</h2><pre><code class="c">ADT 树（tree）Data  树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。Operation  InitTree（*T）：构造空树T。  DestroyTree（*T）：销毁树T。  CreateTree（*T，definition）：按definition中给出树的定义来构造树。  ClearTree（*T）：若树T存在，则将树T清为空树。  TreeEmpty（T）：若T为空树，返回true，否则返回false。  TreeDepth（T）：返回T的深度。  Root（T）：返回T的根结点。  Value（T，cur_e）：cur_e是树T中一个结点，返回此结点的值。  Assign（T，cur_e，value）：给树T的结点cur_e赋值为value。  Parent（T，cur_e）：若cur_e是树T的非根结点，则返回它的双亲，否则返回空。  LeftChild（T，cure）：若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空。  RightSibling（T，cur_e）：若cur_e有右兄弟，则返回它的右兄弟，否则返回空。  InsertChild（*T，*p，i，c）：其中p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树。  DeleteChild（*T，*p，i）：其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树。endADT</code></pre><h2 id="6-4-树的存储结构"><a href="#6-4-树的存储结构" class="headerlink" title="6.4 树的存储结构"></a>6.4 树的存储结构</h2><p>充分利用顺序存储和链式存储结构的特点，可以实现对树的存储结构的表示。我们这里要介绍三种不同的表示法：双亲表示法、孩子表示法、孩子兄弟表示法。  </p><h3 id="6-4-1-双亲表示法"><a href="#6-4-1-双亲表示法" class="headerlink" title="6.4.1 双亲表示法"></a>6.4.1 双亲表示法</h3><p>树除了根结点外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲。<br>我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。<br>data数据域，存储结点的数据信息。而parent指针域，存储该结点的双亲在数组中的下标。<br>以下是我们的双亲表示法的结点结构定义代码:  </p><pre><code class="c">/* 树的双亲表示法结点结构定义 */#define MAX_TREE_SIZE 100 /* 二叉树的最大结点数 */typedef int TElemType;  /* 树结点的数据类型，目前暂定为整型 */typedef struct PTNode/*结点结构*/{  TElemType data;/*结点数据*/  int parent;/*双亲位置*/}PTNode;typedef struct /* 树结构 */{  PTNode nodes[MAX_TREE_SI2E];/* 结点数组 */  int r，n;/* 根的位置和结点数 */}PTree;</code></pre><p>有了这样的结构定义，我们就可以来实现双亲表示法了。由于根结点是没有双亲的，所以我们约定根结点的位置域设置为-1，这也就意味着，我们所有的结点都存有它双亲的位置。如图6-4-1中的树结构和表6-4-2中的树双亲表示所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-1.JPG?raw=true" alt="6-4-1">  </p><p>这样的存储结构，我们可以根据结点的parent指针很容易找到它的双亲结点，所用的时间复杂度为O(1)，直到parent为-1时，表示找到了树结点的根。可如果我们要知道结点的孩子是什么，请遍历整个结构才行。如何改进呢？<br>我们增加一个结点最左边孩子的域，不妨叫它长子域，这样就可以很容易得到结点的孩子。如果没有孩子的结点，这个长子域就设置为-1，如表6-4-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-3.JPG?raw=true" alt="6-4-3">  </p><p>对于有0个或1个孩子结点来说，这样的结构是解决了要找结点孩子的问题了。甚至是有2个孩子，知道了长子是谁，另一个当然就是次子了。<br>另外一个问题是，我们很关注各兄弟之间的关系，双亲表示法无法体现这样的关系，那我们怎么办？嗯，可以增加一个右兄弟域来体现兄弟关系，也就是说，每一个结点如果它存在右兄弟，则记录下右兄弟的下标。同样的，如果右兄弟不存在，则赋值为-1。<br>但如果结点的孩子很多，超过了2个。我们又关注结点的双亲、又关注结点的孩子、还关注结点的兄弟，而且对时间遍历要求还比较高，那么我们还可以把此结构扩展为有双亲域、长子域、再有右兄弟域。存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。注意也不是越多越好，有需要时再设计相应的结构。  </p><h3 id="6-4-2-孩子表示法"><a href="#6-4-2-孩子表示法" class="headerlink" title="6.4.2 孩子表示法"></a>6.4.2 孩子表示法</h3><p>换一种完全不同的考虑方法。由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。不过，树的每个结点的度，也就是它的孩子个数是不同的。所以可以设计两种方案来解决。  </p><h4 id="6-4-2-1-方案一"><a href="#6-4-2-1-方案一" class="headerlink" title="6.4.2.1 方案一"></a>6.4.2.1 方案一</h4><p>一种是指针域的个数就等于树的度，复习一下，树的度是树各个结点度的最大值。其结构如表6-4-5所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-5.JPG?raw=true" alt="6-4-5"><br>其中data是数据域。child1到child d是指针域，用来指向该结点的孩子结点。<br>对于图6-4-1的树来说，树的度是3，所以我们的指针域的个数是3，这种方法实现如图6-4-2所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-2.JPG?raw=true" alt="6-4-2"><br>这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。不过如果树的各结点度相差很小时，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。<br>既然很多指针域都可能为空，那么我们可以按需分配空间。  </p><h4 id="6-4-2-2-方案二"><a href="#6-4-2-2-方案二" class="headerlink" title="6.4.2.2 方案二"></a>6.4.2.2 方案二</h4><p>第二种方案每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数，其结构如表6-4-6所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-6.JPG?raw=true" alt="6-4-6"><br>其中data为数据域，degree为度域，也就是存储该结点的孩子结点的个数，child1到child d为指针域，指向该结点的各个孩子的结点。<br>对于图6-4-2的树来说，这种方法实现如图6-4-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-7.JPG?raw=true" alt="6-4-7"><br>这种方法克服了浪费空间的缺点，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。  </p><p>孩子表示法。具体办法是，<strong>把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</strong>，如图6-4-4所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-8.JPG?raw=true" alt="6-4-8"><br>以下是我们的孩子表示法的结构定义代码:  </p><pre><code class="c">/*树的孩子表示法结构定义*/#define MAX_TREE_SIZE 100typedef struct cTNode/* 孩子结点 */{  int child;  struct CTNode *next;}*ChildPtr;typedef struct  /* 表头结构 */{  TElemType data;  ChildPtr firstChild;}CTBox;typedef struct  /* 树结构 */{  CTBox nodes[MAX_TREE_SIZE];  /* 结点数组 */  int r，n;  /* 根的位置和结点数 */}CTree;</code></pre><p>这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。<br>但是，这也存在着问题，我如何知道某个结点的双亲是谁呢？比较麻烦，需要整棵树遍历才行，难道就不可以把双亲表示法和孩子表示法综合一下吗？当然是可以。如图6-4-5所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-9.JPG?raw=true" alt="6-4-9"><br>我们把这种方法称为双亲孩子表示法。</p><h3 id="6-4-3-孩子兄弟表示法"><a href="#6-4-3-孩子兄弟表示法" class="headerlink" title="6.4.3 孩子兄弟表示法"></a>6.4.3 孩子兄弟表示法</h3><p><strong>我们观察后发现，任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。</strong><br>结点结构如下所示。<br>data | firstChild | rightSib<br>—–|————|———<br>其中data是数据域，firstChild为指针域，存储该结点的第一个孩子结点的存储地址，rightSib是指针域，存储该结点的右兄弟结点的存储地址。<br>结构定义代码如下:  </p><pre><code class="c">/*树的孩子兄弟表示法结构定义*/typedef struct CSNode{  TElemType data;  struct CSNode *firstChild， *rightSib;}CSNode,*CSTree;</code></pre><p>对于图6-4-1的树来说，这种方法实现的示意图如图6-4-6所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-10.JPG?raw=true" alt="6-4-10"><br>这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过firstChild找到此结点的长子，然后再通过长子结点的rightSib找到它的二弟，接着一直下去，直到找到具体的孩子。</p><h2 id="6-5-二叉树的定义"><a href="#6-5-二叉树的定义" class="headerlink" title="6.5 二叉树的定义"></a>6.5 二叉树的定义</h2><p><strong>二叉树（Binary Tree）是n（n≥0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</strong></p><h3 id="6-5-1-二叉树特点"><a href="#6-5-1-二叉树特点" class="headerlink" title="6.5.1 二叉树特点"></a>6.5.1 二叉树特点</h3><p>二叉树的特点有：</p><ul><li>每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。</li><li>左子树和右子树是有顺序的，次序不能任意颠倒。</li><li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。  </li></ul><p>二叉树具有五种基本形态：</p><ol><li>空二叉树。</li><li>只有一个根结点。</li><li>根结点只有左子树。</li><li>根结点只有右子树。</li><li>根结点既有左子树又有右子树。</li></ol><h3 id="6-5-2-特殊二叉树"><a href="#6-5-2-特殊二叉树" class="headerlink" title="6.5.2 特殊二叉树"></a>6.5.2 特殊二叉树</h3><p>一、斜树:所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p><p>二、满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。<br>满二叉树的特点有：</p><ul><li>叶子只能出现在最下一层。出现在其他层就不可能达成平衡。</li><li>非叶子结点的度一定是2。否则就是“缺胳膊少腿”了。</li><li>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li></ul><p>三、完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。<br>完全二叉树的特点：</p><ol><li>叶子结点只能出现在最下两层。</li><li>最下层的叶子一定集中在左部连续位置。</li><li>倒数二层，若有叶子结点，一定都在右部连续位置。</li><li>如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。</li><li>同样结点数的二叉树，完全二叉树的深度最小。</li></ol><h2 id="6-6-二叉树的性质"><a href="#6-6-二叉树的性质" class="headerlink" title="6.6 二叉树的性质"></a>6.6 二叉树的性质</h2><p>二叉树有一些需要理解并记住的特性，以便于我们更好地使用它。</p><h3 id="6-6-1-二叉树性质1"><a href="#6-6-1-二叉树性质1" class="headerlink" title="6.6.1 二叉树性质1"></a>6.6.1 二叉树性质1</h3><p>性质1：在二叉树的第i层上至多有2<sup>i-1</sup>个结点（i≥1）。</p><h3 id="6-6-2-二叉树性质2"><a href="#6-6-2-二叉树性质2" class="headerlink" title="6.6.2 二叉树性质2"></a>6.6.2 二叉树性质2</h3><p>性质2：深度为k的二叉树至多有$2^k-1$个结点（k≥1）。</p><h3 id="6-6-3-二叉树性质3"><a href="#6-6-3-二叉树性质3" class="headerlink" title="6.6.3 二叉树性质3"></a>6.6.3 二叉树性质3</h3><p>性质3：对任何一棵二叉树T，如果其叶子结点数为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1。  </p><h3 id="6-6-4-二叉树性质4"><a href="#6-6-4-二叉树性质4" class="headerlink" title="6.6.4 二叉树性质4"></a>6.6.4 二叉树性质4</h3><p>性质4：具有n个结点的完全二叉树的深度为[log<sub>2</sub>n]+1（[x]表示不大于x的最大整数）。</p><h3 id="6-6-5-二叉树性质5"><a href="#6-6-5-二叉树性质5" class="headerlink" title="6.6.5 二叉树性质5"></a>6.6.5 二叉树性质5</h3><p>性质5：如果对一棵有n个结点的完全二叉树（其深度为[log<sub>2</sub>n]+1）的结点按层序编号（从第1层到第[log<sub>2</sub>n]+1层，每层从左到右），对任一结点i（1≤i≤n）有：</p><ol><li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点[i/2]。</li><li>如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。</li><li>如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1。</li></ol><h2 id="6-7-二叉树的存储结构"><a href="#6-7-二叉树的存储结构" class="headerlink" title="6.7 二叉树的存储结构"></a>6.7 二叉树的存储结构</h2><h3 id="6-7-1-二叉树顺序存储结构"><a href="#6-7-1-二叉树顺序存储结构" class="headerlink" title="6.7.1 二叉树顺序存储结构"></a>6.7.1 二叉树顺序存储结构</h3><p>二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系。<br>所以用来表示完全二叉树比较好。由于它定义的严格，所以用顺序结构也可以表现出二叉树的结构来。<br>当然对于一般的二叉树，尽管层序编号不能反映逻辑关系，但是可以将其按完全二叉树编号，只不过，把不存在的结点设置为“^”而已。如图6-7-3所示，浅色结点表示不存在。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-7-3.JPG?raw=true" alt="6-7-3"><br>但是对于一般二叉树，一棵深度为k的右斜树，它只有k个结点，却需要分配$2^k$-1个存储单元空间，这显然是对存储空间的浪费。<br>所以，顺序存储结构一般只用于完全二叉树。  </p><h3 id="6-7-2-二叉链表"><a href="#6-7-2-二叉链表" class="headerlink" title="6.7.2 二叉链表"></a>6.7.2 二叉链表</h3><p>链式存储结构中。二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。结点结构图如表格6-7-1所示。<br>lChild|data|rChild|<br>–|–|–<br>其中data是数据域，lChild和rChild都是指针域，分别存放指向左孩子和右孩子的指针。<br>以下是我们的二叉链表的结点结构定义代码。</p><pre><code class="c">typedef struct BiTNode  /* 结点结构 */{   TElemType data;    /* 结点数据 */   struct BiTNode *lchild,*rchild; /* 左右孩子指针 */}BiTNode,*BiTree;</code></pre><p>就如同树的存储结构中讨论的一样，如果有需要，还可以再增加一个指向其双亲的指针域，那样就称之为三叉链表。  </p><h2 id="6-8遍历二叉树"><a href="#6-8遍历二叉树" class="headerlink" title="6.8遍历二叉树"></a>6.8遍历二叉树</h2><h3 id="6-8-1二叉树遍历原理"><a href="#6-8-1二叉树遍历原理" class="headerlink" title="6.8.1二叉树遍历原理"></a>6.8.1二叉树遍历原理</h3><p>二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。  </p><h3 id="6-8-2二叉树遍历方法"><a href="#6-8-2二叉树遍历方法" class="headerlink" title="6.8.2二叉树遍历方法"></a>6.8.2二叉树遍历方法</h3><p>二叉树的遍历方式可以很多，如果我们限制了从左到右的习惯方式，那么主要就分为四种：  </p><ol><li><p>前序遍历-根左右<br>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</p></li><li><p>中序遍历-左根右<br>规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。</p></li><li><p>后序遍历-左右根<br>规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。</p></li><li><p>层序遍历<br>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p></li></ol><p>技巧：每个结点单独看。比如后序遍历，每个右结点的左边是该结点的左节点，右边必然是对应的根结点。</p><h3 id="6-8-3-前序遍历算法"><a href="#6-8-3-前序遍历算法" class="headerlink" title="6.8.3 前序遍历算法"></a>6.8.3 前序遍历算法</h3><p>二叉树的定义是用递归的方式，所以，实现遍历算法也可以采用递归，而且极其简洁明了。先来看看二叉树的前序遍历算法。代码如下：  </p><pre><code class="c">/* 二叉树的前序遍历递归算法 */void PreOrderTraverse(BiTree T){    if (T == NULL)        return;    printf(&quot;%c&quot;, T-&gt;data); /* 显示结点数据，可以更改为其它对结点操作 */    PreOrderTraverse(T-&gt;lchild); /* 再先序遍历左子树 */    PreOrderTraverse(T-&gt;rchild); /* 最后先序遍历右子树 */}</code></pre><h3 id="6-8-4-中序遍历算法"><a href="#6-8-4-中序遍历算法" class="headerlink" title="6.8.4 中序遍历算法"></a>6.8.4 中序遍历算法</h3><p>二叉树的中序遍历算法和前序遍历算法仅仅只是代码的顺序上的差异。</p><pre><code class="c">/* 二叉树的中序遍历递归算法 */void InOrderTraverse(BiTree T){    if (T == NULL)        return;    InOrderTraverse(T-&gt;lchild); /* 中序遍历左子树 */    printf(&quot;%c&quot;, T-&gt;data);/* 显示结点数据，可以更改为其它对结点操作 */    InOrderTraverse(T-&gt;rchild); /* 最后中序遍历右子树 */}</code></pre><h3 id="6-8-5后序遍历算法"><a href="#6-8-5后序遍历算法" class="headerlink" title="6.8.5后序遍历算法"></a>6.8.5后序遍历算法</h3><p>那么同样的，后序遍历也就很容易想到应该如何写代码了。</p><pre><code class="c">/* 二叉树的后序遍历递归算法 */void PostOrderTraverse(BiTree T){    if (T == NULL)        return;    PostOrderTraverse(T-&gt;lchild); /* 先后序遍历左子树  */    PostOrderTraverse(T-&gt;rchild); /* 再后序遍历右子树  */    printf(&quot;%c&quot;, T-&gt;data);/* 显示结点数据，可以更改为其它对结点操作 */}</code></pre><h3 id="6-8-6-推导遍历结果"><a href="#6-8-6-推导遍历结果" class="headerlink" title="6.8.6 推导遍历结果"></a>6.8.6 推导遍历结果</h3><p>题目是这样：二叉树的中序序列是ABCDEFG，后序序列是BDCAFGE，求前序序列。<br>这次简单点，由后序的BDCAFG E，得到E是根结点，因此前序首字母是E。<br>于是根据中序序列分为两棵树ABCD和FG，由后序序列的BDCA FGE，知道A是E的左孩子，前序序列目前分析为EA。<br>再由中序序列的A BCDEFG，知道BCD是A结点的右子孙，再由后序序列的BDC AFGE知道C结点是A结点的右孩子，前序序列目前分析得到EAC。<br>中序序列AB C DEFG，得到B是C的左孩子，D是C的右孩子，所以前序序列目前分析结果为EACBD。<br>由后序序列BDCAF G E，得到G是E的右孩子，于是F就是G的孩子。前序遍历序列的最终结果就是EACBDGF。  </p><p>两个二叉树遍历的性质。</p><ul><li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li><li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li></ul><p>但要注意了，已知前序和后序遍历，是不能确定一棵二叉树的，原因也很简单，比如前序序列是ABC，后序序列是CBA。我们可以确定A一定是根结点，但接下来，我们无法知道，哪个结点是左子树，哪个是右子树。这棵树可能有如图6-8-24所示的四种可能。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-8-24.JPG?raw=true" alt="6-8-24">  </p><h2 id="6-9-二叉树的建立"><a href="#6-9-二叉树的建立" class="headerlink" title="6.9 二叉树的建立"></a>6.9 二叉树的建立</h2><p>如果我们要在内存中建立一个二叉树，为了能让每个结点确认是否有左右孩子，我们对它进行了扩展，也就是将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，比如“#”。我们称这种处理后的二叉树为原二叉树的扩展二叉树。扩展二叉树就可以做到一个遍历序列确定一棵二叉树了。<br>前序遍历序列生成二叉树的代码如下：</p><pre><code class="c">/* 按前序输入二叉树中结点的值（一个字符） *//* #表示空树，构造二叉链表表示二叉树T。 */void CreateBiTree(BiTree *T){    TElemType ch;    /* scanf(&quot;%c&quot;,&amp;ch); */    ch = str[index++];    if (ch == &#39;#&#39;)        *T = NULL;    else    {        *T = (BiTree)malloc(sizeof(BiTNode));        if (!*T)            exit(OVERFLOW);        (*T)-&gt;data = ch; /* 生成根结点 */        CreateBiTree(&amp;(*T)-&gt;lchild); /* 构造左子树 */        CreateBiTree(&amp;(*T)-&gt;rchild); /* 构造右子树 */    }}</code></pre><p>当然，你完全也可以用中序或后序遍历的方式实现二叉树的建立，只不过代码里生成结点和构造左右子树的代码顺序交换一下。另外，输入的字符也要做相应的更改。</p><h2 id="6-10-线索二叉树"><a href="#6-10-线索二叉树" class="headerlink" title="6.10 线索二叉树"></a>6.10 线索二叉树</h2><h3 id="6-10-1-线索二叉树原理"><a href="#6-10-1-线索二叉树原理" class="headerlink" title="6.10.1 线索二叉树原理"></a>6.10.1 线索二叉树原理</h3><p><strong>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）。</strong><br>其实线索二叉树，等于是把一棵二叉树转变成了一个双向链表，这样对我们的插入删除结点、查找某个结点都带来了方便。所以<strong>我们对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化</strong>。<br>但是变为线索二叉树，我们并不知道某个结点的lChild是指向它的左孩子还是指向前驱…<br>因此，我们在每个结点再增设两个标志域lTag和rTag，注意lTag和rTag只是存放0或1数字的布尔型变量，其占用的内存空间要小于像lchild和rchild的指针变量。结点结构如下表所示。<br>lChild|lTag|data|rTag|rChild<br>-|-|-|-|-<br>其中：</p><ul><li>lTag为0时指向该结点的左孩子，为1时指向该结点的前驱。</li><li>rTag为0时指向该结点的右孩子，为1时指向该结点的后继。</li></ul><h3 id="6-10-2-线索二叉树结构实现"><a href="#6-10-2-线索二叉树结构实现" class="headerlink" title="6.10.2 线索二叉树结构实现"></a>6.10.2 线索二叉树结构实现</h3><p>由此二叉树的线索存储结构定义代码如下：</p><pre><code class="c">/* 二叉树的二叉线索存储结构定义 */typedef enum { Link, Thread } PointerTag; /* Link==0表示指向左右孩子指针, */                                          /* Thread==1表示指向前驱或后继的线索 */typedef  struct BiThrNode                 /* 二叉线索存储结点结构 */{    TElemType data;    /* 结点数据 */    struct BiThrNode *lchild, *rchild;    /* 左右孩子指针 */    PointerTag LTag;    PointerTag RTag;        /* 左右标志 */} BiThrNode, *BiThrTree;</code></pre><p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以<strong>线索化的过程就是在遍历的过程中修改空指针的过程</strong>。<br>中序遍历线索化的递归函数代码如下：</p><pre><code class="c">BiThrTree pre; /* 全局变量,始终指向刚刚访问过的结点 *//* 中序遍历进行中序线索化 */void InThreading(BiThrTree p){    if (p)    {        InThreading(p-&gt;lchild); /* 递归左子树线索化 */        if (!p-&gt;lchild) /* 没有左孩子 */        {            p-&gt;LTag = Thread; /* 前驱线索 */            p-&gt;lchild = pre; /* 左孩子指针指向前驱 */        }        if (!pre-&gt;rchild) /* 前驱没有右孩子 */        {            pre-&gt;RTag = Thread; /* 后继线索 */            pre-&gt;rchild = p; /* 前驱右孩子指针指向后继(当前结点p) */        }        pre = p; /* 保持pre指向p的前驱 */        InThreading(p-&gt;rchild); /* 递归右子树线索化 */    }}</code></pre><p>if（!p-&gt;lChild）表示如果某结点的左指针域为空，因为其前驱结点刚刚访问过，赋值给了pre，所以可以将pre赋值给p-&gt;lChild，并修改p-&gt;LTag=Thread（也就是定义为1）以完成前驱结点的线索化。<br>后继就要稍稍麻烦一些。因为此时p结点的后继还没有访问到，因此只能对它的前驱结点pre的右指针rchild做判断，if（!pre-&gt;rchild）表示如果为空，则p就是pre的后继，于是pre-&gt;rchild=p，并且设置pre-&gt;RTag=Thread，完成后继结点的线素化。<br>完成前驱和后继的判断后，别忘记将当前的结点p赋值给pre，以便于下一次使用。<br>有了线索二叉树后，我们对它进行遍历时发现，其实就等于是操作一个双向链表结构。<br>和双向链表结构一样，在二叉树线素链表上添加一个头结点，如图6-10-6所示，并令其lchild域的指针指向二叉树的根结点（图中的①），其rchild域的指针指向中序遍历时访问的最后一个结点（图中的②）。反之，令二叉树的中序序列中的第一个结点中，lchild 域指针和最后一个结点的rchild 域指针均指向头结点（图中的③和④）。这样定义的好处就是我们既可以从第一个结点起顺后继进行遍历，也可以从最后一个结点起顺前驱进行遍历。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-10-6.JPG?raw=true" alt="6-10-6">  </p><p>遍历的代码如下：</p><pre><code class="c">/*T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的*//*最后一个结点。中序遍历二叉线索链表表示的二叉树T*/Status InOrderTraverse_Thr(BiThrTree T){    BiThrTree p;    p = T-&gt;lchild; /* p指向根结点 */    while (p != T) /* 空树或遍历结束时，p==T */    { /* 空树或遍历结束时,p==T */        while (p-&gt;LTag == Link) /*当LTag==0时循环到中序序列第一个结点 */            p = p-&gt;lchild;        printf(&quot;%c&quot;,p-&gt;data); /* 显示结点数据，可以更改为其他对结点操作 */        while (p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != T)        {            p = p-&gt;rchild;            printf(&quot;%c&quot;,p-&gt;data);        }        p = p-&gt;rchild; /* p进至其右子树根 */    }    return OK;}</code></pre><p>从这段代码也可以看出，它等于是一个链表的扫描，所以时间复杂度为O(n)。<br>由于它充分利用了空指针域的空间（这等于节省了空间），又保证了创建时的一次遍历就可以终生受用前驱后继的信息（这意味着节省了时间）。所以在实际问题中，<strong>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择</strong>。</p><h2 id="6-11-树、森林与二叉树的转换"><a href="#6-11-树、森林与二叉树的转换" class="headerlink" title="6.11 树、森林与二叉树的转换"></a>6.11 树、森林与二叉树的转换</h2><h3 id="6-11-1-树转换为二叉树"><a href="#6-11-1-树转换为二叉树" class="headerlink" title="6.11.1 树转换为二叉树"></a>6.11.1 树转换为二叉树</h3><p>将树转换为二叉树的步骤如下</p><ol><li>加线。在所有兄弟结点之间加一条连线。</li><li>去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。</li><li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</li></ol><h3 id="6-11-2-森林转换为二叉树"><a href="#6-11-2-森林转换为二叉树" class="headerlink" title="6.11.2 森林转换为二叉树"></a>6.11.2 森林转换为二叉树</h3><p>森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。步骤如下：</p><ol><li>把每个树转换为二叉树。</li><li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。</li></ol><h3 id="6-11-3-二叉树转换为树"><a href="#6-11-3-二叉树转换为树" class="headerlink" title="6.11.3 二叉树转换为树"></a>6.11.3 二叉树转换为树</h3><p>二叉树转换为树是树转换为二叉树的逆过程，也就是反过来做而已。如图6-11-4所示。步骤如下：</p><ol><li>加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……哈，反正就是左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。</li><li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li><li>层次调整。使之结构层次分明。</li></ol><p><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-11-4.JPG?raw=true" alt="6-11-4"></p><h3 id="6-11-4-二叉树转换为森林"><a href="#6-11-4-二叉树转换为森林" class="headerlink" title="6.11.4 二叉树转换为森林"></a>6.11.4 二叉树转换为森林</h3><p>判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。<br>那么如果是转换成森林，步骤如下：</p><ol><li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。</li><li>再将每棵分离后的二叉树转换为树即可。</li></ol><p><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-11-5.JPG?raw=true" alt="6-11-5"></p><h3 id="6-11-5-树与森林的遍历"><a href="#6-11-5-树与森林的遍历" class="headerlink" title="6.11.5 树与森林的遍历"></a>6.11.5 树与森林的遍历</h3><p>树的遍历分为两种方式。</p><ol><li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。</li><li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。比如图6-11-4中最右侧的树，它的先根遍历序列为ABEFCDG，后根遍历序列为EFBCGDA。</li></ol><p>森林的遍历也分为两种方式：</p><ol><li>前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。比如图6-11-5右侧三棵树的森林，前序遍历序列的结果就是ABCDEFGHJI。</li><li>后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。比如图6-11-5右侧三棵树的森林，后序遍历序列的结果就是BCDAFEJHIG。</li></ol><p>可如果我们对二叉树进行分析就会发现，森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。<br>这也就告诉我们，当以二叉链表作树的存储结构时，树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现。这其实也就证实，我们找到了对树和森林这种复杂问题的简单解决办法。  </p><h2 id="6-12-赫夫曼树及其应用"><a href="#6-12-赫夫曼树及其应用" class="headerlink" title="6.12 赫夫曼树及其应用"></a>6.12 赫夫曼树及其应用</h2><h3 id="6-12-1-赫夫曼树"><a href="#6-12-1-赫夫曼树" class="headerlink" title="6.12.1 赫夫曼树"></a>6.12.1 赫夫曼树</h3><p>压缩软件如何做到压缩而不出错的呢？简单说，就是把我们要压缩的文本进行重新编码，以减少不必要的空间。我们今天就来介绍一下最基本的压缩编码方法——赫夫曼编码。<br>由美国数学家赫夫曼（David Huffman）在1952年发明了赫夫曼编码。他在编码中用到的特殊的二叉树称之为赫夫曼树，他的编码方法称为赫夫曼编码。  </p><h3 id="6-12-2-赫夫曼树定义与原理"><a href="#6-12-2-赫夫曼树定义与原理" class="headerlink" title="6.12.2 赫夫曼树定义与原理"></a>6.12.2 赫夫曼树定义与原理</h3><p><strong>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度。</strong><br><strong>树的路径长度就是从树根到每一结点的路径长度之和。</strong><br>如果考虑到带权的结点，结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。假设有n个权值{w1，w2，…，Wn}，构造一棵有n个叶子结点的二叉树，每个叶子结点带权Wk，每个叶子的路径长度为lk，我们通常记作，则其中<strong>带权路径长度WPL最小的二叉树称做赫夫曼树</strong>。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-12-4.JPG?raw=true" alt="6-12-4"><br>有了赫夫曼对带权路径长度的定义，我们来计算一下图6-12-4这两棵树的WPL值。<br>二叉树a的WPL=5×1+15×2+40×3+30×4+10×4=315<br>注意：这里5是A结点的权，1是A结点的路径长度，其他同理。<br>二叉树b的WPL=5×3+15×3+40×2+30×2+10×2=220<br>参考图6-12-4的二叉树b，最优赫夫曼树的解法如下：</p><ol><li>先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即：A5，E10，B15，D30，C40。</li><li>取头两个最小权值的结点作为一个新节点N1的两个子结点，注意相对较小的是左孩子，这里就是A为N1的左孩子，E为N1的右孩子，如图6-12-5所示。新结点的权值为两个叶子权值的和5+10=15。</li><li>将N1替换A与E，插入有序序列中，保持从小到大排列。即：N1 15，B15，D30，C40。</li><li>重复步骤2。将N1与B作为一个新节点N2的两个子结点。如图6-12-6所示。N2的权值=15+15=30。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-12-5.JPG?raw=true" alt="6-12-5"></li><li>将N2替换N1与B，插入有序序列中，保持从小到大排列。即：N2 30，D30，C40。</li><li>重复步骤2。将N2与D作为一个新节点N3的两个子结点。如图6-12-7所示。N3的权值=30+30=60。</li><li>将N3替换N2与D，插入有序序列中，保持从小到大排列。即：C40，N3 60。</li><li>重复步骤2。将C与N3作为一个新节点T的两个子结点，如图6-12-8所示。由于T即是根结点，完成赫夫曼树的构造。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-12-7.JPG?raw=true" alt="6-12-7">  </li></ol><p>此时的图6-12-8二叉树的带权路径长度WPL=40×1+30×2+15×3+10×4+5×4=205。与图6-12-4的二叉树b的WPL值220相比，还少了15。显然此时构造出来的二叉树才是最优的赫夫曼树。<br>通过刚才的步骤，我们可以得出构造赫夫曼树的赫夫曼算法描述。</p><ol><li>根据给定的n个权值{w1，W2，…，Wn}构成n棵二叉树的集合F={T1，T2，…，Tn}，其中每棵二叉树Ti中只有一个带权为wi根结点，其左右子树均为空。</li><li>在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li><li>在F中删除这两棵树，同时将新得到的二叉树加入F中。</li><li>重复2和3步骤，直到F只含一棵树为止。这棵树便是赫夫曼树。</li></ol><h3 id="6-12-3-赫夫曼编码"><a href="#6-12-3-赫夫曼编码" class="headerlink" title="6.12.3 赫夫曼编码"></a>6.12.3 赫夫曼编码</h3><p>按照不同字母出现的频率重新按照赫夫曼树来规划它们。将规划出来的树权值左分支改为0，右分支改为1后。对字母从树根到叶子所经过路径的0或1来编码，可以看出结果串变小了，编码得到了压缩，节约了存储和传输成本。<br>当我们接收到压缩过的新编码时，我们应该如何把它解码出来呢？<br>编码中非0即1，长短不等的话其实是很容易混淆的，所以<strong>若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称做前缀编码</strong>。<br>可仅仅是这样不足以让我们去方便地解码的，因此在解码时，还是要用到赫夫曼树，即发送方和接收方必须要约定好同样的赫夫曼编码规则。<br><strong>一般地，设需要编码的字符集为{d1，d2，…，dn}，各个字符在电文中出现的次数或频率集合为{W1，w2，…，Wn}，以d1，d2，…，dn作为叶子结点，以w1，W2，Wn作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是赫夫曼编码</strong>。  </p><h2 id="6-13-总结回顾"><a href="#6-13-总结回顾" class="headerlink" title="6.13 总结回顾"></a>6.13 总结回顾</h2><p>终于到了总结的时间，这一章与前面章节相比，显得过于庞大了些，原因也就在于树的复杂性和变化丰富度是前面的线性表所不可比拟的。即使在本章之后，我们还要讲解关于树这一数据结构的相关知识，可见它的重要性。<br>开头我们提到了树的定义，讲到了递归在树定义中的应用。提到了如子树、结点、度、叶子、分支结点、双亲、孩子、层次、深度、森林等诸多概念，这些都是需要在理解的基础上去记忆的。<br>我们谈到了树的存储结构时，讲了双亲表示法、孩子表示法、孩子兄弟表示法等不同的存储结构。<br>并由孩子兄弟表示法引出了我们这章中最重要一种树，二叉树。<br>二叉树每个结点最多两棵子树，有左右之分。提到了斜树，满二叉树、完全二叉树等特殊二叉树的概念。<br>我们接着谈到它的各种性质，这些性质给我们研究二叉树带来了方便。<br>二叉树的存储结构由于其特殊性使得既可以用顺序存储结构又可以用链式存储结构表示。<br>遍历是二叉树最重要的一门学问，前序、中序、后序以及层序遍历都是需要熟练掌握的知识。要让自己要学会用计算机的运行思维去模拟递归的实现，可以加深我们对递归的理解。不过，并非二叉树遍历就一定要用到递归，只不过递归的实现比较优雅而已。这点需要明确。<br>二叉树的建立自然也是可以通过递归来实现。<br>研究中也发现，二叉链表有很多浪费的空指针可以利用，查找某个结点的前驱和后继为什么非要每次遍历才可以得到，这就引出了如何构造一棵线索二叉树的问题。<br>线索二叉树给二叉树的结点查找和遍历带来了高效率。<br>树、森林看似复杂，其实它们都可以转化为简单的二叉树来处理，我们提供了树、森林与二叉树的互相转换的办法，这样就使得面对树和森林的数据结构时，编码实现成为了可能。<br>最后，我们提到了关于二叉树的一个应用，赫夫曼树和赫夫曼编码，对于带权路径的二叉树做了详尽地讲述，让你初步理解数据压缩的原理，并明白其是如何做到无损编码和无错解码的。  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;6-1-6-2-树的定义&quot;&gt;&lt;a href=&quot;#6-1-6-2-树的定义&quot; class=&quot;headerlink&quot; title=&quot;6.1-6.2 树的定义&quot;&gt;&lt;/a&gt;6.1-6.2 树的定义&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;树(Tree)是n(n≥0)个结点的有限集。n=0时称为空树。在任意一棵非空树中：1)有且仅有一个特定的称为根(Root)的结点；2)当n&amp;gt;1时，其余结点可分为m(m&amp;gt;0)个互不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。&lt;/strong&gt;&lt;br&gt;对于树的定义还需要强调两点：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;n&amp;gt;0时根结点是唯一的，不可能存在多个根结点，数据结构中的树是只能有一个根结点。&lt;/li&gt;
&lt;li&gt;m&amp;gt;0时，子树的个数没有限制，但它们一定是互不相交的。
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="https://closer_laps.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构第五章 串</title>
    <link href="https://closer_laps.gitee.io/2019/12/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC5%E7%AB%A0%20%E4%B8%B2/"/>
    <id>https://closer_laps.gitee.io/2019/12/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC5%E7%AB%A0%20%E4%B8%B2/</id>
    <published>2019-12-25T11:26:12.000Z</published>
    <updated>2019-12-29T03:38:57.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5-1-5-2-串的定义"><a href="#5-1-5-2-串的定义" class="headerlink" title="5.1-5.2 串的定义"></a>5.1-5.2 串的定义</h2><p>串(string)是由零个或多个字符组成的有限序列，又名叫字符串。<br>一般记为s=“a1a2……an”(n&gt;0)，其中，s是串的名称，用双引号(有些书中也用单引号)括起来的字符序列是串的值，注意单引号不属于串的内容。ai(1≤i≤n)可以是字母、数字或其他字符，i就是该字符在串中的位置。串中的字符数目n称为串的长度，定义中谈到“有限”是指长度n是一个有限的数值。零个字符的串称为空串(null string)，它的长度为零，可以直接用两双引号“”””表示，也可以用希腊字母“Φ”来表示。所谓的序列，说明串的相邻字符之间具有前驱和后继的关系。<br>还有一些概念需要解释：  </p><a id="more"></a><ul><li>空格串，是只包含空格的串。注意它与空串的区别，空格串是有内容有长度的，而且可以不止一个空格。</li><li>子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。</li><li>子串在主串中的位置就是子串的第一个字符在主串中的序号。</li></ul><p>开头我所提到的“over”、“end”、“lie”其实可以认为是“over”、“friend”、“believe”这些单词字符串的子串。  </p><h2 id="5-3-串的比较"><a href="#5-3-串的比较" class="headerlink" title="5.3 串的比较"></a>5.3 串的比较</h2><p>两个字符串的长度以及它们每个位置各个对应位置的字符都相等时，才算是相等。<br>那么对于两个串不相等时，如何判定它们的大小呢。我们这样定义：<br>给定两个串：s=“a1a2……an”，t=“b1b2……bm”，当满足以下条件之一时，<code>s&lt;t</code>。</p><ol><li><code>n&lt;m</code>，且ai=bi(i=1，2，…，n)。<br>例如当s=“hap”，t=“happy”，就有sst。因为t比s多出了两个字母。</li><li>存在某个<code>k&lt;min(m，n)</code>，使得ai=bi；(i=1，2，……，k-1)，<code>ak&lt;bk</code>。<br>例如当s=“happen”，t=“happy”，因为两串的前4个子母均相同，间内串第5个字母(k值)，字母e的ASCII码是101，而字母y的ASCII码是121，显然<code>e&lt;y</code>，所以<code>s&lt;t</code>。</li></ol><h2 id="5-4-串的抽象数据类型"><a href="#5-4-串的抽象数据类型" class="headerlink" title="5.4 串的抽象数据类型"></a>5.4 串的抽象数据类型</h2><pre><code class="c">ADT 串(string)Data  串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。Operation  strAssign(T，*chars)：生成一个其值等于字符串常量chars的串T。  StrCopy(T，S)：串S存在，由串S复制得串T。  ClearString(S)：串S存在，将串清空。  StringEmpty(S)；若串S为空，返回true，否则返回false。  StrLength(S)：返回串S的元素个数，即串的长度。  StrCompare(S，T)：若S&gt;T，返回值&gt;0，若S=T，返回0，若S&lt;T，返回值&lt;0。  Concat(T，S1，S2)：用T返回由S1和S2联接而成的新串。  SubString(Sub，S，pos，len)：串S存在，1≤pos≤StrLength(S)，且0≤len≤StrLength(S)-pos+1，用Sub返回串S的第pos个字符起长度为len的子串。  Index(S，T，pos)：串S和T存在，T是非空串，1≤pos≤StrLength(S)。若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回0。  Replace(S，T，V)：串S、T和v存在，T是非空串。用V替换主串S中出现的所有与T相等的不重叠的子串。  StrInsert(S，pos，T)：串s和T存在，1≤pos≤StrLength(S)+1。在串S的第pos个字符之前插入串T。  StrDelete(S，pos，len)：串S存在，1≤pos≤StrLength(S)-len+1。从串S中删除第pos个字符起长度为len的子串。endADT</code></pre><h2 id="5-5-串的存储结构"><a href="#5-5-串的存储结构" class="headerlink" title="5.5 串的存储结构"></a>5.5 串的存储结构</h2><p>串的存储结构与线性表相同，分为两种。  </p><h3 id="5-5-1-串的顺序存储结构"><a href="#5-5-1-串的顺序存储结构" class="headerlink" title="5.5.1 串的顺序存储结构"></a>5.5.1 串的顺序存储结构</h3><p>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义。<br>既然是定长数组，就存在一个预定义的最大串长度，一般可以将实际的串长度值保存在数组的0下标位置，有的书中也会定义存储在数组的最后一个下标位置。但也有些编程语言不想这么干，觉得存个数字占个空间麻烦。它规定在串值后面加一个不计入串长度的结束标记字符，比如“\0”来表示串值的终结，这个时候，你要想知道此时的串长度，就需要遍历计算一下才知道了，其实这还是需要占用一个空间，何必呢。</p><h3 id="5-5-2-串的链式存储结构"><a href="#5-5-2-串的链式存储结构" class="headerlink" title="5.5.2 串的链式存储结构"></a>5.5.2 串的链式存储结构</h3><p>对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用“#”或其他非串值字符补全，如图5-5-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/5-5-3.JPG?raw=true" alt="5-5-3"><br>当然，这里一个结点存多少个字符才合适就变得很重要，这会直接影响着串处理的效率，需要根据实际情况做出选择。<br>但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。  </p><h2 id="5-6-朴素的模式匹配算法-暴力算法匹配"><a href="#5-6-朴素的模式匹配算法-暴力算法匹配" class="headerlink" title="5.6 朴素的模式匹配算法(暴力算法匹配)"></a>5.6 朴素的模式匹配算法(暴力算法匹配)</h2><p>子串的定位操作通常称做串的模式匹配，也算是串中最重要的操作之一。<br>用基本的数组来实现朴素的模式匹配算法。我们假设主串S和要匹配的子串T的长度存在S[0]与T[0]中。实现代码如下：  </p><pre><code class="c">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在,则函数返回值为0。 *//* 其中,T非空,1≤pos≤StrLength(S)。 */int Index(String S, String T, int pos){    int i = pos;    /* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */    int j = 1;                /* j用于子串T中当前位置下标值 */    while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */    {        if (S[i] == T[j])     /* 两字母相等则继续 */          {            ++i;            ++j;          }          else                 /* 指针后退重新开始匹配 */          {               i = i-j+2;        /* i退回到上次匹配首位的下一位 */             j = 1;             /* j退回到子串T的首位 */          }    }    if (j &gt; T[0])        return i-T[0];    else        return 0;}</code></pre><p>非最坏情况下，只需要匹配2个串的首字母，所以根据等概率原则，平均是(n+m)/2次查找，时间复杂度为O(n+m)。<br>而最坏情况就是0000000000000000001，此时时间复杂度为O((n-m+1)*m)。  </p><h2 id="5-7-KMP-模式匹配算法"><a href="#5-7-KMP-模式匹配算法" class="headerlink" title="5.7 KMP 模式匹配算法"></a>5.7 KMP 模式匹配算法</h2><p>有三位前辈，D.E.Knuth、J.H.Morris 和V.R.Pratt（其中Knuth和Pratt 共同研究，Morris独立研究）发表一个模式匹配算法，可以大大避免重复遍历的情况，我们把它称之为克努特一莫里斯一普拉特算法，简称KMP算法。  </p><h3 id="5-7-1-KMP模式匹配算法原理"><a href="#5-7-1-KMP模式匹配算法原理" class="headerlink" title="5.7.1 KMP模式匹配算法原理"></a>5.7.1 KMP模式匹配算法原理</h3><p>首先要理解上面的朴素模式的匹配算法，主串设为S，要匹配的模式串设为T。<br>对于在子串中有与首字符相等的字符，也是可以省略一部分不必要的判断步骤。<br>我们在朴素的模式匹配算法中，主串的i值是不断地回溯来完成的。而我们的分析发现，这种回溯其实是可以不需要的，我们的KMP模式匹配算法就是为了让这没必要的回溯不发生。<br>既然i值不回溯，也就是不可以变小，那么要考虑的变化就是j(j在模式串中所在的位置)值了。通过观察也可发现，我们屡屡提到了T串的首字符与自身后面字符的比较，发现如果有相等字符，j(j在模式串中所在的位置)值的变化就会不相同。也就是说，这个j(j在模式串中所在的位置)值的变化与主串其实没什么关系，关键就取决于T串的结构中是否有重复的问题。<br>我们可以得出规律，j(j在模式串中所在的位置)值的多少取决于当前字符之前的串的前后缀的相似度。<br>我们把T串各个位置的j(j在模式串中所在的位置)值的变化定义为一个数组next，那么next的长度就是T串的长度。于是我们可以得到下面的函数定义：<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/5-7-6.JPG?raw=true" alt="5-7-6"></p><h3 id="5-7-2-next数组值推导"><a href="#5-7-2-next数组值推导" class="headerlink" title="5.7.2 next数组值推导"></a>5.7.2 next数组值推导</h3><p>“前缀”指除了最后一个字符以外，一个字符串的全部头部组合；<br>“后缀”指除了第一个字符以外，一个字符串的全部尾部组合。<br>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例，</p><ul><li>“A”的前缀和后缀都为空集，共有元素的长度为0；</li><li>“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</li><li>“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</li><li>“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</li><li>“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</li><li>“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</li><li>“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。  </li></ul><p>我们可以根据经验得到:如果前缀后缀最长共有元素的长度为1，k值是2，最长的共有元素的长度为2，k值是3。<br><strong>最长的共有元素的长度为n，k值就是n+1</strong>。  </p><h3 id="5-7-3KMP模式匹配算法实现"><a href="#5-7-3KMP模式匹配算法实现" class="headerlink" title="5.7.3KMP模式匹配算法实现"></a>5.7.3KMP模式匹配算法实现</h3><p>next代码如下：</p><pre><code class="c">/* 通过计算返回子串T的next数组。 */void get_next(String T, int *next){    int i, j;    i = 1;    j = 0;    next[1] = 0;    while (i &lt; T[0])  /* 此处T[0]表示串T的长度 */    {        if (j == 0 || T[i] == T[j])     /* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */        {            ++i;            ++j;            next[i] = j;        }        else            j = next[j];    /* 若字符不相同，则j值回溯 */    }}</code></pre><p>这段代码的目的就是为了计算出当前要匹配的串T的next数组。  </p><pre><code class="c">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。 *//*  T非空，1≤pos≤StrLength(S)。 */int Index_KMP(String S, String T, int pos){    int i = pos;        /* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */    int j = 1;            /* j用于子串T中当前位置下标值 */    int next[255];        /* 定义一next数组 */    get_next(T, next);    /* 对串T作分析，得到next数组 */    while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */    {        if (j == 0 || S[i] == T[j])     /* 两字母相等则继续，与朴素算法增加了j=0判断 */        {            ++i;            ++j;        }        else             /* 指针后退重新开始匹配 */            j = next[j];/* j退回合适的位置，i值不变 */    }    if (j &gt; T[0])        return i - T[0];    else        return 0;}</code></pre><p>对于get_next函数来说，若模式串的长度为m，因只涉及到简单的单循环，其时间复杂度为O(m)，而由于i值的不回溯，使得indexKMP算法效率得到了提高，while 循环的时间复杂度为O(n)。因此，整个算法的时间复杂度为O(n+m)。相较于朴素模式匹配算法的O((n-m+1)*m)来说，是要好一些。  </p><h3 id="5-7-4-KMP模式匹配算法改进"><a href="#5-7-4-KMP模式匹配算法改进" class="headerlink" title="5.7.4 KMP模式匹配算法改进"></a>5.7.4 KMP模式匹配算法改进</h3><pre><code class="c">/* 求模式串T的next函数修正值并存入数组nextval */void get_nextval(String T, int *nextval){    int i, j;    i = 1;    j = 0;    nextval[1] = 0;    while (i &lt; T[0])  /* 此处T[0]表示串T的长度 */    {        if (j == 0 || T[i] == T[j])     /* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */        {            ++i;            ++j;            if (T[i] != T[j])      /* 若当前字符与前缀字符不同 */                nextval[i] = j;    /* 则当前的j为nextval在i位置的值 */            else                nextval[i] = nextval[j];    /* 如果与前缀字符相同，则将前缀字符的 */                                            /* nextval值赋值给nextval在i位置的值 */        }        else            j = nextval[j];            /* 若字符不相同，则j值回溯 */    }}</code></pre><h3 id="5-7-5-nextval-数组值推导"><a href="#5-7-5-nextval-数组值推导" class="headerlink" title="5.7.5 nextval 数组值推导"></a>5.7.5 nextval 数组值推导</h3><p>总结改进过的KMP算法，它是在计算出next值的同时，如果a位字符与它next值指向的b位字符相等，则该a位的nextval就指向b位的nextval值，如果不等，则该a位的nextval值就是它自己a位的next的值。  </p><h2 id="5-8-总结回顾"><a href="#5-8-总结回顾" class="headerlink" title="5.8 总结回顾"></a>5.8 总结回顾</h2><p>这一章节我们重点讲了“串”这样的数据结构，串（string）是由零个或多个字符组成的有限序列，又名叫字符串。本质上，它是一种线性表的扩展，但相对于线性表关注一个个元素来说，我们对串这种结构更多的是关注它子串的应用问题，如查找、替换等操作。现在的高级语言都有针对串的函数可以调用。我们在使用这些函数的时候，同时也应该要理解它当中的原理，以便于在碰到复杂的问题时，可以更加灵活的使用，比如KMP模式匹配算法的学习，就是更有效地去理解index函数当中的实现细节。  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;5-1-5-2-串的定义&quot;&gt;&lt;a href=&quot;#5-1-5-2-串的定义&quot; class=&quot;headerlink&quot; title=&quot;5.1-5.2 串的定义&quot;&gt;&lt;/a&gt;5.1-5.2 串的定义&lt;/h2&gt;&lt;p&gt;串(string)是由零个或多个字符组成的有限序列，又名叫字符串。&lt;br&gt;一般记为s=“a1a2……an”(n&amp;gt;0)，其中，s是串的名称，用双引号(有些书中也用单引号)括起来的字符序列是串的值，注意单引号不属于串的内容。ai(1≤i≤n)可以是字母、数字或其他字符，i就是该字符在串中的位置。串中的字符数目n称为串的长度，定义中谈到“有限”是指长度n是一个有限的数值。零个字符的串称为空串(null string)，它的长度为零，可以直接用两双引号“”””表示，也可以用希腊字母“Φ”来表示。所谓的序列，说明串的相邻字符之间具有前驱和后继的关系。&lt;br&gt;还有一些概念需要解释：  &lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="https://closer_laps.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>hexo next主题导航栏图标显示问号解决方案</title>
    <link href="https://closer_laps.gitee.io/2019/12/10/hexo/hexo-next%E4%B8%BB%E9%A2%98%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA%E9%97%AE%E5%8F%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://closer_laps.gitee.io/2019/12/10/hexo/hexo-next%E4%B8%BB%E9%A2%98%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA%E9%97%AE%E5%8F%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2019-12-10T02:46:08.000Z</published>
    <updated>2019-12-10T02:52:14.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>导航栏图标显示问号，当修改<code>hexo\themes\next\_config.yml</code>主题配置文件后，图标显示正常，但是点击链接不能打开相应主页、标签页、归档页…<br>经研究，应该把menu下面的不同页面的/后面的空格删掉，即可。<br>具体配置如下：  </p><a id="more"></a><pre><code class="yml">menu:  home: /|| home                  #主页  archives: /archives/|| archive  #归档  categories: /categories/|| th   #分类  tags: /tags/|| tags             #标签  about: /about/|| user           #关于我  #search: /search  #schedule: /schedule/ || calendar  #sitemap: /sitemap.xml || sitemap  #commonweal: /404.html# Enable/Disable menu icons.menu_icons:  enable: true  # Icon Mapping.  home: home  archives: archive  categories: th  tags: tags  about: user  #commonweal: heartbeat  #search: search</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;导航栏图标显示问号，当修改&lt;code&gt;hexo\themes\next\_config.yml&lt;/code&gt;主题配置文件后，图标显示正常，但是点击链接不能打开相应主页、标签页、归档页…&lt;br&gt;经研究，应该把menu下面的不同页面的/后面的空格删掉，即可。&lt;br&gt;具体配置如下：  &lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo 多客户端上更新博客</title>
    <link href="https://closer_laps.gitee.io/2019/12/09/hexo/hexo%20%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/"/>
    <id>https://closer_laps.gitee.io/2019/12/09/hexo/hexo%20%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-12-09T10:08:25.000Z</published>
    <updated>2020-01-26T16:59:35.992Z</updated>
    
    <content type="html"><![CDATA[<p><code>git add source/ &amp;&amp; git commit -m &quot;博客更新&quot; &amp;&amp; git push origin hexo &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; exit</code></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>静态网页文件存放在<code>master主分支</code>，个人文件存放在<code>hexo分支</code>。  </p><h2 id="一、本地电脑设置"><a href="#一、本地电脑设置" class="headerlink" title="一、本地电脑设置"></a>一、本地电脑设置</h2><p>先新建一个hexo文件夹，在git bash下cd进入hexo文件夹。</p><ol><li><code>git init</code></li><li><code>git checkout -b hexo</code> //新建hexo分支并切换到hexo</li><li>将原来博客文件夹里面的<code>_config.yml</code>，<code>theme/</code>，<code>source/</code>，<code>scaffolds/</code>，<code>package.json</code>，<code>.gitignore</code>，共6个文件/文件夹 拷贝到hexo文件夹下面。<br>需要拷贝的文件如下:  <a id="more"></a></li></ol><ul><li>_config.yml（站点配置）；</li><li>theme文件夹里面的主题；</li><li>source文件夹；</li><li>scaffolds文件夹（文章的模板）；</li><li>package.json（说明使用哪些包）；</li><li>.gitignore（限定在提交的时候哪些文件可以忽略）；  </li><li><strong>注意：不要<code>hexo init</code>去整体初始化，因为需要的文件我们已经拷贝过来了。</strong>  </li></ul><ol start="4"><li>将theme文件夹里面的你的主题文件夹下的.git文件夹删除。</li><li><code>git add scaffolds/ source/ themes/ .gitignore _config.yml package.json</code><br><code>git commit -m &quot;init&quot;</code>  </li><li><code>git remote add origin git@github.com:你的ID/你的仓库名字</code>  //添加本地hexo和远程仓库的关联  </li><li>登录github，将分支仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为hexo，Update保存。 </li><li><code>git push origin hexo</code>  //上传更新</li></ol><h2 id="二、另外一台电脑上配置"><a href="#二、另外一台电脑上配置" class="headerlink" title="二、另外一台电脑上配置"></a>二、另外一台电脑上配置</h2><ol><li>官网下载安装：  </li></ol><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">安装 Node.js；</a></li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">安装 Git。</a></li></ul><ol start="2"><li>新建hexo目录，cd进入。</li><li><code>git clone https://github.com/你的ID/你的ID.github.io.git</code>  //克隆到本地</li><li>将新电脑生成的ssh key添加到gitHub账户上。<br>需要配置 git。</li></ol><ul><li><code>git config --global user.email &quot;xxx@qq.com&quot;</code> 引号内的<a href="mailto:xxx@qq.com">xxx@qq.com</a>改为你github注册并且验证的邮箱；</li><li><code>git config --global user.name &quot;xxxx&quot;</code>   引号内的xxxx改为你的 github 用户名；</li><li><code>ssh-keygen</code> 会出现下面的内容，一直按Enter键就行；</li><li>打开用户目录下的 <code>.ssh</code>目录下面生成 <code>id_rsa(私钥)id_rsa.pub(公钥)</code>两个文件，打开<code>id_rsa.pub</code>，复制里面的内容,到 github: <code>Settings -&gt; SSH and GPG keys -&gt; SSH keys -&gt; New SSH key -&gt; (填写)Title -&gt; (粘贴)Key -&gt; Add SSH Key</code>；</li><li>测试 <code>ssh -T git@github.com</code>，输出 <strong>You’ve successfully authenticated</strong> 表示添加key 成功。</li></ul><ol start="5"><li><code>npm install hexo-cli -g</code> //安装hexo</li><li><code>npm install</code> //安装依赖包  </li></ol><ul><li>如果出现报错<code>ERROR Try runing: &#39;npm install hexo --save</code>则执行命令<code>npm install hexo --save</code>，如果没有，则忽略。</li></ul><h2 id="三、发布博客"><a href="#三、发布博客" class="headerlink" title="三、发布博客"></a>三、发布博客</h2><ol><li>cd进入博客目录</li><li><code>git pull origin hexo</code> //保证和分支同步</li><li><code>hexo n &quot;新建博客&quot;</code></li><li><code>git add source/</code>      //因为博客文件是在source文件夹下面的</li><li><code>git commit -m &quot;博客更新&quot;</code></li><li><code>git push origin hexo</code>//长传更新</li><li><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>//部署博客</li></ol><p>至此，多终端发布博客已经配置完成。</p><h2 id="四、更新主题"><a href="#四、更新主题" class="headerlink" title="四、更新主题"></a>四、更新主题</h2><p>配置好主题文件后，执行：<br><code>git add scaffolds/ source/ themes/ .gitignore _config.yml package.json</code><br><code>git commit -m &quot;更新主题&quot;</code><br><code>git push origin hexo</code>  //上传更新</p><h2 id="五、快速上传部署命令"><a href="#五、快速上传部署命令" class="headerlink" title="五、快速上传部署命令"></a>五、快速上传部署命令</h2><p>只更新博客内容，可以从上述第 三 大步第 4 步后可以这样子发布：<br><code>git add source/ &amp;&amp; git commit -m &quot;博客更新&quot; &amp;&amp; git push origin hexo &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; exit</code><br>把所有命令用<code>&amp;&amp;</code>串起来，有一个失败就会停止；成功，最后一条命令就会退出终端。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;git add source/ &amp;amp;&amp;amp; git commit -m &amp;quot;博客更新&amp;quot; &amp;amp;&amp;amp; git push origin hexo &amp;amp;&amp;amp; hexo clean &amp;amp;&amp;amp; hexo g &amp;amp;&amp;amp; hexo d &amp;amp;&amp;amp; exit&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;静态网页文件存放在&lt;code&gt;master主分支&lt;/code&gt;，个人文件存放在&lt;code&gt;hexo分支&lt;/code&gt;。  &lt;/p&gt;
&lt;h2 id=&quot;一、本地电脑设置&quot;&gt;&lt;a href=&quot;#一、本地电脑设置&quot; class=&quot;headerlink&quot; title=&quot;一、本地电脑设置&quot;&gt;&lt;/a&gt;一、本地电脑设置&lt;/h2&gt;&lt;p&gt;先新建一个hexo文件夹，在git bash下cd进入hexo文件夹。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;git init&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout -b hexo&lt;/code&gt; //新建hexo分支并切换到hexo&lt;/li&gt;
&lt;li&gt;将原来博客文件夹里面的&lt;code&gt;_config.yml&lt;/code&gt;，&lt;code&gt;theme/&lt;/code&gt;，&lt;code&gt;source/&lt;/code&gt;，&lt;code&gt;scaffolds/&lt;/code&gt;，&lt;code&gt;package.json&lt;/code&gt;，&lt;code&gt;.gitignore&lt;/code&gt;，共6个文件/文件夹 拷贝到hexo文件夹下面。&lt;br&gt;需要拷贝的文件如下:
    
    </summary>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/tags/hexo/"/>
    
      <category term="多客户端" scheme="https://closer_laps.gitee.io/tags/%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>hexo配置文件设置</title>
    <link href="https://closer_laps.gitee.io/2019/12/09/hexo/hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE/"/>
    <id>https://closer_laps.gitee.io/2019/12/09/hexo/hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE/</id>
    <published>2019-12-08T16:15:17.000Z</published>
    <updated>2019-12-10T03:49:03.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo配置文件设置"><a href="#hexo配置文件设置" class="headerlink" title="hexo配置文件设置"></a>hexo配置文件设置</h2><p>hexo配置文件<code>_config.yml</code>基本配置</p><a id="more"></a><pre><code class="yml"># Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 网站title: closer的个人博客subtitle: welcome!description: 非专业初学者码农一枚keywords:author: closerlanguage: zh-Hans #语言timezone: &#39;&#39;# URL 网址## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: https://closer_laps.gitee.io/root: / #根目录位置，如果只是github pages的子目录需要更改permalink: :year/:month/:day/:title/permalink_defaults:# Directory #文件结构 默认即可source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: langskip_render:# Writing #编辑博文的选项new_post_name: :title.md # File name of new postsdefault_layout: postauto_spacing: falsetitlecase: false # 把标题转换为 title case external_link:  enable: true # Open external links in new tab  field: site # Apply to the whole site  exclude: &#39;&#39;filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写 render_drafts: false #显示草稿 post_asset_folder: false #启动 Asset 文件夹 relative_link: false #把链接改为与根目录的相对位址 future: true #显示未来的文章 highlight:  #代码块的设置  enable: false  #开启代码块高亮  auto_detect: false #如果未指定语言，则启用自动检测  line_number: true #显示行数  tab_replace: &#39;&#39; #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs # Home page setting# path: Root path for your blogs index page. (default = &#39;&#39;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator:  path: &#39;&#39;  per_page: 10  order_by: -date# Category &amp; Tag #分类 &amp; 标签default_category: uncategorizedcategory_map:tag_map:# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# Date / Time format #日期显示格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD #日期格式 time_format: HH:mm:ss #时间格式## Use post&#39;s date for updated date unless set in front-matteruse_date_for_updated: false# Pagination #分页器## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能) 10pagination_dir: page #分页目录 # Include / Exclude file(s)## include:/exclude: options only apply to the &#39;source/&#39; folderinclude:exclude:ignore:# Extensions #拓展## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: next #主题更换# Deployment #部署参数## Docs: http://hexo.io/docs/deployment.htmldeploy:  type: git  repo: https://github.com/closer2018/closer2018.github.io.git  #repo: https://gitee.com/closer_laps/closer_laps.git  branch: master# 搜索设置search:  path: search.xml  field: post  format: html  limit: 10000</code></pre><p>以上就是配置文件的基础设置。</p><h2 id="更换主题NexT"><a href="#更换主题NexT" class="headerlink" title="更换主题NexT"></a>更换主题NexT</h2><p>Hexo安装主题的方式非常简单，只需要将主题文件放置于站点目录的themes下，然后修改下配置文件即可。这里我以NexT主题为例。<br>在git bash操作下cd至博客根目录，执行如下代码：  </p><p><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p><p>等待下载完成后，修改根目录下_config.yml文件的theme字段为next即可启用NexT主题，十分简单便捷。<br>其它具体设置可参照<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT官方文档</a>。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>cd至blog根目录。  </p><pre><code class="yml">npm install hexo-generator-searchdb --save  #搜索插件npm install --save hexo-generator-feed   #RSS插件npm install hexo-wordcount --save   #字符统计及阅读时长估计npm install hexo-generator-sitemap --save  #博客添加网站地图sitemapnpm install hexo-generator-index-pin-top --save   #置顶插件</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;hexo配置文件设置&quot;&gt;&lt;a href=&quot;#hexo配置文件设置&quot; class=&quot;headerlink&quot; title=&quot;hexo配置文件设置&quot;&gt;&lt;/a&gt;hexo配置文件设置&lt;/h2&gt;&lt;p&gt;hexo配置文件&lt;code&gt;_config.yml&lt;/code&gt;基本配置&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/categories/hexo/"/>
    
    
      <category term="hexo配置文件" scheme="https://closer_laps.gitee.io/tags/hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>hexo上传部署命令</title>
    <link href="https://closer_laps.gitee.io/2019/12/01/hexo/hexo%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://closer_laps.gitee.io/2019/12/01/hexo/hexo%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-11-30T16:00:00.000Z</published>
    <updated>2019-12-10T02:18:32.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo上传部署三连杀命令-先cd进入git目录"><a href="#hexo上传部署三连杀命令-先cd进入git目录" class="headerlink" title="hexo上传部署三连杀命令(先cd进入git目录)"></a>hexo上传部署三连杀命令(先<code>cd</code>进入git目录)</h2><pre><code class="bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><a id="more"></a><h3 id="我们运行测试时，经常用到的有三个命令"><a href="#我们运行测试时，经常用到的有三个命令" class="headerlink" title="我们运行测试时，经常用到的有三个命令"></a>我们运行测试时，经常用到的有三个命令</h3><pre><code class="bash">hexo clean #用来清理缓存文件hexo g      #生成文件hexo  d   #上传到服务器</code></pre><h4 id="本地检测时运行"><a href="#本地检测时运行" class="headerlink" title="本地检测时运行"></a>本地检测时运行</h4><pre><code class="bash">hexo s</code></pre><p>然后打开浏览器，输入localhost:4000，就能看到博客了。<br>这样说明本地环境搭建完成。</p><h3 id="特别感谢B站up主CodeSheep的帮助和细心指导"><a href="#特别感谢B站up主CodeSheep的帮助和细心指导" class="headerlink" title="特别感谢B站up主CodeSheep的帮助和细心指导"></a>特别感谢<a href="https://space.bilibili.com/384068749/" target="_blank" rel="noopener">B站up主CodeSheep</a>的帮助和细心指导</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;hexo上传部署三连杀命令-先cd进入git目录&quot;&gt;&lt;a href=&quot;#hexo上传部署三连杀命令-先cd进入git目录&quot; class=&quot;headerlink&quot; title=&quot;hexo上传部署三连杀命令(先cd进入git目录)&quot;&gt;&lt;/a&gt;hexo上传部署三连杀命令(先&lt;code&gt;cd&lt;/code&gt;进入git目录)&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;hexo clean &amp;amp;&amp;amp; hexo g &amp;amp;&amp;amp; hexo d&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://closer_laps.gitee.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构第三章 线性表</title>
    <link href="https://closer_laps.gitee.io/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC3%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://closer_laps.gitee.io/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC3%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2019-11-27T16:00:00.000Z</published>
    <updated>2019-12-29T03:44:56.158Z</updated>
    
    <content type="html"><![CDATA[<p>线性表：零个或多个数据元素的有限序列。</p><h2 id="3-1-3-2线性表的定义"><a href="#3-1-3-2线性表的定义" class="headerlink" title="3.1-3.2线性表的定义"></a>3.1-3.2线性表的定义</h2><p>线性表（List）：零个或多个数据元素的有限序列。</p><p>若将线性表记为（a_1，…，a_(i−1)，a_i，a_(i+1)，…，a_n），则表中a_(i−1) 领先于a_i，a_i 领先于a_(i+1)，称a_(i−1) 是a_i 的直接前驱元素，a_(i+1) 是a_i 的直接后继元素。当i=1，2，…，n-1时，a_i 有且仅有一个直接后继，当i=2，3，…，n时，a_i 有且仅有一个直接前驱。<br>如图3-2-1所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.2.1.GIF?raw=true" alt="3-2-1"></p><p>所以线性表元素的个数n（n&gt;0）定义为线性表的长度，当n=0时，称为空表。<br>在较复杂的线性表中，一个数据元素可以由若干个数据项组成。</p><a id="more"></a><h2 id="3-3线性表的抽象数据类型"><a href="#3-3线性表的抽象数据类型" class="headerlink" title="3.3线性表的抽象数据类型"></a>3.3线性表的抽象数据类型</h2><p>线性表的抽象数据类型定义如下：</p><pre><code class="c">ADT线性表（List）Data    线性表的数据对象集合为{a1，a2…，an），每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。Operation    InitList（*L）；初始化操作，建立一个空的线性表L。    ListEmpty（L）；若线性表为空，返回true，否则返回false。    ClearList（*L）；将线性表清空。    GetElem（L，i，*e）；将线性表L中的第i个位置元素值返回给e。    LocateElem（L，e）；在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。    ListInsert（*L，i，e）；在线性表L中的第i个位置插入新元素e。    ListDelete（*L，i，*e）；删除线性表L中第i个位置元素，并用e返回其值。    ListLength（L）；返回线性表L的元素个数。endADT</code></pre><h3 id="3-3-1两个线性表集合的并集操作"><a href="#3-3-1两个线性表集合的并集操作" class="headerlink" title="3.3.1两个线性表集合的并集操作"></a>3.3.1两个线性表集合的并集操作</h3><p>要使得集合A=AUB。说白了，就是把存在集合B中但并不存在A中的数据元素插入到A中即可。<br>仔细分析一下这个操作，发现我们只要循环集合B中的每个元素，判断当前元素是否存在A中，若不存在，则插入到A中即可。思路应该是很容易想到的。<br>我们假设La表示集合A，Lb表示集合B，则实现的代码如下：</p><pre><code class="c">    /*将所有的在线性表Lb中但不在La中的数据元素插入到La中*/    void unionL(SqList *La, SqList Lb)    {        int La_len, Lb_len, i;        ElemType e;                          /*声明与La和Lb相同的数据元素e*/        La_len = ListLength(*La);                /*求线性表的长度*/        Lb_len = ListLength(Lb);        for (i = 1; i &lt;= Lb_len; i++)        {            GetElem(Lb, i, &amp;e);           /*取Lb中第i个数据元素赋给e*/            if (!LocateElem(*La, e))           /*La中不存在和e相同数据元素*/                ListInsert(La, ++La_len, e);          /*插入*/        }    }</code></pre><h2 id="3-4线性表的顺序存储结构"><a href="#3-4线性表的顺序存储结构" class="headerlink" title="3.4线性表的顺序存储结构"></a>3.4线性表的顺序存储结构</h2><h3 id="3-4-1顺序存储定义"><a href="#3-4-1顺序存储定义" class="headerlink" title="3.4.1顺序存储定义"></a>3.4.1顺序存储定义</h3><p>线性表的两种物理结构的第一种——顺序存储结构。<br>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p><h3 id="3-4-2顺序存储方式"><a href="#3-4-2顺序存储方式" class="headerlink" title="3.4.2顺序存储方式"></a>3.4.2顺序存储方式</h3><p>可以用C语言（其他语言也相同）的一维数组来实现顺序存储结构。<br>线性表的顺序存储的结构代码如下</p><pre><code class="c">    #define MAXSIZE 20/*存储空间初始分配量*/    typedef int ElemType;  /*ElemType 类型根据实际情况而定，这里假设为int*/    typedef struct    {        ElemType data[MAXSIZE];/*数组存储数据元素，最大值为MAXSIZE*/        int length;  /*线性表当前长度*/    }SqList;</code></pre><p>这里，我们就发现描述顺序存储结构需要三个属性：<br>    • 存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。<br>    • 线性表的最大存储容量：数组长度MaxSize。<br>    • 线性表的当前长度：length。</p><h3 id="3-4-3数据长度与线性表长度区别"><a href="#3-4-3数据长度与线性表长度区别" class="headerlink" title="3.4.3数据长度与线性表长度区别"></a>3.4.3数据长度与线性表长度区别</h3><p>数组的长度是存放线性表的存储空间的长度，存储分配后这个量是一般是不变的。<br>线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。<br>在任意时刻，线性表的长度应该小于等于数组的长度。</p><h3 id="3-4-4地址计算方法"><a href="#3-4-4地址计算方法" class="headerlink" title="3.4.4地址计算方法"></a>3.4.4地址计算方法</h3><p>存储器中的每个存储单元都有自己的编号，这个编号称为地址。<br>假设占用的是c个存储单元，那么线性表中第i+1个数据元素的存储位置和第i个数据元素的存储位置满足下列关系（LOC表示获得存储位置的函数）。<br>    LOC（a_(i+1)）=LOC（a_i）+c<br>所以对于第i个数据元素ai的存储位置可以由a1推算得出：<br>    LOC（a_i）=LOC（a_1）+（i-1）*c</p><h2 id="3-5顺序存储结构的插入与删除"><a href="#3-5顺序存储结构的插入与删除" class="headerlink" title="3.5顺序存储结构的插入与删除"></a>3.5顺序存储结构的插入与删除</h2><h3 id="3-5-1获得元素操作"><a href="#3-5-1获得元素操作" class="headerlink" title="3.5.1获得元素操作"></a>3.5.1获得元素操作</h3><p>我们要实现GetElem操作，即将线性表L中的第i个位置元素值返回。只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。</p><pre><code class="c">    #define OK 1    #define ERROR 0    #define TRUE 1    #define FALSE 0    typedef int Status;          /* Status是函数的类型,其值是函数结果状态代码，如OK等 */    /* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */    /* 操作结果：用e返回L中第i个数据元素的值,注意i是指位置，第1个位置的数组是从0开始 */    Status GetElem(SqList L, int i, ElemType *e)    {        if (L.length == 0 || i&lt;1 || i&gt;L.length)            return ERROR;        *e = L.data[i - 1];        return OK;    }</code></pre><h3 id="3-5-2插入操作"><a href="#3-5-2插入操作" class="headerlink" title="3.5.2插入操作"></a>3.5.2插入操作</h3><p>插入算法的思路：<br>    • 如果插入位置不合理，抛出异常；<br>    • 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；<br>    • 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；<br>    • 将要插入元素填入位置i处；<br>    • 表长加1。<br>实现代码如下：</p><pre><code class="c">    /* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */    /* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */    Status ListInsert(SqList *L, int i, ElemType e)    {        int k;        if (L-&gt;length == MAXSIZE)  /* 顺序线性表已经满 */            return ERROR;        if (i&lt;1 || i&gt;L-&gt;length + 1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */            return ERROR;        if (i &lt;= L-&gt;length)        /* 若插入数据位置不在表尾 */        {            for (k = L-&gt;length - 1; k &gt;= i - 1; k--)  /* 将要插入位置之后的数据元素向后移动一位 */                L-&gt;data[k + 1] = L-&gt;data[k];        }        L-&gt;data[i - 1] = e;          /* 将新元素插入 */        L-&gt;length++;        return OK;    }</code></pre><h3 id="3-5-3删除操作"><a href="#3-5-3删除操作" class="headerlink" title="3.5.3删除操作"></a>3.5.3删除操作</h3><p>删除算法的思路：<br>    • 如果删除位置不合理，抛出异常；<br>    • 取出删除元素；<br>    • 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；<br>    • 表长减1。<br>实现代码如下：</p><pre><code class="c">    /* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */    /* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */    Status ListDelete(SqList *L, int i, ElemType *e)    {        int k;        if (L-&gt;length == 0)               /* 线性表为空 */            return ERROR;        if (i&lt;1 || i&gt;L-&gt;length)         /* 删除位置不正确 */            return ERROR;        *e = L-&gt;data[i - 1];        if (i &lt; L-&gt;length)                /* 如果删除不是最后位置 */        {            for (k = i; k &lt; L-&gt;length; k++)/* 将删除位置后继元素前移 */                L-&gt;data[k - 1] = L-&gt;data[k];        }        L-&gt;length--;        return OK;    }</code></pre><p>线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O（1）；而插入或删除时，时间复杂度都是O（n）。</p><h3 id="3-5-4线性表顺序存储结构的优缺点"><a href="#3-5-4线性表顺序存储结构的优缺点" class="headerlink" title="3.5.4线性表顺序存储结构的优缺点"></a>3.5.4线性表顺序存储结构的优缺点</h3><p>线性表的顺序存储结构的优缺点如图3-5-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.5.3.GIF?raw=true" alt="3-5-3"></p><h3 id="3-6线性表的链式存储结构"><a href="#3-6线性表的链式存储结构" class="headerlink" title="3.6线性表的链式存储结构"></a>3.6线性表的链式存储结构</h3><h3 id="3-6-2线性表链式存储结构定义"><a href="#3-6-2线性表链式存储结构定义" class="headerlink" title="3.6.2线性表链式存储结构定义"></a>3.6.2线性表链式存储结构定义</h3><p>为了表示每个数据元素a_i 与其直接后继数据元素a_(i+1) 之间的逻辑关系，对数据元素a1来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素a_i 的存储映像，称为结点（Node）。<br>n个结点（a_i 的存储映像）链结成一个链表，即为线性表（a_1，a_2，…，a_n）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。<br>我们把链表中第一个结点的存储位置叫做头指针,线性链表的最后一个结点指针为“空”（通常用NULL或“^”符号表示）。<br>有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息。</p><h3 id="3-6-3头指针与头结点的异同"><a href="#3-6-3头指针与头结点的异同" class="headerlink" title="3.6.3头指针与头结点的异同"></a>3.6.3头指针与头结点的异同</h3><p><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.6.3.GIF?raw=true" alt="3-6-3"></p><h3 id="3-6-4线性表链式存储结构代码描述"><a href="#3-6-4线性表链式存储结构代码描述" class="headerlink" title="3.6.4线性表链式存储结构代码描述"></a>3.6.4线性表链式存储结构代码描述</h3><pre><code class="c">//线性表的单链表存储结构typedef struct Node{    ElemType data;    struct Node *next;}Node;typedef struct Node *LinkList;/* 定义LinkList */</code></pre><p>节点Node是由存放数据元素的数据域和存放后继节点地址的指针域组成。  </p><h2 id="3-7单链表的读取"><a href="#3-7单链表的读取" class="headerlink" title="3.7单链表的读取"></a>3.7单链表的读取</h2><p>获得链表第i个的数据的算法思路：  </p><ol><li>声明一个结点p指向链表第一个结点，初始化j从1开始;  </li><li>当<code>j&lt;i</code>时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1;  </li><li>若到链表末尾p为空，则说明第i个元素不存在;  </li><li>否则查找成功，返回结点p的数据。  </li></ol><p>实现代码算法如下：</p><pre><code class="c">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) *//* 操作结果：用e返回L中第i个数据元素的值 */Status GetElem(LinkList L,int i,ElemType *e){    int j;    LinkList p;  /* 声明一结点p */    p = L-&gt;next;  /* 让p指向链表L的第一个结点 */    j = 1;        /*  j为计数器 */    while (p &amp;&amp; j&lt;i)  /* p不为空或者计数器j还没有等于i时，循环继续 */    {        p = p-&gt;next;  /* 让p指向下一个结点 */        ++j;    }    if ( !p || j&gt;i )        return ERROR;  /*  第i个元素不存在 */    *e = p-&gt;data;   /*  取第i个元素的数据 */    return OK;}</code></pre><p>这个算法的最坏情况时间复杂度为O(n)。  </p><h2 id="3-8-单链表的插入和删除"><a href="#3-8-单链表的插入和删除" class="headerlink" title="3.8 单链表的插入和删除"></a>3.8 单链表的插入和删除</h2><h3 id="3-8-1-单链表的插入"><a href="#3-8-1-单链表的插入" class="headerlink" title="3.8.1 单链表的插入"></a>3.8.1 单链表的插入</h3><p><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.8.1.GIF?raw=true" alt="图3-8-1"><br>假设上一个结点是p，下一个结点是p-&gt;next,现在要把结点s插入这两个结点中去。只需要2行代码：<br><code>s-&gt;next=p-&gt;next;//先让s的指针域指向p-&gt;next</code><br><code>p-&gt;next=s;//把s的地址赋给p的指针域</code></p><p>ps:这两句顺序不能交换。<br>如果先<code>p-&gt;next=s</code>;再<code>s-&gt;next=p-&gt;next</code>;就等于<code>s-&gt;next=s</code>;<br>所以这2句如论如何都不能反，这点初学者一定要注意。  </p><p>单链表第i个数据插入结点的算法思路：</p><ol><li>声明一结点p指向链表第一个结点，初始化j从1开始;</li><li>当j&lt;1时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1;</li><li>若到链表末尾p为空，则说明第i个元素不存在;</li><li>否则查找成功，在系统中生成一个空结点s;</li><li>将数据元素e赋值给<code>s-&gt;data</code>;</li><li>单链表的插入标准语句<code>s-&gt;next=p-&gt;next;p-&gt;next=s;</code>;</li><li>返回成功;  </li></ol><p>实现代码算法如下:</p><pre><code class="c">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， *//* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */Status ListInsert(LinkList *L,int i,ElemType e){    int j;    LinkList p,s;    p = *L;    j = 1;    while (p &amp;&amp; j &lt; i)     /* 寻找第i个结点 */    {        p = p-&gt;next;        ++j;    }    if (!p || j &gt; i)        return ERROR;   /* 第i个元素不存在 */    s = (LinkList)malloc(sizeof(Node));  /*  生成新结点(C语言标准函数) */    s-&gt;data = e;      s-&gt;next = p-&gt;next;      /* 将p的后继结点赋值给s的后继  */    p-&gt;next = s;          /* 将s赋值给p的后继 */    return OK;}</code></pre><h3 id="3-8-2-单链表的删除"><a href="#3-8-2-单链表的删除" class="headerlink" title="3.8.2 单链表的删除"></a>3.8.2 单链表的删除</h3><p><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.8.5.GIF?raw=true" alt="3-8-5"><br>要删除节点q，其实就是要让<code>p-&gt;next=q-&gt;next</code>;<br>单链表第i个数据删除结点的算法思路：</p><ol><li>声明一结点p指向链表第一个结点，初始化j从1开始</li><li>当<code>j&lt;i</code>时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；</li><li>若到链表末尾p为空，则说明第i个元素不存在；</li><li>否则查找成功，将欲删除的结点<code>p-&gt;next</code>赋值给q；</li><li>单链表的删除标准语句<code>p-&gt;next=q-&gt;next</code>；</li><li>将q结点中的数据赋值给e，作为返回；</li><li>释放q结点；</li><li>返回成功。  </li></ol><p>实现代码算法如下：</p><pre><code class="c">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) *//* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */Status ListDelete(LinkList *L,int i,ElemType *e){    int j;    LinkList p,q;    p = *L;    j = 1;    while (p-&gt;next &amp;&amp; j &lt; i)    /* 遍历寻找第i个元素 */    {        p = p-&gt;next;        ++j;    }    if (!(p-&gt;next) || j &gt; i)        return ERROR;           /* 第i个元素不存在 */    q = p-&gt;next;              //q结点指向要删除的结点（即要删除的结点地址赋值给q）    p-&gt;next = q-&gt;next;            /* 将q的后继(第三个结点)赋值给p的后继 */    *e = q-&gt;data;               /* 将q结点中的数据给e */    free(q);                    /* 让系统回收此结点，释放内存 */    return OK;}</code></pre><p>分析一下刚才我们讲解的单链表插入和删除算法，我们很容易推导出：它们的时间复杂度都是O（n）。<br>显然，对于<strong>插入或删除数据越频繁的操作，单链表的效率优势就越是明显</strong>。</p><h2 id="3-9单链表的整表创建"><a href="#3-9单链表的整表创建" class="headerlink" title="3.9单链表的整表创建"></a>3.9单链表的整表创建</h2><p>单链表整表创建的算法思路：</p><ol><li>声明一结点p和计数器变量i；</li><li>初始化一空链表L；</li><li>让L的头结点的指针指向NULL，即建立一个带头结点的单链表；</li><li>循环：<ul><li>生成一新结点赋值给p；</li><li>随机生成一数字赋值给p的数据域p&gt;data；  </li><li>将p插入到头结点与前一新结点之间。  </li></ul></li></ol><p>实现头插法的代码算法如下(这段算法代码里,我们用插队的办法，始终让新结点在第一的位置。这种算法简称为头插法)：</p><pre><code class="c">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */void CreateListHead(LinkList *L, int n){    LinkList p;    int i;    srand(time(0));                         /* 初始化随机数种子 */    *L = (LinkList)malloc(sizeof(Node));    (*L)-&gt;next = NULL;                      /*  先建立一个带头结点的单链表 */    for (i=0; i&lt;n; i++)    {        p = (LinkList)malloc(sizeof(Node)); /*  生成新结点 */        p-&gt;data = rand()%100+1;             /*  随机生成100以内的数字 */        p-&gt;next = (*L)-&gt;next;        (*L)-&gt;next = p;                        /*  插入到表头 */    }}</code></pre><p>事实上，我们一般插队都是放在最后的。如果我们把每次的新结点都插在终端结点的后面，这种算法称之为尾插法。  </p><p>实现尾插法代码算法如下：</p><pre><code class="c">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */void CreateListTail(LinkList *L, int n){    LinkList p,r;    int i;    srand(time(0));                      /* 初始化随机数种子 */    *L = (LinkList)malloc(sizeof(Node)); /* L为整个线性表 */    r=*L;                                /* r为指向尾部的结点 */    for (i=0; i&lt;n; i++)    {        p = (Node *)malloc(sizeof(Node)); /*  生成新结点 */        p-&gt;data = rand()%100+1;           /*  随机生成100以内的数字 */        r-&gt;next=p;                        /* 将表尾终端结点的指针指向新结点 */        r = p;                            /* 将当前的新结点定义为表尾终端结点 */    }    r-&gt;next = NULL;                       /* 表示当前链表结束 */}</code></pre><p>PS：这里需解释一下，<code>r-&gt;next=p</code>的意思，其实就是将刚才的表尾终端结点r的指针指向新结点p，如图3-9-2所示，当中①位置的连线就是表示这个意思。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.9.2.GIF?raw=true" alt="3-9-2"><br><code>r=p</code>的意思请看图3-9-3，就是本来r是a_(i-1)元素的结点，现在它已经不是最后的结点了，现在最后的结点是a_i，所以应该将p结点这个最后的结点赋值给r。此时r又是最终的尾结点了。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.9.3.GIF?raw=true" alt="3-9-3">  </p><p>循环结束后，那么应该让这个链表的指针域置空，因此有了<code>r-&gt;next=NULL</code>，以便以后遍历时可以确认其是尾部。  </p><h2 id="3-10单链表的整表删除"><a href="#3-10单链表的整表删除" class="headerlink" title="3.10单链表的整表删除"></a>3.10单链表的整表删除</h2><p>单链表整表删除的算法思路如下：</p><ol><li>声明一结点p和q；</li><li>将第一个结点赋值给p；</li><li>循环：<ul><li>将下一结点赋值给q；</li><li>释放p；将q赋值给p。  </li></ul></li></ol><p>实现代码算法如下：  </p><pre><code class="c">/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */Status ClearList(LinkList *L){    LinkList p,q;    p=(*L)-&gt;next;           /*  p指向第一个结点 */    while(p)                /*  没到表尾 */    {        q=p-&gt;next;   //下一个结点地址赋值给临时结点q        free(p);     //释放p结点内存        p=q;         //临时结点q的地址赋值给p，使p能够指向继续指向下一个结点    }    (*L)-&gt;next=NULL;        /* 头结点指针域为空 */    return OK;}</code></pre><h2 id="3-11单链表结构与顺序存储结构优缺点"><a href="#3-11单链表结构与顺序存储结构优缺点" class="headerlink" title="3.11单链表结构与顺序存储结构优缺点"></a>3.11单链表结构与顺序存储结构优缺点</h2><p>简单地对单链表结构和顺序存储结构做对比,如图3-11-1：<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.11.1.GIF?raw=true" alt="3-11-1">  </p><p>通过上面的对比，我们可以得出一些经验性的结论：</p><ul><li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。</li><li>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。  </li></ul><p>总之，线性表的顺序存储结构和单链表结构各有其优缺点，不能简单的说哪个好，哪个不好，需要根据实际情况，来综合平衡采用哪种数据结构更能满足和达到需求和性能。  </p><h2 id="3-12静态链表"><a href="#3-12静态链表" class="headerlink" title="3.12静态链表"></a>3.12静态链表</h2><p>静态链表是由数组组成。<br>我们让数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下标都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而游标cur相当于单链表中的next 指针，存放该元素的后继在数组中的下标。<br>我们把这种用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。<br>静态链表的结构定义如下：  </p><pre><code class="c">/* 线性表的静态链表存储结构 */typedef struct{    ElemType data;    int cur;  /* 游标(Cursor) ，为0时表示无指向 */} Component,StaticLinkList[MAXSIZE];</code></pre><p>另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据。我们通常把未被使用的数组元素称为备用链表。而数组第一个元素，即<strong>下标为0的元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标</strong>，相当于单链表中的头结点作用，当整个链表为空时，则为0<sup>2</sup>。如图3-12-1所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.12.1.GIF?raw=true" alt="3-12-1">  </p><p>初始化数组状态，代码如下：  </p><pre><code class="c">/* 将一维数组space中各分量链成一个备用链表，space[0].cur为头指针，&quot;0&quot;表示空指针 */Status InitList(StaticLinkList space){    int i;    for (i=0; i&lt;MAXSIZE-1; i++)          space[i].cur = i+1;    space[MAXSIZE-1].cur = 0; /* 目前静态链表为空，最后一个元素的cur为0 */    return OK;}</code></pre><h3 id="3-12-1静态链表的插入操作"><a href="#3-12-1静态链表的插入操作" class="headerlink" title="3.12.1静态链表的插入操作"></a>3.12.1静态链表的插入操作</h3><p>在静态链表中，需要我们自己实现结点的申请和释放这2个函数，才可以做插入和删除的操作。<br>为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。  </p><pre><code class="c">/* 若备用空间链表非空，则返回分配的结点下标，否则返回0 */int Malloc_SSL(StaticLinkList space){    int i = space[0].cur;                   /* 当前数组第一个元素的cur存的值 */                                            /* 就是要返回的第一个备用空闲的下标 */    if (space[0]. cur)        space[0]. cur = space[i].cur;       /* 由于要拿出一个分量来使用了， */                               ll             /* 所以我们就得把它的下一个 */                                            /* 分量用来做备用 */    return i;}</code></pre><p>这段代码有意思，它的作用就是返回一个下标值，这个值就是数组头元素的cur存的第一个空闲的下标,同时把这个空闲的下标给<code>space[0].cur</code>，之后就可以继续分配新的空闲分量，实现类似mallbc（）函数的作用。<br>插入操作的实现代码如下：  </p><pre><code class="c">/*  在L中第i个元素之前插入新的数据元素e   */Status ListInsert(StaticLinkList L, int i, ElemType e){      int j, k, l;    k = MAXSIZE - 1;   /* 注意k首先是最后一个元素的下标 */    if (i &lt; 1 || i &gt; ListLength(L) + 1)        return ERROR;    j = Malloc_SSL(L);   /* 获得空闲分量的下标 */    if (j)    {        L[j].data = e;   /* 将数据赋值给此分量的data */        for(l = 1; l &lt;= i - 1; l++)   /* 找到第i个元素之前的位置 */           k = L[k].cur;        L[j].cur = L[k].cur;    /* 把第i个元素之前的cur赋值给新元素的cur */        L[k].cur = j;           /* 把新元素的下标赋值给第i个元素之前元素的ur */        return OK;    }    return ERROR;}</code></pre><h3 id="3-12-2静态链表的删除操作"><a href="#3-12-2静态链表的删除操作" class="headerlink" title="3.12.2静态链表的删除操作"></a>3.12.2静态链表的删除操作</h3><p>删除元素时，实现的代码如下：  </p><pre><code class="c">/*  删除在L中第i个数据元素   */Status ListDelete(StaticLinkList L, int i){    int j, k;    if (i &lt; 1 || i &gt; ListLength(L))        return ERROR;    k = MAXSIZE - 1;    for (j = 1; j &lt;= i - 1; j++)        k = L[k].cur;    j = L[k].cur;    L[k].cur = L[j].cur;    Free_SSL(L, j);    return OK;}</code></pre><p>释放结点的函数代码如下：  </p><pre><code class="c">/*  将下标为k的空闲结点回收到备用链表 */void Free_SSL(StaticLinkList space, int k){      space[k].cur = space[0].cur;    /* 把第一个元素的cur值赋给要删除的分量cur */    space[0].cur = k;               /* 把要删除的分量下标赋值给第一个元素的cur */}</code></pre><p>返回静态链表长度的代码实现如下：  </p><pre><code class="c">/* 初始条件：静态链表L已存在。操作结果：返回L中数据元素个数 */int ListLength(StaticLinkList L){    int j=0;    int i=L[MAXSIZE-1].cur;    while(i)    {        i=L[i].cur;        j++;    }    return j;}</code></pre><h3 id="3-12-3静态链表优缺点"><a href="#3-12-3静态链表优缺点" class="headerlink" title="3.12.3静态链表优缺点"></a>3.12.3静态链表优缺点</h3><p>总结一下静态链表的优缺点（见图3-12-5）：<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.12.5.GIF?raw=true" alt="3-12-5"><br>总的来说，静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。尽管大家不一定会用得上，但这样的思考方式是非常巧妙的，应该理解其思想，以备不时之需。  </p><h2 id="3-13循环链表"><a href="#3-13循环链表" class="headerlink" title="3.13循环链表"></a>3.13循环链表</h2><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。<br>其实循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断<code>p-&gt;next</code>是否为空，现在则是<code>p-&gt;next</code>不等于头结点，则循环未结束。<br>在单链表中，我们有了头结点时，我们可以用O（1）的时间访问第一个结点，但如果想要用O（1）的时间访问到最后一个结点，则需要改造一下这个循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表（如图3-13-5）。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.5.GIF?raw=true" alt="3-13-5"><br>从上图可以看出，终端结点用尾指针rear指示，则查找终端结点是O（1），而开始结点，其实就是<code>rear-&gt;next-&gt;next</code>，其时间复杂也为O（1）。<br>举个程序的例子，要将两个循环链表合并成一个表时，有了尾指针就非常简单了。比如下面的这两个循环链表，它们的尾指针分别是rearA和rearB，如图3-13-6所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.6.GIF?raw=true" alt="3-13-6"><br>要想把它们合并，只需要如下的操作即可，如图3-13-7所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.7.GIF?raw=true" alt="3-13-7"><br>具体代码如下：  </p><pre><code class="c">p=rearA-&gt;next;     /*保存A表的头结点，即①*/rearA-&gt;next=rearB-&gt;next-&gt;next;     /*将本是指向B表的第一个结点（不是头结点）赋值给reaA-&gt;next,即②*/rearB-&gt;next=p;/*将原A表的头结点赋值给rearB-&gt;next，即③**/free(p);/*释放p*/</code></pre><h2 id="3-14双向链表"><a href="#3-14双向链表" class="headerlink" title="3.14双向链表"></a>3.14双向链表</h2><p>双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。<br>所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。  </p><pre><code class="c">/*线性表的双向链表存储结构*/typedef struct DulNode{    ElemType data；    struct DuLNode *prior；/*直接前驱指针*/    struct DuLNode *next；/*直接后继指针*/}DulNode，*DuLinkList；</code></pre><p>既然单链表也可以有循环链表，那么双向链表当然也可以是循环表。<br>双向链表的循环带头结点的空链表如图3-14-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.3.GIF?raw=true" alt="3-14-3"><br>非空的循环的带头结点的双向链表如图3-14-4所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.4.GIF?raw=true" alt="3-14-4"><br>PS：双向链表在插入和删除时，需要更改两个指针变量。<br>插入操作时，其实并不复杂，不过<strong>顺序很重要，千万不能写反了</strong>。<br>我们现在假设存储元素e的结点为s，要实现将结点s插入到结点p和<code>p-&gt;next</code>之间需要下面几步，如图3-14-5所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.5.GIF?raw=true" alt="3-14-5">  </p><pre><code class="c">s-&gt;prior=p;/*把p赋值给s的前驱，如图中①*/s-&gt;next=p-&gt;next;/*把p-&gt;next赋值给s的后继，如图中②*/p-&gt;next-&gt;prior=s;/*把s赋值给p-&gt;next的前驱，如图中③*/p-&gt;next=s;/*把s赋值给p的后继，如图中④*/</code></pre><p>关键在于它们的顺序，由于第2步和第3步都用到了<code>p-&gt;next</code>。如果第4步先执行，则会使得<code>p-&gt;next</code>提前变成了s，使得插入的工作完不成。所以我们不妨把上面这张图在理解的基础上记忆，顺序是先搞定s的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。  </p><p>若要删除结点p，只需要下面两步骤，如图3-14-6所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.6.GIF?raw=true" alt="3-14-6">  </p><pre><code class="c">p-&gt;prior-&gt;next=p-&gt;next；/*把p-&gt;next赋值给p-&gt;prior的后继，如图中①*/p-&gt;next-&gt;prior=p-&gt;prior；/*把p-&gt;prior 赋值给p-&gt;next的前驱，如图中②*/free（p）；/*释放结点*/</code></pre><h2 id="3-15总结回顾"><a href="#3-15总结回顾" class="headerlink" title="3.15总结回顾"></a>3.15总结回顾</h2><p>这一章，主要讲的是线性表。<br>先谈了它的定义，线性表是零个或多个具有相同类型的数据元素的有限序列。然后谈了线性表的抽象数据类型，如它的一些基本操作。<br>之后我们就线性表的两大结构做了讲述，先讲的是比较容易的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。通常我们都是用数组来实现这一结构。<br>后来是我们的重点，由顺序存储结构的插入和删除操作不方便，引出了链式存储结构。它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。然后我们分别就链式存储结构的不同形式，如单链表、循环链表和双向链表做了讲解，另外我们还讲了若不使用指针如何处理链表结构的静态链表方法。<br>总的来说，线性表的这两种结构（如图3-15-1所示）是后面其他数据结构的基础，把它们学明白了，对后面的学习有着至关重要的作用。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.15.1.GIF?raw=true" alt="3-15-1">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性表：零个或多个数据元素的有限序列。&lt;/p&gt;
&lt;h2 id=&quot;3-1-3-2线性表的定义&quot;&gt;&lt;a href=&quot;#3-1-3-2线性表的定义&quot; class=&quot;headerlink&quot; title=&quot;3.1-3.2线性表的定义&quot;&gt;&lt;/a&gt;3.1-3.2线性表的定义&lt;/h2&gt;&lt;p&gt;线性表（List）：零个或多个数据元素的有限序列。&lt;/p&gt;
&lt;p&gt;若将线性表记为（a_1，…，a_(i−1)，a_i，a_(i+1)，…，a_n），则表中a_(i−1) 领先于a_i，a_i 领先于a_(i+1)，称a_(i−1) 是a_i 的直接前驱元素，a_(i+1) 是a_i 的直接后继元素。当i=1，2，…，n-1时，a_i 有且仅有一个直接后继，当i=2，3，…，n时，a_i 有且仅有一个直接前驱。&lt;br&gt;如图3-2-1所示。&lt;br&gt;&lt;img src=&quot;https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.2.1.GIF?raw=true&quot; alt=&quot;3-2-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;所以线性表元素的个数n（n&amp;gt;0）定义为线性表的长度，当n=0时，称为空表。&lt;br&gt;在较复杂的线性表中，一个数据元素可以由若干个数据项组成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="https://closer_laps.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线性表" scheme="https://closer_laps.gitee.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构第四章 栈与队列</title>
    <link href="https://closer_laps.gitee.io/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC4%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>https://closer_laps.gitee.io/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC4%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2019-11-27T16:00:00.000Z</published>
    <updated>2019-12-29T03:41:37.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-1-4-2-栈的定义"><a href="#4-1-4-2-栈的定义" class="headerlink" title="4.1-4.2 栈的定义"></a>4.1-4.2 栈的定义</h2><h3 id="4-2-1-栈的定义"><a href="#4-2-1-栈的定义" class="headerlink" title="4.2.1 栈的定义"></a>4.2.1 栈的定义</h3><p><strong>栈是限定仅在表尾进行插入和删除操作的线性表。</strong><br>我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简尔LIFO结构。<br>它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。<br>栈的插入操作，叫作进栈，也称压栈、入栈(push)。<br>栈的删除操作，叫作出栈，也有的叫作弹栈(pop)。  </p><h2 id="4-3-栈的抽象数据类型"><a href="#4-3-栈的抽象数据类型" class="headerlink" title="4.3 栈的抽象数据类型"></a>4.3 栈的抽象数据类型</h2><a id="more"></a><pre><code class="c">ADT 栈(stack)Data    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。Operation    InitStack(*s)：初始化操作，建立一个空栈s。    DestroyStack(*s)：若楼存在，则销毁它。    ClearStack(*s)：将栽清空。    StackEmpty(S)：若为空，返回true，否则返回false。    GetTop(s，*e)：若栽存在且非空，用e返回s的栽顶元素。    Push(*s，e)：若栈S存在，插入新元素e到栈S中并成为栈顶元素。    Pop(*S，*e)：删除栈S中栈顶元素，并用e返回其值。    StackLength(s)：返回栈s的元素个数。endADT</code></pre><h2 id="4-4-栈的顺序存储结构及实现"><a href="#4-4-栈的顺序存储结构及实现" class="headerlink" title="4.4 栈的顺序存储结构及实现"></a>4.4 栈的顺序存储结构及实现</h2><h3 id="4-4-1-栈的顺序存储结构"><a href="#4-4-1-栈的顺序存储结构" class="headerlink" title="4.4.1 栈的顺序存储结构"></a>4.4.1 栈的顺序存储结构</h3><p>栈是线性表的特例，那么栈的顺序存储其实也是线性表顺序存储的简化，我们简称为顺序栈。线性表是用数组来实现的。<br>我们定义一个top变量来指示栈顶元素在数组中的位置，它可以来回移动，意味着栈顶的top可以变大变小，但无论如何游标不能超出栈的长度。同理，若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判定条件定为top等于-1。</p><p>栈的结构定义：  </p><pre><code class="c">typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int *//* 顺序栈结构 */typedef struct{        SElemType data[MAXSIZE];        int top; /* 用于栈顶指针 */}SqStack;</code></pre><p>若现在有一个栈，StackSize是5，则栈普通情况、空栈和栈满的情况示意图如图4-4-2所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-4-2.JPG?raw=true" alt="4-4-2">  </p><h3 id="4-4-2-栈的顺序存储结构——进栈操作"><a href="#4-4-2-栈的顺序存储结构——进栈操作" class="headerlink" title="4.4.2 栈的顺序存储结构——进栈操作"></a>4.4.2 栈的顺序存储结构——进栈操作</h3><p>对于栈的插入，即进栈操作，其实就是在栈顶插入一个元素。<br>进栈操作push，其代码如下：  </p><pre><code class="c">/* 插入元素e为新的栈顶元素 */Status Push(SqStack *S,SElemType e){        if(S-&gt;top == MAXSIZE -1) /* 栈满 */        {            return ERROR;        }        S-&gt;top++;   /* 栈顶指针增加一 */        S-&gt;data[S-&gt;top]=e;  /* 将新插入元素赋值给栈顶空间 */        return OK;}</code></pre><h3 id="4-4-3-栈的顺序存储结构——出栈操作"><a href="#4-4-3-栈的顺序存储结构——出栈操作" class="headerlink" title="4.4.3 栈的顺序存储结构——出栈操作"></a>4.4.3 栈的顺序存储结构——出栈操作</h3><p>出栈操作pop，代码如下：  </p><pre><code class="c">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */Status Pop(SqStack *S,SElemType *e){        if(S-&gt;top==-1)                return ERROR;        *e=S-&gt;data[S-&gt;top]; /* 将要删除的栈顶元素赋值给e */        S-&gt;top--;   /* 栈顶指针减一 */        return OK;}</code></pre><p>两者没有涉及到任何循环语句，因此时间复杂度均是O(1)。  </p><h2 id="4-5-两栈共享空间"><a href="#4-5-两栈共享空间" class="headerlink" title="4.5 两栈共享空间"></a>4.5 两栈共享空间</h2><p>如果我们有两个相同类型的栈，我们为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。这又何必呢？我们完全可以用一个数组来存储两个栈，只不过需要点小技巧。<br>数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为栈的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。<br>其实关键思路是：它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。<br>从这里也就可以分析出来，栈1为空时，就是top1等于-1时；而当top2等于n时，即是栈2为空时，那什么时候栈满呢？<br>想想极端的情况，若栈2是空栈，栈1的top1等于n-1时，就是栈1满了。反之，当栈1为空栈时，top2等于0时，为栈2满。但更多的情况，其实就是我刚才说的，两个栈见面之时，也就是两个指针之间相差1时，即top1+1==top2为栈满。<br>两栈共享空间的结构的代码如下：</p><pre><code class="c">/* 两栈共享空间结构 */typedef struct{    SElemType data[MAXSIZE];    int top1;    /* 栈1栈顶指针 */    int top2;    /* 栈2栈顶指针 */}SqDoubleStack;</code></pre><p>对于两栈共享空间的push方法，我们除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber。插入元素的代码如下：</p><pre><code class="c">/* 插入元素e为新的栈顶元素 */Status Push(SqDoubleStack *S, SElemType e, int stackNumber){    if (S-&gt;top1 + 1 == S-&gt;top2)    /* 栈已满，不能再push新元素了 */        return ERROR;    if (stackNumber == 1)            /* 栈1有元素进栈 */        S-&gt;data[++S-&gt;top1] = e; /* 若是栈1则先top1+1后给数组元素赋值。 */    else if (stackNumber == 2)    /* 栈2有元素进栈 */        S-&gt;data[--S-&gt;top2] = e; /* 若是栈2则先top2-1后给数组元素赋值。 */    return OK;}</code></pre><p>因为在开始已经判断了是否有栈满的情况，所以后面的top1+1或top2-1是不担心溢出问题的。<br>对于两栈共享空间的pop方法，参数就只是判断栈1栈2的参数stackNumber，代码如下：</p><pre><code class="c">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */Status Pop(SqDoubleStack *S, SElemType *e, int stackNumber){    if (stackNumber == 1)    {        if (S-&gt;top1 == -1)            return ERROR; /* 说明栈1已经是空栈，溢出 */        *e = S-&gt;data[S-&gt;top1--]; /* 将栈1的栈顶元素出栈 */    }    else if (stackNumber == 2)    {        if (S-&gt;top2 == MAXSIZE)            return ERROR; /* 说明栈2已经是空栈，溢出 */        *e = S-&gt;data[S-&gt;top2++]; /* 将栈2的栈顶元素出栈 */    }    return OK;}</code></pre><p>事实上，使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。就像买卖股票一样，你买入时，一定是有一个你不知道的人在做卖出操作。有人赚钱，就一定是有人赔钱。这样使用两栈共享空间存储方法才有比较大的意义。否则两个栈都在不停地增长，那很快就会因栈满而溢出了。  </p><h2 id="4-6-栈的链式存储结构及实现"><a href="#4-6-栈的链式存储结构及实现" class="headerlink" title="4.6 栈的链式存储结构及实现"></a>4.6 栈的链式存储结构及实现</h2><h3 id="4-6-1-栈的链式存储结构"><a href="#4-6-1-栈的链式存储结构" class="headerlink" title="4.6.1 栈的链式存储结构"></a>4.6.1 栈的链式存储结构</h3><p>栈的链式存储结构，简称为链栈。<br>链栈的结构代码如下：  </p><pre><code class="c">/* 链栈结构 */typedef struct StackNode{    SElemType data;    struct StackNode *next;}StackNode,*LinkStackPtr;typedef struct LinkStack{    LinkStackPtr top;    int count;}LinkStack;</code></pre><h3 id="4-6-2-栈的链式存储结构-进栈操作"><a href="#4-6-2-栈的链式存储结构-进栈操作" class="headerlink" title="4.6.2 栈的链式存储结构-进栈操作"></a>4.6.2 栈的链式存储结构-进栈操作</h3><p>对于链栈的进栈push操作，假设元素值为e的新结点是s，top为栈顶指针，示意图如图4-6-2所示代码如下。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-6-2.JPG?raw=true" alt="4-6-2">  </p><pre><code class="c">/* 插入元素e为新的栈顶元素 */Status Push(LinkStack *S,SElemType e){    LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode));    s-&gt;data=e;    s-&gt;next=S-&gt;top;/* 把当前的栈顶元素赋值给新结点的直接后继，见图中① */    S-&gt;top=s;         /* 将新的结点s赋值给栈顶指针，见图中② */    S-&gt;count++;    return OK;}</code></pre><h3 id="4-6-3-栈的链式存储结构——出栈操作"><a href="#4-6-3-栈的链式存储结构——出栈操作" class="headerlink" title="4.6.3 栈的链式存储结构——出栈操作"></a>4.6.3 栈的链式存储结构——出栈操作</h3><p>至于链栈的出栈pop操作，也是很简单的三句操作。假设变量p用来存储要删除的栈顶结点，将栈顶指针下移一位，最后释放p即可，如图4-6-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-6-3.JPG?raw=true" alt="4-6-3">  </p><pre><code class="c">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */Status Pop(LinkStack *S,SElemType *e){        LinkStackPtr p;        if(StackEmpty(*S))                return ERROR;        *e=S-&gt;top-&gt;data;        p=S-&gt;top;               /* 将栈顶结点赋值给p，见图中③ */        S-&gt;top=S-&gt;top-&gt;next;    /* 使得栈顶指针下移一位，指向后一结点，见图中④ */        free(p);                    /* 释放结点p */        S-&gt;count--;        return OK;}</code></pre><p>链栈的进栈push和出栈pop操作都很简单，时间复杂度均是O(1)。<br>对比一下顺序栈与链栈，它们在时间复杂度上是一样的，均为O(1)。对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以它们的区别是如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。  </p><h2 id="4-7-栈的作用"><a href="#4-7-栈的作用" class="headerlink" title="4.7 栈的作用"></a>4.7 栈的作用</h2><p>栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。  </p><h2 id="4-8-栈的应用——递归"><a href="#4-8-栈的应用——递归" class="headerlink" title="4.8 栈的应用——递归"></a>4.8 栈的应用——递归</h2><h3 id="4-8-1-4-8-2递归定义"><a href="#4-8-1-4-8-2递归定义" class="headerlink" title="4.8.1-4.8.2递归定义"></a>4.8.1-4.8.2递归定义</h3><p>我们<strong>把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数</strong>。<br>当然，写递归程序最怕的就是陷入永不结束的无穷递归中，所以，<strong>每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出</strong>。  </p><h2 id="4-9-栈的应用——四则运算表达式求值"><a href="#4-9-栈的应用——四则运算表达式求值" class="headerlink" title="4.9 栈的应用——四则运算表达式求值"></a>4.9 栈的应用——四则运算表达式求值</h2><h3 id="4-9-1-后缀-逆波兰-表示法定义"><a href="#4-9-1-后缀-逆波兰-表示法定义" class="headerlink" title="4.9.1 后缀(逆波兰)表示法定义"></a>4.9.1 后缀(逆波兰)表示法定义</h3><p>栈的现实应用也很多，我们再来重点讲一个比较常见的应用：数学表达式的求值。<br>一种不需要括号的后缀表达法，我们也把它称为逆波兰(Reverse Polish Notation，RPN)表示。<br>我们先来看看，对于“<code>9+(3-1)×3+10÷2</code>”，如果要用后缀表示法应该是：“<code>9 3 1-3*+10 2/+</code>”，这样的表达式称为后缀表达式，叫后缀的原因在于<strong>所有的符号都是在要运算数字的后面出现</strong>。  </p><h3 id="4-9-2-后缀表达式计算结果"><a href="#4-9-2-后缀表达式计算结果" class="headerlink" title="4.9.2 后缀表达式计算结果"></a>4.9.2 后缀表达式计算结果</h3><p>后缀表达式：<code>9 3 1-3*+10 2/+</code><br>规则：<strong>从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</strong>  </p><h3 id="4-9-3-中缀表达式转后缀表达式"><a href="#4-9-3-中缀表达式转后缀表达式" class="headerlink" title="4.9.3 中缀表达式转后缀表达式"></a>4.9.3 中缀表达式转后缀表达式</h3><p>我们把平时所用的标准四则运算表达式，即“<code>9+(3-1)×3+10÷2</code>”叫做中缀表达式。因为所有的运算符号都在两数字的中间。<br>中缀表达式“<code>9+(3-1)×3+10÷2</code>”转化为后缀表达式“<code>9 3 1-3*+10 2/+</code>”。<br>规则：<strong>从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号(乘除优先加减)则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</strong>  </p><h2 id="4-10-队列的定义"><a href="#4-10-队列的定义" class="headerlink" title="4.10 队列的定义"></a>4.10 队列的定义</h2><p>队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。  </p><h2 id="4-11-队列的抽象数据类型"><a href="#4-11-队列的抽象数据类型" class="headerlink" title="4.11 队列的抽象数据类型"></a>4.11 队列的抽象数据类型</h2><pre><code class="c">ADT 队列(Queue)Data    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。Operation    InitQueue(*Q)：初始化操作，建立一个空队列Q。    DestroyQueue(*Q)：若队列Q存在，则销毁它。    ClearQueue(*Q)：将队列Q清空。    QueueEmpty(Q)：若队列Q为空，返回true，否则返回false。    GetHead(Q，*e)：若队列Q存在且非空，用e返回队列Q的队头元素。    EnQueue(*Q，e)：若队列Q存在，插入新元素e到队列Q中并成为队尾元素。    DeQueue(*Q，*e)：删除队列Q中队头元素，并用e返回其值。    QueueLength(Q)：返回队列Q的元素个数endADT</code></pre><h2 id="4-12-循环队列"><a href="#4-12-循环队列" class="headerlink" title="4.12 循环队列"></a>4.12 循环队列</h2><h3 id="4-12-1-队列顺序存储的不足"><a href="#4-12-1-队列顺序存储的不足" class="headerlink" title="4.12.1 队列顺序存储的不足"></a>4.12.1 队列顺序存储的不足</h3><p>入队的时间复杂度为O(1)。<br>与栈不同的是，队列元素的出列是在队头，即下标为0的位置，那也就意味着，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为0的位置不为空，此时时间复杂度为出队的时间复杂度为O(n)，效率太低。<br>如果队列前面的位置空的，后面的位置排满了，那么新进的元素可以排到前面，这就引进了循环队列的概念。<br>为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列是空队列。  </p><h3 id="4-12-2-循环队列定义"><a href="#4-12-2-循环队列定义" class="headerlink" title="4.12.2 循环队列定义"></a>4.12.2 循环队列定义</h3><p>队列中头尾相接的顺序存储结构称为循环队列。<br>此时问题又出来了，空队列时，front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？</p><ol><li>办法一是设置一个标志变量flag，当<code>front==rear</code>，且flag=0时为队列空，当<code>front==rear</code>，且flag=1时为队列满。</li><li>办法二是当队列空时，条件就是<code>front=rear</code>，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。<br>我们重点来讨论第二种方法，由于rear可能比front大，也可能比front小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的最大尺寸为QueueSize，那么队列满的条件是“<code>(rear+1)%QueueSize==front</code>”(取模“%”的目的就是为了整合rear与front大小为一个问题)。<br>通用的计算队列长度公式为：<code>(rear-front+QueueSize)%QueueSize</code>。<br>循环队列的顺序存储结构代码如下：</li></ol><pre><code class="c">typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int *//* 循环队列的顺序存储结构 */typedef struct{    QElemType data[MAXSIZE];    int front;      /* 头指针 */    int rear;       /* 尾指针，若队列不空，指向队列尾元素的下一个位置 */}SqQueue;</code></pre><p>循环队列的初始化代码如下：</p><pre><code class="c">/* 初始化一个空队列Q */Status InitQueue(SqQueue *Q){    Q-&gt;front = 0;    Q-&gt;rear = 0;    return  OK;}</code></pre><p>循环队列求队列长度代码如下：</p><pre><code class="c">/* 返回Q的元素个数，也就是队列的当前长度 */int QueueLength(SqQueue Q){    return  (Q.rear - Q.front + MAXSIZE) % MAXSIZE;}</code></pre><p>循环队列的入队列操作代码如下：</p><pre><code class="c">/* 若队列未满，则插入元素e为Q新的队尾元素 */Status EnQueue(SqQueue *Q, QElemType e){    if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front)    /* 队列满的判断 */        return ERROR;    Q-&gt;data[Q-&gt;rear] = e;               /* 将元素e赋值给队尾 */    Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE;/* rear指针向后移一位置， */                                      /* 若到最后则转到数组头部 */    return  OK;}</code></pre><p>循环队列的出队列操作代码如下：</p><pre><code class="c">/* 若队列不空，则删除Q中队头元素，用e返回其值 */Status DeQueue(SqQueue *Q, QElemType *e){    if (Q-&gt;front == Q-&gt;rear)            /* 队列空的判断 */        return ERROR;    *e = Q-&gt;data[Q-&gt;front];                /* 将队头元素赋值给e */    Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;    /* front指针向后移一位置 */                                    /* 若到最后则转到数组头部 */    return  OK;}</code></pre><h2 id="4-13-队列的链式存储结构及实现"><a href="#4-13-队列的链式存储结构及实现" class="headerlink" title="4.13 队列的链式存储结构及实现"></a>4.13 队列的链式存储结构及实现</h2><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。<br>为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点，如图4-13-1所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-1.JPG?raw=true" alt="4-13-1"><br>空队列时，front和rear都指向头结点，如图4-13-2所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-2.JPG?raw=true" alt="4-13-2"><br>链队列的结构为：  </p><pre><code class="c">typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */typedef struct QNode    /* 结点结构 */{    QElemType data;    struct QNode *next;}QNode, *QueuePtr;typedef struct            /* 队列的链表结构 */{    QueuePtr front, rear; /* 队头、队尾指针 */}LinkQueue;</code></pre><h3 id="4-13-1-队列的链式存储结构——入队操作"><a href="#4-13-1-队列的链式存储结构——入队操作" class="headerlink" title="4.13.1 队列的链式存储结构——入队操作"></a>4.13.1 队列的链式存储结构——入队操作</h3><p>入队操作时，其实就是在链表尾部插入结点，如图4-13-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-3.JPG?raw=true" alt="4-13-3"><br>入队代码如下：</p><pre><code class="c">/* 插入元素e为Q的新的队尾元素 */Status EnQueue(LinkQueue *Q, QElemType e){    QueuePtr s = (QueuePtr)malloc(sizeof(QNode));    if (!s) /* 存储分配失败 */        exit(OVERFLOW);    s-&gt;data = e;    s-&gt;next = NULL;    Q-&gt;rear-&gt;next = s;    /* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */    Q-&gt;rear = s;        /* 把当前的s设置为队尾结点，rear指向s，见图中② */    return OK;}</code></pre><h3 id="4-13-2-队列的链式存储结构——出队操作"><a href="#4-13-2-队列的链式存储结构——出队操作" class="headerlink" title="4.13.2 队列的链式存储结构——出队操作"></a>4.13.2 队列的链式存储结构——出队操作</h3><p>出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将rear指向头结点，如图4-13-4所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-4.JPG?raw=true" alt="4-13-4">  </p><p>出队代码如下：</p><pre><code class="c">/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */Status DeQueue(LinkQueue *Q, QElemType *e){    QueuePtr p;    if (Q-&gt;front == Q-&gt;rear)        return ERROR;    p = Q-&gt;front-&gt;next;        /* 将欲删除的队头结点暂存给p，见图中① */    *e = p-&gt;data;                /* 将欲删除的队头结点的值赋值给e */    Q-&gt;front-&gt;next = p-&gt;next;/* 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中② */    if (Q-&gt;rear == p)/* 空队列的时候 */ /* 若队头就是队尾，则删除后将rear指向头结点，见图中③ */        Q-&gt;rear = Q-&gt;front;    free(p);    return OK;}</code></pre><p>对于循环队列与链队列的比较，可以从两方面来考虑，从时间上，其实它们的基本操作都是常数时间，即都为O(1)的，不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。对于空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。<br>总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。  </p><h2 id="4-14-总结回顾"><a href="#4-14-总结回顾" class="headerlink" title="4.14 总结回顾"></a>4.14 总结回顾</h2><p>这一章讲的是栈和队列，它们都是特殊的线性表，只不过对插入和删除操作做了限制。<br>栈(stack)是限定仅在表尾进行插入和删除操作的线性表。<br>队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。因此它们各自有各自的技巧来解决这个问题。<br>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。<br>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。<br>它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同如图4-14-1所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-14-1.JPG?raw=true" alt="4-14-1">  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;4-1-4-2-栈的定义&quot;&gt;&lt;a href=&quot;#4-1-4-2-栈的定义&quot; class=&quot;headerlink&quot; title=&quot;4.1-4.2 栈的定义&quot;&gt;&lt;/a&gt;4.1-4.2 栈的定义&lt;/h2&gt;&lt;h3 id=&quot;4-2-1-栈的定义&quot;&gt;&lt;a href=&quot;#4-2-1-栈的定义&quot; class=&quot;headerlink&quot; title=&quot;4.2.1 栈的定义&quot;&gt;&lt;/a&gt;4.2.1 栈的定义&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;栈是限定仅在表尾进行插入和删除操作的线性表。&lt;/strong&gt;&lt;br&gt;我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简尔LIFO结构。&lt;br&gt;它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。&lt;br&gt;栈的插入操作，叫作进栈，也称压栈、入栈(push)。&lt;br&gt;栈的删除操作，叫作出栈，也有的叫作弹栈(pop)。  &lt;/p&gt;
&lt;h2 id=&quot;4-3-栈的抽象数据类型&quot;&gt;&lt;a href=&quot;#4-3-栈的抽象数据类型&quot; class=&quot;headerlink&quot; title=&quot;4.3 栈的抽象数据类型&quot;&gt;&lt;/a&gt;4.3 栈的抽象数据类型&lt;/h2&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://closer_laps.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="https://closer_laps.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈和队列" scheme="https://closer_laps.gitee.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
