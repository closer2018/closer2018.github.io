<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="沧海横流，尽显英雄本色；激浊扬清，正是猛士当时">
  <meta name="author" content="closer">
  <meta name="keywords" content="">
  <title>大话数据结构第三章 线性表 - closer的自留地</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/androidstudio.min.css" />


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">




<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Welcome!</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              首页</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">
              <i class="iconfont icon-archive-fill"></i>
              归档</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">
              <i class="iconfont icon-category-fill"></i>
              分类</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">
              <i class="iconfont icon-tags-fill"></i>
              标签</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              关于</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/links/">
              <i class="iconfont icon-link-fill"></i>
              友链</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2019-11-28 00:00">
                    2019年11月28日 凌晨
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    7.2k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    86
                     分钟
                  </span>
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="iconfont icon-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>
                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年2月19日 晚上
                
              </p>
            
            <article class="markdown-body">
              <p>线性表：零个或多个数据元素的有限序列。</p>
<h2 id="3-1-3-2线性表的定义"><a href="#3-1-3-2线性表的定义" class="headerlink" title="3.1-3.2线性表的定义"></a>3.1-3.2线性表的定义</h2><p>线性表（List）：零个或多个数据元素的有限序列。</p>
<p>若将线性表记为（a_1，…，a_(i−1)，a_i，a_(i+1)，…，a_n），则表中a_(i−1) 领先于a_i，a_i 领先于a_(i+1)，称a_(i−1) 是a_i 的直接前驱元素，a_(i+1) 是a_i 的直接后继元素。当i=1，2，…，n-1时，a_i 有且仅有一个直接后继，当i=2，3，…，n时，a_i 有且仅有一个直接前驱。<br>如图3-2-1所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.2.1.GIF?raw=true" srcset="/img/loading.gif" alt="3-2-1"></p>
<p>所以线性表元素的个数n（n&gt;0）定义为线性表的长度，当n=0时，称为空表。</p>
<a id="more"></a>

<p>在较复杂的线性表中，一个数据元素可以由若干个数据项组成。</p>
<h2 id="3-3线性表的抽象数据类型"><a href="#3-3线性表的抽象数据类型" class="headerlink" title="3.3线性表的抽象数据类型"></a>3.3线性表的抽象数据类型</h2><p>线性表的抽象数据类型定义如下：</p>
<div class="hljs"><pre><code class="hljs c">ADT线性表（List）
Data
    线性表的数据对象集合为&#123;a1，a2…，an），每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
Operation
    InitList（*L）；初始化操作，建立一个空的线性表L。
    ListEmpty（L）；若线性表为空，返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span>。
    ClearList（*L）；将线性表清空。
    GetElem（L，i，*e）；将线性表L中的第i个位置元素值返回给e。
    LocateElem（L，e）；在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回<span class="hljs-number">0</span>表示失败。
    ListInsert（*L，i，e）；在线性表L中的第i个位置插入新元素e。
    ListDelete（*L，i，*e）；删除线性表L中第i个位置元素，并用e返回其值。
    ListLength（L）；返回线性表L的元素个数。
endADT</code></pre></div>

<h3 id="3-3-1两个线性表集合的并集操作"><a href="#3-3-1两个线性表集合的并集操作" class="headerlink" title="3.3.1两个线性表集合的并集操作"></a>3.3.1两个线性表集合的并集操作</h3><p>要使得集合A=AUB。说白了，就是把存在集合B中但并不存在A中的数据元素插入到A中即可。<br>仔细分析一下这个操作，发现我们只要循环集合B中的每个元素，判断当前元素是否存在A中，若不存在，则插入到A中即可。思路应该是很容易想到的。<br>我们假设La表示集合A，Lb表示集合B，则实现的代码如下：</p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/*将所有的在线性表Lb中但不在La中的数据元素插入到La中*/</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unionL</span><span class="hljs-params">(SqList *La, SqList Lb)</span>
</span>&#123;
    <span class="hljs-keyword">int</span> La_len, Lb_len, i;
    ElemType e;                          <span class="hljs-comment">/*声明与La和Lb相同的数据元素e*/</span>
    La_len = ListLength(*La);                <span class="hljs-comment">/*求线性表的长度*/</span>
    Lb_len = ListLength(Lb);
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= Lb_len; i++)
    &#123;
        GetElem(Lb, i, &amp;e);           <span class="hljs-comment">/*取Lb中第i个数据元素赋给e*/</span>
        <span class="hljs-keyword">if</span> (!LocateElem(*La, e))           <span class="hljs-comment">/*La中不存在和e相同数据元素*/</span>
            ListInsert(La, ++La_len, e);          <span class="hljs-comment">/*插入*/</span>
    &#125;
&#125;</code></pre></div>

<h2 id="3-4线性表的顺序存储结构"><a href="#3-4线性表的顺序存储结构" class="headerlink" title="3.4线性表的顺序存储结构"></a>3.4线性表的顺序存储结构</h2><h3 id="3-4-1顺序存储定义"><a href="#3-4-1顺序存储定义" class="headerlink" title="3.4.1顺序存储定义"></a>3.4.1顺序存储定义</h3><p>线性表的两种物理结构的第一种——顺序存储结构。<br>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p>
<h3 id="3-4-2顺序存储方式"><a href="#3-4-2顺序存储方式" class="headerlink" title="3.4.2顺序存储方式"></a>3.4.2顺序存储方式</h3><p>可以用C语言（其他语言也相同）的一维数组来实现顺序存储结构。<br>线性表的顺序存储的结构代码如下</p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 20<span class="hljs-comment">/*存储空间初始分配量*/</span></span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;  <span class="hljs-comment">/*ElemType 类型根据实际情况而定，这里假设为int*/</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
&#123;</span>
    ElemType data[MAXSIZE];<span class="hljs-comment">/*数组存储数据元素，最大值为MAXSIZE*/</span>
    <span class="hljs-keyword">int</span> length;  <span class="hljs-comment">/*线性表当前长度*/</span>
&#125;SqList;</code></pre></div>

<p>这里，我们就发现描述顺序存储结构需要三个属性：<br>    • 存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。<br>    • 线性表的最大存储容量：数组长度MaxSize。<br>    • 线性表的当前长度：length。</p>
<h3 id="3-4-3数据长度与线性表长度区别"><a href="#3-4-3数据长度与线性表长度区别" class="headerlink" title="3.4.3数据长度与线性表长度区别"></a>3.4.3数据长度与线性表长度区别</h3><p>数组的长度是存放线性表的存储空间的长度，存储分配后这个量是一般是不变的。<br>线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。<br>在任意时刻，线性表的长度应该小于等于数组的长度。</p>
<h3 id="3-4-4地址计算方法"><a href="#3-4-4地址计算方法" class="headerlink" title="3.4.4地址计算方法"></a>3.4.4地址计算方法</h3><p>存储器中的每个存储单元都有自己的编号，这个编号称为地址。<br>假设占用的是c个存储单元，那么线性表中第i+1个数据元素的存储位置和第i个数据元素的存储位置满足下列关系（LOC表示获得存储位置的函数）。<br>    LOC（a_(i+1)）=LOC（a_i）+c<br>所以对于第i个数据元素ai的存储位置可以由a1推算得出：<br>    LOC（a_i）=LOC（a_1）+（i-1）*c</p>
<h2 id="3-5顺序存储结构的插入与删除"><a href="#3-5顺序存储结构的插入与删除" class="headerlink" title="3.5顺序存储结构的插入与删除"></a>3.5顺序存储结构的插入与删除</h2><h3 id="3-5-1获得元素操作"><a href="#3-5-1获得元素操作" class="headerlink" title="3.5.1获得元素操作"></a>3.5.1获得元素操作</h3><p>我们要实现GetElem操作，即将线性表L中的第i个位置元素值返回。只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。</p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE 1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 0</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Status;          <span class="hljs-comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span>
<span class="hljs-comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span>
<span class="hljs-comment">/* 操作结果：用e返回L中第i个数据元素的值,注意i是指位置，第1个位置的数组是从0开始 */</span>
<span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-keyword">int</span> i, ElemType *e)</span>
</span>&#123;
    <span class="hljs-keyword">if</span> (L.length == <span class="hljs-number">0</span> || i&lt;<span class="hljs-number">1</span> || i&gt;L.length)
        <span class="hljs-keyword">return</span> ERROR;
    *e = L.data[i - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">return</span> OK;
&#125;</code></pre></div>

<h3 id="3-5-2插入操作"><a href="#3-5-2插入操作" class="headerlink" title="3.5.2插入操作"></a>3.5.2插入操作</h3><p>插入算法的思路：<br>    • 如果插入位置不合理，抛出异常；<br>    • 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；<br>    • 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；<br>    • 将要插入元素填入位置i处；<br>    • 表长加1。<br>实现代码如下：</p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */</span>
<span class="hljs-comment">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */</span>
<span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList *L, <span class="hljs-keyword">int</span> i, ElemType e)</span>
</span>&#123;
    <span class="hljs-keyword">int</span> k;
    <span class="hljs-keyword">if</span> (L-&gt;length == MAXSIZE)  <span class="hljs-comment">/* 顺序线性表已经满 */</span>
        <span class="hljs-keyword">return</span> ERROR;
    <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">1</span> || i&gt;L-&gt;length + <span class="hljs-number">1</span>)<span class="hljs-comment">/* 当i比第一位置小或者比最后一位置后一位置还要大时 */</span>
        <span class="hljs-keyword">return</span> ERROR;
    <span class="hljs-keyword">if</span> (i &lt;= L-&gt;length)        <span class="hljs-comment">/* 若插入数据位置不在表尾 */</span>
    &#123;
        <span class="hljs-keyword">for</span> (k = L-&gt;length - <span class="hljs-number">1</span>; k &gt;= i - <span class="hljs-number">1</span>; k--)  <span class="hljs-comment">/* 将要插入位置之后的数据元素向后移动一位 */</span>
            L-&gt;data[k + <span class="hljs-number">1</span>] = L-&gt;data[k];
    &#125;
    L-&gt;data[i - <span class="hljs-number">1</span>] = e;          <span class="hljs-comment">/* 将新元素插入 */</span>
    L-&gt;length++;
    <span class="hljs-keyword">return</span> OK;
&#125;</code></pre></div>

<h3 id="3-5-3删除操作"><a href="#3-5-3删除操作" class="headerlink" title="3.5.3删除操作"></a>3.5.3删除操作</h3><p>删除算法的思路：<br>    • 如果删除位置不合理，抛出异常；<br>    • 取出删除元素；<br>    • 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；<br>    • 表长减1。<br>实现代码如下：</p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span>
<span class="hljs-comment">/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span>
<span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList *L, <span class="hljs-keyword">int</span> i, ElemType *e)</span>
</span>&#123;
    <span class="hljs-keyword">int</span> k;
    <span class="hljs-keyword">if</span> (L-&gt;length == <span class="hljs-number">0</span>)               <span class="hljs-comment">/* 线性表为空 */</span>
        <span class="hljs-keyword">return</span> ERROR;
    <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">1</span> || i&gt;L-&gt;length)         <span class="hljs-comment">/* 删除位置不正确 */</span>
        <span class="hljs-keyword">return</span> ERROR;
    *e = L-&gt;data[i - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">if</span> (i &lt; L-&gt;length)                <span class="hljs-comment">/* 如果删除不是最后位置 */</span>
    &#123;
        <span class="hljs-keyword">for</span> (k = i; k &lt; L-&gt;length; k++)<span class="hljs-comment">/* 将删除位置后继元素前移 */</span>
            L-&gt;data[k - <span class="hljs-number">1</span>] = L-&gt;data[k];
    &#125;
    L-&gt;length--;
    <span class="hljs-keyword">return</span> OK;
&#125;</code></pre></div>

<p>线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O（1）；而插入或删除时，时间复杂度都是O（n）。</p>
<h3 id="3-5-4线性表顺序存储结构的优缺点"><a href="#3-5-4线性表顺序存储结构的优缺点" class="headerlink" title="3.5.4线性表顺序存储结构的优缺点"></a>3.5.4线性表顺序存储结构的优缺点</h3><p>线性表的顺序存储结构的优缺点如图3-5-3所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.5.3.GIF?raw=true" srcset="/img/loading.gif" alt="3-5-3"></p>
<h3 id="3-6线性表的链式存储结构"><a href="#3-6线性表的链式存储结构" class="headerlink" title="3.6线性表的链式存储结构"></a>3.6线性表的链式存储结构</h3><h3 id="3-6-2线性表链式存储结构定义"><a href="#3-6-2线性表链式存储结构定义" class="headerlink" title="3.6.2线性表链式存储结构定义"></a>3.6.2线性表链式存储结构定义</h3><p>为了表示每个数据元素a_i 与其直接后继数据元素a_(i+1) 之间的逻辑关系，对数据元素a1来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素a_i 的存储映像，称为结点（Node）。<br>n个结点（a_i 的存储映像）链结成一个链表，即为线性表（a_1，a_2，…，a_n）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。<br>我们把链表中第一个结点的存储位置叫做头指针,线性链表的最后一个结点指针为“空”（通常用NULL或“^”符号表示）。<br>有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息。</p>
<h3 id="3-6-3头指针与头结点的异同"><a href="#3-6-3头指针与头结点的异同" class="headerlink" title="3.6.3头指针与头结点的异同"></a>3.6.3头指针与头结点的异同</h3><p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.6.3.GIF?raw=true" srcset="/img/loading.gif" alt="3-6-3"></p>
<h3 id="3-6-4线性表链式存储结构代码描述"><a href="#3-6-4线性表链式存储结构代码描述" class="headerlink" title="3.6.4线性表链式存储结构代码描述"></a>3.6.4线性表链式存储结构代码描述</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">//线性表的单链表存储结构</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
&#123;</span>
    ElemType data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span>
&#125;Node;
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">LinkList</span>;</span><span class="hljs-comment">/* 定义LinkList */</span></code></pre></div>

<p>节点Node是由存放数据元素的数据域和存放后继节点地址的指针域组成。  </p>
<h2 id="3-7单链表的读取"><a href="#3-7单链表的读取" class="headerlink" title="3.7单链表的读取"></a>3.7单链表的读取</h2><p>获得链表第i个的数据的算法思路：  </p>
<ol>
<li>声明一个结点p指向链表第一个结点，初始化j从1开始;  </li>
<li>当<code>j&lt;i</code>时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1;  </li>
<li>若到链表末尾p为空，则说明第i个元素不存在;  </li>
<li>否则查找成功，返回结点p的数据。  </li>
</ol>
<p>实现代码算法如下：</p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span>
<span class="hljs-comment">/* 操作结果：用e返回L中第i个数据元素的值 */</span>
<span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L,<span class="hljs-keyword">int</span> i,ElemType *e)</span>
</span>&#123;
    <span class="hljs-keyword">int</span> j;
    LinkList p;  <span class="hljs-comment">/* 声明一结点p */</span>
    p = L-&gt;next;  <span class="hljs-comment">/* 让p指向链表L的第一个结点 */</span>
    j = <span class="hljs-number">1</span>;        <span class="hljs-comment">/*  j为计数器 */</span>
    <span class="hljs-keyword">while</span> (p &amp;&amp; j&lt;i)  <span class="hljs-comment">/* p不为空或者计数器j还没有等于i时，循环继续 */</span>
    &#123;
        p = p-&gt;next;  <span class="hljs-comment">/* 让p指向下一个结点 */</span>
        ++j;
    &#125;
    <span class="hljs-keyword">if</span> ( !p || j&gt;i )
        <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">/*  第i个元素不存在 */</span>
    *e = p-&gt;data;   <span class="hljs-comment">/*  取第i个元素的数据 */</span>
    <span class="hljs-keyword">return</span> OK;
&#125;</code></pre></div>

<p>这个算法的最坏情况时间复杂度为O(n)。  </p>
<h2 id="3-8-单链表的插入和删除"><a href="#3-8-单链表的插入和删除" class="headerlink" title="3.8 单链表的插入和删除"></a>3.8 单链表的插入和删除</h2><h3 id="3-8-1-单链表的插入"><a href="#3-8-1-单链表的插入" class="headerlink" title="3.8.1 单链表的插入"></a>3.8.1 单链表的插入</h3><p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.8.1.GIF?raw=true" srcset="/img/loading.gif" alt="图3-8-1"><br>假设上一个结点是p，下一个结点是p-&gt;next,现在要把结点s插入这两个结点中去。只需要2行代码：<br><code>s-&gt;next=p-&gt;next;//先让s的指针域指向p-&gt;next</code><br><code>p-&gt;next=s;//把s的地址赋给p的指针域</code></p>
<p>ps:这两句顺序不能交换。<br>如果先<code>p-&gt;next=s</code>;再<code>s-&gt;next=p-&gt;next</code>;就等于<code>s-&gt;next=s</code>;<br>所以这2句如论如何都不能反，这点初学者一定要注意。  </p>
<p>单链表第i个数据插入结点的算法思路：</p>
<ol>
<li>声明一结点p指向链表第一个结点，初始化j从1开始;</li>
<li>当j&lt;1时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1;</li>
<li>若到链表末尾p为空，则说明第i个元素不存在;</li>
<li>否则查找成功，在系统中生成一个空结点s;</li>
<li>将数据元素e赋值给<code>s-&gt;data</code>;</li>
<li>单链表的插入标准语句<code>s-&gt;next=p-&gt;next;p-&gt;next=s;</code>;</li>
<li>返回成功;  </li>
</ol>
<p>实现代码算法如下:</p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */</span>
<span class="hljs-comment">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */</span>
<span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(LinkList *L,<span class="hljs-keyword">int</span> i,ElemType e)</span>
</span>&#123;
    <span class="hljs-keyword">int</span> j;
    LinkList p,s;
    p = *L;
    j = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (p &amp;&amp; j &lt; i)     <span class="hljs-comment">/* 寻找第i个结点 */</span>
    &#123;
        p = p-&gt;next;
        ++j;
    &#125;
    <span class="hljs-keyword">if</span> (!p || j &gt; i)
        <span class="hljs-keyword">return</span> ERROR;   <span class="hljs-comment">/* 第i个元素不存在 */</span>
    s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));  <span class="hljs-comment">/*  生成新结点(C语言标准函数) */</span>
    s-&gt;data = e;  
    s-&gt;next = p-&gt;next;      <span class="hljs-comment">/* 将p的后继结点赋值给s的后继  */</span>
    p-&gt;next = s;          <span class="hljs-comment">/* 将s赋值给p的后继 */</span>
    <span class="hljs-keyword">return</span> OK;
&#125;</code></pre></div>

<h3 id="3-8-2-单链表的删除"><a href="#3-8-2-单链表的删除" class="headerlink" title="3.8.2 单链表的删除"></a>3.8.2 单链表的删除</h3><p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.8.5.GIF?raw=true" srcset="/img/loading.gif" alt="3-8-5"><br>要删除节点q，其实就是要让<code>p-&gt;next=q-&gt;next</code>;<br>单链表第i个数据删除结点的算法思路：</p>
<ol>
<li>声明一结点p指向链表第一个结点，初始化j从1开始</li>
<li>当<code>j&lt;i</code>时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；</li>
<li>若到链表末尾p为空，则说明第i个元素不存在；</li>
<li>否则查找成功，将欲删除的结点<code>p-&gt;next</code>赋值给q；</li>
<li>单链表的删除标准语句<code>p-&gt;next=q-&gt;next</code>；</li>
<li>将q结点中的数据赋值给e，作为返回；</li>
<li>释放q结点；</li>
<li>返回成功。  </li>
</ol>
<p>实现代码算法如下：</p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span>
<span class="hljs-comment">/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span>
<span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(LinkList *L,<span class="hljs-keyword">int</span> i,ElemType *e)</span>
</span>&#123;
    <span class="hljs-keyword">int</span> j;
    LinkList p,q;
    p = *L;
    j = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i)    <span class="hljs-comment">/* 遍历寻找第i个元素 */</span>
    &#123;
        p = p-&gt;next;
        ++j;
    &#125;
    <span class="hljs-keyword">if</span> (!(p-&gt;next) || j &gt; i)
        <span class="hljs-keyword">return</span> ERROR;           <span class="hljs-comment">/* 第i个元素不存在 */</span>
    q = p-&gt;next;              <span class="hljs-comment">//q结点指向要删除的结点（即要删除的结点地址赋值给q）</span>
    p-&gt;next = q-&gt;next;            <span class="hljs-comment">/* 将q的后继(第三个结点)赋值给p的后继 */</span>
    *e = q-&gt;data;               <span class="hljs-comment">/* 将q结点中的数据给e */</span>
    <span class="hljs-built_in">free</span>(q);                    <span class="hljs-comment">/* 让系统回收此结点，释放内存 */</span>
    <span class="hljs-keyword">return</span> OK;
&#125;</code></pre></div>

<p>分析一下刚才我们讲解的单链表插入和删除算法，我们很容易推导出：它们的时间复杂度都是O（n）。<br>显然，对于<strong>插入或删除数据越频繁的操作，单链表的效率优势就越是明显</strong>。</p>
<h2 id="3-9单链表的整表创建"><a href="#3-9单链表的整表创建" class="headerlink" title="3.9单链表的整表创建"></a>3.9单链表的整表创建</h2><p>单链表整表创建的算法思路：</p>
<ol>
<li>声明一结点p和计数器变量i；</li>
<li>初始化一空链表L；</li>
<li>让L的头结点的指针指向NULL，即建立一个带头结点的单链表；</li>
<li>循环：<ul>
<li>生成一新结点赋值给p；</li>
<li>随机生成一数字赋值给p的数据域p&gt;data；  </li>
<li>将p插入到头结点与前一新结点之间。  </li>
</ul>
</li>
</ol>
<p>实现头插法的代码算法如下(这段算法代码里,我们用插队的办法，始终让新结点在第一的位置。这种算法简称为头插法)：</p>
<div class="hljs"><pre><code class="c"><span class="comment">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */</span>
<span class="function"><span class="keyword">void</span> <span class="title">CreateListHead</span><span class="params">(LinkList *L, <span class="keyword">int</span> n)</span></span>
<span class="function"></span>{
    LinkList p;
    <span class="keyword">int</span> i;
    srand(time(<span class="number">0</span>));                         <span class="comment">/* 初始化随机数种子 */</span>
    *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));
    (*L)-&gt;next = <span class="literal">NULL</span>;                      <span class="comment">/*  先建立一个带头结点的单链表 */</span>
    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)
    {
        p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">/*  生成新结点 */</span>
        p-&gt;data = rand()%<span class="number">100</span>+<span class="number">1</span>;             <span class="comment">/*  随机生成100以内的数字 */</span>
        p-&gt;next = (*L)-&gt;next;
        (*L)-&gt;next = p;                        <span class="comment">/*  插入到表头 */</span>
    }
}</code></pre></div>
<p>事实上，我们一般插队都是放在最后的。如果我们把每次的新结点都插在终端结点的后面，这种算法称之为尾插法。  </p>
<p>实现尾插法代码算法如下：</p>
<div class="hljs"><pre><code class="c"><span class="comment">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */</span>
<span class="function"><span class="keyword">void</span> <span class="title">CreateListTail</span><span class="params">(LinkList *L, <span class="keyword">int</span> n)</span></span>
<span class="function"></span>{
    LinkList p,r;
    <span class="keyword">int</span> i;
    srand(time(<span class="number">0</span>));                      <span class="comment">/* 初始化随机数种子 */</span>
    *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">/* L为整个线性表 */</span>
    r=*L;                                <span class="comment">/* r为指向尾部的结点 */</span>
    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)
    {
        p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">/*  生成新结点 */</span>
        p-&gt;data = rand()%<span class="number">100</span>+<span class="number">1</span>;           <span class="comment">/*  随机生成100以内的数字 */</span>
        r-&gt;next=p;                        <span class="comment">/* 将表尾终端结点的指针指向新结点 */</span>
        r = p;                            <span class="comment">/* 将当前的新结点定义为表尾终端结点 */</span>
    }
    r-&gt;next = <span class="literal">NULL</span>;                       <span class="comment">/* 表示当前链表结束 */</span>
}</code></pre></div>
<p>PS：这里需解释一下，<code>r-&gt;next=p</code>的意思，其实就是将刚才的表尾终端结点r的指针指向新结点p，如图3-9-2所示，当中①位置的连线就是表示这个意思。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.9.2.GIF?raw=true" srcset="/img/loading.gif" alt="3-9-2"><br><code>r=p</code>的意思请看图3-9-3，就是本来r是a_(i-1)元素的结点，现在它已经不是最后的结点了，现在最后的结点是a_i，所以应该将p结点这个最后的结点赋值给r。此时r又是最终的尾结点了。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.9.3.GIF?raw=true" srcset="/img/loading.gif" alt="3-9-3">  </p>
<p>循环结束后，那么应该让这个链表的指针域置空，因此有了<code>r-&gt;next=NULL</code>，以便以后遍历时可以确认其是尾部。  </p>
<h2 id="3-10单链表的整表删除"><a href="#3-10单链表的整表删除" class="headerlink" title="3.10单链表的整表删除"></a>3.10单链表的整表删除</h2><p>单链表整表删除的算法思路如下：</p>
<ol>
<li>声明一结点p和q；</li>
<li>将第一个结点赋值给p；</li>
<li>循环：<ul>
<li>将下一结点赋值给q；</li>
<li>释放p；将q赋值给p。  </li>
</ul>
</li>
</ol>
<p>实现代码算法如下：  </p>
<div class="hljs"><pre><code class="c"><span class="comment">/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */</span>
<span class="function">Status <span class="title">ClearList</span><span class="params">(LinkList *L)</span></span>
<span class="function"></span>{
    LinkList p,q;
    p=(*L)-&gt;next;           <span class="comment">/*  p指向第一个结点 */</span>
    <span class="keyword">while</span>(p)                <span class="comment">/*  没到表尾 */</span>
    {
        q=p-&gt;next;   <span class="comment">//下一个结点地址赋值给临时结点q</span>
        <span class="built_in">free</span>(p);     <span class="comment">//释放p结点内存</span>
        p=q;         <span class="comment">//临时结点q的地址赋值给p，使p能够指向继续指向下一个结点</span>
    }
    (*L)-&gt;next=<span class="literal">NULL</span>;        <span class="comment">/* 头结点指针域为空 */</span>
    <span class="keyword">return</span> OK;
}</code></pre></div>
<h2 id="3-11单链表结构与顺序存储结构优缺点"><a href="#3-11单链表结构与顺序存储结构优缺点" class="headerlink" title="3.11单链表结构与顺序存储结构优缺点"></a>3.11单链表结构与顺序存储结构优缺点</h2><p>简单地对单链表结构和顺序存储结构做对比,如图3-11-1：<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.11.1.GIF?raw=true" srcset="/img/loading.gif" alt="3-11-1">  </p>
<p>通过上面的对比，我们可以得出一些经验性的结论：</p>
<ul>
<li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。</li>
<li>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。  </li>
</ul>
<p>总之，线性表的顺序存储结构和单链表结构各有其优缺点，不能简单的说哪个好，哪个不好，需要根据实际情况，来综合平衡采用哪种数据结构更能满足和达到需求和性能。  </p>
<h2 id="3-12静态链表"><a href="#3-12静态链表" class="headerlink" title="3.12静态链表"></a>3.12静态链表</h2><p>静态链表是由数组组成。<br>我们让数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下标都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而游标cur相当于单链表中的next 指针，存放该元素的后继在数组中的下标。<br>我们把这种用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。<br>静态链表的结构定义如下：  </p>
<div class="hljs"><pre><code class="c"><span class="comment">/* 线性表的静态链表存储结构 */</span>
<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span>
<span class="class">{</span>
    ElemType data;
    <span class="keyword">int</span> cur;  <span class="comment">/* 游标(Cursor) ，为0时表示无指向 */</span>
} Component,StaticLinkList[MAXSIZE];</code></pre></div>
<p>另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据。我们通常把未被使用的数组元素称为备用链表。而数组第一个元素，即<strong>下标为0的元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标</strong>，相当于单链表中的头结点作用，当整个链表为空时，则为0。如图3-12-1所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.12.1.GIF?raw=true" srcset="/img/loading.gif" alt="3-12-1">  </p>
<p>初始化数组状态，代码如下：  </p>
<div class="hljs"><pre><code class="c"><span class="comment">/* 将一维数组space中各分量链成一个备用链表，space[0].cur为头指针，"0"表示空指针 */</span>
<span class="function">Status <span class="title">InitList</span><span class="params">(StaticLinkList space)</span></span>
<span class="function"></span>{
    <span class="keyword">int</span> i;
    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;MAXSIZE<span class="number">-1</span>; i++)  
        space[i].cur = i+<span class="number">1</span>;
    space[MAXSIZE<span class="number">-1</span>].cur = <span class="number">0</span>; <span class="comment">/* 目前静态链表为空，最后一个元素的cur为0 */</span>
    <span class="keyword">return</span> OK;
}</code></pre></div>
<h3 id="3-12-1静态链表的插入操作"><a href="#3-12-1静态链表的插入操作" class="headerlink" title="3.12.1静态链表的插入操作"></a>3.12.1静态链表的插入操作</h3><p>在静态链表中，需要我们自己实现结点的申请和释放这2个函数，才可以做插入和删除的操作。<br>为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。  </p>
<div class="hljs"><pre><code class="c"><span class="comment">/* 若备用空间链表非空，则返回分配的结点下标，否则返回0 */</span>
<span class="function"><span class="keyword">int</span> <span class="title">Malloc_SSL</span><span class="params">(StaticLinkList space)</span></span>
<span class="function"></span>{
    <span class="keyword">int</span> i = space[<span class="number">0</span>].cur;                   <span class="comment">/* 当前数组第一个元素的cur存的值 */</span>
                                            <span class="comment">/* 就是要返回的第一个备用空闲的下标 */</span>
    <span class="keyword">if</span> (space[<span class="number">0</span>]. cur)
        space[<span class="number">0</span>]. cur = space[i].cur;       <span class="comment">/* 由于要拿出一个分量来使用了， */</span>
                               ll             <span class="comment">/* 所以我们就得把它的下一个 */</span>
                                            <span class="comment">/* 分量用来做备用 */</span>
    <span class="keyword">return</span> i;
}</code></pre></div>
<p>这段代码有意思，它的作用就是返回一个下标值，这个值就是数组头元素的cur存的第一个空闲的下标,同时把这个空闲的下标给<code>space[0].cur</code>，之后就可以继续分配新的空闲分量，实现类似mallbc（）函数的作用。<br>插入操作的实现代码如下：  </p>
<div class="hljs"><pre><code class="c"><span class="comment">/*  在L中第i个元素之前插入新的数据元素e   */</span>
<span class="function">Status <span class="title">ListInsert</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i, ElemType e)</span></span>
<span class="function"></span>{  
    <span class="keyword">int</span> j, k, l;
    k = MAXSIZE - <span class="number">1</span>;   <span class="comment">/* 注意k首先是最后一个元素的下标 */</span>
    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L) + <span class="number">1</span>)
        <span class="keyword">return</span> ERROR;
    j = Malloc_SSL(L);   <span class="comment">/* 获得空闲分量的下标 */</span>
    <span class="keyword">if</span> (j)
    {
        L[j].data = e;   <span class="comment">/* 将数据赋值给此分量的data */</span>
        <span class="keyword">for</span>(l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; l++)   <span class="comment">/* 找到第i个元素之前的位置 */</span>
           k = L[k].cur;
        L[j].cur = L[k].cur;    <span class="comment">/* 把第i个元素之前的cur赋值给新元素的cur */</span>
        L[k].cur = j;           <span class="comment">/* 把新元素的下标赋值给第i个元素之前元素的ur */</span>
        <span class="keyword">return</span> OK;
    }
    <span class="keyword">return</span> ERROR;
}</code></pre></div>
<h3 id="3-12-2静态链表的删除操作"><a href="#3-12-2静态链表的删除操作" class="headerlink" title="3.12.2静态链表的删除操作"></a>3.12.2静态链表的删除操作</h3><p>删除元素时，实现的代码如下：  </p>
<div class="hljs"><pre><code class="c"><span class="comment">/*  删除在L中第i个数据元素   */</span>
<span class="function">Status <span class="title">ListDelete</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i)</span></span>
<span class="function"></span>{
    <span class="keyword">int</span> j, k;
    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L))
        <span class="keyword">return</span> ERROR;
    k = MAXSIZE - <span class="number">1</span>;
    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)
        k = L[k].cur;
    j = L[k].cur;
    L[k].cur = L[j].cur;
    Free_SSL(L, j);
    <span class="keyword">return</span> OK;
}</code></pre></div>
<p>释放结点的函数代码如下：  </p>
<div class="hljs"><pre><code class="c"><span class="comment">/*  将下标为k的空闲结点回收到备用链表 */</span>
<span class="function"><span class="keyword">void</span> <span class="title">Free_SSL</span><span class="params">(StaticLinkList space, <span class="keyword">int</span> k)</span></span>
<span class="function"></span>{  
    space[k].cur = space[<span class="number">0</span>].cur;    <span class="comment">/* 把第一个元素的cur值赋给要删除的分量cur */</span>
    space[<span class="number">0</span>].cur = k;               <span class="comment">/* 把要删除的分量下标赋值给第一个元素的cur */</span>
}</code></pre></div>
<p>返回静态链表长度的代码实现如下：  </p>
<div class="hljs"><pre><code class="c"><span class="comment">/* 初始条件：静态链表L已存在。操作结果：返回L中数据元素个数 */</span>
<span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span></span>
<span class="function"></span>{
    <span class="keyword">int</span> j=<span class="number">0</span>;
    <span class="keyword">int</span> i=L[MAXSIZE<span class="number">-1</span>].cur;
    <span class="keyword">while</span>(i)
    {
        i=L[i].cur;
        j++;
    }
    <span class="keyword">return</span> j;
}</code></pre></div>
<h3 id="3-12-3静态链表优缺点"><a href="#3-12-3静态链表优缺点" class="headerlink" title="3.12.3静态链表优缺点"></a>3.12.3静态链表优缺点</h3><p>总结一下静态链表的优缺点（见图3-12-5）：<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.12.5.GIF?raw=true" srcset="/img/loading.gif" alt="3-12-5"><br>总的来说，静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。尽管大家不一定会用得上，但这样的思考方式是非常巧妙的，应该理解其思想，以备不时之需。  </p>
<h2 id="3-13循环链表"><a href="#3-13循环链表" class="headerlink" title="3.13循环链表"></a>3.13循环链表</h2><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。<br>其实循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断<code>p-&gt;next</code>是否为空，现在则是<code>p-&gt;next</code>不等于头结点，则循环未结束。<br>在单链表中，我们有了头结点时，我们可以用O（1）的时间访问第一个结点，但如果想要用O（1）的时间访问到最后一个结点，则需要改造一下这个循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表（如图3-13-5）。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.5.GIF?raw=true" srcset="/img/loading.gif" alt="3-13-5"><br>从上图可以看出，终端结点用尾指针rear指示，则查找终端结点是O（1），而开始结点，其实就是<code>rear-&gt;next-&gt;next</code>，其时间复杂也为O（1）。<br>举个程序的例子，要将两个循环链表合并成一个表时，有了尾指针就非常简单了。比如下面的这两个循环链表，它们的尾指针分别是rearA和rearB，如图3-13-6所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.6.GIF?raw=true" srcset="/img/loading.gif" alt="3-13-6"><br>要想把它们合并，只需要如下的操作即可，如图3-13-7所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.7.GIF?raw=true" srcset="/img/loading.gif" alt="3-13-7"><br>具体代码如下：  </p>
<div class="hljs"><pre><code class="c">p=rearA-&gt;next;     <span class="comment">/*保存A表的头结点，即①*/</span>
rearA-&gt;next=rearB-&gt;next-&gt;next;     <span class="comment">/*将本是指向B表的第一个结点（不是头结点）赋值给reaA-&gt;next,即②*/</span>
rearB-&gt;next=p;<span class="comment">/*将原A表的头结点赋值给rearB-&gt;next，即③**/</span>
<span class="built_in">free</span>(p);<span class="comment">/*释放p*/</span></code></pre></div>
<h2 id="3-14双向链表"><a href="#3-14双向链表" class="headerlink" title="3.14双向链表"></a>3.14双向链表</h2><p>双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。<br>所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。  </p>
<div class="hljs"><pre><code class="c"><span class="comment">/*线性表的双向链表存储结构*/</span>
<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span></span>
<span class="class">{</span>
    ElemType data；
    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>；/*直接前驱指针*/</span>
<span class="class">    <span class="title">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>；/*直接后继指针*/</span>
<span class="class">}<span class="title">DulNode</span>，*<span class="title">DuLinkList</span>；</span></code></pre></div>
<p>既然单链表也可以有循环链表，那么双向链表当然也可以是循环表。<br>双向链表的循环带头结点的空链表如图3-14-3所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.3.GIF?raw=true" srcset="/img/loading.gif" alt="3-14-3"><br>非空的循环的带头结点的双向链表如图3-14-4所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.4.GIF?raw=true" srcset="/img/loading.gif" alt="3-14-4"><br>PS：双向链表在插入和删除时，需要更改两个指针变量。<br>插入操作时，其实并不复杂，不过<strong>顺序很重要，千万不能写反了</strong>。<br>我们现在假设存储元素e的结点为s，要实现将结点s插入到结点p和<code>p-&gt;next</code>之间需要下面几步，如图3-14-5所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.5.GIF?raw=true" srcset="/img/loading.gif" alt="3-14-5">  </p>
<div class="hljs"><pre><code class="c">s-&gt;prior=p;<span class="comment">/*把p赋值给s的前驱，如图中①*/</span>
s-&gt;next=p-&gt;next;<span class="comment">/*把p-&gt;next赋值给s的后继，如图中②*/</span>
p-&gt;next-&gt;prior=s;<span class="comment">/*把s赋值给p-&gt;next的前驱，如图中③*/</span>
p-&gt;next=s;<span class="comment">/*把s赋值给p的后继，如图中④*/</span></code></pre></div>
<p>关键在于它们的顺序，由于第2步和第3步都用到了<code>p-&gt;next</code>。如果第4步先执行，则会使得<code>p-&gt;next</code>提前变成了s，使得插入的工作完不成。所以我们不妨把上面这张图在理解的基础上记忆，顺序是先搞定s的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。  </p>
<p>若要删除结点p，只需要下面两步骤，如图3-14-6所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.6.GIF?raw=true" srcset="/img/loading.gif" alt="3-14-6">  </p>
<div class="hljs"><pre><code class="c">p-&gt;prior-&gt;next=p-&gt;next；<span class="comment">/*把p-&gt;next赋值给p-&gt;prior的后继，如图中①*/</span>
p-&gt;next-&gt;prior=p-&gt;prior；<span class="comment">/*把p-&gt;prior 赋值给p-&gt;next的前驱，如图中②*/</span>
<span class="built_in">free</span>（p）；<span class="comment">/*释放结点*/</span></code></pre></div>
<h2 id="3-15总结回顾"><a href="#3-15总结回顾" class="headerlink" title="3.15总结回顾"></a>3.15总结回顾</h2><p>这一章，主要讲的是线性表。<br>先谈了它的定义，线性表是零个或多个具有相同类型的数据元素的有限序列。然后谈了线性表的抽象数据类型，如它的一些基本操作。<br>之后我们就线性表的两大结构做了讲述，先讲的是比较容易的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。通常我们都是用数组来实现这一结构。<br>后来是我们的重点，由顺序存储结构的插入和删除操作不方便，引出了链式存储结构。它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。然后我们分别就链式存储结构的不同形式，如单链表、循环链表和双向链表做了讲解，另外我们还讲了若不使用指针如何处理链表结构的静态链表方法。<br>总的来说，线性表的这两种结构（如图3-15-1所示）是后面其他数据结构的基础，把它们学明白了，对后面的学习有着至关重要的作用。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.15.1.GIF?raw=true" srcset="/img/loading.gif" alt="3-15-1"></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">大话数据结构</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2019/12/01/hexo/hexo%E4%B8%8A%E4%BC%A0%E9%83%A8%E7%BD%B2%E5%91%BD%E4%BB%A4/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">hexo上传部署命令</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC4%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/">
                        <span class="hidden-mobile">大话数据结构第四章 栈与队列</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script defer src="https://cdn.staticfile.org/valine/1.4.14/Valine.min.js" ></script>

  <script type="text/javascript">
    var oldLoadVa = window.onload;
    window.onload = function () {
      oldLoadVa && oldLoadVa();

      new Valine({
        el: "#vcomments",
        app_id: "YzLqNtMw1YEwwACli1FUsIUM-gzGzoHsz",
        app_key: "HLUt5izfTvTcbEbOrA59W92a",
        placeholder: "畅所欲言...",
        path: window.location.pathname,
        avatar: "robohash",
        meta: ["nick","mail","link"],
        pageSize: "10",
        lang: "zh-CN",
        highlight: true,
        recordIP: false,
        serverURLs: "",
      });
    };
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-md">
    <div class="container custom post-content mx-auto">
      <img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/pay/pay.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-3" style="width:355.4px; height:200px;">
    </div>
  </div>


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  
    <!-- APlayer 音乐播放器 -->
    <div id="aplayer"></div>
    <script defer src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.js" ></script>
<link  rel="stylesheet" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" />
<script type="text/javascript">
  var oldLoadAp = window.onload;
  window.onload = function () {
    oldLoadAp && oldLoadAp();

    new APlayer({
      container: document.getElementById('aplayer'),
      fixed: true,
      autoplay: 'false' === 'true',
      loop: 'all',
      order: 'random',
      theme: '#b7daff',
      preload: 'none',
      audio: [{"name":"灰色空间","artist":"罗志祥","url":"https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/music/%E7%81%B0%E8%89%B2%E7%A9%BA%E9%97%B4%20-%20%E7%BD%97%E5%BF%97%E7%A5%A5.mp3","cover":"https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/music/luozhixiang.png"}]
    });
  }
</script>

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人
    </span>
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->


  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?608f2baddd361128381ad2bf9377bf89";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "大话数据结构第三章 线性表&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "always",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js" ></script>

  



  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  



  <script>(function (i, s, o, g, r, a, m) {
      i['DaoVoiceObject'] = r;
      i[r] = i[r] ||
        function () {
          (i[r].q = i[r].q || []).push(arguments);
        };
      i[r].l = 1 * new Date();
      a = s.createElement(o);
      m = s.getElementsByTagName(o)[0];
      a.async = 1;
      a.src = g;
      a.charset = 'utf-8';
      m.parentNode.insertBefore(a, m);
    })(window, document, 'script', ('https:' === document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/aa03e448.js", 'daovoice');
    daovoice('init', {
      app_id: "aa03e448",
    });
    daovoice('update');
  </script>










</body>
</html>
