<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="热爱学习的小码农报道">
  <meta name="author" content="closer">
  <meta name="keywords" content="">
  <title>python学习之路 一：基础知识 ~ closer的自留地</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="closer的自留地" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>welcome!</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background"
         style="background: url('/img/default.jpg')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期三, 二月 12日 2020, 10:40 上午
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    8.1k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      32 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <p>本文适合有基础c、c++语言知识的人学习，同时也可当作python工具书查阅。</p>
<h2 id="前言">前言</h2>
<ol>
<li>
<p>这里选择的是最新版 Python3<br>
安装教程这里推荐：<a href="http://www.runoob.com/python3/python3-install.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-install.html</a><br>
win下载地址：<a href="https://www.python.org/downloads/windows" target="_blank" rel="noopener">https://www.python.org/downloads/windows</a><br>
Linux下载地址：<a href="https://www.python.org/downloads/source" target="_blank" rel="noopener">https://www.python.org/downloads/source</a></p>
</li>
<li>
<p>可视化开发工具IDE：<a href="https://www.jetbrains.com/pycharm/download/" target="_blank" rel="noopener">https://www.jetbrains.com/pycharm/download/</a></p>
</li>
<li>
<p><strong>因国内pip速度较慢，安装完python后建议改为国内清华大学镜像源，以下：</strong></p>
<ul>
<li>
<p>临时使用<br>
<code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 模块名字</code></p>
</li>
<li>
<p>设为默认<br>
升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置：<br>
<code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U</code><br>
<code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
</li>
</ul>
</li>
</ol>
<h2 id="1-1基础语法">1.1基础语法</h2>
<h3 id="1-1-1-输出">1.1.1 输出</h3>
<p>打印 <code>print (&quot;Hello, Python!&quot;)</code><br>
print 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号<code>,</code>。</p>
<h3 id="1-1-2-字符串转义">1.1.2 字符串转义</h3>
<a id="more"></a>
<p>特殊字符会使用反斜杠<code>\</code>来转义。比如<code>\n</code>表示换行，<code>\t</code>表示制表符，字符<code>\</code>本身也要转义，所以\表示的字符就是\<br>
<code>print('Isn\'t, they said.')</code><br>
如果不希望前置了 \ 的字符转义成特殊字符，而是使用<em>原始字符串</em>方式，在引号前添加 r 即可。<br>
<code>print(r'C:\软件\python')</code><br>
用三重引号可以跨行连续输入。<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>或<code>'''...'''</code><br>
字符串可以用 + 进行连接（粘到一起），也可以用 * 进行重复:<code>3 * 'io' + ' so easy'</code></p>
<h3 id="1-1-3-脚本式编程">1.1.3 脚本式编程</h3>
<p>Python 文件将以 <code>.py</code> 为扩展名。<br>
在linux和mac上面编程时，已经设置了PATH变量，头文件加入<code>#!/usr/bin/python</code>，可以直接执行。</p>
<pre><code class="language-python">#!/usr/bin/python
# -*- coding: utf-8 -*-
print (&quot;Hello, Python!&quot;)
</code></pre>
<p>这里，假定您的Python解释器在/usr/bin目录中，使用以下命令执行脚本：</p>
<pre><code class="language-py">chmod +x test.py     # 脚本文件添加可执行权限
./test.py
</code></pre>
<h3 id="1-1-4-行和缩进">1.1.4 行和缩进</h3>
<p>Python与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。<br>
缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量(一般是四个空格)，这个必须严格执行。</p>
<h3 id="1-1-5-注释">1.1.5 注释</h3>
<p>python中单行注释采用 # 开头。<br>
python 中多行注释使用三个单引号(’’’)或三个双引号(&quot;&quot;&quot;)。</p>
<h3 id="1-1-6-同一行显示多条语句">1.1.6 同一行显示多条语句</h3>
<p>Python可以在同一行中使用多条语句，语句之间使用分号(;)分割。</p>
<h3 id="1-1-7-多个语句构成代码组">1.1.7 多个语句构成代码组</h3>
<p>缩进相同的一组语句构成一个代码块，我们称之代码组。<br>
像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。<br>
我们将首行及后面的代码组称为一个子句(clause)。<br>
如下实例：</p>
<pre><code class="language-py">if expression :
   suite
elif expression :  
   suite  
else :  
   suite
</code></pre>
<h2 id="1-2-变量类型">1.2 变量类型</h2>
<h3 id="1-2-1-变量赋值">1.2.1 变量赋值</h3>
<p>Python 中的变量赋值不需要类型声明。<br>
Python允许你同时为多个变量赋值。例如：<br>
<code>a, b, c = 1, 2, &quot;john&quot;</code></p>
<h3 id="1-2-2-标准数据类型">1.2.2 标准数据类型</h3>
<p>Python 定义了一些标准类型，用于存储各种类型的数据。<br>
Python有五个标准的数据类型：</p>
<ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Dictionary（字典）</li>
</ul>
<p>bool类型有True和False和None（等于NULL）。</p>
<h3 id="1-2-2-1-Python数字">1.2.2.1 Python数字</h3>
<p>数字数据类型用于存储数值。他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。<br>
当你指定一个值时，Number对象就会被创建：<br>
<code>var1 = 1</code><br>
您也可以使用del语句删除一些对象的引用。del语句的语法是：<br>
<code>del var1[,var2[,var3[....,varN]]]]</code><br>
您可以通过使用del语句删除单个或多个对象的引用。例如：<br>
<code>del var_a, var_b</code><br>
Python支持四种不同的数字类型：</p>
<ul>
<li>int（有符号整型,如<code>0112L</code>,<code>0xDEFL</code>,<code>0x69</code>）# long 类型只在Python2.X版本中。在Python3.X版本中 long 类被 int 替代。</li>
<li>float（浮点型,<code>-32.54e100</code>）</li>
<li>complex（复数,<code>4.53e-7j</code>）</li>
</ul>
<h3 id="1-2-2-2-Python字符串">1.2.2.2 Python字符串</h3>
<p>字符串或串(String)是由数字、字母、下划线组成的一串字符。<br>
python的字串列表有2种取值顺序:</p>
<ul>
<li>从左到右索引默认0开始的，最大范围是字符串长度少1</li>
<li>从右到左索引默认-1开始的，最大范围是字符串开头</li>
</ul>
<p>如果你要实现从字符串中获取一段子字符串的话，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。<br>
[头下标:尾下标] 获取的子字符串包含头下标的字符，但不包含尾下标的字符。</p>
<pre><code class="language-py">&gt;&gt;&gt; s = 'abcdef'
&gt;&gt;&gt; print('s[1:5]  ',s[1:5])
&gt;&gt;&gt; print('s[-6:-4]  ',s[-6:-4])
s[1:5]   bcde
s[-6:-4]   ab
</code></pre>
<p>字符串格式化<br>
在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。</p>
<pre><code class="language-py">&gt;&gt;&gt; print(&quot;My name is %s and weight is %d kg!&quot; % ('Zara', 21))
My name is Zara and weight is 21 kg!
</code></pre>
<h3 id="1-2-2-3-Python列表">1.2.2.3 Python列表</h3>
<p>List（列表）相当于c语言中的数组。 是 Python 中使用最频繁的数据类型。<br>
列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。<br>
列表用 <code>[ ]</code> 标识，是 python 最通用的复合数据类型。<br>
列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。<br>
加号 + 是列表连接运算符，星号 * 是重复操作。如下实例：</p>
<pre><code class="language-py">&gt;&gt;&gt; list = [ 'runoob', 786 , 2.23, 'john', 70.2 ]
&gt;&gt;&gt; tinylist = [123, 'john']
&gt;&gt;&gt; print ('输出第1个至第三个元素  ', list[1:3]) 
&gt;&gt;&gt; print ('输出从第2个开始至列表末尾的所有元素   ', list[2:])
&gt;&gt;&gt; print ('输出列表两次    ', tinylist * 2)
&gt;&gt;&gt; print ('打印组合的列表    ', list + tinylist)
输出第1个至第三个元素   [786, 2.23]
输出从第2个开始至列表末尾的所有元素    [2.23, 'john', 70.2]
输出列表两次     [123, 'john', 123, 'john']
打印组合的列表     ['runoob', 786, 2.23, 'john', 70.2, 123, 'john']
</code></pre>
<p>每当需要访问最后一个列表元素时，都可使用索引-1，来获取最后一个元素。如<code>list[-1]</code>。<br>
<code>squares = [value**2 for value in range(1,11)]</code>此列表解析生成1-10的平方数存入数组。<br>
<code>list[1]=list[:]</code>可以复制列表。</p>
<h3 id="1-2-2-4-Python-元组">1.2.2.4 Python 元组</h3>
<p>元组是另一个数据类型，类似于 List（列表）。<br>
元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。<br>
<strong>元组是不允许更新的。而列表是允许更新的。</strong></p>
<h3 id="1-2-2-5-Python-字典">1.2.2.5 Python 字典</h3>
<p>字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。<br>
两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。<br>
字典用&quot;{ }&quot;标识。字典由索引(key)和它对应的值value组成。</p>
<pre><code class="language-py">&gt;&gt;&gt; dict = {}
&gt;&gt;&gt; dict['one'] = &quot;This is one&quot;
&gt;&gt;&gt; dict[2] = &quot;This is two&quot;
&gt;&gt;&gt; tinydict = {'name': 'john','code':6734, 'dept': 'sales'}
&gt;&gt;&gt; print (dict['one'])          # 输出键为'one' 的值
&gt;&gt;&gt; print (dict[2])              # 输出键为 2 的值
&gt;&gt;&gt; print (tinydict)             # 输出完整的字典
&gt;&gt;&gt; print (tinydict.keys())      # 输出所有键
&gt;&gt;&gt; print (tinydict.values())    # 输出所有值
This is one
This is two
{'name': 'john', 'code': 6734, 'dept': 'sales'}
dict_keys(['name', 'code', 'dept'])
dict_values(['john', 6734, 'sales'])
</code></pre>
<ol>
<li>
<p>修改字典中的值<br>
<code>dict['color'] = 'yellow'</code></p>
</li>
<li>
<p>删除键-值对<br>
<code>del dict['color']</code> # 删除键’color’<br>
<code>dict.clear()</code> # 清空字典<br>
<code>del dict</code> # 删除字典</p>
</li>
<li>
<p>遍历字典</p>
<pre><code class="language-py">for key, value in dict.items():
  print(&quot;\nKey: &quot; + key)
  print(&quot;Value: &quot; + value)
</code></pre>
</li>
</ol>
<h3 id="1-2-3-Python数据类型转换">1.2.3 Python数据类型转换</h3>
<p>和c语言一样。当我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。<br>
<code>float(2)</code></p>
<h3 id="1-2-4-常用函数">1.2.4 常用函数</h3>
<ol>
<li>添加元素<br>
<code>list.append('name'</code>)函数将元素添加到表尾；<br>
<code>list.insert(0,'name')</code>函数在列表的任何位置添加新元素；</li>
<li>删除元素<br>
<code>del list[1]</code>函数删除列表指定位置的元素；<br>
<code>list.pop()</code>函数可删除列表末尾的元素，并让你能够接着使用它，list.pop(i)删除指定i位置元素；<br>
<code>list.remove('name')</code>函数根据值删除元素；</li>
<li>排序<br>
<code>list.sort()</code>函数永久进行从小到大排序；<code>list.sort(reverse=True)</code>函数参数反序排序；<br>
<code>sorted(list)</code>函数临时从小到大排序；<code>sorted(list,reverse=True)</code>函数参数反序排序;<br>
<code>list.reverse()</code>函数永久性地反转列表元素的排列顺序；</li>
<li>长度<br>
<code>len(list)</code>函数可快速获取列表长度。</li>
<li>range()<br>
<code>range(1，101)</code>函数生成数字1-100；<code>numbers = list(range(1,6))</code>生成一个数字列表;<br>
<code>numbers = list(range(2,11,3))</code>函数第3个参数可指定步长，此例num打印出2，5，8;</li>
<li><code>min(list)</code>、<code>max(list)</code>、<code>sum(list)</code>；</li>
<li><code>list.title()</code>函数列表单词首字母大写；</li>
<li><code>set(favorite_languages.values())</code>函数可以剔除重复项，筛选出唯一项。</li>
</ol>
<h2 id="1-3-运算符">1.3 运算符</h2>
<p><code>+、-、*、/、%</code>和c语言一样<br>
<code>**</code>是幂，<code>2**3=8</code><br>
<code>//</code>是取整除,<code>9//2=4</code><br>
比较运算符和c语言一样<br>
赋值运算符和c语言一样，多了<code>**=</code>,<code>//=</code><br>
位运算符和c语言一样<br>
逻辑运算符:<code>and</code>等同于c语言中的<code>&amp;&amp;</code>，<code>or</code>等于c语言中的<code>||</code>，<code>not</code>等于c语言中的<code>!</code></p>
<h3 id="1-3-1-成员运算符">1.3.1 成员运算符</h3>
<p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p>
<ul>
<li>in<br>
如果在指定的序列中找到值返回 True，否则返回 False。例子：x in y , 如果 x 在 y 序列中返回 True。</li>
<li>not in<br>
如果在指定的序列中没有找到值返回 True，否则返回 False。例子：x not in y , 如果 x 不在 y 序列中返回 True。</li>
</ul>
<h3 id="1-3-2-身份运算符">1.3.2 身份运算符</h3>
<p>身份运算符用于比较两个对象的存储单元.</p>
<ul>
<li>is<br>
is 是判断两个标识符是不是引用自一个对象。例子：x is y, 类似 id(x) == id(y)</li>
<li>is not<br>
is not 是判断两个标识符是不是引用自不同对象。例子：x is not y ， 类似 id(a) != id(b)</li>
</ul>
<h2 id="1-4-条件语句">1.4 条件语句</h2>
<p><code>if</code>等用于c语言中<code>if</code>，<code>else</code>等同于c语言中<code>else</code>，<code>elif</code>等同于c语言中<code>else if</code><br>
Python程序语言指定任何非0和非空（null）值为True，0 或者 null为False。<br>
Python 编程中 if 语句用于控制程序的执行，基本形式为：</p>
<pre><code class="language-py">if 判断条件1:
    执行语句1……
elif 判断条件2:
    执行语句2……
elif 判断条件3:
    执行语句3……
else:
    执行语句4……
</code></pre>
<h2 id="1-5-循环语句">1.5 循环语句</h2>
<p>有while，for循环，循环控制语句有break，continue，pass。</p>
<h3 id="1-5-1-while">1.5.1 while</h3>
<p>while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。其基本形式为：</p>
<pre><code class="language-py">while 判断条件(condition)：
    执行语句(statements)……
</code></pre>
<p>例子：</p>
<pre><code class="language-py">pets = ['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat']
while 'cat' in pets:
    pets.remove('cat')
print(pets)
</code></pre>
<h3 id="1-5-2-for">1.5.2 for</h3>
<p>for循环的语法格式如下：</p>
<pre><code class="language-py">for 迭代变量(iterating_var) in 数列、序列(sequence):
   执行语句(statements)
</code></pre>
<pre><code class="language-py">sum = 0
for x in range(101):
    sum = sum + x
print(sum) #1-100的和，等于5050
</code></pre>
<pre><code class="language-py">L = ['Bart', 'Lisa', 'Adam']
for i in L:
    print(i)
</code></pre>
<h3 id="1-5-3-循环控制语句">1.5.3 循环控制语句</h3>
<p>break,continue和c语言相同。pass就是一个空语句,不做任何事情，一般用做占位语句。。</p>
<h2 id="1-6-函数">1.6 函数</h2>
<p>Python内置了很多有用的函数，我们可以直接调用。可以直接从Python的官方网站查看文档：<br>
<a href="https://docs.python.org/zh-cn/3/library/functions.html#abs" target="_blank" rel="noopener">Python的官方网站查看内置函数</a><br>
比如求绝对值的函数abs，只有一个参数。<br>
也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。</p>
<h3 id="1-6-1-定义函数">1.6.1 定义函数</h3>
<p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p>
<ol>
<li>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。</li>
<li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li>
<li>函数内容以冒号起始，并且缩进。</li>
<li>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li>
</ol>
<p>一般格式如下：</p>
<pre><code class="language-py">def 函数名（参数列表）:
    函数体
</code></pre>
<p>python函数的使用方法基本上和c语言相同，不用指定返回类型，可以返回列表，字典等。</p>
<p>一、python可以给函数指定默认值。<br>
<code>def student(name='Li Ming', age=18):</code><br>
如果函数有一个实参默认值为空，则必须确保为空的实参在最后一个。如：<br>
<code>def get_name(first_name, last_name, middle_name=''):</code></p>
<p>二、将列表传递给函数后，函数就可对其进行修改。在函数中对这个列表所做的任何修改都是永久性的，这让你能够高效地处理大量的数据。<br>
有时候，需要禁止函数修改列表。这时候，可向函数传递列表的副本而不是原件。<br>
<code>def stu(name[:], age[:])</code></p>
<p>三、Python允许函数从调用语句中收集任意数量的实参。<br>
<code>def make_pizza(*toppings):</code><br>
形参名 *toppings 中的星号让Python创建一个名为 toppings 的空元组，并将收到的所有值都封装到这个元组中。<br>
如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。<br>
<code>def make_pizza(size, *toppings):</code></p>
<p>四、使用任意数量的关键字实参<br>
<code>def build_profile(first, last, **user_info):</code></p>
<h3 id="1-6-2-将函数存储在模块中">1.6.2 将函数存储在模块中</h3>
<p>可以将函数存储在被称为模块的独立文件中，再将模块导入到主程序中。跟c语言差不多，c语言中用头文件，函数文件。</p>
<ol>
<li>导入整个模块<br>
假设<code>xxx.py</code>所在目录内有另外一个<code>pizza.py</code>，添加<code>import pizza</code>语句<br>
导入名为模块 module_name.py 的的整个模块通用语法：<code>import module_name</code><br>
可使用下面的语法来使用其中任何一个函数：<code>module_name.function_name ()</code></li>
<li>导入特定的函数<br>
<code>from module_name import function_0 , function_1 , function_2</code><br>
通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数。<br>
若使用这种语法，调用函数时就无需使用句点。<code>make_pizza(16, 'pepperoni')</code></li>
<li>使用 as 给函数指定别名<br>
指定别名的通用语法如下：<code>from module_name import function_name as fn</code></li>
<li>使用 as 给模块指定别名<br>
给模块指定别名的通用语法如下：<code>import module_name as mn</code></li>
<li>导入模块中的所有函数<br>
最好只导入你需要用的函数，或者导入整个模块并使用句点表示法。<br>
导入模块 module_name 中的所有函数通用语法如下：<code>from module_name import *</code></li>
</ol>
<p>所有的 import 语句都应放在文件开头，唯一例外的情形是，在文件开头使用了注释来描述整个程序。</p>
<h2 id="1-7-类">1.7 类</h2>
<h3 id="1-7-1-创建类">1.7.1 创建类</h3>
<p>根据约定，在Python中，首字母大写的名称指的是类。</p>
<pre><code class="language-py">class Dog():
    &quot;&quot;&quot;一次模拟小狗的简单尝试&quot;&quot;&quot;
    def __init__(self, name, age):
        &quot;&quot;&quot;初始化属性name和age&quot;&quot;&quot;
        self.name = name
        self.age = age
        self.son = 'zero'
    def sit(self):
        &quot;&quot;&quot;模拟小狗被命令时蹲下&quot;&quot;&quot;
        print(self.name.title() + &quot; is now sitting.&quot;)
    def roll_over(self):
        &quot;&quot;&quot;模拟小狗被命令时打滚&quot;&quot;&quot;
        print(self.name.title() + &quot; rolled over!&quot;)
my_dog = Dog('willie', 6)
print(&quot;My dog's name is &quot; + my_dog.name.title() + &quot;.&quot;)
print(&quot;My dog is &quot; + str(my_dog.age) + &quot; years old.&quot;)
my_dog.sit()
print(my_dog.son)
</code></pre>
<p>一 方法 <strong>init</strong>()<br>
可参考c++中的构造函数。</p>
<ol>
<li>我们将方法 <strong>init</strong>() 定义成了包含三个形参： self 、 name 和 age 。在这个方法的定义中，形参 self 必不可少，还必须位于其他形参的前面，相当于c++中的This指针。</li>
<li>因为Python调用这个 <strong>init</strong>() 方法来创建 Dog 实例时，将自动传入实参 self 。每个与类相关联的方法调用都自动传递实参 self ，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。</li>
<li>我们将通过实参向 Dog() 传递名字和年龄； self 会自动传递，因此我们不需要传递它。每当我们根据 Dog 类创建实例时，都只需给最后两个形参（ name 和 age ）提供值。</li>
<li>Dog 类还定义了另外两个方法： sit() 和 roll_over() 。由于这些方法不需要额外的信息，如名字，因此它们只有一个形参 self 。</li>
</ol>
<p>二 根据类创建实例</p>
<ol>
<li>访问属性<br>
要访问实例的属性，可使用句点表示法。<code>my_dog.name</code></li>
<li>调用方法<br>
用句点表示法来调用 Dog 类中定义的任何方法。<code>my_dog.roll_over()</code></li>
<li>给属性指定默认值<br>
可以在方法 <strong>init</strong>()中添加默认值<br>
如果你对某个属性这样做了，就无需包含为它提供初始值的形参。</li>
</ol>
<p>三 修改属性的值</p>
<ol>
<li>直接修改属性的值<br>
<code>my_dog.son='kuku'</code></li>
<li>通过方法修改属性的值<br>
等于在类里面新建一个方法，来修改类里面属性的值<br>
<code>def update_name(self, mile):</code><br>
<code>self.name = mile</code></li>
<li>通过方法对属性的值进行递增<br>
跟2差不多，用方法里面的实参来修改。</li>
</ol>
<h3 id="1-7-2-继承">1.7.2 继承</h3>
<pre><code class="language-py">class ElectricCar(Car):
    &quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;
   def __init__(self, make, model, year):
      &quot;&quot;&quot;初始化父类的属性&quot;&quot;&quot;
      super().__init__(make, model, year)
      self.battery_size = 70
</code></pre>
<p>一 给子类定义属性和方法<br>
<strong>super() 是一个特殊函数，帮助Python将父类和子类关联起来。这行代码让Python调用ElectricCar 的父类的方法 <strong>init</strong>() ，让 ElectricCar 实例包含父类的所有属性。父类也称为超类（superclass），名称super因此而得名。</strong></p>
<p>二 重写父类的方法</p>
<p>可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。</p>
<h3 id="1-7-3-导入类">1.7.3 导入类</h3>
<p>Python允许你将类存储在模块中，然后在主程序中导入所需的模块。</p>
<ol>
<li>导入类<br>
<code>from car import Car</code></li>
<li>从一个模块中导入多个类<br>
<code>from car import Car, ElectricCar</code></li>
<li>导入整个模块<br>
你还可以导入整个模块，再使用句点表示法访问需要的类。<code>import car</code></li>
<li>导入模块中的所有类<br>
<code>from module_name import *</code> #不推荐这种方式</li>
<li>在一个模块中导入另一个模块</li>
</ol>
<h3 id="1-7-4-类编码风格">1.7.4 类编码风格</h3>
<p>类名应采用驼峰命名法，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。</p>
<h2 id="1-8-文件和异常">1.8 文件和异常</h2>
<h3 id="1-8-1-从文件中读取数据">1.8.1 从文件中读取数据</h3>
<h4 id="1-8-1-1-读取整个文件">1.8.1.1 读取整个文件</h4>
<p>open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。<br>
<code>open(file, mode='r')</code><br>
完整的语法格式为：<br>
<code>open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code><br>
参数说明:</p>
<ul>
<li>file: 必需，文件路径（相对或者绝对路径）。</li>
<li>mode: 可选，文件打开模式</li>
<li>buffering: 设置缓冲</li>
<li>encoding: 一般使用utf8</li>
<li>errors: 报错级别</li>
<li>newline: 区分换行符</li>
<li>closefd: 传入的file参数类型</li>
<li>opener:</li>
</ul>
<pre><code class="language-py">with open('pi_digits.txt') as file_object:
   contents = file_object.read()
   print(contents)
</code></pre>
<p>函数 open() 接受一个参数：要打开的文件的名称。 函数 open()返回一个表示文件的对象。Python将这个对象存储在我们将在后面使用的变量中。<br>
关键字 ==with== 在不再需要访问文件后将其关闭。在这个程序中，我们没有调用 close() ；你只管打开文件，并在需要时使用它，Python自会在合适的时候自动将其关闭。<br>
有了表示 pi_digits.txt 的文件对象后，我们使用方法 read() （前述程序的第2行）读取这个文件的全部内容，并将其作为一个长长的字符串存储在变量 contents 中。这样，通过打印 contents 的值，就可将这个文本文件的全部内容显示出来。<br>
相比于原始文件，该输出唯一不同的地方是末尾多了一个空行。为何会多出这个空行呢？因为 read() 到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除多出来的空行，可在 print 语句中使用 rstrip() ：<code>print(contents.rstrip())</code></p>
<h4 id="1-8-1-2-文件路径">1.8.1.2 文件路径</h4>
<p>在Linux和OS X中，你可以这样编写代码：<br>
<code>file_path = '/home/ehmatthes/other_files/text_files/filename.txt'</code><br>
<code>with open(file_path) as file_object:</code><br>
Windows系统中，在文件路径中使用反斜杠（ \ ）而不是斜杠（ / ）：<br>
<code>file_path = 'C:\Users\ehmatthes\other_files\text_files\filename.txt'</code><br>
<code>with open(file_path) as file_object:</code></p>
<h4 id="1-8-1-3-逐行读取">1.8.1.3 逐行读取</h4>
<pre><code class="language-py">filename = 'pi_digits.txt'
with open(filename) as file_object:
   for a in file_object:
      print(a.rstrip())
</code></pre>
<h4 id="1-8-1-4-创建一个包含文件各行内容的列表">1.8.1.4 创建一个包含文件各行内容的列表</h4>
<pre><code class="language-py">filename = 'pi_digits.txt'
with open(filename) as file_object:
   lines = file_object.readlines()
for line in lines:
   print(line.rstrip())
</code></pre>
<h4 id="1-8-1-5-使用文件的内容">1.8.1.5 使用文件的内容</h4>
<pre><code class="language-py">filename = 'pi_digits.txt'
with open(filename) as file_object:
   lines = file_object.readlines()
pi_string = ''
for line in lines:
   pi_string += line.strip()
print(pi_string)
</code></pre>
<p>输出3.141592653589793238462643383279<br>
在变量 pi_string 存储的字符串中，包含原来位于每行左边的空格，为删除这些空格，可使用 strip() 函数消除空格。<br>
<code>print str.strip( '0' );  # 去除首尾字符 0</code></p>
<h3 id="1-8-2-写入文件">1.8.2 写入文件</h3>
<h4 id="1-8-2-1-写入空文件">1.8.2.1 写入空文件</h4>
<pre><code class="language-py">filename = 'a.txt'
with open(filename, 'w') as file_object:
   file_object.write(&quot;I love programming.\n&quot;)
</code></pre>
<p>打开文件时，可指定<strong>读取模式（ ‘r’ ）、写入模式（ ‘w’ ）、附加模式（ ‘a’ ）或让你能够读取和写入文件的模式（ ‘r+’ ）</strong>。如果<br>
你省略了模式实参，Python将以默认的只读模式打开文件。<br>
<strong>Python只能将字符串写入文本文件。要将数值数据存储到文本文件中，必须先使用函数str() 将其转换为字符串格式。</strong></p>
<h4 id="1-8-2-2-写入多行">1.8.2.2 写入多行</h4>
<p>每句后面加上换行符。</p>
<h3 id="1-8-3-异常">1.8.3 异常</h3>
<p>Python使用被称为异常的特殊对象来管理程序执行期间发生的错误。每当发生错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继续运行；如果你未对异常进行处理，程序将停止，并显示一个traceback，其中包含有关异常的报告。<br>
异常是使用 try-except 代码块处理的。 try-except 代码块让Python执行指定的操作，同时告诉Python发生异常时怎么办。使用了 try-except 代码块时，即便出现异常，程序也将继续运行：显示你编写的友好的错误消息，而不是令用户迷惑的traceback。</p>
<h4 id="1-8-3-1-使用-try-except-else-代码块">1.8.3.1 使用 try-except-else 代码块</h4>
<pre><code class="language-py">print(&quot;Give me two numbers, and I'll divide them.&quot;)
print(&quot;Enter 'q' to quit.&quot;)
while True:
   first_number = input(&quot;\nFirst number: &quot;)
   if first_number == 'q':
     break
   second_number = input(&quot;Second number: &quot;)
   try:
      answer = int(first_number) / int(second_number)
   except ZeroDivisionError:
      print(&quot;You can't divide by 0!&quot;)
   else:
      print(answer)
</code></pre>
<p>当你认为可能发生了错误时，可编写一个 try-except 代码块来处理可能引发的异常。<br>
通过将可能引发错误的代码放在 try-except 代码块中，可提高这个程序抵御错误的能力。这个示例还包含一个 else 代码块；依赖于 try 代码块成功执行的代码都应放到 else 代码块中。<br>
try-except-else 代码块的工作原理大致如下：<strong>Python尝试执行 try 代码块中的代码；只有可能引发异常的代码才需要放在 try 语句中。有时候，有一些仅在 try 代码块成功执行时才需要运行的代码；这些代码应放在 else 代码块中。 except 代码块告诉Python，如果它尝试运行 try 代码块中的代码时引发了指定的异常，该怎么办。</strong></p>
<h4 id="1-8-3-2-分析多个文本">1.8.3.2 分析多个文本</h4>
<pre><code class="language-py">def count_words(filename):
   &quot;&quot;&quot;计算一个文件大致包含多少个单词&quot;&quot;&quot;
   try:
      with open(filename) as f_obj:
         contents = f_obj.read()
   except FileNotFoundError:
      print(&quot;Sorry, the file &quot; + filename + &quot; does not exist.&quot;)
   else:
      # 计算文件大致包含多少个单词
      words = contents.split()
      num_words = len(words)
      print(&quot;The file &quot; + filename + &quot; has about &quot; + str(num_words) + &quot; words.&quot;)

filenames = ['0.txt', '1.txt', '2.txt', '3.txt']
for filename in filenames:
   count_words(filename)
</code></pre>
<p>如果你希望失败的时候不提示用户，可以在 except xxxError 后面添加一句pass。</p>
<h3 id="1-8-4-存储数据">1.8.4 存储数据</h3>
<p>模块 json 让你能够将简单的Python数据结构转储到文件中，并在程序再次运行时加载该文件中的数据。还可以使用 json 在Python程序之间分享数据。更重要的是，JSON数据格式并非Python专用的，这让你能够将以JSON格式存储的数据与使用其他编程语言的人分享。</p>
<h4 id="1-8-4-1-使用-json-dump-和-json-load-保存和读取用户生成的数据">1.8.4.1 使用 json.dump() 和 json.load() 保存和读取用户生成的数据</h4>
<pre><code class="language-py">import json
# 如果以前存储了用户名，就加载它
# 否则，就提示用户输入用户名并存储它
filename = 'username.json'
try:
   with open(filename) as f_obj:
      username = json.load(f_obj)
except FileNotFoundError:
   username = input(&quot;What is your name? &quot;)
   with open(filename, 'w') as f_obj:
      json.dump(username, f_obj)
      print(&quot;We'll remember you when you come back, &quot; + username + &quot;!&quot;)
else:
   print(&quot;Welcome back, &quot; + username + &quot;!&quot;)
</code></pre>
<p>先导入模块json，通过方法json.dump() 和 json.load()来保存用户名。<br>
上面的程序，如果第一次执行，保存用户名到username，第二次执行则显示欢迎回来。</p>
<h4 id="1-8-4-2-重构">1.8.4.2 重构</h4>
<p>有时候，我们要保证高内聚，低耦合，需要将各个模块代码分为一系列完成具体工作的函数，这样的过程称为重构。<br>
下面我们来重构上一节的代码：</p>
<pre><code class="language-py">import json
def get_stored_username():
   &quot;&quot;&quot;如果存储了用户名，就获取它&quot;&quot;&quot;
   filename = 'username.json'
   try:
      with open(filename) as f_obj:
         username = json.load(f_obj)
   except FileNotFoundError:
      return None
   else:
      return username

def get_new_username():
   &quot;&quot;&quot;提示用户输入用户名&quot;&quot;&quot;
   username = input(&quot;What is your name? &quot;)
   filename = 'username.json'
   with open(filename, 'w') as f_obj:
      json.dump(username, f_obj)
   return username

def greet_user():
   &quot;&quot;&quot;问候用户，并指出其名字&quot;&quot;&quot;
   username = get_stored_username()
   if username:
      print(&quot;Welcome back, &quot; + username + &quot;!&quot;)
   else:
      username = get_new_username()
      print(&quot;We'll remember you when you come back, &quot; + username + &quot;!&quot;)

greet_user()
</code></pre>
<p>在这个最终版本中，每个函数都执行单一而清晰的任务。要编写出清晰而易于维护和扩展的代码，划分工作必不可少。</p>
<h2 id="1-9-测试代码">1.9 测试代码</h2>
<p>这章中我们学习如何使用Python模块 unittest 中的工具来测试代码。</p>
<h3 id="1-9-1-测试函数">1.9.1 测试函数</h3>
<h4 id="1-9-1-1-单元测试和测试用例">1.9.1.1 单元测试和测试用例</h4>
<p>Python标准库中的模块 unittest 提供了代码测试工具。单元测试用于核实函数的某个方面没有问题；测试用例是一组单元测试，这些单元测试一起核实函数在各种情形下的行为都符合要求。良好的测试用例考虑到了函数可能收到的各种输入，包含针对所有这些情形的测试。全覆盖式测试用例包含一整套单元测试，涵盖了各种可能的函数使用方式。对于大型项目，要实现全覆盖可能很难。通常，最初只要针对代码的重要行为编写测试即可，等项目被广泛使用时再考虑全覆盖。</p>
<h4 id="1-9-1-2-如何测试">1.9.1.2 如何测试</h4>
<p>要为函数编写测试用例，可先导入模块 unittest 以及要测试的函数，再创建一个继承 unittest.TestCase 的类，并编写一系列方法对函数行为的不同方面进行测试。<br>
下面是一个只包含一个方法的测试用例，它检查函数 get_formatted_name() 在给定名和姓时能否正确地工作：</p>
<pre><code class="language-py">#文件名name_function.py
def get_formatted_name(first, last, middle=''):
    &quot;&quot;&quot;生成整洁的姓名&quot;&quot;&quot;
    if middle:
        full_name = first + ' ' + middle + ' ' + last
    else:
        full_name = first + ' ' + last
    return full_name.title()
</code></pre>
<pre><code class="language-py">import unittest
from name_function import get_formatted_name
#文件名test_name_ function.py
class NamesTestCase(unittest.TestCase):
    &quot;&quot;&quot;测试name_function.py&quot;&quot;&quot;
    def test_first_last_name(self):
        &quot;&quot;&quot;能够正确地处理像Janis Joplin这样的姓名吗？&quot;&quot;&quot;
        formatted_name = get_formatted_name('janis', 'joplin')
        self.assertEqual(formatted_name, 'Janis Joplin')

    def test_first_last_middle_name(self):
        &quot;&quot;&quot;能够正确地处理像Wolfgang Amadeus Mozart这样的姓名吗？&quot;&quot;&quot;
        formatted_name = get_formatted_name('wolfgang', 'mozart', 'amadeus')
        self.assertEqual(formatted_name, 'Wolfgang Amadeus Mozart')

unittest.main()
</code></pre>
<p>首先，我们导入了模块 unittest 和要测试的函数 get_formatted_ name() 。我们创建了一个名为 NamesTestCase（名字随便） 的类，用于包含一系列针对 get_formatted_name() 的单元测试。这个类必须继承unittest.TestCase 类，这样Python才知道如何运行你编写的测试。<br>
我们运行 test_name_function.py 时，所有以 test_ 打头的方法都将自动运行。<br>
在这个方法中，我们调用了要测试的函数，并存储了要测试的返回值。<br>
最后我们使用了 unittest 类最有用的功能之一：一个断言方法。断言方法用来核实得到的结果是否与期望的结果一致。<br>
我们调用 <strong>unittest 的方法 assertEqual()</strong> ，并向它传递 formatted_name 和 ‘Janis Joplin’ 。代码行 <code>self.assertEqual(formatted_name, 'Janis Joplin')</code> 的意思是说：“将 formatted_name 的值同字符串 ‘Janis Joplin’ 进行比较，如果它们相等，就万事大吉，如果它们不相等，跟我说一声！”</p>
<h3 id="1-9-2-测试类">1.9.2 测试类</h3>
<h4 id="1-9-2-1-各种断言方法">1.9.2.1 各种断言方法</h4>
<p>Python在 unittest.TestCase 类中提供了很多断言方法。如下：</p>
<table>
<thead>
<tr>
<th>方 法</th>
<th>用 途</th>
</tr>
</thead>
<tbody>
<tr>
<td>assertEqual(a, b)</td>
<td>核实 a == b</td>
</tr>
<tr>
<td>assertNotEqual(a, b)</td>
<td>核实 a != b</td>
</tr>
<tr>
<td>assertTrue(x)</td>
<td>核实 x 为 True</td>
</tr>
<tr>
<td>assertFalse(x)</td>
<td>核实 x 为 False</td>
</tr>
<tr>
<td>assertIn( item , list )</td>
<td>核实 item 在 list 中</td>
</tr>
<tr>
<td>assertNotIn( item , list )</td>
<td>核实 item 不在 list 中</td>
</tr>
</tbody>
</table>
<h4 id="1-9-2-2-方法-setUp">1.9.2.2 方法 setUp()</h4>
<pre><code class="language-py">class AnonymousSurvey():
    &quot;&quot;&quot;收集匿名调查问卷的答案&quot;&quot;&quot;
    def __init__(self, question):
        &quot;&quot;&quot;存储一个问题，并为存储答案做准备&quot;&quot;&quot;
        self.question = question
        self.responses = []

    def show_question(self):
        &quot;&quot;&quot;显示调查问卷&quot;&quot;&quot;
        print(question)

    def store_response(self, new_response):
        &quot;&quot;&quot;存储单份调查答卷&quot;&quot;&quot;
        self.responses.append(new_response)

    def show_results(self):
        &quot;&quot;&quot;显示收集到的所有答卷&quot;&quot;&quot;
        print(&quot;Survey results:&quot;)
        for response in responses:
            print('- ' + response)
</code></pre>
<pre><code class="language-py">import unittest
from survey import AnonymousSurvey
class TestAnonymousSurvey(unittest.TestCase):
    &quot;&quot;&quot;针对AnonymousSurvey类的测试&quot;&quot;&quot;
    def setUp(self):
    # 创建一个调查对象和一组答案，供使用的测试方法使用
        question = &quot;What language did you first learn to speak?&quot;
        self.my_survey = AnonymousSurvey(question)
        self.responses = ['English', 'Spanish', 'Mandarin']

    def test_store_single_response(self):
        &quot;&quot;&quot;测试单个答案会被妥善地存储&quot;&quot;&quot;
        self.my_survey.store_response(self.responses[0])
        self.assertIn(self.responses[0], self.my_survey.responses)

    def test_store_three_responses(self):
        &quot;&quot;&quot;测试三个答案会被妥善地存储&quot;&quot;&quot;
        for response in self.responses:
            self.my_survey.store_response(response)
        for response in self.responses:
            self.assertIn(response, self.my_survey.responses)

unittest.main()
</code></pre>
<p>使用 setUp() 来创建一个调查对象和一组答案，供方法 <code>test_store_single_response()</code> 和 <code>test_store_three_responses()</code> 使用。<br>
方法 setUp() 做了两件事情：创建一个调查对象（见方法setUp()第4行）；创建一个答案列表（见方法setUp()第5行）。<br>
这让两个测试方法都更简单，因为它们都不用创建调查对象和答案。方法 <code>test_store_three_response()</code> 核实 self.responses 中的第一个答案—— self.responses[0] ——被妥善地存储，而方法 <code>test_store_three_response()</code> 核实 self.responses 中的全部三个答案都被妥善地存储。</p>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/python">python</a>
                  &nbsp;
                
                  <a class="hover-with-bg" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0">读书笔记</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0">读书笔记</a>
                
                  <a class="hover-with-bg" href="/tags/python">python</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->

  <div class="col-lg-7 mx-auto nopadding-md">
    <div class="container custom post-content mx-auto">
      <img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/pay/pay.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-3" style="width:355.4px; height:200px;">
    </div>
  </div>


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
      <br><br>
      
      
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script>
      var disqus_config = function () {
        this.page.url = 'https://closer_laps.gitee.io/2020/02/12/读书笔记/Python/python学习之路 一：基础知识/';
        this.page.identifier = '/2020/02/12/读书笔记/Python/python学习之路 一：基础知识/';
      };
      var oldLoad = window.onload;
      window.onload = function () {
        var d = document, s = d.createElement('script');
        s.type = 'text/javascript';
        s.src = '//' + 'https-8hn9w5-coding-pages-com' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      };
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" target="_blank" rel="nofollow noopener noopener">comments
        powered by Disqus.</a></noscript>
  </div>


    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv">总访问量 
          <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv">总访客数 
            <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;
  
  <br>



    


    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smooth-scroll/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  
    <!-- Baidu Analytics -->
    <script>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?608f2baddd361128381ad2bf9377bf89";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  
    <!-- Tencent Analytics -->
    <script>
      var _mtac = {};
      (function () {
        var mta = document.createElement("script");
        mta.src = "//pingjs.qq.com/h5/stats.js?v2.0.4";
        mta.setAttribute("name", "MTAH5");
        mta.setAttribute("sid", "500710993");
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(mta, s);
      })();
    </script>
  

  

  <!-- cnzz Analytics -->
  



  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "python学习之路 一：基础知识&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 60,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>



  

  
    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
              processEscapes: true,
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          }
      });

      MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for(i=0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
      });

    </script>

    <script src="https://cdn.staticfile.org/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML" ></script>

  



  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  







</body>
</html>
