<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="沧海横流，尽显英雄本色；激浊扬清，正是猛士当时">
  <meta name="author" content="closer">
  <meta name="keywords" content="">
  <title>SQL语言学习笔记 ~ closer的自留地</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="closer的自留地" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>welcome!</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/links/">友链</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" false
         style="background: url('/img/default.jpg')no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期五, 四月 3日 2020, 2:31 下午
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    14.1k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      59 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <h2 id="一、SQL简介"><a href="#一、SQL简介" class="headerlink" title="一、SQL简介"></a>一、SQL简介</h2><h3 id="1-1-SQL是什么"><a href="#1-1-SQL是什么" class="headerlink" title="1.1 SQL是什么"></a>1.1 SQL是什么</h3><blockquote>
<p>SQL是结构化查询语言，它是一种用于存储，操作和检索存储在关系数据库中的数据的计算机语言</p>
</blockquote>
<p>关系型数据库可以通过E-R图转换而来，E-R图中矩形是实体集，菱形是关系，椭圆是属性。</p>
<h3 id="1-2-SQL命令"><a href="#1-2-SQL命令" class="headerlink" title="1.2 SQL命令"></a>1.2 SQL命令</h3><h4 id="1）-DDL——数据定义语言"><a href="#1）-DDL——数据定义语言" class="headerlink" title="1） DDL——数据定义语言"></a>1） DDL——数据定义语言</h4><table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>CREATE</td>
<td>用于在数据库中创建新表，表视图或其他对象</td>
</tr>
<tr>
<td>2</td>
<td>ALTER</td>
<td>用于修改现有数据库对象，例如：表</td>
</tr>
<tr>
<td>3</td>
<td>DROP</td>
<td>用于删除整个表，数据库中的表或其他对象的视图</td>
</tr>
</tbody></table>
<h4 id="2）-DML——数据操纵语言"><a href="#2）-DML——数据操纵语言" class="headerlink" title="2） DML——数据操纵语言"></a>2） DML——数据操纵语言</h4><table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SELECT</td>
<td>从一个或多个表中检索某些记录</td>
</tr>
<tr>
<td>2</td>
<td>INSERT</td>
<td>创建一条记录</td>
</tr>
<tr>
<td>3</td>
<td>UPDATE</td>
<td>用于修改(更新)记录</td>
</tr>
<tr>
<td>4</td>
<td>DELETE</td>
<td>删除记录</td>
</tr>
</tbody></table>
<h4 id="3）-DCL——数据控制语言"><a href="#3）-DCL——数据控制语言" class="headerlink" title="3） DCL——数据控制语言"></a>3） DCL——数据控制语言</h4><table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>GRANT</td>
<td>为用户提供权限</td>
</tr>
<tr>
<td>2</td>
<td>REVOKE</td>
<td>撤销用户授予的权限</td>
</tr>
</tbody></table>
<h3 id="1-3-数据的完整性"><a href="#1-3-数据的完整性" class="headerlink" title="1.3 数据的完整性"></a>1.3 数据的完整性</h3><p>每个RDBMS(关系型数据库)都存在以下类别的数据完整性</p>
<ul>
<li><p>实体完整性 - 表中没有重复的行。</p>
</li>
<li><p>域完整性 - 通过限制值的类型，格式或范围，为给定列强制执行有效条目。</p>
</li>
<li><p>参照完整性 - 其他记录使用(引用)导致这些行无法删除。</p>
</li>
<li><p>用户定义的完整性 - 实施一些不属于实体，域或参照完整性的特定业务规则</p>
</li>
</ul>
<h3 id="1-4-SQL约束"><a href="#1-4-SQL约束" class="headerlink" title="1.4 SQL约束"></a>1.4 SQL约束</h3><ul>
<li><p><a href="https://www.yiibai.com/sql/sql-not-null.html" target="_blank" rel="noopener">NOT NULL约束</a> - 确保列不能具有NULL值。</p>
</li>
<li><p><a href="https://www.yiibai.com/sql/sql-default.html" target="_blank" rel="noopener">默认值约束</a> - 在未指定列时为列提供默认值。</p>
</li>
<li><p><a href="https://www.yiibai.com/sql/sql-unique.html" target="_blank" rel="noopener">唯一约束</a> - 确保列中的所有值都不同。</p>
</li>
<li><p><a href="https://www.yiibai.com/sql/sql-primary-key.html" target="_blank" rel="noopener">主键</a> - 唯一标识数据库表中的每一行/记录。</p>
</li>
<li><p><a href="https://www.yiibai.com/sql/sql-foreign-key.html" target="_blank" rel="noopener">外键</a> - 唯一标识任何其他数据库表中的行/记录。</p>
</li>
<li><p><a href="https://www.yiibai.com/sql/sql-check.html" target="_blank" rel="noopener">检查约束</a> - CHECK约束确保列中的所有值都满足特定条件。</p>
</li>
<li><p><a href="https://www.yiibai.com/sql/sql-index.html" target="_blank" rel="noopener">索引</a> - 用于非常快速地从数据库创建和检索数据。</p>
</li>
</ul>
<h3 id="1-5-数据库范式"><a href="#1-5-数据库范式" class="headerlink" title="1.5 数据库范式"></a>1.5 数据库范式</h3><h4 id="1）-第一范式（1NF）"><a href="#1）-第一范式（1NF）" class="headerlink" title="1） 第一范式（1NF）"></a>1） 第一范式（1NF）</h4><ol>
<li>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</li>
<li>所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</li>
<li>简而言之，第一范式就是无重复的列。</li>
</ol>
<h4 id="2）-第二范式（2NF）"><a href="#2）-第二范式（2NF）" class="headerlink" title="2） 第二范式（2NF）"></a>2） 第二范式（2NF）</h4><ol>
<li>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。这个唯一属性列被称为主关键字或主键、主码。</li>
<li>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。</li>
<li>简而言之，第二范式就是非主属性<strong>部分依赖于主关键字</strong>。</li>
</ol>
<h4 id="3）-第三范式（3NF）"><a href="#3）-第三范式（3NF）" class="headerlink" title="3） 第三范式（3NF）"></a>3） 第三范式（3NF）</h4><ol>
<li>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。</li>
<li>例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。</li>
<li>简而言之，第三范式就是属性<strong>不依赖于其它非主属性</strong>。</li>
</ol>
<h3 id="1-6-运算符"><a href="#1-6-运算符" class="headerlink" title="1.6 运算符"></a>1.6 运算符</h3><p>假设变量a的值是：10，变量b的值是：20</p>
<h4 id="1）-SQL算术运算符"><a href="#1）-SQL算术运算符" class="headerlink" title="1） SQL算术运算符"></a>1） SQL算术运算符</h4><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法，执行加法运算。</td>
<td>a + b = 30</td>
</tr>
<tr>
<td>-</td>
<td>减法，执行减法运算。</td>
<td>a + b = -10</td>
</tr>
<tr>
<td>*</td>
<td>除法，执行除法运算</td>
<td>a * b = 200</td>
</tr>
<tr>
<td>/</td>
<td>用左操作数除右手操作数</td>
<td>b / a = 2</td>
</tr>
<tr>
<td>%</td>
<td>用左手操作数除左手操作数并返回余数</td>
<td>b % a = 0</td>
</tr>
</tbody></table>
<h3 id="1-7-在MySQL中创建表的示例"><a href="#1-7-在MySQL中创建表的示例" class="headerlink" title="1.7 在MySQL中创建表的示例"></a>1.7 在MySQL中创建表的示例</h3><pre><code class="SQL">create database test default character set utf8 collate utf8_general_ci;

CREATE TABLE regions (
    region_id INT (11) AUTO_INCREMENT PRIMARY KEY,
    region_name VARCHAR (25) DEFAULT NULL
);

CREATE TABLE countries (
    country_id CHAR (2) PRIMARY KEY,
    country_name VARCHAR (40) DEFAULT NULL,
    region_id INT (11) NOT NULL,
    FOREIGN KEY (region_id) REFERENCES regions (region_id) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE locations (
    location_id INT (11) AUTO_INCREMENT PRIMARY KEY,
    street_address VARCHAR (40) DEFAULT NULL,
    postal_code VARCHAR (12) DEFAULT NULL,
    city VARCHAR (30) NOT NULL,
    state_province VARCHAR (25) DEFAULT NULL,
    country_id CHAR (2) NOT NULL,
    FOREIGN KEY (country_id) REFERENCES countries (country_id) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE jobs (
    job_id INT (11) AUTO_INCREMENT PRIMARY KEY,
    job_title VARCHAR (35) NOT NULL,
    min_salary DECIMAL (8, 2) DEFAULT NULL,
    max_salary DECIMAL (8, 2) DEFAULT NULL
);

CREATE TABLE departments (
    department_id INT (11) AUTO_INCREMENT PRIMARY KEY,
    department_name VARCHAR (30) NOT NULL,
    location_id INT (11) DEFAULT NULL,
    FOREIGN KEY (location_id) REFERENCES locations (location_id) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE employees (
    employee_id INT (11) AUTO_INCREMENT PRIMARY KEY,
    first_name VARCHAR (20) DEFAULT NULL,
    last_name VARCHAR (25) NOT NULL,
    email VARCHAR (100) NOT NULL,
    phone_number VARCHAR (20) DEFAULT NULL,
    hire_date DATE NOT NULL,
    job_id INT (11) NOT NULL,
    salary DECIMAL (8, 2) NOT NULL,
    manager_id INT (11) DEFAULT NULL,
    department_id INT (11) DEFAULT NULL,
    FOREIGN KEY (job_id) REFERENCES jobs (job_id) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (department_id) REFERENCES departments (department_id) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (manager_id) REFERENCES employees (employee_id)
);

CREATE TABLE dependents (
    dependent_id INT (11) AUTO_INCREMENT PRIMARY KEY,
    first_name VARCHAR (50) NOT NULL,
    last_name VARCHAR (50) NOT NULL,
    relationship VARCHAR (25) NOT NULL,
    employee_id INT (11) NOT NULL,
    FOREIGN KEY (employee_id) REFERENCES employees (employee_id) ON DELETE CASCADE ON UPDATE CASCADE
);</code></pre>
<h2 id="二、SQL数据库操作"><a href="#二、SQL数据库操作" class="headerlink" title="二、SQL数据库操作"></a>二、SQL数据库操作</h2><p>语句<code>SHOW DATABASES;</code>用于查看可用数据库列表。</p>
<h3 id="2-0-帮助命令-help"><a href="#2-0-帮助命令-help" class="headerlink" title="2.0 帮助命令 help"></a>2.0 帮助命令 help</h3><p>如果不知道命令或者函数怎么用，可以使用help命令，mariaDB里面都会罗列出语法。</p>
<pre><code class="SQL">--示例1
help

/*示例2*/
help create table
help join
help trigger
help grant</code></pre>
<h3 id="2-1-Create-Database-语句"><a href="#2-1-Create-Database-语句" class="headerlink" title="2.1 Create Database 语句"></a>2.1 Create Database 语句</h3><p>SQL中<code>CREATE DATABASE</code>语句用于创建新的SQL数据库：</p>
<pre><code class="SQL">--语法格式
CREATE {DATABASE|SCHEMA} [IF NOT EXISTS] database_name
[DEFAULT] CHARACTER SET [=]charset_name|[DEFAULT] COLLATE [=]collation_name;
/*[]标记其内容为可选，|用于分隔跨括号中的选择项，DEFAULT用于指定默认值，关键字CHARACTER SET用于指定数据库字符集，关键字COLLATE用于指定字符集的校对规则*/

/*示例*/
CREATE DATABASE testdb;

/*查看*/
mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| testdb             |
+--------------------+
3 rows in set</code></pre>
<p><strong>数据库名称(<code>database_name</code>)在<code>RDBMS(关系数据库管理系统)</code>中必须是唯一的</strong></p>
<h3 id="2-2-Drop-Database-语句"><a href="#2-2-Drop-Database-语句" class="headerlink" title="2.2 Drop Database 语句"></a>2.2 Drop Database 语句</h3><p>SQL中<code>DROP DATABASE</code>语句用于删除SQL模式中已存在的数据库。</p>
<pre><code class="SQL">--语法格式
DROP DATABASE database_name;

/*示例*/
DROP DATABASE testdb;

mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
+--------------------+
2 rows in set</code></pre>
<h3 id="2-3-Rename-Database-语句"><a href="#2-3-Rename-Database-语句" class="headerlink" title="2.3 Rename Database 语句"></a>2.3 Rename Database 语句</h3><p>当需要更改数据库的名称时，将使用SQL <code>RENAME DATABASE</code></p>
<pre><code class="SQL">RENAME DATABASE old_db_name TO new_db_name;

ALTER DATABASE old_name MODIFY NAME = new_name;</code></pre>
<h3 id="2-4-Use-语句"><a href="#2-4-Use-语句" class="headerlink" title="2.4 Use 语句"></a>2.4 Use 语句</h3><p>如果SQL模式中有多个数据库，那么在开始操作之前，需要选择一个将执行操作的数据库。</p>
<p>SQL中的<code>USE</code>语句用于选择SQL模式中的任何现有数据库。</p>
<pre><code class="SQL">--语法格式
USE database_name;

/*示例*/
mysql&gt; SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| test               |
+--------------------+
3 rows in set

USE test;</code></pre>
<h2 id="三、表操作"><a href="#三、表操作" class="headerlink" title="三、表操作"></a>三、表操作</h2><h3 id="3-1-创建表-Create-Table"><a href="#3-1-创建表-Create-Table" class="headerlink" title="3.1 创建表 Create Table"></a>3.1 创建表 Create Table</h3><pre><code class="SQL">CREATE [TEMPORARY] TABLE table_name(
     column_name_1 data_type default value column_constraint,
     column_name_2 data_type default value column_constraint,
     ...,
     table_constraint
);</code></pre>
<ul>
<li>由table_name指定的表名在数据库中必须是唯一的</li>
<li>每个列定义由列名，列的<a href="https://www.yiibai.com/sql/sql-data-types.html" target="_blank" rel="noopener">数据类型</a>，默认值和一个或多个列约束组成</li>
<li>列的数据类型指定列可以存储的数据类型。 列的数据类型可以是数字，字符，日期等</li>
<li>列约束控制可以存储在列中的值的类型。 例如，<code>NOT NULL</code>约束确保列不包含<code>NULL</code>值。列可能有多个列约束。 例如，<code>users</code>表的<code>username</code>列可以同时具有<code>NOT NULL</code>和<a href="https://www.yiibai.com/sql/sql-unique-constraint.html" target="_blank" rel="noopener"><code>UNIQUE</code>约束</a>。</li>
<li>如果约束包含多个列，则使用表约束。 例如，如果表的主键包含两列，则在这种情况下，必须使用<code>PRIMARY KEY</code><a href="https://www.yiibai.com/sql/sql-primary-key.html" target="_blank" rel="noopener">主键约束</a>。</li>
<li><code>TEMPORARY</code>关键字用于创建临时表，当断开与数据库连接时，mysql会自动删除它们。</li>
</ul>
<pre><code class="SQL">/*示例*/
CREATE TABLE courses (
    course_id INT AUTO_INCREMENT PRIMARY KEY,
    course_name VARCHAR(50) NOT NULL
);

/*
courses课程表有两列：course_id和course_name;

course_id是课程表的主键列。 每个表都有一个且只有一个主键，用于唯一标识表中的每一行

course_id的数据类型是整数，由INT关键字表示。 此外，course_id列的值为AUTO_INCREMENT(自动递增)。表示表中数据类为整型的列设置自增属性，自动设置为“此前表中该列的最大值加1”，同时每个表智能有一个AUTO_INCREMENT列，并且它必须被索引。

course_name存储课程名称。 其数据类型是最大长度为50的可变长度的字符串(VARCHAR)。NOT NULL约束确保course_name列中不存储NULL值。
*/</code></pre>
<pre><code class="SQL">--示例
/*有了课程表。 要存储训练数据，请按如下方式创建名为training的新表。*/
CREATE TABLE trainings (
    employee_id INT,
    course_id INT,
    taken_date DATE,
    PRIMARY KEY (employee_id , course_id)
);
/*trainings表包含三列：

employee_id列存储参加课程的员工的ID。
course_id列存储员工所采用的课程。
taken_date列存储员工参加课程的日期。

因为trainings表的主键由两列组成：employee_id和course_id，所以必须使用PRIMARY KEY表约束。*/</code></pre>
<h3 id="3-2-更新表-Alter-Table"><a href="#3-2-更新表-Alter-Table" class="headerlink" title="3.2 更新表 Alter Table"></a>3.2 更新表 Alter Table</h3><p>使用SQL <code>ALTER TABLE</code>更改数据库中现有表的结构</p>
<p><code>ALTER TABLE</code>语句用于对现有表执行以下操作：</p>
<ul>
<li>使用<code>ADD</code>子句添加新列。</li>
<li>使用<code>CHANGE</code>子句用于修改表中的列名称和数据类型。</li>
<li>使用<code>ALTER SET DEFAULT</code>子句修改或删除表中指定列的默认值。</li>
<li>使用<code>MODIFY</code>子句修改列的属性，例如：约束，默认值等。</li>
<li>使用<code>DROP</code>子句删除列。</li>
</ul>
<h4 id="3-2-1-ALTER-TABLE-ADD列"><a href="#3-2-1-ALTER-TABLE-ADD列" class="headerlink" title="3.2.1 ALTER TABLE ADD列"></a>3.2.1 ALTER TABLE ADD列</h4><p>该子句的作用是向表中添加一个或多个新列</p>
<pre><code class="SQL">--语法格式
ALTER TABLE table_name
ADD [COLUMN] column_name data_type column_constraint [AFTER existing_column];
/*要向表中添加一个或多个列，需要执行以下步骤：

首先，在ALTER TABLE子句之后指定要添加table_name，表示列所在的表。
其次，将新列定义放在ADD子句之后。 如果要在表中指定新列的顺序，可以使用可选子句AFTER existing_column。
*/

/* 以下语句将一个名称为credit_hours的新列添加到courses表中。*/
ALTER TABLE courses ADD credit_hours INT NOT NULL;

/*示例*/
ALTER TABLE courses
ADD COLUMN fee NUMERIC (10, 2) AFTER course_name,
ADD COLUMN max_limit INT AFTER course_name;</code></pre>
<h4 id="3-2-2-ALTER-TABLE-CHANGE列名称和属性"><a href="#3-2-2-ALTER-TABLE-CHANGE列名称和属性" class="headerlink" title="3.2.2 ALTER TABLE CHANGE列名称和属性"></a>3.2.2 ALTER TABLE CHANGE列名称和属性</h4><p><code>CHANGE</code>子句用于修改表中的列名称和数据类型。</p>
<pre><code class="SQL">--语法格式
ALTER TABLE table_name
CHANGE [COLUMN] column_name new_column_name column_properties;

/*示例*/
ALTER TABLE students
CHANGE students_name names varchar(100) NOT NULL;</code></pre>
<h4 id="3-2-3-ALTER-TABLE-ALTER-SET-DEFAULT列"><a href="#3-2-3-ALTER-TABLE-ALTER-SET-DEFAULT列" class="headerlink" title="3.2.3 ALTER TABLE ALTER SET DEFAULT列"></a>3.2.3 ALTER TABLE ALTER SET DEFAULT列</h4><p><code>ALTER [COLUMN] SET</code>子句修改或删除表中指定列的默认值。</p>
<pre><code class="SQL">--语法格式
ALTER TABLE table_name
ALTER [COLUMN] column_name SET DEFAULT &#39;xxx&#39;;

/*示例*/
ALTER TABLE customers
ALTER city SET DEFAULT &#39;beijing&#39;;</code></pre>
<h4 id="3-2-4-ALTERE-TABLE-MODIFY列"><a href="#3-2-4-ALTERE-TABLE-MODIFY列" class="headerlink" title="3.2.4 ALTERE TABLE MODIFY列"></a>3.2.4 ALTERE TABLE MODIFY列</h4><p>MODIFY子句用于更改现有列的数据类型。</p>
<pre><code class="SQL">--语法格式
ALTER TABLE table_name
MODIFY [COLUMN] column_name column_properties;

/*示例*/
ALTER TABLE students MODIFY name VARCHAR(20) NOT NULL;</code></pre>
<h4 id="3-2-5-ALTER-TABLE-DROP列"><a href="#3-2-5-ALTER-TABLE-DROP列" class="headerlink" title="3.2.5 ALTER TABLE DROP列"></a>3.2.5 ALTER TABLE DROP列</h4><p>当表的列已过时且未被任何其他数据库对象(如触发器，视图，存储过程和存储过程)使用时，将其从表中删除，请使用以下语法：</p>
<pre><code class="SQL">--语法格式
ALTER TABLE table_name
DROP [COLUMN] column_name,
DROP [COLUMN] column_name,
...

/*示例1-删除一列*/
ALTER TABLE courses DROP fee;

/*示例2-删除多列*/
ALTER TABLE courses
DROP COLUMN max_limit,
DROP COLUMN credit_hours;</code></pre>
<h4 id="3-2-6-ALTER-TABLE-RENAME-TO"><a href="#3-2-6-ALTER-TABLE-RENAME-TO" class="headerlink" title="3.2.6 ALTER TABLE RENAME TO"></a>3.2.6 ALTER TABLE RENAME TO</h4><p><code>RENAME TO</code>子句为表重新赋予一个表名。</p>
<pre><code class="SQL">--语法格式
ALTER TABLE table_name
RENAME [TO] new_table_name;

/*示例*/
ALTER TABLE classes
RENAME new_classes;</code></pre>
<h3 id="3-3-删除表-DROP-TABLE"><a href="#3-3-删除表-DROP-TABLE" class="headerlink" title="3.3 删除表 DROP TABLE"></a>3.3 删除表 DROP TABLE</h3><p>使用SQL <code>DROP TABLE</code>语句删除数据库中的一个或多个表</p>
<pre><code class="SQL">--语法格式
DROP [TEMPORARY] TABLE [IF EXISTS] table_name [ RESTRICT | CASCADE ];
--为了防止删除不存在的表的错误，使用可选子句IF EXISTS。

/*示例*/
DROP TABLE students;

/*删除多个表*/
DROP TABLE IF EXISTS table_name1,table_name2,...;</code></pre>
<ul>
<li><p>DROP TABLE语句永久删除表的数据和结构，某些数据库系统要求表中的记录必须为空时才能从数据库中删除。这有助于防止意外删除仍在使用的表。</p>
</li>
<li><p>要删除表中的所有数据，可以使用<a href="https://www.yiibai.com/sql/sql-delete.html" target="_blank" rel="noopener">DELETE</a>或<a href="https://www.yiibai.com/sql/sql-truncate-table.html" target="_blank" rel="noopener">TRUNCATE TABLE</a>语句。</p>
</li>
<li><p>要删除由另一个表的外键约束引用的表，必须在删除表之前禁用或删除外部约束。</p>
</li>
</ul>
<h3 id="3-4-快速删除表-TURNCATE-TABLE"><a href="#3-4-快速删除表-TURNCATE-TABLE" class="headerlink" title="3.4 快速删除表 TURNCATE TABLE"></a>3.4 快速删除表 TURNCATE TABLE</h3><p>使用SQL <code>TRUNCATE TABLE</code>语句高效，快速地删除表中的所有数据</p>
<pre><code class="SQL">--语法格式
TRUNCATE TABLE table_name;     /*快速删除大表中的所有行*/

TRUNCATE TABLE IF EXISTS table_name1, table_name2, ...;

/*示例*/
TRUNCATE TABLE IF EXISTS students, teachers;</code></pre>
<h3 id="3-5-重命名表-RENAME-TABLE"><a href="#3-5-重命名表-RENAME-TABLE" class="headerlink" title="3.5 重命名表 RENAME TABLE"></a>3.5 重命名表 RENAME TABLE</h3><p>SQL RENAME TABLE用于更改表的名称。</p>
<pre><code class="SQL">--语法格式1
ALTER TABLE table_name
RENAME [TO] new_table_name;
--语法格式2
RENAME TABLE old_table_name To new_table_name;

/*示例1*/
ALTER TABLE Students
RENAME Student_bank;
/*示例2*/
RENAME TABLE Student_bank TO Students;</code></pre>
<h3 id="3-6-复制表-amp-临时表"><a href="#3-6-复制表-amp-临时表" class="headerlink" title="3.6 复制表&amp;临时表"></a>3.6 复制表&amp;临时表</h3><h4 id="1）-复制表"><a href="#1）-复制表" class="headerlink" title="1） 复制表"></a>1） 复制表</h4><p>如果要将SQL表复制到同一数据库中的另一个表中，可以使用<code>select</code>语句。</p>
<pre><code class="SQL">--语法格式1
--从一个表复制到另一个表的语法如下：
SELECT * INTO &lt;destination_table&gt; FROM &lt;source_table&gt;

/*示例*/
SELECT * INTO my_table_2 FROM my_table_1;</code></pre>
<blockquote>
<p>注意：<code>SELECT INTO</code>与<code>INSERT INTO</code>语句完全不同。</p>
</blockquote>
<h4 id="2）-临时表"><a href="#2）-临时表" class="headerlink" title="2） 临时表"></a>2） 临时表</h4><p>临时表可以在运行时创建，并且可以像普通表一样执行各种操作，这些临时表是在<code>tempdb</code>数据库中创建的。</p>
<p>根据行为和范围，有如下两种类型的临时表。1. 局部临时变量。 2. 全局临时变量。</p>
<p>① 局部临时变量</p>
<pre><code class="SQL">/*示例*/
/*局部临时变量表仅在当前连接时可用。 当用户与实例断开连接时，它会自动删除。 它以哈希(#)符号开头*/
CREATE TABLE #local temp table (  
    User_id int,  
    User_name varchar (50),  
    User_address varchar (150)  
)</code></pre>
<p>② 全局临时变量</p>
<pre><code class="SQL">/*全局临时表名称以双哈希(##)开头。 创建此表后，它就像一个永久表。 它始终为所有用户准备好，并且在撤消总连接之前不会被删除。*/
cREATE TABLE ##new global temp table (  
    User_id int,  
    User_name varchar (50),  
    User_address varchar (150)  </code></pre>
<h3 id="3-7-查看表"><a href="#3-7-查看表" class="headerlink" title="3.7 查看表"></a>3.7 查看表</h3><h4 id="3-7-1-查看表的名称"><a href="#3-7-1-查看表的名称" class="headerlink" title="3.7.1 查看表的名称"></a>3.7.1 查看表的名称</h4><pre><code class="SQL">--语法格式
SHOW [FULL] TABLES [{ FROM | IN } table_name]
[ LIKE &#39;pattern&#39; | WHERE expr];

/*示例*/
SHOW TABLES;</code></pre>
<h4 id="3-7-2-显示表的结构"><a href="#3-7-2-显示表的结构" class="headerlink" title="3.7.2 显示表的结构"></a>3.7.2 显示表的结构</h4><pre><code class="SQL">--语法格式
SHOW [FULL] COLUMNS {FROM|IN} table_name [{ FROM | IN } table_name]
[ LIKE &#39;pattern&#39; | WHERE expr];
--或者使用DESCRIBE语句
{DESCRIBE | DESC} table_name [ col_name | wild ];

/*示例*/
DESC test.classes;</code></pre>
<h2 id="四、数据操作语句"><a href="#四、数据操作语句" class="headerlink" title="四、数据操作语句"></a>四、数据操作语句</h2><h3 id="4-1-INSERT语句"><a href="#4-1-INSERT语句" class="headerlink" title="4.1 INSERT语句"></a>4.1 INSERT语句</h3><p>SQL提供了<code>INSERT</code>语句，用于将一行或多行插入表中。 <code>INSERT</code>语句用于：</p>
<ul>
<li>向表中插入一行</li>
<li>向表中插入多行</li>
<li>将行从一个表复制到另一个表中。</li>
</ul>
<pre><code class="SQL">--语法格式1
--插入一行,不建议省略column_name。
INSERT [INTO] table_name [(col_name,...)]
{VALUES | VALUE}
    ({expr | DEFAULT},...),(...),...;
--语法格式2
INSERT [INTO] table_name
    SET col_name={expr | DEFAULT},...
/*&quot;expr&quot;，表示一个常量、变量或一个表达式，也可以是空值NULL
“DEFAULT”关键字，用于指定此列值为该列的默认值，前提是该列已经有默认值。*/

--从其他表复制行记录
INSERT INTO table1 (column1, column2,...)
SELECT
    column1,
    column2
FROM
    table2
WHERE
    condition1;

/*示例1*/
INSERT students(class_id,name,gender,score)
VALUE
    (&#39;3&#39;,&#39;小绿&#39;,&#39;M&#39;,&#39;95&#39;);

/*示例2*/
INSERT INTO temp(id,name)
VALUES
    (2,&#39;xiaoli&#39;),
    (3,&#39;xiaowang&#39;),
    (4,&#39;xiaojun&#39;);

/*示例3*/
INSERT INTO customers
    SET cust_name=&#39;李四&#39;,cust_address=&#39;武汉市&#39;,cust_sex=DEFAULT;</code></pre>
<h3 id="4-2-Insert-Into-Select"><a href="#4-2-Insert-Into-Select" class="headerlink" title="4.2 Insert Into Select"></a>4.2 Insert Into Select</h3><p>在表中插入多行，可以将<code>Insert</code>与<code>select</code>语句结合使用。</p>
<pre><code class="SQL">INSERT INTO &quot;table 1&quot; (&quot;column1&quot;, &quot;column2&quot;,....)  
SELECT &quot;column3&quot;, &quot;column4&quot;,....  
FROM &quot;table2&quot;;</code></pre>
<p><code>INSERT INTO</code>语句还可以包含许多子句，如：<code>SELECT</code>，<code>GROUP BY</code>，<code>HAVING</code>以及<code>JOIN</code>和<code>ALIAS</code>。 因此，<code>insert into select</code>语句可能会有些复杂。</p>
<pre><code class="SQL">/*示例*/
INSERT INTO store (store_name, sales, transaction_date)  
SELECT store_name, sum (sales), transaction_date  
FROM sales_information  
GROUP BY store_name, transaction_date;</code></pre>
<h3 id="4-3-Update语句"><a href="#4-3-Update语句" class="headerlink" title="4.3 Update语句"></a>4.3 Update语句</h3><p>使用SQL <code>UPDATE</code>语句来修改表中现有行的数据</p>
<pre><code class="SQL">--语法格式
UPDATE table_name
    SET col_name1={expr1 | DEFAULT}
        [,col_name2 = {expr2 | DEFAULT}] ...
    [WHERE condition]
    [ORDER BY ...]
    [LIMIT row_count];
/*在上面的语法中
首先，在SET子句中指定要修改的列。 SET子句中未列出的列的值不会被修改。
其次，指定WHERE子句中要更新的行。
第三，WHERE子句是可选的，如果省略它，表中的所有行都将受到影响。*/

/*示例1--小于3000的工资改为3000*/
UPDATE
    workers
SET
    salary=3000
WHERE
    salary&lt;3000;

/*示例2--确保子项dependents的last_name始终与employees表中的last_name匹配*/
UPDATE dependents
SET last_name = (
    SELECT
        last_name
    FROM
        employees
    WHERE
        employee_id = dependents.employee_id
);

/*示例3--给工资超过100000美元的教师涨3%的工资，其余教师涨5%*/
UPDATE instructor
SET salary=case
        when salary&lt;=100000 then salary * 1.05
        else salary * 1.03
end</code></pre>
<h3 id="4-4-UPDATE-amp-JOIN语句"><a href="#4-4-UPDATE-amp-JOIN语句" class="headerlink" title="4.4 UPDATE &amp; JOIN语句"></a>4.4 UPDATE &amp; JOIN语句</h3><p><code>UPDATE JOIN</code>可使用一个表和连接条件来更新另一个表。</p>
<pre><code class="SQL">/*假设有一个客户表，要用最新数据来更新客户表。可使用客户ID来连接在目标表和源表之间执行连接*/

/*语法格式*/
UPDATE customer_table  
INNER JOIN  
Customer_table  
ON customer_table.rel_cust_name = customer_table.cust_id  
SET customer_table.rel_cust_name = customer_table.cust_name

--示例
/*在table2中共有3行，假设想要将table1中的值更新为table2中column1为21和31行的值。
仅更新column2和column3的值。
最简单和最常用的方法是在update语句中使用join子句并在update语句中使用多个表。*/
UPDATE table1 t1
LEFT JOIN  table2 t2
ON t1.column1 = t2.column1
SET t1.column2 = t2.column2,  
t1.column3 = t2.column3
where t1.column1 in(21,31);</code></pre>
<h3 id="4-5-更新日期数据"><a href="#4-5-更新日期数据" class="headerlink" title="4.5 更新日期数据"></a>4.5 更新日期数据</h3><p>要在SQL中更新日期和时间字段，则应使用以下查询。</p>
<pre><code class="SQL">--语法格式
UPDATE table
SET Column_Name = &#39;YYYY-MM-DD HH:MM:SS&#39;  
WHERE Id = value

/*示例*/
UPDATE table1
SET EndDate = &#39;2019-03-16 00:00:00.000&#39;
WHERE id in(1,3);</code></pre>
<h3 id="4-6-DELETE语句"><a href="#4-6-DELETE语句" class="headerlink" title="4.6 DELETE语句"></a>4.6 DELETE语句</h3><p>使用SQL <code>DELETE</code>语句删除表中的一行或多行。</p>
<pre><code class="SQL">--语法格式
DELETE
FROM
    table_name
WHERE
    condition;
/*1. 提供要删除行的表名称(table_name)。
2. 在WHERE子句中指定条件以标识需要删除的行记录。 如果省略WHERE子句，则将删除表中的所有行记录。 因此，应始终谨慎使用DELETE语句。*/

/*示例*/
DELETE FROM dependents
WHERE
    employee_id IN (100 , 101, 102);</code></pre>
<h2 id="五、SQL查询语句"><a href="#五、SQL查询语句" class="headerlink" title="五、SQL查询语句"></a>五、SQL查询语句</h2><p>SQL查询语句的通用形式：</p>
<pre><code class="SQL">select &lt;[distinct] c1，c2…&gt;
from &lt;r1,……&gt;
[where &lt;condition&gt;]
[group by &lt;c1，c2.…&gt; [having &lt;cond2&gt;]]
[order by&lt;c1[desc] ,[c2[desc|asc],…]&gt;</code></pre>
<p>SQL查询语句执行顺序：<br><code>from→where→group（aggregate）→having→select→order by</code></p>
<h3 id="5-1-SELECT语句"><a href="#5-1-SELECT语句" class="headerlink" title="5.1 SELECT语句"></a>5.1 SELECT语句</h3><p>除了<code>SELECT</code>和<code>FROM</code>子句之外，<code>SELECT</code>语句还可以包含许多其他子句，例如 -</p>
<ul>
<li><a href="https://www.yiibai.com/sql/sql-where.html" target="_blank" rel="noopener">WHERE</a> - 用于根据指定条件过滤数据</li>
<li><a href="https://www.yiibai.com/sql/sql-inner-join.html" target="_blank" rel="noopener">JOIN</a> - 用于查询来自多个相关表的数据</li>
<li><a href="https://www.yiibai.com/sql/sql-group-by.html" target="_blank" rel="noopener">GROUP BY</a> - 用于根据一列或多列对数据进行分组</li>
<li><a href="https://www.yiibai.com/sql/sql-having.html" target="_blank" rel="noopener">HAVING</a> - 用于过滤分组</li>
<li><a href="https://www.yiibai.com/sql/sql-order-by.html" target="_blank" rel="noopener">ORDER BY</a> - 用于对结果集进行排序</li>
<li><a href="https://www.yiibai.com/sql/sql-limit.html" target="_blank" rel="noopener">LIMIT</a> - 用于限制返回的行</li>
</ul>
<pre><code class="SQL">--语法格式
SELECT
    [ALL | DISTINCT | DISTINCTROW ]
    select_expr [, select_expr ...]
    [FROM table_references
    [WHERE where_condition]
    [GROUP BY {col_name | expr | position}
      [ASC | DESC], ... [WITH ROLLUP]]
    [HAVING where_condition]
    [ORDER BY {col_name | expr | position}
      [ASC | DESC], ...]
    [LIMIT {[offset,] row_count | row_count OFFSET offset}]
/*select子句的使用顺序需要按照上述语法格式依次输入执行。
[ALL | DISTINCT | DISTINCTROW ]指定是否返回结果集中的重复行，默认ALL。
SELECT * FROM table_name查询tbl_name中所有行列。*/

--语法格式附加
--替换查询结果集中的数据
CASE
WHEN 条件1 THEN 表达式1
    WHEN 条件2 THEN 表达式2
    ...
    WHEN 条件n THEN 表达式n
ELSE 表达式n
END

/*示例*/
/*查询特定的列*/
SELECT
    employee_id,
    first_name,
    last_name,
    hire_date
FROM
    employees;

/*示例2*/
/*以下查询使用FLOOR()，DATEDIFF()和CURRENT_DATE函数计算员工的服务年份。要计算服务年份，将DATEDIFF()函数的结果除以365。FLOOR()函数返回小于或等于数值表达式结果的最大整数。YoS是下面表达式的列别名。*/
SELECT
    employee_id,
    first_name,
    last_name,
    FLOOR(DATEDIFF(NOW(), hire_date) / 365) AS YoS
FROM
    employees;

/*示例3--判断结果集中的值，如果值为M，输出男，否则为女，同时列名为性别*/
SELECT name,
    CASE
    WHEN gender=&#39;M&#39; THEN &#39;男&#39;
    ELSE &#39;女&#39;
    END AS 性别
FROM students;</code></pre>
<h3 id="5-2-ORDER-BY排序"><a href="#5-2-ORDER-BY排序" class="headerlink" title="5.2 ORDER BY排序"></a>5.2 ORDER BY排序</h3><p>SQL <code>ORDER BY</code>子句根据指定的标准按升序或降序对结果集进行排序。</p>
<pre><code class="SQL">--语法格式
SELECT
    column1, column2
FROM
    table_name
ORDER BY column1 ASC ,  --默认升序
         column2 DESC;  --降序
/*在此语法中，ORDER BY子句放在FROM子句之后。 如果SELECT语句包含WHERE子句，则ORDER BY子句必须放在WHERE子句之后。
要指定要排序的列以及排序顺序的类型：
1. 升序(使用：ASC表示，默认是升序)
2. 降序(使用：DESC表示)*/

/*示例--班级id按人数多少升序排列*/
select class_id,count(*) AS &quot;人数&quot;
    FROM students
    GROUP BY class_id
    HAVING count(*)&gt;=1
    ORDER BY count(*);</code></pre>
<h3 id="5-3-DISTINCT运算符"><a href="#5-3-DISTINCT运算符" class="headerlink" title="5.3 DISTINCT运算符"></a>5.3 DISTINCT运算符</h3><p>使用SQL <code>DISTINCT</code>运算符从结果集中删除重复数据项。</p>
<pre><code class="SQL">--语法格式
SELECT DISTINCT
    column1,column2......
FROM
    table1;
/*DISTINCT运算符将所有NULL值视为相同的值。因此在结果集中，DISTINCT运算符只保留一个NULL值，并从结果集中删除其它的NULL值。*/

/*示例*/
SELECT DISTINCT
    job_id,
    salary
FROM
    employees
ORDER BY
    job_id,
    salary DESC;</code></pre>
<h3 id="5-4-LIMIT子句"><a href="#5-4-LIMIT子句" class="headerlink" title="5.4 LIMIT子句"></a>5.4 LIMIT子句</h3><p>使用SQL <code>LIMIT</code>子句来限制<code>SELECT</code>语句返回的行数。</p>
<pre><code class="SQL">--语法格式
--使用LIMIT和OFFSET子句。
LIMIT {[offset,] row_count | row_count OFFSET offset}
/*1. row_count用于返回数据的行数。
2. OFFSET可选项，默认为0。用于指定返回数据的第一行在SELECT语句结果集中的偏移量，其必须是非负的整数常量。
3.row_count OFFSET offset:从第offset+1行开始，取row_count行。*/

/*示例--跳过三行并获取接下来的五行,即显示4-8行*/
SELECT
    employee_id, first_name, last_name
FROM
    employees
ORDER BY first_name
LIMIT 5 OFFSET 3;
/*LIMIT 5 OFFSET 3等同于LIMIT 3,5*/

/*示例2-获取薪水最高的前5名*/
SELECT
    employee_id, first_name, last_name, salary
FROM
    employees
ORDER BY salary DESC
LIMIT 5;

/*示例3-获取薪水排名第三高的人名*/
/*通过嵌套子查询，先查出第三高的是多少salary，然后查name*/
SELECT
    employee_id, first_name, last_name, salary
FROM
    employees
WHERE
    salary = (SELECT DISTINCT
            salary
        FROM
            employees
        ORDER BY salary DESC
        LIMIT 2 , 1);</code></pre>
<h3 id="5-5-ALL-ANY-SOME语句"><a href="#5-5-ALL-ANY-SOME语句" class="headerlink" title="5.5 ALL,ANY,SOME语句"></a>5.5 ALL,ANY,SOME语句</h3><p>SQL <code>ALL</code>与集合中所有元素比较；<code>ANY</code>和<code>SOME</code>与集合中的某些元素比较。</p>
<pre><code class="SQL">/*示例1--找出所有 工资至少比生物系一个教师的工资要高 的教师*/
SELECT name
FROM instructor
WHERE salary &gt; SOME(SELECT salary
                    FROM instructor
                    WHERE dept_name=&#39;Biology&#39;);

/*示例2--找出平均工资最高的系*/
SELECT dept_name
FROM instructor
GROUP BY dept_name
having avg(salary) &gt;= ALL(SELECT avg(salary)
                          FROM instructor
                          GROUP BY dept_name);</code></pre>
<h3 id="5-6-BETWEEN-IN-LIKE-NULL"><a href="#5-6-BETWEEN-IN-LIKE-NULL" class="headerlink" title="5.6 BETWEEN | IN | LIKE | NULL"></a>5.6 BETWEEN | IN | LIKE | NULL</h3><h4 id="5-6-1-BETWEEN"><a href="#5-6-1-BETWEEN" class="headerlink" title="5.6.1 BETWEEN"></a>5.6.1 BETWEEN</h4><p>SQL <code>BETWEEN</code>运算符选择指定范围内的值。</p>
<pre><code class="SQL">--语法格式
expression BETWEEN low AND high;
expression NOT BETWEEN low AND high;

/*示例*/
SELECT
    employee_id, first_name, last_name, hire_date
FROM
    employees
WHERE
    hire_date BETWEEN &#39;1999-01-01&#39; AND &#39;2000-12-31&#39;
ORDER BY hire_date;

/*1. BETWEEN运算符需要低值和高值。如果低值大于高值，将得到一个空的结果集。
2. 2000-12-31默认为2000-12-31  00:00:00.000000*/</code></pre>
<h4 id="5-6-2-IN"><a href="#5-6-2-IN" class="headerlink" title="5.6.2 IN"></a>5.6.2 IN</h4><p>SQL <code>IN</code>运算符将列中的值与括号内的一组值进行比较。<br>要比较连续的值可用<code>LIMIT</code>，比如5-100。</p>
<pre><code class="SQL">--语法格式
expression IN (value1,value2,...)
expression NOT IN (value1, value2,...)

/*示例--查找工作ID不是8,9或10的所有员工*/
SELECT
    employee_id, first_name, last_name, job_id
FROM
    employees
WHERE
    job_id NOT IN (8, 9, 10)
ORDER BY
    job_id;</code></pre>
<h4 id="5-6-3-LIKE"><a href="#5-6-3-LIKE" class="headerlink" title="5.6.3 LIKE"></a>5.6.3 LIKE</h4><p>SQL <code>LIKE</code>运算符来测试表达式是否与模式匹配。</p>
<p>要构造模式，请使用两个SQL通配符：</p>
<ul>
<li><code>%</code> 百分号匹配零个，一个或多个字符。</li>
<li><code>_</code> 下划线符号匹配单个字符</li>
</ul>
<p>下表说明了一些模式及其含义：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>LIKE ‘Yii%’</td>
<td>匹配以Yii开始的字符串</td>
</tr>
<tr>
<td>LIKE ‘%su’</td>
<td>匹配以su结尾的字符串</td>
</tr>
<tr>
<td>LIKE ‘%ch%</td>
<td>匹配包含ch的字符串</td>
</tr>
<tr>
<td>LIKE ‘Luc_’</td>
<td>以Luc开始，后面只有一个字符，例如：Lucy，LucC等</td>
</tr>
<tr>
<td>LIKE ‘_cy’</td>
<td>以cy结尾，前面只有一个字符，例如：Lcy，ucy等</td>
</tr>
<tr>
<td>LIKE ‘%yiiBai_’</td>
<td>包含yiiBai，以任意数量的字符开头，最多以一个字符结尾。</td>
</tr>
<tr>
<td>LIKE ‘_yiiBai%’</td>
<td>包含yiiBai，最多以一个字符开头，以任意数量的字符结尾。</td>
</tr>
</tbody></table>
<pre><code class="SQL">--语法格式
expression LIKE pattern

/*如果要匹配通配符%或_，则必须使用反斜杠字符\来对其进行转义。 如果要使用其它的转义字符而不是反斜杠，可以在LIKE表达式中使用ESCAPE子句，如下所示：*/
expression LIKE pattern ESCAPE escape_character

/*示例--要查找名字以M开头但不以Ma开头的所有员工，请使用以下语句：*/
SELECT
    employee_id, first_name, last_name
FROM
    employees
WHERE
    first_name LIKE &#39;M%&#39;
AND first_name NOT LIKE &#39;Ma%&#39;
ORDER BY
    first_name;</code></pre>
<h4 id="5-6-4-NULL"><a href="#5-6-4-NULL" class="headerlink" title="5.6.4 NULL"></a>5.6.4 NULL</h4><p>使用SQL <code>IS NULL</code>和<code>IS NOT NULL</code>运算符来测试表达式是否为<code>NULL</code>。</p>
<p><code>NULL</code>表示数据未知的值，在数据库中缺少数据。</p>
<pre><code class="SQL">--语法格式
expression IS NULL;

/*示例--查找具有电话号码的所有员工，请使用IS NOT NULL，如以下语句所示：*/
SELECT
    employee_id,
    first_name,
    last_name,
    phone_number
FROM
    employees
WHERE
    phone_number IS NOT NULL;</code></pre>
<p>注意：</p>
<ol>
<li>不能使用比较运算符的等于(=)将值与<code>NULL</code>值进行比较</li>
<li><code>NULL</code>值是特殊的，任何与<code>NULL</code>值的比较都不会返回<code>true</code>或<code>false</code>，而是返回未知</li>
</ol>
<h3 id="5-7-SQL别名"><a href="#5-7-SQL别名" class="headerlink" title="5.7 SQL别名"></a>5.7 SQL别名</h3><p>SQL别名，包括表和列别名，使查询更短，更易理解。</p>
<p>使用关键词<code>AS</code>，可省略。</p>
<h4 id="5-7-1-列别名"><a href="#5-7-1-列别名" class="headerlink" title="5.7.1 列别名"></a>5.7.1 列别名</h4><pre><code class="SQL">/*示例*/
SELECT
    inv_no AS invoice_no,
    amount,
    due_date AS &#39;截止日期&#39;,
    cust_no &#39;客户编号&#39;
FROM
    invoices;
/*别名包含空格，必须使用单引号(&#39;)或双引号(&quot;)来包围别名。*/</code></pre>
<h4 id="5-7-2-表别名"><a href="#5-7-2-表别名" class="headerlink" title="5.7.2 表别名"></a>5.7.2 表别名</h4><pre><code class="SQL">--语法格式
SELECT
    d.department_name
FROM
    departments AS d

/*示例一--以下查询使用inner join子句从employees和departments表中选择数据。*/
SELECT
    employee_id,
    first_name,
    last_name,
    e.department_id,
    department_name
FROM
    employees e
INNER JOIN departments d ON d.department_id = e.department_id
ORDER BY
    first_name;

/*示例二--以下查询使用self-join将employee表自联接。*/
SELECT
    e.first_name AS employee,
    m.first_name AS manager
FROM
    employees e
LEFT JOIN employees m ON m.employee_id = e.manager_id
ORDER BY
    manager;</code></pre>
<h3 id="5-8-JOIN操作"><a href="#5-8-JOIN操作" class="headerlink" title="5.8 JOIN操作"></a>5.8 JOIN操作</h3><p><code>SELECT</code>语句不仅能从单个表中查询数据，而且可以将多个表链接在一起。连接表的过程称为<code>Join</code>。</p>
<p>SQL提供了多种连接，如内连接，左连接，右连接，全外连接等。</p>
<h4 id="5-8-1-INNER-JOIN"><a href="#5-8-1-INNER-JOIN" class="headerlink" title="5.8.1 INNER JOIN"></a>5.8.1 INNER JOIN</h4><p>SQL <code>INNER JOIN</code>内连接子句来查询来自两个或多个表的数据。</p>
<p>内连接子句消除了与另一个表的行不匹配的行，相当于交集。</p>
<pre><code class="SQL">--语法格式
SELECT
  A.n
FROM A
INNER JOIN B ON B.n = A.n

/*示例--employees表中的department_id列是将员工链接到departments表的外键列。*/
SELECT
    first_name,
    last_name,
    employees.department_id,
    departments.department_id,
    department_name
FROM
    employees
        INNER JOIN
    departments ON departments.department_id = employees.department_id
WHERE
    employees.department_id IN (1, 2, 3);

--语法格式
/*INNER JOIN子句可以连接三个或更多表，只要它们具有关系，通常是外键关系。*/
SELECT
  A.n
FROM A
INNER JOIN B ON B.n = A.n
INNER JOIN C ON C.n = A.n;

/*示例--使用内部联接子句连接3个表：员工，部门和工作岗位，以获取在部门ID为：1,2和3中工作的员工的信息。*/
SELECT
    first_name, last_name, job_title, department_name
FROM
    employees e
INNER JOIN departments d ON d.department_id = e.department_id
INNER JOIN jobs j ON j.job_id = e.job_id
WHERE
    e.department_id IN (1, 2, 3);</code></pre>
<h4 id="5-8-2-LEFT-JOIN"><a href="#5-8-2-LEFT-JOIN" class="headerlink" title="5.8.2 LEFT JOIN"></a>5.8.2 LEFT JOIN</h4><p>左连接将返回左表中的所有行，而不管右表中是否存在匹配的行，相当于AB交集后显示A。</p>
<pre><code class="SQL">--语法格式
SELECT
    A.n
FROM
    A
LEFT JOIN B ON B.n = A.n;

/*示例*/
SELECT
    c.country_name, c.country_id, l.country_id, l.street_address, l.city
FROM
    countries c
LEFT JOIN locations l ON l.country_id = c.country_id
WHERE
    c.country_id IN (&#39;US&#39;, &#39;UK&#39;, &#39;CN&#39;)
/*右表中的非匹配行使用NULL值填充*/</code></pre>
<h4 id="5-8-3-FULL-OUTER-JOIN"><a href="#5-8-3-FULL-OUTER-JOIN" class="headerlink" title="5.8.3 FULL OUTER JOIN"></a>5.8.3 FULL OUTER JOIN</h4><p>完全外连接是左连接和右连接的组合。完整外连接包括连接表中的所有行，相当于并集。</p>
<p>如果连接表中的行不匹配，则使用NULL值填充。</p>
<pre><code class="SQL">--语法格式
SELECT column_list
FROM A
FULL OUTER JOIN B ON B.n = A.n;

/*示例--查找不存储任何水果的空篮子*/
SELECT
    basket_name,
    fruit_name
FROM
    fruits
FULL OUTER JOIN baskets ON baskets.basket_id = fruits.basket_id
WHERE
    fruit_name IS NULL;</code></pre>
<h4 id="5-8-4-Cross-Join"><a href="#5-8-4-Cross-Join" class="headerlink" title="5.8.4 Cross Join"></a>5.8.4 Cross Join</h4><p>SQL <code>Cross Join</code>交叉连接是一种连接操作，它生成两个或多个表的笛卡尔积。</p>
<pre><code class="SQL">--语法格式
SELECT column_list
FROM table_A
CROSS JOIN table_B;
/*在SQL中，假设A表有n行，而B表有m行，那么A和B表的交叉连接结果有n x m行*/

/*以下语句等同于使用上面的CROSS JOIN子句的语句*/
SELECT
    column_list
FROM
    table_A,table_B;</code></pre>
<h4 id="5-8-5-自连接"><a href="#5-8-5-自连接" class="headerlink" title="5.8.5 自连接"></a>5.8.5 自连接</h4><p>SQL自连接技术将表连接到自身。</p>
<p>我们将一张表连接到自身来评估同一个表中其他行的行。 要执行自联接，我们使用内连接或左连接子句。</p>
<p>因为同一张表在单个查询中出现两次，所以必须使用表别名。</p>
<pre><code class="SQL">--语法格式
SELECT
    column1,
    column2,
    column3,
        ...
FROM
    table1 A
INNER JOIN table1 B ON B.column1 = A.column2;
/*在此语句中，使用INNER JOIN子句将table1连接到自身。 A和B是table1的表别名。 B.column1 = A.column2是连接条件。*/

/*示例一--查询每位员工的上级经理信息。*/
SELECT
    CONCAT(e.first_name, &#39; &#39;, e.last_name) as employee,
    CONCAT(m.first_name, &#39; &#39;, m.last_name) as manager
FROM
    employees e
        INNER JOIN
    employees m ON m.employee_id = e.manager_id
ORDER BY manager;

/*示例二--查询每位员工的上级经理信息。包含最高领导。*/
SELECT
    CONCAT(e.first_name, &#39; &#39;, e.last_name) as employee,
    CONCAT(m.first_name, &#39; &#39;, m.last_name) as manager
FROM
    employees e
        LEFT JOIN
    employees m ON m.employee_id = e.manager_id
ORDER BY manager;</code></pre>
<h2 id="六、聚合函数"><a href="#六、聚合函数" class="headerlink" title="六、聚合函数"></a>六、聚合函数</h2><p>SQL聚合函数计算一组值并返回单个值。</p>
<p>因为聚合函数对一组值进行操作，所以它通常与<code>SELECT</code>语句的<code>GROUP BY</code>子句一起使用。<code>GROUP BY</code>子句将结果集划分为值分组，聚合函数为每个分组返回单个值。</p>
<p>以下是常用的SQL聚合函数：</p>
<ul>
<li>AVG() - 返回集合的平均值。</li>
<li>COUNT() - 返回集合中的项目数。</li>
<li>MAX() - 返回集合中的最大值。</li>
<li>MIN() - 返回集合中的最小值</li>
<li>SUM() - 返回集合中所有或不同值的总和。</li>
</ul>
<h3 id="6-1-AVG-（平均）"><a href="#6-1-AVG-（平均）" class="headerlink" title="6.1  AVG （平均）"></a>6.1  AVG （平均）</h3><p><code>AVG()</code>函数返回集合中的平均值</p>
<pre><code class="SQL">--语法格式
AVG([ALL|DISTINCT] expression)
/*ALL关键字计算所有值的平均值，而DISTINCT关键字强制函数仅对不同的值进行操作。默认情况下，使用ALL选项*/

/*示例1*/
SELECT
    AVG(salary)
FROM
    employees;
SELECT
    ROUND(AVG(DISTINCT salary), 2)
FROM
    employees;
--使用ROUND函数，结果舍入为2位小数

/*示例2 ： 与分组一起使用*/
SELECT
    department_id,
    AVG(salary)
FROM
    employees
GROUP BY
    department_id;

/*示例3：与JOIN一起使用*/
SELECT
    e.department_id,
    department_name,
    AVG(salary)
FROM
    employees e
INNER JOIN departments d ON d.department_id = e.department_id
GROUP BY
    e.department_id;

/*示例4 ： 与HAVING一起使用*/
SELECT
    e.department_id,
    department_name,
    AVG(salary) AS avgsalary
FROM
    employees e
INNER JOIN departments d ON d.department_id = e.department_id
GROUP BY
    e.department_id
HAVING avgsalary&lt;5000
ORDER BY
    AVG(salary) DESC;

/*示例5： 子查询*/
SELECT
    AVG(employee_sal_avg)
FROM
    (
        SELECT
            AVG(salary) employee_sal_avg
        FROM
            employees
        GROUP BY
            department_id
    ) t;</code></pre>
<h3 id="6-2-COUNT（统计）"><a href="#6-2-COUNT（统计）" class="headerlink" title="6.2 COUNT（统计）"></a>6.2 COUNT（统计）</h3><p>SQL <code>COUNT</code>函数来获取组中的项目数。它返回符合条件行数。</p>
<pre><code class="SQL">--语法格式
COUNT ([ALL | DISTINCT] expression);
/*COUNT(*)函数返回表中的行数，包括包含NULL值的行。*/

/*示例1 ： 与GROUP BY一起使用*/
SELECT
    e.department_id,
    department_name,
    COUNT(*)
FROM
    employees e
INNER JOIN departments d ON d.department_id = e.department_id
GROUP BY
    e.department_id;

/*示例2 ：与HAVING一起使用 */
/*要按COUNT(*)函数的结果过滤分组，需要在COUNT(*)函数使用HAVING子句*/
SELECT
    e.department_id,
    department_name,
    COUNT(*)
FROM
    employees e
INNER JOIN departments d ON d.department_id = e.department_id
GROUP BY
    e.department_id
HAVING
    COUNT(*) &gt; 5
ORDER BY
    COUNT(*) DESC;</code></pre>
<h3 id="6-3-SUM（求和）"><a href="#6-3-SUM（求和）" class="headerlink" title="6.3 SUM（求和）"></a>6.3 SUM（求和）</h3><pre><code class="SQL">--语法格式
SUM([ALL|DISTINCT] expression)
/*只能将SUM函数应用于数字列，SUM函数忽略NULL值。*/

/*示例1 ：与HAVING 以及 GROUP BY一起使用*/
SELECT
    e.department_id,
    department_name,
    SUM(salary)
FROM
    employees e
INNER JOIN departments d ON d.department_id = e.department_id
GROUP BY
    e.department_id
HAVING
    SUM(salary) &gt; 30000
ORDER BY
    SUM(salary) DESC;</code></pre>
<h3 id="6-4-MAX-amp-MIN"><a href="#6-4-MAX-amp-MIN" class="headerlink" title="6.4 MAX &amp; MIN"></a>6.4 MAX &amp; MIN</h3><p>SQL <code>Max</code>函数查找组中的最大值，<code>Min</code>函数查找组中的最小值。。</p>
<pre><code class="SQL">--语法格式
MAX(expression)
MIN(expression)

/*示例1 ： 用于子查询中*/
SELECT
    employee_id,
    first_name,
    last_name,
    salary
FROM
    employees
WHERE
    salary = (
        SELECT
            MAX(salary)
        FROM
            employees
    );

/*示例2 ： 返回每个部门中员工的最高工资，并根据最高工资对结果集进行排序。*/
SELECT
    d.department_id,
    department_name,
    MAX(salary)
FROM
    employees e
INNER JOIN departments d ON d.department_id = e.department_id
GROUP BY
    e.department_id
ORDER BY
    MAX(salary) DESC;

/*示例3 ： 获得具有最高薪水大于12000的员工的部门*/
SELECT
    d.department_id,
    department_name,
    MAX(salary)
FROM
    employees e
INNER JOIN departments d ON d.department_id = e.department_id
GROUP BY
    e.department_id
HAVING
    MAX(salary) &gt; 12000;</code></pre>
<h3 id="6-6-Group-By子句"><a href="#6-6-Group-By子句" class="headerlink" title="6.6 Group By子句"></a>6.6 Group By子句</h3><p><code>GROUP BY</code>子句是<code>SELECT</code>语句的可选子句，它根据指定列中的匹配值将行组合成组，每组返回一行。</p>
<pre><code class="SQL">--语法格式
[GROUP BY {col_name | expr | position}
      [ASC | DESC], ... [WITH ROLLUP]]
/*1. col_name:指定用于分组的选择列，可指定多列，彼此间用逗号分隔。
2.expr:指定用于分组的表达式
3.position:指定用于分组的选择列在SELECT语句结果集中的位置，通常是一个正整数。
4.ASC | DESC:升降序排列，默认ASC升序。
5.WITH ROLLUP:用于指定在结果集中不仅包含由GROUP BY子句分组后的数据行，还包括各分组的汇总行，以及所有分组的整体汇总行。*/

/*示例--结果集包含相同地址的男性客户人数、女性客户人数、总人数以及客户的总人数*/
SELECT cust_address,cust_sex,COUNT(*) AS &quot;人数&quot;
    FROM customers
    GROUP BY cust_address,cust_sex
    WITH ROLLUP;</code></pre>
<h3 id="6-6-HAVING"><a href="#6-6-HAVING" class="headerlink" title="6.6 HAVING"></a>6.6 HAVING</h3><p>SQL <code>HAVING</code>子句，该子句用于为<code>GROUP BY</code>子句汇总的组指定条件，一般搭配<code>GROUP BY</code>子句使用。</p>
<pre><code class="SQL">--语法格式
SELECT
    column1,
    column2,
    AGGREGATE_FUNCTION (column3)
FROM
    table1
GROUP BY
    column1,
    column2
HAVING
    group_condition;
/*注：需要注意的是，在GROUP BY子句之前应用WHERE子句之后应用HAVING子句之前*/

/*示例--统计人数大于1的班级*/
SELECT class_id,count(*) AS &quot;人数&quot;
    FROM students
    GROUP BY class_id
    HAVING count(*)&gt;1;</code></pre>
<h2 id="七、高级查询"><a href="#七、高级查询" class="headerlink" title="七、高级查询"></a>七、高级查询</h2><h3 id="7-1-GROUPING-SETS运算符"><a href="#7-1-GROUPING-SETS运算符" class="headerlink" title="7.1 GROUPING SETS运算符"></a>7.1 GROUPING SETS运算符</h3><p>使用SQL <code>GROUPING SETS</code>运算符生成多个分组集</p>
<p>分组集是一组使用<code>GROUP BY</code>子句进行分组的列。 通常，单个聚合查询定义单个分组集</p>
<pre><code class="SQL">--语法格式
SELECT
    c1,
    c2,
    aggregate (c3)
FROM
    table
GROUP BY
    GROUPING SETS (
        (c1, c2),
        (c1),
        (c2),
        ()
);</code></pre>
<h3 id="7-2-ROLLUP运算符"><a href="#7-2-ROLLUP运算符" class="headerlink" title="7.2 ROLLUP运算符"></a>7.2 ROLLUP运算符</h3><p><code>ROLLUP</code>是<code>GROUP BY</code>子句的扩展。<code>ROLLUP</code>选项允许包含表示小计的额外行，通常称为超级聚合行，以及总计行。</p>
<pre><code class="SQL">--语法格式
SELECT
    c1, c2, aggregate_function(c3)
FROM
    table
GROUP BY ROLLUP (c1, c2);
/*ROLLUP假定输入列之间存在层次结构。 例如，如果输入列是(c1，c2)，则层次结构c1&gt; c2。
ROLLUP生成考虑此层次结构有意义的所有分组集。 这就是为什么我们经常使用ROLLUP来生成小计和总计以用于报告目的*/

/*示例1*/
SELECT
    COALESCE(warehouse, &#39;All warehouses&#39;) AS warehouse,
    SUM(quantity)
FROM
    inventory
GROUP BY ROLLUP (warehouse);

/*示例2*/
SELECT
    warehouse, product, SUM(quantity)
FROM
    inventory
GROUP BY warehouse, ROLLUP (product);</code></pre>
<h3 id="7-3-UNION运算符-并集"><a href="#7-3-UNION运算符-并集" class="headerlink" title="7.3 UNION运算符 (并集)"></a>7.3 UNION运算符 (并集)</h3><p>使用SQL <code>UNION</code>组合来自多个查询的两个或多个结果集，<code>UNION</code>运算符将两个或多个<code>SELECT</code>语句的结果集合并到一个结果集中,相当于并集。</p>
<pre><code class="SQL">--语法格式
SELECT
    column1, column2
FROM
    table1
UNION [ALL]
SELECT
    column3, column4
FROM
    table2;
/*带ALL参数不去重，不带ALL则去重*/</code></pre>
<h3 id="7-4-INTERSECT-交"><a href="#7-4-INTERSECT-交" class="headerlink" title="7.4 INTERSECT(交)"></a>7.4 INTERSECT(交)</h3><p>SQL <code>INTERSECT</code>运算符，来获取两个或多个查询的交集。</p>
<pre><code class="SQL">--语法格式
SELECT
    id
FROM
    a
INTERSECT
SELECT
    id
FROM
    b;</code></pre>
<p>要使用<code>INTERSECT</code>运算符，<code>SELECT</code>语句的列需要遵循以下规则：</p>
<ul>
<li>列的数据类型必须兼容。</li>
<li><code>SELECT</code>语句中的列数及其顺序必须相同</li>
</ul>
<h3 id="7-5-MINUS（差）"><a href="#7-5-MINUS（差）" class="headerlink" title="7.5 MINUS（差）"></a>7.5 MINUS（差）</h3><p>SQL <code>MINUS</code>运算符从另一个结果集中减去一个结果集。</p>
<pre><code class="SQL">--语法格式
SELECT
    id
FROM
    A
MINUS
SELECT
    id
FROM
    B;

/*示例*/
SELECT
    employee_id
FROM
    employees
MINUS
SELECT
    employee_id
FROM
    dependents
ORDER BY employee_id;</code></pre>
<h3 id="7-6-子查询"><a href="#7-6-子查询" class="headerlink" title="7.6 子查询"></a>7.6 子查询</h3><pre><code class="SQL">/*示例1*/
SELECT
    employee_id, first_name, last_name
FROM
    employees
WHERE
    department_id NOT IN (SELECT
            department_id
        FROM
            departments
        WHERE
            location_id = 1700)
ORDER BY first_name , last_name;

/*示例2*/
SELECT
    employee_id, first_name, last_name, salary
FROM
    employees
WHERE
    salary &gt; (SELECT
            AVG(salary)
        FROM
            employees);</code></pre>
<h3 id="7-7-EXISTS运算符"><a href="#7-7-EXISTS运算符" class="headerlink" title="7.7 EXISTS运算符"></a>7.7 EXISTS运算符</h3><p><code>EXISTS</code>运算符用于指定子查询以测试行的存在。如果子查询包含任何行，则返回<code>true</code>。否则，它返回<code>false</code>。</p>
<pre><code class="SQL">--语法格式
EXISTS (subquery)
NOT EXISTS (subquery)

/*示例--查找没有任何家属的员工*/
SELECT
    department_name
FROM
    departments d
WHERE
    NOT EXISTS( SELECT
            1
        FROM
            employees e
        WHERE
            salary &gt; 10000
                AND e.department_id = d.department_id)
ORDER BY department_name;</code></pre>
<h2 id="八、约束"><a href="#八、约束" class="headerlink" title="八、约束"></a>八、约束</h2><p>完整性约束保证授权用户对数据库所做的修改不会破坏数据的一致性。</p>
<h3 id="8-1-SQL主键约束"><a href="#8-1-SQL主键约束" class="headerlink" title="8.1 SQL主键约束"></a>8.1 SQL主键约束</h3><p>每个表都有一个且只有一个主键。 主键不接受<code>NULL</code>或重复值。如果主键由两列或更多列组成，则值可能在一列中重复，但主键中所有列的值组合必须是唯一的。</p>
<pre><code class="SQL">/*示例1 ： 主键由多列组成，用PRIMARY KEY定义主键*/
CREATE TABLE project_assignments (
    project_id INT,
    employee_id INT,
    join_date DATE NOT NULL,
    CONSTRAINT pk_assgn PRIMARY KEY (project_id , employee_id)
);

/*示例2-- 使用ALTER TABLE语句添加主键，将milestone_id列设置为主键。*/
ALTER TABLE project_milestones
ADD PRIMARY KEY (milestone_id);

/*示例3-- 删除project_milestones表的主键约束*/
ALTER TABLE project_milestones
DROP CONSTRAINT pk_milestone_id;</code></pre>
<h3 id="8-2-外键约束"><a href="#8-2-外键约束" class="headerlink" title="8.2 外键约束"></a>8.2 外键约束</h3><p>SQL外键<code>FOREIGN KEY</code>约束以强制表之间的关系。定义外码的主要目的是：让系统做参照完整性约束的检查。</p>
<p><strong>参照关系中外码的值必须在被参照关系中实际存在或为null</strong>。</p>
<pre><code class="SQL">--语法格式
--默认地，外码参照被参照关系中的主码，即下面dept_name是外码，department是主码
foreign key (dept_name) references department

/*示例1--创建表时创建FOREIGN KEY约束*/
CREATE TABLE project_milestones (
    milestone_id INT AUTO_INCREMENT PRIMARY KEY,
    project_id INT,
    milestone_name VARCHAR(100),
    FOREIGN KEY (project_id)
        REFERENCES projects (project_id)
);
--FOREIGN KEY子句将project_milestones表的project_id设置为引用project表的project_id列的外键。

/*可以为FOREIGN KEY约束指定名称*/
CREATE TABLE project_milestones (
    milestone_id INT AUTO_INCREMENT PRIMARY KEY,
    project_id INT,
    milestone_name VARCHAR(100),
    CONSTRAINT fk_project FOREIGN KEY (project_id)
        REFERENCES projects (project_id)
);
--fk_project是FOREIGN KEY约束的名称。

/*使用ALTER来向现有表中添加FOREIGN KEY约束*/
ALTER TABLE table_1
ADD CONSTRAINT fk_name FOREIGN KEY (fk_key_column)
   REFERENCES table_2(pk_key_column)

/*删除外键约束*/
ALTER TABLE table_name
DROP CONSTRAINT fk_name;</code></pre>
<h3 id="8-3-唯一约束"><a href="#8-3-唯一约束" class="headerlink" title="8.3 唯一约束"></a>8.3 唯一约束</h3><p>使用SQL <code>UNIQUE</code>约束强制列或一组列中值的唯一性</p>
<p><code>UNIQUE</code>约束定义了一个规则，该规则可防止存储在不参与主键的特定列中有重复值</p>
<p><code>UNIQUE</code>约束和<code>PRIMARY KEY</code>约束之间的区别：<br>比较项|<code>PRIMARY KEY</code>约束|<code>UNIQUE</code>约束<br>-|-|-<br>约束的数量|一个|多个<br>NULL值|不允许|允许</p>
<pre><code class="SQL">/*示例1--创建了UNIQUE约束作为列约束。*/
CREATE TABLE users (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(255) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL
);

/*示例2--表约束语法创建的UNIQUE约束*/
CREATE TABLE users (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(255) NOT NULL,
    password VARCHAR(255) NOT NULL,
    CONSTRAINT uc_username UNIQUE (username)
);

/*示例3： 将UNIQUE约束添加到现有表*/
ALTER TABLE users
ADD CONSTRAINT uc_username UNIQUE(username);

ALTER TABLE users
ADD new_column data_type UNIQUE;

/*示例4： 删除UNIQUE约束*/
ALTER TABLE table_name
DROP CONSTRAINT unique_constraint_name;</code></pre>
<h3 id="8-4-NOT-NULL"><a href="#8-4-NOT-NULL" class="headerlink" title="8.4 NOT NULL"></a>8.4 NOT NULL</h3><p><code>NOT NULL</code>约束是一个列约束，它定义将列限制为仅具有非<code>NULL</code>值的规则。</p>
<pre><code class="SQL">--语法格式
CREATE TABLE table_name(
   ...
   column_name data_type NOT NULL,
   ...
);

/*示例1*/
CREATE TABLE training (
    employee_id INT,
    course_id INT,
    taken_date DATE NOT NULL,
    PRIMARY KEY (employee_id , course_id)
);

/*示例2--ALTER TABLE NOT NULL语句*/
ALTER TABLE training
MODIFY taken_date date NOT NULL;</code></pre>
<h3 id="8-5-检查约束"><a href="#8-5-检查约束" class="headerlink" title="8.5 检查约束"></a>8.5 检查约束</h3><p><code>CHECK</code>约束是SQL中的完整性约束，它允许指定列或列集中的值必须满足布尔表达式</p>
<pre><code class="SQL">--语法格式
--CHECK约束由关键字CHECK后跟括号中的布尔表达式组成：
CHECK(Boolean_expression)
--如果要为CHECK约束指定名称，请使用以下语法：
CONSTRAINT constraint_name CHECK(Boolean_expression)

/*示例1--其products_price列中的值必须为正数*/
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(255) NOT NULL,
    selling_price NUMERIC(10,2) CHECK (selling_price &gt; 0)
);

/*示例2--分配CHECK约束名称*/
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(255) NOT NULL,
    selling_price NUMERIC(10,2) CONSTRAINT positive_selling_price CHECK (selling_price &gt; 0)
);

/*示例3： 涉及多个列 （表约束）*/
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR (255) NOT NULL,
    selling_price NUMERIC (10, 2) CHECK (selling_price &gt; 0),
    cost NUMERIC (10, 2) CHECK (cost &gt; 0),
    CONSTRAINT valid_selling_price  CHECK (selling_price &gt; cost)
);</code></pre>
<h3 id="8-6-域约束"><a href="#8-6-域约束" class="headerlink" title="8.6 域约束"></a>8.6 域约束</h3><p><code>create domain</code>域约束是完整性约束的最基本形式，可用于检测插入到数据库中的数据的合法性</p>
<pre><code class="SQL">--从现有数据类型可以创建新的域
create domain Dollars as numeric(12，2) not null
create domain Pounds as numeric(12，2);
create table instructor
    (ID char(5) primary key,
    name varchar(20),
    dept name varchar(20),
    salary Dollars,
    comm Pounds
    );</code></pre>
<h3 id="8-7-级联动作"><a href="#8-7-级联动作" class="headerlink" title="8.7 级联动作"></a>8.7 级联动作</h3><pre><code class="SQL">--语法格式
create table course(
    ...
    foreign key(dept_name) references department
        [on delete cascade]
        [on update cascade]
    ...);</code></pre>
<h2 id="九、视图与索引"><a href="#九、视图与索引" class="headerlink" title="九、视图与索引"></a>九、视图与索引</h2><h3 id="9-1-视图"><a href="#9-1-视图" class="headerlink" title="9.1 视图"></a>9.1 视图</h3><p>在某些情况下，让所有用户看到整个逻辑模型是不合适的，视图就提供了这种机制：向用户隐藏特定的数据。</p>
<p>SQL允许通过查询来定义“虚关系”，它在概念上包含查询的结果，但并不预先计算并存储。像这种作为虚关系对用户可见的关系称为视图（view）。</p>
<h4 id="9-1-1-创建视图"><a href="#9-1-1-创建视图" class="headerlink" title="9.1.1 创建视图"></a>9.1.1 创建视图</h4><pre><code class="SQL">--语法格式
CREATE [OR REPLACE] VIEW view_name [(column_list)]
    AS select_statement
    [WITH [CASCADED | LOCAL] CHECK OPTION]
/*1. view_name:指定视图的名称，且必须唯一。不能重名。
2. column_list:可选项，用于为视图中每个列指定明确的名称，必须与select的列数相同，逗号分隔。
3.select_statement:指定创建视图的SELECT语句。
4.WITH CHECK OPTION:可选项，用于指定在可更新视图上所进行的修改都需要符合select_statement中所指定的限制条件，这样可以确保数据修改后，仍可以通过视图看到修改后的数据。
5.CASCADED | LOCAL:决定检查测试的范围。默认CASCADED，它会对所有视图进行检查。而LOCAL只对定义的视图进行检查。*/

/*示例--视图physics_fall_2009_Watson，列出于2009年秋季学期在Watson大楼开设的所有Physics课程的标识和教室号*/
create view physics_fall_2009_watson as
select course_id, room_number
from physics_fall_2009
where building=&#39;Watson&#39;;

/*示例2--创建视图customers_view,要求包含客户信息表中所有男性客户，并要求保证今后对该视图数据的修改都必须符和客户性别为男性这个条件。*/
CREATE OR REPLACE VIEW mysql_test.customers_view
    AS
    SELECT * FROM mysql_test.customers
        WHERE cust_sex=&#39;M&#39;
    WITH CHECK OPTION;</code></pre>
<h4 id="9-1-2-删除视图"><a href="#9-1-2-删除视图" class="headerlink" title="9.1.2 删除视图"></a>9.1.2 删除视图</h4><pre><code class="SQL">--语法格式
DROP VIEW [IF EXISTS]
    view_name [, view_name] ...
    [RESTRICT | CASCADE]</code></pre>
<h4 id="9-1-3-更新视图"><a href="#9-1-3-更新视图" class="headerlink" title="9.1.3 更新视图"></a>9.1.3 更新视图</h4><pre><code class="SQL">--语法格式
ALTER VIEW view_name [(column_list)]
    AS select_statement
    [WITH [CASCADED | LOCAL] CHECK OPTION]
/*语法与创建视图语法相似，也可以通过先删除再创建来实现修改视图*/</code></pre>
<h4 id="9-1-4-查看视图定义"><a href="#9-1-4-查看视图定义" class="headerlink" title="9.1.4 查看视图定义"></a>9.1.4 查看视图定义</h4><pre><code class="SQL">--语法格式
SHOW CREATE VIEW view_name</code></pre>
<h4 id="9-1-5-更新视图数据"><a href="#9-1-5-更新视图数据" class="headerlink" title="9.1.5 更新视图数据"></a>9.1.5 更新视图数据</h4><p>一般地，如果定义视图的查询能满足下列条件，我们称SQL视图是可更新的（updatable），即视图上可以执行插入、更新或删除</p>
<ul>
<li><code>from</code>子句中只有一个数据库关系</li>
<li><code>select</code>子句中只包含关系的属性名，不包含任何表达式、聚集或<code>distinct</code>声明</li>
<li>任何没有出现在<code>select</code>子句中的属性可以取空值；即这些属性上没有<code>not null</code>约束，也不构成主码的一部分</li>
<li>查询中不含有<code>group by</code>或<code>having</code>子句</li>
</ul>
<pre><code class="SQL">/*示例1--通过INSERT语句通过视图向基本表插入数据*/
--假设我们向视图faculty插入一条新元组，可写为：
insert into faculty values(‘30765&#39;，‘Green&#39;，‘Music&#39;);
/*该语句能够成功执行，是因为创建视图时添加了WITH CHECK OPTION*/

/*示例2--使用UPDATE语句通过视图修改基本表的数据*/
UPDATE mysql_test.customers_view
    SET cust_address=&#39;上海市&#39;;

/*示例3--使用DELETE语句通过视图删除基本表的数据*/
DELETE FROM mysql_test.customers_view
    WHERE cust_name=&#39;周明&#39;;</code></pre>
<h3 id="9-2-索引"><a href="#9-2-索引" class="headerlink" title="9.2 索引"></a>9.2 索引</h3><h4 id="9-2-1-索引的创建"><a href="#9-2-1-索引的创建" class="headerlink" title="9.2.1 索引的创建"></a>9.2.1 索引的创建</h4><p>我们用<code>create index</code>命令，为关系中的某些属性创建索引。索引，就是DBMS根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表，因而索引实质上是一张描述索引列的列值与原表中的记录行之间一对应关系的有序表。</p>
<p>更新表的时候索引会被自动更新，因此索引提高查询速度，降低更新速度。</p>
<h5 id="9-2-1-1-使用CREATE-INDEX语句"><a href="#9-2-1-1-使用CREATE-INDEX语句" class="headerlink" title="9.2.1.1 使用CREATE INDEX语句"></a>9.2.1.1 使用CREATE INDEX语句</h5><pre><code class="SQL">--语法格式全面
CREATE [ONLINE|OFFLINE] [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name
    [index_type]
    ON tbl_name (index_col_name,...)
    [index_option] ...

--语法格式常用
CREATE [UNIQUE] INDEX index_name ON table_name (index_col_name,...);
/*其中index_col_name的格式为:
    col_name [(length)] [ASC | DESC]
可选项length指定前length个字符创建索引，可减少索引文件大小。
关键字[ASC | DESC]指定索引升序还是降序排列，默认ASC*/

/*示例--在students表上用学生name前三个字符创建名为index_students的索引*/
CREATE INDEX index_students ON students(name(3) ASC);

--我们用`create unique index`命令，为关系中的某些属性创建唯一索引
CREATE UNIQUE INDEX uni_stu_index ON student(ID,name);</code></pre>
<h5 id="9-2-1-2-使用CREATE-TABLE语句"><a href="#9-2-1-2-使用CREATE-TABLE语句" class="headerlink" title="9.2.1.2 使用CREATE TABLE语句"></a>9.2.1.2 使用CREATE TABLE语句</h5><pre><code class="SQL">--语法格式
--在create table后面添加以下语法成分
{INDEX | KEY} [index_name] (index_col_name,...)
/*关键字KEY是关键字INDEX的同义词*/

/*示例*/
CREATE TABLE seller
    (
    seller_id INT NOT NULL AUTO_INCREMENT,
    seller_name char(50) NOT NULL,
    product_type int(5) NULL,
    sales INT NULL,
    PRIMARY KEY(seller_id,product_type),
    KEY index_seller(sales)
    );</code></pre>
<h5 id="9-2-1-3-使用ALTER-TABLE语句"><a href="#9-2-1-3-使用ALTER-TABLE语句" class="headerlink" title="9.2.1.3 使用ALTER TABLE语句"></a>9.2.1.3 使用ALTER TABLE语句</h5><pre><code class="SQL">--语法格式
--在alter table后面添加以下语法成分
ADD {INDEX | KEY} [index_name] (index_col_name,...)

/*示例*/
ALTER TABLE seller
    ADD INDEX index_seller_name (seller_name);</code></pre>
<h4 id="9-2-2-索引的查看"><a href="#9-2-2-索引的查看" class="headerlink" title="9.2.2 索引的查看"></a>9.2.2 索引的查看</h4><pre><code class="SQL">--语法格式
SHOW {INDEX | INDEXES | KEYS}
    {FROM | IN} tbl_name
    [{FROM | IN} db_name]
    [WHERE expr]

/*示例*/
SHOW KEYS IN seller;</code></pre>
<h4 id="9-2-3-索引的删除"><a href="#9-2-3-索引的删除" class="headerlink" title="9.2.3 索引的删除"></a>9.2.3 索引的删除</h4><h5 id="9-2-3-1-使用DROP-INDEX语句"><a href="#9-2-3-1-使用DROP-INDEX语句" class="headerlink" title="9.2.3.1 使用DROP INDEX语句"></a>9.2.3.1 使用DROP INDEX语句</h5><pre><code class="SQL">--语法格式
DROP [ONLINE|OFFLINE] INDEX index_name ON tbl_name

/*示例*/
DROP INDEX index_seller_name ON seller;</code></pre>
<h5 id="9-2-3-2-使用ALTER-TABLE语句"><a href="#9-2-3-2-使用ALTER-TABLE语句" class="headerlink" title="9.2.3.2 使用ALTER TABLE语句"></a>9.2.3.2 使用ALTER TABLE语句</h5><p>在ALTER TABLE语句下面添加以下一项。</p>
<pre><code class="SQL">--语法格式
DROP PRIMARY KEY;
DROP INDEX index_name;
/*删除主键也就是删除索引，主键也是一个索引*/

/*示例*/
ALTER TABLE seller
    DROP PRIMARY KEY,
    DROP INDEX index_seller;</code></pre>
<h2 id="十、事务"><a href="#十、事务" class="headerlink" title="十、事务"></a>十、事务</h2><p>事务（transaction）由查询和更新语句的序列组成。SQL标准规定当一条SQL语句被执行，就隐式地开始了一个事务。</p>
<p>下列SQL语句之一会结束一个事务：</p>
<ul>
<li><code>Commit work</code>：提交当前事务，也就是将该事务所做的更新在数据库中持久保存。在事务被提交后，一个新的事务自动开始</li>
<li><code>Rollback work</code>：回滚当前事务，即撤销该事务中所有SQL语句对数据库的更新。这样，数据库就恢复到执行该事务第一条语句之前的状态</li>
</ul>
<h2 id="十一、断言及触发器"><a href="#十一、断言及触发器" class="headerlink" title="十一、断言及触发器"></a>十一、断言及触发器</h2><h3 id="11-1-断言"><a href="#11-1-断言" class="headerlink" title="11.1 断言"></a>11.1 断言</h3><p>断言（assertion）是表达要求数据库永远满足的条件的谓词（复杂check条件）</p>
<p>SQL中的断言形式如下：</p>
<pre><code class="SQL">create assertion &lt;assertion_name&gt; check &lt;predicate&gt;</code></pre>
<p>创建了某断言之后，系统将检查它的合法性，并对每一个可能破坏该断言的数据库更新进行检测<br><strong>这种检测会产生大量的开销，因此断言的使用应非常谨慎</strong></p>
<pre><code class="SQL">--例2，每位教师不能在同一个学期的同一个时间段在两个不同的教室授
create assertion ins_teaches_constraint check not exists
(select ID，name,section_id,semester,year,time_slot_id,
    count(distinct building,room,number)
from instructor natural join teaches natural join section
group by (ID,name,section_id,semester,year,time_slot_id)
having count(building,room_number)&gt;1)</code></pre>
<h3 id="11-2-触发器"><a href="#11-2-触发器" class="headerlink" title="11.2 触发器"></a>11.2 触发器</h3><p>触发器（trigger）是由数据库更新操作引起的被系统自动执行的语句</p>
<p>设计触发器必须：</p>
<ul>
<li>指明触发器被执行的条件</li>
<li>指明触发器执行时所做的具体操作</li>
</ul>
<pre><code class="SQL">--例，使用触发器来确保关系section中属性time_slot_id的参照完整性
create trigger timeslot_check1 after insert on section
         referencing new row as nrow
         for each row
         when (nrow.time_slot_id not in
                (select time_slot_id from
                 time_slot))/*time_slot中不存在该time_slot_id*/
begin rollback end;

--例，某种物品库存量小到一定程度就发订货单或打开报警灯
create trigger reorder_trigger after update of level on inventory
    referencing old row as orow, new row as nrow
    for each row
    when nrow.level&lt;=/*保证修改后库存量低于最小库存量,更新前库存大于最小库存*/
            (select level/*目的是只更新一次*/
            from minlevel
            where minlevel.item=nrow.item) and orow.level&gt;
                    (select level
                    from minlevel
                    where minlevel.item= orow.item)
begin
    insert into orders
            (select item, amount
             from reorder
             where reorder.item= orow.item)
end</code></pre>
<h2 id="十二、-安全性"><a href="#十二、-安全性" class="headerlink" title="十二、 安全性"></a>十二、 安全性</h2><h3 id="12-1-权限管理"><a href="#12-1-权限管理" class="headerlink" title="12.1 权限管理"></a>12.1 权限管理</h3><p>数据库系统级</p>
<ul>
<li><strong>验证</strong>和<strong>授权</strong>机制使得特定用户存取特定数据</li>
<li>本章中主要讨论授权机制</li>
</ul>
<p>对数据的授权包括：</p>
<ul>
<li>读权限 允许读，但不允许更新数据</li>
<li>插入权限 允许插入新数据，但不允许更新现有数据</li>
<li>修改权限 允许修改，但不允许删除数据</li>
<li>删除权限 允许删除数据</li>
</ul>
<p>对修改数据库模式的授权包括：</p>
<ul>
<li>索引权限-允许创建和删除索引</li>
<li>资源权限-允许创建新关系</li>
<li>修改权限-允许增加或删除关系的属性</li>
<li>删除权限-允许删除关系</li>
</ul>
<pre><code class="SQL">--语法格式
--grant语句用于授权
GRANT &lt;privilege list&gt;
ON &lt;relation name or view name&gt; TO &lt;user list&gt;;</code></pre>
<p><code>privilege list</code>可有以下选择:</p>
<ol>
<li>select：允许读关系，或查询视图<pre><code> 例如：授予用户U1，U2，Ua对instructor关系的select权限：
 `grant select on instructor to U1,U2,U3`</code></pre></li>
<li><code>insert</code>：允许插入元组</li>
<li><code>update</code>：允许修改元组</li>
<li><code>delete</code>：允许删除元组</li>
<li><code>references</code>：创建关系时允许声明外键</li>
<li><code>all privileges</code>：所有权限</li>
<li><code>with grant option</code>：允许用户把被授予的权限再转授给其他用户<pre><code> 例如：授予U1，对instructor的select权限并允许U1，将此权限授予其他用户
 `grant select on instructor to U1 with grant option`</code></pre></li>
</ol>
<pre><code class="SQL">--收回权限
--revoke语句用于回收权限
REVOKE &lt;privilege list&gt; ON &lt;relation name or view name&gt;
FROM &lt;user list&gt; [ restrict | cascade ]

/*示例*/
revoke select on instructor from U1,,U2,U3 cascade
/*从一用户收回权限可能导致其他用户也失去该权限，称为级联回收*/

--指定restrict可以阻止级联回收
revoke select on instructor from U1,U2,U3 restrict
/*如果要求级联回收，则带有restrict的revoke命令将会失败*/</code></pre>
<h3 id="12-2-审计跟踪"><a href="#12-2-审计跟踪" class="headerlink" title="12.2 审计跟踪"></a>12.2 审计跟踪</h3><p>分为语句审计和对象审计</p>
<pre><code class="SQL">--语法格式-语句审计
AUDIT &lt;st-opt&gt; [BY &lt;users&gt;]
[BY SESSION | ACCESS]
[WHENEVER SUCCESSFUL | WHENEVER NOT SUCCESSFUL]
--当BY &lt;users&gt;缺省，对所有用户审计
--BY SESSION每次会话期间，相同类型的需审计的SQL语句仅记录一次
--常用的&lt;st-opt&gt;:table，view，role，index，……
--取消审计：NOAUDIT…（其余同audit语句）

/*示例--审计用户scott每次成功执行有关table的语句。*/
audit table by scott by access whenever successful;</code></pre>
<pre><code class="SQL">--语法格式-对象审计
AUDIT &lt;obj-opt&gt; ON &lt;obj&gt;|DEFAULT
[BY SESSION | BY ACCESS]
[WHENEVER SUCCESSFUL | WHENEVER NOT SUCCESSFUL]
--obj-opt:insert，delete，update，select，grant，…
--实体审计对所有的用户起作用
--ON&lt;obj&gt;指出审计对象表、视图名
--ONDEFAULT 对其后创建的所有对象起作用
--取消审计：NOAUDIT…

/*示例--审计所有用户对student表的delete和update操作*/
audit delete,update on student;</code></pre>
<h2 id="十三、-数据库编程"><a href="#十三、-数据库编程" class="headerlink" title="十三、 数据库编程"></a>十三、 数据库编程</h2><h3 id="13-1-存储过程"><a href="#13-1-存储过程" class="headerlink" title="13.1 存储过程"></a>13.1 存储过程</h3><h4 id="13-1-1-存储过程的基本概念"><a href="#13-1-1-存储过程的基本概念" class="headerlink" title="13.1.1 存储过程的基本概念"></a>13.1.1 存储过程的基本概念</h4><p>存储过程是一组SQL语句编译成一个SQL。类似于批量处理的SQL脚本。</p>
<p>存储过程的好处：</p>
<ul>
<li>可增强SQL语言的功能和灵活性</li>
<li>良好的封装性</li>
<li>高性能</li>
<li>可减少网络流量</li>
<li>存储过程可作为一种安全机制来确保数据库的安全性和数据的完整性</li>
</ul>
<h4 id="13-1-2-创建存储过程"><a href="#13-1-2-创建存储过程" class="headerlink" title="13.1.2 创建存储过程"></a>13.1.2 创建存储过程</h4><p><code>delimiter</code>是<code>MySQL</code>中的命令，这个命令与存储过程没什么关系。</p>
<p>其实就是告诉<code>mysql</code>解释器，该段命令是否已经结束了，mysql是否可以执行了。即改变输入结束符。</p>
<p>默认情况下，<code>delimiter</code>是分号“;”。</p>
<p>但有时候，不希望<code>MySQL</code>这么做。因为可能输入较多的语句，且语句中包含有分号。</p>
<p>默认情况下，<code>mysql</code>一遇到分号，它就要自动执行。</p>
<p>这种情况下，就可以使用<code>delimiter</code>，把<code>delimiter</code>后面换成其它符号，如<code>//</code>或<code>$$</code>。</p>
<p>此时，<code>delimiter</code>作用就是对整个小段语句做一个简单的封装。</p>
<pre><code class="SQL">delimiter //
delimiter ;</code></pre>
<p>每次使用完要记得换回原来的分号<code>;</code></p>
<p>使用<code>CREATE PROCEDURE</code>来创建存储过程：</p>
<pre><code class="SQL">--语法格式
CREATE PROCEDURE sp_name ([proc_parameter[,...]])
    routine_body
/*其中“proc_parameter”语法格式是[IN | OUT |INOUT]param_name type,
1.在此语法格式中，“sp_name”用于指定存储过程的名称，且默认在当前数据库中创建。
2.“proc_parameter”用于指定存储过程中的参数列表，“type”为SQL的数据类型。
3.IN | OUT |INOUT：表示输入、输出和输入/输出参数。输入参数传递参数给存储过程；输出参数用于存储过程返回一个操作结果；而输出/输出参数则两者皆可。
4.参数的取名不能和表中列名相同，会引发不可预知结果。
5.routine_body：表示存储过程的主体部分。以BEGIN开始，END结束。*/

/*示例*/
use test;
delimiter $$
CREATE PROCEDURE sp_update_sex (IN cid INT,IN csex CHAR(1))
BEGIN
    UPDATE customers SET cust_sex=csex WHERE cust_id=cid;
END$$
delimiter ;</code></pre>
<h4 id="13-1-3-存储过程体"><a href="#13-1-3-存储过程体" class="headerlink" title="13.1.3 存储过程体"></a>13.1.3 存储过程体</h4><h5 id="13-1-3-1-局部变量"><a href="#13-1-3-1-局部变量" class="headerlink" title="13.1.3.1 局部变量"></a>13.1.3.1 局部变量</h5><p>使用<code>DECLARE</code>语句来声明局部变量。</p>
<pre><code class="SQL">--语法格式
DECLARE var_name [, var_name] ... type [DEFAULT value]
/*var_name:用于指定局部变量的名称。
type:用于声明局部变量的数据类型。
DEFAULT:用于为局部变量指定一个默认值，若没有指定，默认为NULL。*/

/*示例*/
DECLARE cid INT(10);
--局部变量智能在存储过程体的BEGIN...END语句块中声明使用。</code></pre>
<h5 id="13-1-3-2-SET语句"><a href="#13-1-3-2-SET语句" class="headerlink" title="13.1.3.2 SET语句"></a>13.1.3.2 SET语句</h5><p><code>SET</code>为局部变量赋值。</p>
<pre><code class="SQL">--语法格式
SET var_name=expr [, var_name=expr] ...

/*示例*/
SET cid=910;</code></pre>
<h5 id="13-1-3-3-SELECT…INTO语句"><a href="#13-1-3-3-SELECT…INTO语句" class="headerlink" title="13.1.3.3 SELECT…INTO语句"></a>13.1.3.3 SELECT…INTO语句</h5><p><code>SELECT...INTO</code>语句把选定列的值直接存储到局部变量中。</p>
<pre><code class="SQL">--语法格式
SELECT col_name [,...] INTO var_name [,...] table_expr
/*col_name用于指定列名。
var_name用于指定要赋值的变量名。
table_expr表示SELECT语句中FROM子句及其后面的语法部分。
SELECT...INTO语句返回的结果集只能有一行数据。*/</code></pre>
<h5 id="13-1-3-4-游标"><a href="#13-1-3-4-游标" class="headerlink" title="13.1.3.4 游标"></a>13.1.3.4 游标</h5><p>游标是一个被<code>SELECT</code>语句检索出来的结果集。在存储了游标后，应用程序或用户就可以根据需要滚动或浏览其中的数据。使用游标的步骤如下：</p>
<p>1） 声明游标</p>
<pre><code class="SQL">--语法格式
DECLARE cursor_name CURSOR FOR select_statement
/*1. cursor_name：用于指定要创建的游标的名称
2. select_statement:用于指定一个SELECT语句，返回一到多行数据。*/</code></pre>
<p>2） 打开游标</p>
<p>必须打开游标才能使用。</p>
<pre><code class="SQL">OPEN cursor_name;
/*游标可被打开多次，若其他用户或程序更新数据表，每次打开游标结果集可能不同*/</code></pre>
<p>3） 读取数据</p>
<pre><code class="SQL">FETCH cursor_name INTO var_name [,var_name] ...
/*cursor_name:用于指定已经打开的游标
var_name:指定存放数据的变量名*/</code></pre>
<p>4） 关闭游标</p>
<pre><code class="SQL">CLOSE cursor_name;</code></pre>
<p>5） 示例</p>
<p>创建一个存储过程，用于计算表customers中数据行的行数。</p>
<pre><code class="SQL">delimiter $$
create procedure sp_sumofrow(out rows int)
begin
    declare cid int;
    declare found boolean default true;
    declare cur_cid cursor for
        select cust_id from customers;
    declare continue handler for not found
        set found=false;
    set rows=0;
    open cur_cid;
    fetch cur_cid into cid;
    while found do
        set rows=rows+1;
        fetch cur_cid into cid;
    end while;
    close cur_cid;
end$$
delimiter ;
/*定义一个CONTINUE HANDLER句柄，它是在条件出现时被执行的代码，用于控制循环语句，实现游标的下移。
定义局部变量必须在定义任意游标和句柄之前。*/

/*游标只能用于存储过程或存储函数中，不能单独在查询操作中使用。*/</code></pre>
<h4 id="13-1-4-调用存储过程"><a href="#13-1-4-调用存储过程" class="headerlink" title="13.1.4 调用存储过程"></a>13.1.4 调用存储过程</h4><pre><code class="SQL">--语法格式
CALL sp_name([parameter[,...]]);
CALL sp_name[()];
/*sp_name:指定被调用的存储过程的名称。
parameter：指定调用存储过程所使用的参数*/

/*示例*/
CALL sp_update_sex(909,&#39;M&#39;);</code></pre>
<h4 id="13-1-5-删除存储过程"><a href="#13-1-5-删除存储过程" class="headerlink" title="13.1.5 删除存储过程"></a>13.1.5 删除存储过程</h4><pre><code class="SQL">--语法格式
DROP PROCEDURE [IF EXISTS] sp_name;

/*示例*/
DROP PROCEDURE IF EXISTS sp_update_sex;</code></pre>
<h3 id="13-2-存储函数"><a href="#13-2-存储函数" class="headerlink" title="13.2 存储函数"></a>13.2 存储函数</h3><p>存储过程和存储函数的区别：</p>
<ul>
<li>存储函数不能拥有输出参数，自身即是输出参数；存储过程可以拥有输出参数</li>
<li>存储函数可以被直接调用，而存储过程必须通过CALL语句调用</li>
<li>存储函数中必须包含一条RETURN语句，而这条特殊的SQL语句不允许包含于存储过程中</li>
</ul>
<pre><code class="SQL">--1.创建函数
--语法格式
CREATE FUNCTION sp_name ([func_parameter[,...]])
    RETURNS type
    routine_body

/*示例--根据给定学生id号返回学生性别，如果没有给定id，则返回&quot;没有该学生&quot;*/
USE test;
DELIMITER $$
CREATE FUNCTION fn_search(cid INT)
    RETURNS CHAR(2)
BEGIN
    DECLARE SEX CHAR(2);
    SELECT gender INTO SEX FROM students
        WHERE id=cid;
    IF SEX IS NULL THEN
        RETURN(SELECT &quot;没有该学生&quot;);
    ELSE
        IF SEX=&#39;F&#39; THEN
            RETURN(SELECT &#39;女&#39;);
        ELSE
            RETURN(SELECT &#39;男&#39;);
        END IF;
    END IF;
END$$
DELIMITER ;


--2.调用函数
--语法格式
SELECT sp_name([func_parameter[,...]])

/*示例*/
SELECT fn_search(10);


--3.删除函数
--语法格式
DROP FUNCTION [IF EXISTS] sp_name

/*示例*/
DROP FUNCTION IF EXISTS fn_search;</code></pre>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0">读书笔记</a>
                  &nbsp;
                
                  <a class="hover-with-bg" href="/categories/SQL">SQL</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0">读书笔记</a>
                
                  <a class="hover-with-bg" href="/tags/SQL">SQL</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->

  <div class="col-lg-7 mx-auto nopadding-md">
    <div class="container custom post-content mx-auto">
      <img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/pay/pay.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-3" style="width:355.4px; height:200px;">
    </div>
  </div>


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
      <br><br>
      
      
  <div id="vcomments" style="width: 90%; margin: 0 auto;"></div>
  <script defer src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script defer src="//unpkg.com/valine/dist/Valine.min.js"></script>

  <script>
    var notify = 'false' === true;
    var verify = 'false' === true;
    var oldLoad = window.onload;
    window.onload = function () {
      new Valine({
        el: '#vcomments',
        notify: notify,
        verify: verify,
        app_id: "YzLqNtMw1YEwwACli1FUsIUM-gzGzoHsz",
        app_key: "HLUt5izfTvTcbEbOrA59W92a",
        placeholder: "畅所欲言...",
        avatar: "robohash",
        meta: ['nick', 'mail', 'link'],
        pageSize: "10",
      });
      oldLoad && oldLoad();
    };
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv"></span>总访问量 
          <span id="busuanzi_value_site_pv"></span> 次&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv"></span>总访客数 
            <span id="busuanzi_value_site_uv"></span> 人&nbsp;
  
  <br>



    


    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smoothscroll/SmoothScroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  
    <!-- Baidu Analytics -->
    <script>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?608f2baddd361128381ad2bf9377bf89";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  
    <!-- Tencent Analytics -->
    <script>
      var _mtac = {};
      (function () {
        var mta = document.createElement("script");
        mta.src = "//pingjs.qq.com/h5/stats.js?v2.0.4";
        mta.setAttribute("name", "MTAH5");
        mta.setAttribute("sid", "500710993");
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(mta, s);
      })();
    </script>
  

  

  <!-- cnzz Analytics -->
  



  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "SQL语言学习笔记&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 60,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "always",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>



  

  
    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
              processEscapes: true,
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          }
      });

      MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for(i=0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
      });

    </script>

    <script src="https://cdn.staticfile.org/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML" ></script>

  



  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  








</body>
</html>
