<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>大话数据结构第六章 树</title>
    <url>/2019/12/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC6%E7%AB%A0%20%E6%A0%91/</url>
    <content><![CDATA[<h2 id="6-1-6-2-树的定义"><a href="#6-1-6-2-树的定义" class="headerlink" title="6.1-6.2 树的定义"></a>6.1-6.2 树的定义</h2><p><strong>树(Tree)是n(n≥0)个结点的有限集。n=0时称为空树。在任意一棵非空树中：1)有且仅有一个特定的称为根(Root)的结点；2)当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。</strong><br>对于树的定义还需要强调两点：  </p>
<ol>
<li>n&gt;0时根结点是唯一的，不可能存在多个根结点，数据结构中的树是只能有一个根结点。</li>
<li>m&gt;0时，子树的个数没有限制，但它们一定是互不相交的。  <a id="more"></a>
<h3 id="6-2-1-结点分类"><a href="#6-2-1-结点分类" class="headerlink" title="6.2.1 结点分类"></a>6.2.1 结点分类</h3></li>
</ol>
<p>树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。如图6-2-4所示，因为这棵树结点的度的最大值是结点D的度为3，所以树的度也为3。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-2-4.JPG?raw=true" alt="6-2-4">  </p>
<h3 id="6-2-2-结点间关系"><a href="#6-2-2-结点间关系" class="headerlink" title="6.2.2 结点间关系"></a>6.2.2 结点间关系</h3><p>结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）。同一个双亲的孩子之间互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。  </p>
<h3 id="6-2-3-树的其他相关概念"><a href="#6-2-3-树的其他相关概念" class="headerlink" title="6.2.3 树的其他相关概念"></a>6.2.3 树的其他相关概念</h3><p>结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。其双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度。<br>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。<br>森林（Forest）是m（m&gt;0）棵互不相交的树的集合。<br>对比线性表与树的结构，它们有很大的不同，如图6-2-7所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-2-7.JPG?raw=true" alt="6-2-7"></p>
<h2 id="6-3-树的抽象数据类型"><a href="#6-3-树的抽象数据类型" class="headerlink" title="6.3 树的抽象数据类型"></a>6.3 树的抽象数据类型</h2><pre><code class="c">ADT 树（tree）
Data
  树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。
Operation
  InitTree（*T）：构造空树T。
  DestroyTree（*T）：销毁树T。
  CreateTree（*T，definition）：按definition中给出树的定义来构造树。
  ClearTree（*T）：若树T存在，则将树T清为空树。
  TreeEmpty（T）：若T为空树，返回true，否则返回false。
  TreeDepth（T）：返回T的深度。
  Root（T）：返回T的根结点。
  Value（T，cur_e）：cur_e是树T中一个结点，返回此结点的值。
  Assign（T，cur_e，value）：给树T的结点cur_e赋值为value。
  Parent（T，cur_e）：若cur_e是树T的非根结点，则返回它的双亲，否则返回空。
  LeftChild（T，cure）：若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空。
  RightSibling（T，cur_e）：若cur_e有右兄弟，则返回它的右兄弟，否则返回空。
  InsertChild（*T，*p，i，c）：其中p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树。
  DeleteChild（*T，*p，i）：其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树。
endADT</code></pre>
<h2 id="6-4-树的存储结构"><a href="#6-4-树的存储结构" class="headerlink" title="6.4 树的存储结构"></a>6.4 树的存储结构</h2><p>充分利用顺序存储和链式存储结构的特点，可以实现对树的存储结构的表示。我们这里要介绍三种不同的表示法：双亲表示法、孩子表示法、孩子兄弟表示法。  </p>
<h3 id="6-4-1-双亲表示法"><a href="#6-4-1-双亲表示法" class="headerlink" title="6.4.1 双亲表示法"></a>6.4.1 双亲表示法</h3><p>树除了根结点外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲。<br>我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。<br>data数据域，存储结点的数据信息。而parent指针域，存储该结点的双亲在数组中的下标。<br>以下是我们的双亲表示法的结点结构定义代码:  </p>
<pre><code class="c">/* 树的双亲表示法结点结构定义 */
#define MAX_TREE_SIZE 100 /* 二叉树的最大结点数 */
typedef int TElemType;  /* 树结点的数据类型，目前暂定为整型 */
typedef struct PTNode/*结点结构*/
{
  TElemType data;/*结点数据*/
  int parent;/*双亲位置*/
}PTNode;
typedef struct /* 树结构 */
{
  PTNode nodes[MAX_TREE_SI2E];/* 结点数组 */
  int r，n;/* 根的位置和结点数 */
}PTree;</code></pre>
<p>有了这样的结构定义，我们就可以来实现双亲表示法了。由于根结点是没有双亲的，所以我们约定根结点的位置域设置为-1，这也就意味着，我们所有的结点都存有它双亲的位置。如图6-4-1中的树结构和表6-4-2中的树双亲表示所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-1.JPG?raw=true" alt="6-4-1">  </p>
<p>这样的存储结构，我们可以根据结点的parent指针很容易找到它的双亲结点，所用的时间复杂度为O(1)，直到parent为-1时，表示找到了树结点的根。可如果我们要知道结点的孩子是什么，请遍历整个结构才行。如何改进呢？<br>我们增加一个结点最左边孩子的域，不妨叫它长子域，这样就可以很容易得到结点的孩子。如果没有孩子的结点，这个长子域就设置为-1，如表6-4-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-3.JPG?raw=true" alt="6-4-3">  </p>
<p>对于有0个或1个孩子结点来说，这样的结构是解决了要找结点孩子的问题了。甚至是有2个孩子，知道了长子是谁，另一个当然就是次子了。<br>另外一个问题是，我们很关注各兄弟之间的关系，双亲表示法无法体现这样的关系，那我们怎么办？嗯，可以增加一个右兄弟域来体现兄弟关系，也就是说，每一个结点如果它存在右兄弟，则记录下右兄弟的下标。同样的，如果右兄弟不存在，则赋值为-1。<br>但如果结点的孩子很多，超过了2个。我们又关注结点的双亲、又关注结点的孩子、还关注结点的兄弟，而且对时间遍历要求还比较高，那么我们还可以把此结构扩展为有双亲域、长子域、再有右兄弟域。存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。注意也不是越多越好，有需要时再设计相应的结构。  </p>
<h3 id="6-4-2-孩子表示法"><a href="#6-4-2-孩子表示法" class="headerlink" title="6.4.2 孩子表示法"></a>6.4.2 孩子表示法</h3><p>换一种完全不同的考虑方法。由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。不过，树的每个结点的度，也就是它的孩子个数是不同的。所以可以设计两种方案来解决。  </p>
<h4 id="6-4-2-1-方案一"><a href="#6-4-2-1-方案一" class="headerlink" title="6.4.2.1 方案一"></a>6.4.2.1 方案一</h4><p>一种是指针域的个数就等于树的度，复习一下，树的度是树各个结点度的最大值。其结构如表6-4-5所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-5.JPG?raw=true" alt="6-4-5"><br>其中data是数据域。child1到child d是指针域，用来指向该结点的孩子结点。<br>对于图6-4-1的树来说，树的度是3，所以我们的指针域的个数是3，这种方法实现如图6-4-2所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-2.JPG?raw=true" alt="6-4-2"><br>这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。不过如果树的各结点度相差很小时，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。<br>既然很多指针域都可能为空，那么我们可以按需分配空间。  </p>
<h4 id="6-4-2-2-方案二"><a href="#6-4-2-2-方案二" class="headerlink" title="6.4.2.2 方案二"></a>6.4.2.2 方案二</h4><p>第二种方案每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数，其结构如表6-4-6所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-6.JPG?raw=true" alt="6-4-6"><br>其中data为数据域，degree为度域，也就是存储该结点的孩子结点的个数，child1到child d为指针域，指向该结点的各个孩子的结点。<br>对于图6-4-2的树来说，这种方法实现如图6-4-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-7.JPG?raw=true" alt="6-4-7"><br>这种方法克服了浪费空间的缺点，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。  </p>
<p>孩子表示法。具体办法是，<strong>把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</strong>，如图6-4-4所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-8.JPG?raw=true" alt="6-4-8"><br>以下是我们的孩子表示法的结构定义代码:  </p>
<pre><code class="c">/*树的孩子表示法结构定义*/
#define MAX_TREE_SIZE 100
typedef struct cTNode/* 孩子结点 */
{
  int child;
  struct CTNode *next;
}*ChildPtr;
typedef struct  /* 表头结构 */
{
  TElemType data;
  ChildPtr firstChild;
}CTBox;
typedef struct  /* 树结构 */
{
  CTBox nodes[MAX_TREE_SIZE];  /* 结点数组 */
  int r，n;  /* 根的位置和结点数 */
}CTree;</code></pre>
<p>这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。<br>但是，这也存在着问题，我如何知道某个结点的双亲是谁呢？比较麻烦，需要整棵树遍历才行，难道就不可以把双亲表示法和孩子表示法综合一下吗？当然是可以。如图6-4-5所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-9.JPG?raw=true" alt="6-4-9"><br>我们把这种方法称为双亲孩子表示法。</p>
<h3 id="6-4-3-孩子兄弟表示法"><a href="#6-4-3-孩子兄弟表示法" class="headerlink" title="6.4.3 孩子兄弟表示法"></a>6.4.3 孩子兄弟表示法</h3><p><strong>我们观察后发现，任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。</strong><br>结点结构如下所示。<br>data | firstChild | rightSib<br>—–|————|———<br>其中data是数据域，firstChild为指针域，存储该结点的第一个孩子结点的存储地址，rightSib是指针域，存储该结点的右兄弟结点的存储地址。<br>结构定义代码如下:  </p>
<pre><code class="c">/*树的孩子兄弟表示法结构定义*/
typedef struct CSNode
{
  TElemType data;
  struct CSNode *firstChild， *rightSib;
}CSNode,*CSTree;</code></pre>
<p>对于图6-4-1的树来说，这种方法实现的示意图如图6-4-6所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-10.JPG?raw=true" alt="6-4-10"><br>这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过firstChild找到此结点的长子，然后再通过长子结点的rightSib找到它的二弟，接着一直下去，直到找到具体的孩子。</p>
<h2 id="6-5-二叉树的定义"><a href="#6-5-二叉树的定义" class="headerlink" title="6.5 二叉树的定义"></a>6.5 二叉树的定义</h2><p><strong>二叉树（Binary Tree）是n（n≥0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</strong></p>
<h3 id="6-5-1-二叉树特点"><a href="#6-5-1-二叉树特点" class="headerlink" title="6.5.1 二叉树特点"></a>6.5.1 二叉树特点</h3><p>二叉树的特点有：</p>
<ul>
<li>每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。</li>
<li>左子树和右子树是有顺序的，次序不能任意颠倒。</li>
<li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。  </li>
</ul>
<p>二叉树具有五种基本形态：</p>
<ol>
<li>空二叉树。</li>
<li>只有一个根结点。</li>
<li>根结点只有左子树。</li>
<li>根结点只有右子树。</li>
<li>根结点既有左子树又有右子树。</li>
</ol>
<h3 id="6-5-2-特殊二叉树"><a href="#6-5-2-特殊二叉树" class="headerlink" title="6.5.2 特殊二叉树"></a>6.5.2 特殊二叉树</h3><p>一、斜树:所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p>
<p>二、满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。<br>满二叉树的特点有：</p>
<ul>
<li>叶子只能出现在最下一层。出现在其他层就不可能达成平衡。</li>
<li>非叶子结点的度一定是2。否则就是“缺胳膊少腿”了。</li>
<li>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li>
</ul>
<p>三、完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。<br>完全二叉树的特点：</p>
<ol>
<li>叶子结点只能出现在最下两层。</li>
<li>最下层的叶子一定集中在左部连续位置。</li>
<li>倒数二层，若有叶子结点，一定都在右部连续位置。</li>
<li>如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。</li>
<li>同样结点数的二叉树，完全二叉树的深度最小。</li>
</ol>
<h2 id="6-6-二叉树的性质"><a href="#6-6-二叉树的性质" class="headerlink" title="6.6 二叉树的性质"></a>6.6 二叉树的性质</h2><p>二叉树有一些需要理解并记住的特性，以便于我们更好地使用它。</p>
<h3 id="6-6-1-二叉树性质1"><a href="#6-6-1-二叉树性质1" class="headerlink" title="6.6.1 二叉树性质1"></a>6.6.1 二叉树性质1</h3><p>性质1：在二叉树的第i层上至多有2<sup>i-1</sup>个结点（i≥1）。</p>
<h3 id="6-6-2-二叉树性质2"><a href="#6-6-2-二叉树性质2" class="headerlink" title="6.6.2 二叉树性质2"></a>6.6.2 二叉树性质2</h3><p>性质2：深度为k的二叉树至多有$2^k-1$个结点（k≥1）。</p>
<h3 id="6-6-3-二叉树性质3"><a href="#6-6-3-二叉树性质3" class="headerlink" title="6.6.3 二叉树性质3"></a>6.6.3 二叉树性质3</h3><p>性质3：对任何一棵二叉树T，如果其叶子结点数为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1。  </p>
<h3 id="6-6-4-二叉树性质4"><a href="#6-6-4-二叉树性质4" class="headerlink" title="6.6.4 二叉树性质4"></a>6.6.4 二叉树性质4</h3><p>性质4：具有n个结点的完全二叉树的深度为[log<sub>2</sub>n]+1（[x]表示不大于x的最大整数）。</p>
<h3 id="6-6-5-二叉树性质5"><a href="#6-6-5-二叉树性质5" class="headerlink" title="6.6.5 二叉树性质5"></a>6.6.5 二叉树性质5</h3><p>性质5：如果对一棵有n个结点的完全二叉树（其深度为[log<sub>2</sub>n]+1）的结点按层序编号（从第1层到第[log<sub>2</sub>n]+1层，每层从左到右），对任一结点i（1≤i≤n）有：</p>
<ol>
<li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点[i/2]。</li>
<li>如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。</li>
<li>如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1。</li>
</ol>
<h2 id="6-7-二叉树的存储结构"><a href="#6-7-二叉树的存储结构" class="headerlink" title="6.7 二叉树的存储结构"></a>6.7 二叉树的存储结构</h2><h3 id="6-7-1-二叉树顺序存储结构"><a href="#6-7-1-二叉树顺序存储结构" class="headerlink" title="6.7.1 二叉树顺序存储结构"></a>6.7.1 二叉树顺序存储结构</h3><p>二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系。<br>所以用来表示完全二叉树比较好。由于它定义的严格，所以用顺序结构也可以表现出二叉树的结构来。<br>当然对于一般的二叉树，尽管层序编号不能反映逻辑关系，但是可以将其按完全二叉树编号，只不过，把不存在的结点设置为“^”而已。如图6-7-3所示，浅色结点表示不存在。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-7-3.JPG?raw=true" alt="6-7-3"><br>但是对于一般二叉树，一棵深度为k的右斜树，它只有k个结点，却需要分配$2^k$-1个存储单元空间，这显然是对存储空间的浪费。<br>所以，顺序存储结构一般只用于完全二叉树。  </p>
<h3 id="6-7-2-二叉链表"><a href="#6-7-2-二叉链表" class="headerlink" title="6.7.2 二叉链表"></a>6.7.2 二叉链表</h3><p>链式存储结构中。二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。结点结构图如表格6-7-1所示。<br>lChild|data|rChild|<br>–|–|–<br>其中data是数据域，lChild和rChild都是指针域，分别存放指向左孩子和右孩子的指针。<br>以下是我们的二叉链表的结点结构定义代码。</p>
<pre><code class="c">typedef struct BiTNode  /* 结点结构 */
{
   TElemType data;    /* 结点数据 */
   struct BiTNode *lchild,*rchild; /* 左右孩子指针 */
}BiTNode,*BiTree;</code></pre>
<p>就如同树的存储结构中讨论的一样，如果有需要，还可以再增加一个指向其双亲的指针域，那样就称之为三叉链表。  </p>
<h2 id="6-8遍历二叉树"><a href="#6-8遍历二叉树" class="headerlink" title="6.8遍历二叉树"></a>6.8遍历二叉树</h2><h3 id="6-8-1二叉树遍历原理"><a href="#6-8-1二叉树遍历原理" class="headerlink" title="6.8.1二叉树遍历原理"></a>6.8.1二叉树遍历原理</h3><p>二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。  </p>
<h3 id="6-8-2二叉树遍历方法"><a href="#6-8-2二叉树遍历方法" class="headerlink" title="6.8.2二叉树遍历方法"></a>6.8.2二叉树遍历方法</h3><p>二叉树的遍历方式可以很多，如果我们限制了从左到右的习惯方式，那么主要就分为四种：  </p>
<ol>
<li><p>前序遍历-根左右<br>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</p>
</li>
<li><p>中序遍历-左根右<br>规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。</p>
</li>
<li><p>后序遍历-左右根<br>规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。</p>
</li>
<li><p>层序遍历<br>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p>
</li>
</ol>
<p>技巧：每个结点单独看。比如后序遍历，每个右结点的左边是该结点的左节点，右边必然是对应的根结点。</p>
<h3 id="6-8-3-前序遍历算法"><a href="#6-8-3-前序遍历算法" class="headerlink" title="6.8.3 前序遍历算法"></a>6.8.3 前序遍历算法</h3><p>二叉树的定义是用递归的方式，所以，实现遍历算法也可以采用递归，而且极其简洁明了。先来看看二叉树的前序遍历算法。代码如下：  </p>
<pre><code class="c">/* 二叉树的前序遍历递归算法 */
void PreOrderTraverse(BiTree T)
{
    if (T == NULL)
        return;
    printf(&quot;%c&quot;, T-&gt;data); /* 显示结点数据，可以更改为其它对结点操作 */
    PreOrderTraverse(T-&gt;lchild); /* 再先序遍历左子树 */
    PreOrderTraverse(T-&gt;rchild); /* 最后先序遍历右子树 */
}</code></pre>
<h3 id="6-8-4-中序遍历算法"><a href="#6-8-4-中序遍历算法" class="headerlink" title="6.8.4 中序遍历算法"></a>6.8.4 中序遍历算法</h3><p>二叉树的中序遍历算法和前序遍历算法仅仅只是代码的顺序上的差异。</p>
<pre><code class="c">/* 二叉树的中序遍历递归算法 */
void InOrderTraverse(BiTree T)
{
    if (T == NULL)
        return;
    InOrderTraverse(T-&gt;lchild); /* 中序遍历左子树 */
    printf(&quot;%c&quot;, T-&gt;data);/* 显示结点数据，可以更改为其它对结点操作 */
    InOrderTraverse(T-&gt;rchild); /* 最后中序遍历右子树 */
}</code></pre>
<h3 id="6-8-5后序遍历算法"><a href="#6-8-5后序遍历算法" class="headerlink" title="6.8.5后序遍历算法"></a>6.8.5后序遍历算法</h3><p>那么同样的，后序遍历也就很容易想到应该如何写代码了。</p>
<pre><code class="c">/* 二叉树的后序遍历递归算法 */
void PostOrderTraverse(BiTree T)
{
    if (T == NULL)
        return;
    PostOrderTraverse(T-&gt;lchild); /* 先后序遍历左子树  */
    PostOrderTraverse(T-&gt;rchild); /* 再后序遍历右子树  */
    printf(&quot;%c&quot;, T-&gt;data);/* 显示结点数据，可以更改为其它对结点操作 */
}</code></pre>
<h3 id="6-8-6-推导遍历结果"><a href="#6-8-6-推导遍历结果" class="headerlink" title="6.8.6 推导遍历结果"></a>6.8.6 推导遍历结果</h3><p>题目是这样：二叉树的中序序列是ABCDEFG，后序序列是BDCAFGE，求前序序列。<br>这次简单点，由后序的BDCAFG E，得到E是根结点，因此前序首字母是E。<br>于是根据中序序列分为两棵树ABCD和FG，由后序序列的BDCA FGE，知道A是E的左孩子，前序序列目前分析为EA。<br>再由中序序列的A BCDEFG，知道BCD是A结点的右子孙，再由后序序列的BDC AFGE知道C结点是A结点的右孩子，前序序列目前分析得到EAC。<br>中序序列AB C DEFG，得到B是C的左孩子，D是C的右孩子，所以前序序列目前分析结果为EACBD。<br>由后序序列BDCAF G E，得到G是E的右孩子，于是F就是G的孩子。前序遍历序列的最终结果就是EACBDGF。  </p>
<p>两个二叉树遍历的性质。</p>
<ul>
<li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li>
<li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li>
</ul>
<p>但要注意了，已知前序和后序遍历，是不能确定一棵二叉树的，原因也很简单，比如前序序列是ABC，后序序列是CBA。我们可以确定A一定是根结点，但接下来，我们无法知道，哪个结点是左子树，哪个是右子树。这棵树可能有如图6-8-24所示的四种可能。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-8-24.JPG?raw=true" alt="6-8-24">  </p>
<h2 id="6-9-二叉树的建立"><a href="#6-9-二叉树的建立" class="headerlink" title="6.9 二叉树的建立"></a>6.9 二叉树的建立</h2><p>如果我们要在内存中建立一个二叉树，为了能让每个结点确认是否有左右孩子，我们对它进行了扩展，也就是将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，比如“#”。我们称这种处理后的二叉树为原二叉树的扩展二叉树。扩展二叉树就可以做到一个遍历序列确定一棵二叉树了。<br>前序遍历序列生成二叉树的代码如下：</p>
<pre><code class="c">/* 按前序输入二叉树中结点的值（一个字符） */
/* #表示空树，构造二叉链表表示二叉树T。 */
void CreateBiTree(BiTree *T)
{
    TElemType ch;
    /* scanf(&quot;%c&quot;,&amp;ch); */
    ch = str[index++];
    if (ch == &#39;#&#39;)
        *T = NULL;
    else
    {
        *T = (BiTree)malloc(sizeof(BiTNode));
        if (!*T)
            exit(OVERFLOW);
        (*T)-&gt;data = ch; /* 生成根结点 */
        CreateBiTree(&amp;(*T)-&gt;lchild); /* 构造左子树 */
        CreateBiTree(&amp;(*T)-&gt;rchild); /* 构造右子树 */
    }
}</code></pre>
<p>当然，你完全也可以用中序或后序遍历的方式实现二叉树的建立，只不过代码里生成结点和构造左右子树的代码顺序交换一下。另外，输入的字符也要做相应的更改。</p>
<h2 id="6-10-线索二叉树"><a href="#6-10-线索二叉树" class="headerlink" title="6.10 线索二叉树"></a>6.10 线索二叉树</h2><h3 id="6-10-1-线索二叉树原理"><a href="#6-10-1-线索二叉树原理" class="headerlink" title="6.10.1 线索二叉树原理"></a>6.10.1 线索二叉树原理</h3><p><strong>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）。</strong><br>其实线索二叉树，等于是把一棵二叉树转变成了一个双向链表，这样对我们的插入删除结点、查找某个结点都带来了方便。所以<strong>我们对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化</strong>。<br>但是变为线索二叉树，我们并不知道某个结点的lChild是指向它的左孩子还是指向前驱…<br>因此，我们在每个结点再增设两个标志域lTag和rTag，注意lTag和rTag只是存放0或1数字的布尔型变量，其占用的内存空间要小于像lchild和rchild的指针变量。结点结构如下表所示。<br>lChild|lTag|data|rTag|rChild<br>-|-|-|-|-<br>其中：</p>
<ul>
<li>lTag为0时指向该结点的左孩子，为1时指向该结点的前驱。</li>
<li>rTag为0时指向该结点的右孩子，为1时指向该结点的后继。</li>
</ul>
<h3 id="6-10-2-线索二叉树结构实现"><a href="#6-10-2-线索二叉树结构实现" class="headerlink" title="6.10.2 线索二叉树结构实现"></a>6.10.2 线索二叉树结构实现</h3><p>由此二叉树的线索存储结构定义代码如下：</p>
<pre><code class="c">/* 二叉树的二叉线索存储结构定义 */
typedef enum { Link, Thread } PointerTag; /* Link==0表示指向左右孩子指针, */
                                          /* Thread==1表示指向前驱或后继的线索 */
typedef  struct BiThrNode                 /* 二叉线索存储结点结构 */
{
    TElemType data;    /* 结点数据 */
    struct BiThrNode *lchild, *rchild;    /* 左右孩子指针 */
    PointerTag LTag;
    PointerTag RTag;        /* 左右标志 */
} BiThrNode, *BiThrTree;</code></pre>
<p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以<strong>线索化的过程就是在遍历的过程中修改空指针的过程</strong>。<br>中序遍历线索化的递归函数代码如下：</p>
<pre><code class="c">BiThrTree pre; /* 全局变量,始终指向刚刚访问过的结点 */
/* 中序遍历进行中序线索化 */
void InThreading(BiThrTree p)
{
    if (p)
    {
        InThreading(p-&gt;lchild); /* 递归左子树线索化 */
        if (!p-&gt;lchild) /* 没有左孩子 */
        {
            p-&gt;LTag = Thread; /* 前驱线索 */
            p-&gt;lchild = pre; /* 左孩子指针指向前驱 */
        }
        if (!pre-&gt;rchild) /* 前驱没有右孩子 */
        {
            pre-&gt;RTag = Thread; /* 后继线索 */
            pre-&gt;rchild = p; /* 前驱右孩子指针指向后继(当前结点p) */
        }
        pre = p; /* 保持pre指向p的前驱 */
        InThreading(p-&gt;rchild); /* 递归右子树线索化 */
    }
}</code></pre>
<p>if（!p-&gt;lChild）表示如果某结点的左指针域为空，因为其前驱结点刚刚访问过，赋值给了pre，所以可以将pre赋值给p-&gt;lChild，并修改p-&gt;LTag=Thread（也就是定义为1）以完成前驱结点的线索化。<br>后继就要稍稍麻烦一些。因为此时p结点的后继还没有访问到，因此只能对它的前驱结点pre的右指针rchild做判断，if（!pre-&gt;rchild）表示如果为空，则p就是pre的后继，于是pre-&gt;rchild=p，并且设置pre-&gt;RTag=Thread，完成后继结点的线素化。<br>完成前驱和后继的判断后，别忘记将当前的结点p赋值给pre，以便于下一次使用。<br>有了线索二叉树后，我们对它进行遍历时发现，其实就等于是操作一个双向链表结构。<br>和双向链表结构一样，在二叉树线素链表上添加一个头结点，如图6-10-6所示，并令其lchild域的指针指向二叉树的根结点（图中的①），其rchild域的指针指向中序遍历时访问的最后一个结点（图中的②）。反之，令二叉树的中序序列中的第一个结点中，lchild 域指针和最后一个结点的rchild 域指针均指向头结点（图中的③和④）。这样定义的好处就是我们既可以从第一个结点起顺后继进行遍历，也可以从最后一个结点起顺前驱进行遍历。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-10-6.JPG?raw=true" alt="6-10-6">  </p>
<p>遍历的代码如下：</p>
<pre><code class="c">/*T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的*/
/*最后一个结点。中序遍历二叉线索链表表示的二叉树T*/
Status InOrderTraverse_Thr(BiThrTree T)
{
    BiThrTree p;
    p = T-&gt;lchild; /* p指向根结点 */
    while (p != T) /* 空树或遍历结束时，p==T */
    { /* 空树或遍历结束时,p==T */
        while (p-&gt;LTag == Link) /*当LTag==0时循环到中序序列第一个结点 */
            p = p-&gt;lchild;
        printf(&quot;%c&quot;,p-&gt;data); /* 显示结点数据，可以更改为其他对结点操作 */
        while (p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != T)
        {
            p = p-&gt;rchild;
            printf(&quot;%c&quot;,p-&gt;data);
        }
        p = p-&gt;rchild; /* p进至其右子树根 */
    }
    return OK;
}</code></pre>
<p>从这段代码也可以看出，它等于是一个链表的扫描，所以时间复杂度为O(n)。<br>由于它充分利用了空指针域的空间（这等于节省了空间），又保证了创建时的一次遍历就可以终生受用前驱后继的信息（这意味着节省了时间）。所以在实际问题中，<strong>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择</strong>。</p>
<h2 id="6-11-树、森林与二叉树的转换"><a href="#6-11-树、森林与二叉树的转换" class="headerlink" title="6.11 树、森林与二叉树的转换"></a>6.11 树、森林与二叉树的转换</h2><h3 id="6-11-1-树转换为二叉树"><a href="#6-11-1-树转换为二叉树" class="headerlink" title="6.11.1 树转换为二叉树"></a>6.11.1 树转换为二叉树</h3><p>将树转换为二叉树的步骤如下</p>
<ol>
<li>加线。在所有兄弟结点之间加一条连线。</li>
<li>去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。</li>
<li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</li>
</ol>
<h3 id="6-11-2-森林转换为二叉树"><a href="#6-11-2-森林转换为二叉树" class="headerlink" title="6.11.2 森林转换为二叉树"></a>6.11.2 森林转换为二叉树</h3><p>森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。步骤如下：</p>
<ol>
<li>把每个树转换为二叉树。</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。</li>
</ol>
<h3 id="6-11-3-二叉树转换为树"><a href="#6-11-3-二叉树转换为树" class="headerlink" title="6.11.3 二叉树转换为树"></a>6.11.3 二叉树转换为树</h3><p>二叉树转换为树是树转换为二叉树的逆过程，也就是反过来做而已。如图6-11-4所示。步骤如下：</p>
<ol>
<li>加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……哈，反正就是左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。</li>
<li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li>
<li>层次调整。使之结构层次分明。</li>
</ol>
<p><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-11-4.JPG?raw=true" alt="6-11-4"></p>
<h3 id="6-11-4-二叉树转换为森林"><a href="#6-11-4-二叉树转换为森林" class="headerlink" title="6.11.4 二叉树转换为森林"></a>6.11.4 二叉树转换为森林</h3><p>判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。<br>那么如果是转换成森林，步骤如下：</p>
<ol>
<li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。</li>
<li>再将每棵分离后的二叉树转换为树即可。</li>
</ol>
<p><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-11-5.JPG?raw=true" alt="6-11-5"></p>
<h3 id="6-11-5-树与森林的遍历"><a href="#6-11-5-树与森林的遍历" class="headerlink" title="6.11.5 树与森林的遍历"></a>6.11.5 树与森林的遍历</h3><p>树的遍历分为两种方式。</p>
<ol>
<li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。</li>
<li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。比如图6-11-4中最右侧的树，它的先根遍历序列为ABEFCDG，后根遍历序列为EFBCGDA。</li>
</ol>
<p>森林的遍历也分为两种方式：</p>
<ol>
<li>前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。比如图6-11-5右侧三棵树的森林，前序遍历序列的结果就是ABCDEFGHJI。</li>
<li>后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。比如图6-11-5右侧三棵树的森林，后序遍历序列的结果就是BCDAFEJHIG。</li>
</ol>
<p>可如果我们对二叉树进行分析就会发现，森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。<br>这也就告诉我们，当以二叉链表作树的存储结构时，树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现。这其实也就证实，我们找到了对树和森林这种复杂问题的简单解决办法。  </p>
<h2 id="6-12-赫夫曼树及其应用"><a href="#6-12-赫夫曼树及其应用" class="headerlink" title="6.12 赫夫曼树及其应用"></a>6.12 赫夫曼树及其应用</h2><h3 id="6-12-1-赫夫曼树"><a href="#6-12-1-赫夫曼树" class="headerlink" title="6.12.1 赫夫曼树"></a>6.12.1 赫夫曼树</h3><p>压缩软件如何做到压缩而不出错的呢？简单说，就是把我们要压缩的文本进行重新编码，以减少不必要的空间。我们今天就来介绍一下最基本的压缩编码方法——赫夫曼编码。<br>由美国数学家赫夫曼（David Huffman）在1952年发明了赫夫曼编码。他在编码中用到的特殊的二叉树称之为赫夫曼树，他的编码方法称为赫夫曼编码。  </p>
<h3 id="6-12-2-赫夫曼树定义与原理"><a href="#6-12-2-赫夫曼树定义与原理" class="headerlink" title="6.12.2 赫夫曼树定义与原理"></a>6.12.2 赫夫曼树定义与原理</h3><p><strong>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度。</strong><br><strong>树的路径长度就是从树根到每一结点的路径长度之和。</strong><br>如果考虑到带权的结点，结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。假设有n个权值{w1，w2，…，Wn}，构造一棵有n个叶子结点的二叉树，每个叶子结点带权Wk，每个叶子的路径长度为lk，我们通常记作，则其中<strong>带权路径长度WPL最小的二叉树称做赫夫曼树</strong>。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-12-4.JPG?raw=true" alt="6-12-4"><br>有了赫夫曼对带权路径长度的定义，我们来计算一下图6-12-4这两棵树的WPL值。<br>二叉树a的WPL=5×1+15×2+40×3+30×4+10×4=315<br>注意：这里5是A结点的权，1是A结点的路径长度，其他同理。<br>二叉树b的WPL=5×3+15×3+40×2+30×2+10×2=220<br>参考图6-12-4的二叉树b，最优赫夫曼树的解法如下：</p>
<ol>
<li>先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即：A5，E10，B15，D30，C40。</li>
<li>取头两个最小权值的结点作为一个新节点N1的两个子结点，注意相对较小的是左孩子，这里就是A为N1的左孩子，E为N1的右孩子，如图6-12-5所示。新结点的权值为两个叶子权值的和5+10=15。</li>
<li>将N1替换A与E，插入有序序列中，保持从小到大排列。即：N1 15，B15，D30，C40。</li>
<li>重复步骤2。将N1与B作为一个新节点N2的两个子结点。如图6-12-6所示。N2的权值=15+15=30。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-12-5.JPG?raw=true" alt="6-12-5"></li>
<li>将N2替换N1与B，插入有序序列中，保持从小到大排列。即：N2 30，D30，C40。</li>
<li>重复步骤2。将N2与D作为一个新节点N3的两个子结点。如图6-12-7所示。N3的权值=30+30=60。</li>
<li>将N3替换N2与D，插入有序序列中，保持从小到大排列。即：C40，N3 60。</li>
<li>重复步骤2。将C与N3作为一个新节点T的两个子结点，如图6-12-8所示。由于T即是根结点，完成赫夫曼树的构造。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-12-7.JPG?raw=true" alt="6-12-7">  </li>
</ol>
<p>此时的图6-12-8二叉树的带权路径长度WPL=40×1+30×2+15×3+10×4+5×4=205。与图6-12-4的二叉树b的WPL值220相比，还少了15。显然此时构造出来的二叉树才是最优的赫夫曼树。<br>通过刚才的步骤，我们可以得出构造赫夫曼树的赫夫曼算法描述。</p>
<ol>
<li>根据给定的n个权值{w1，W2，…，Wn}构成n棵二叉树的集合F={T1，T2，…，Tn}，其中每棵二叉树Ti中只有一个带权为wi根结点，其左右子树均为空。</li>
<li>在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li>
<li>在F中删除这两棵树，同时将新得到的二叉树加入F中。</li>
<li>重复2和3步骤，直到F只含一棵树为止。这棵树便是赫夫曼树。</li>
</ol>
<h3 id="6-12-3-赫夫曼编码"><a href="#6-12-3-赫夫曼编码" class="headerlink" title="6.12.3 赫夫曼编码"></a>6.12.3 赫夫曼编码</h3><p>按照不同字母出现的频率重新按照赫夫曼树来规划它们。将规划出来的树权值左分支改为0，右分支改为1后。对字母从树根到叶子所经过路径的0或1来编码，可以看出结果串变小了，编码得到了压缩，节约了存储和传输成本。<br>当我们接收到压缩过的新编码时，我们应该如何把它解码出来呢？<br>编码中非0即1，长短不等的话其实是很容易混淆的，所以<strong>若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称做前缀编码</strong>。<br>可仅仅是这样不足以让我们去方便地解码的，因此在解码时，还是要用到赫夫曼树，即发送方和接收方必须要约定好同样的赫夫曼编码规则。<br><strong>一般地，设需要编码的字符集为{d1，d2，…，dn}，各个字符在电文中出现的次数或频率集合为{W1，w2，…，Wn}，以d1，d2，…，dn作为叶子结点，以w1，W2，Wn作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是赫夫曼编码</strong>。  </p>
<h2 id="6-13-总结回顾"><a href="#6-13-总结回顾" class="headerlink" title="6.13 总结回顾"></a>6.13 总结回顾</h2><p>终于到了总结的时间，这一章与前面章节相比，显得过于庞大了些，原因也就在于树的复杂性和变化丰富度是前面的线性表所不可比拟的。即使在本章之后，我们还要讲解关于树这一数据结构的相关知识，可见它的重要性。<br>开头我们提到了树的定义，讲到了递归在树定义中的应用。提到了如子树、结点、度、叶子、分支结点、双亲、孩子、层次、深度、森林等诸多概念，这些都是需要在理解的基础上去记忆的。<br>我们谈到了树的存储结构时，讲了双亲表示法、孩子表示法、孩子兄弟表示法等不同的存储结构。<br>并由孩子兄弟表示法引出了我们这章中最重要一种树，二叉树。<br>二叉树每个结点最多两棵子树，有左右之分。提到了斜树，满二叉树、完全二叉树等特殊二叉树的概念。<br>我们接着谈到它的各种性质，这些性质给我们研究二叉树带来了方便。<br>二叉树的存储结构由于其特殊性使得既可以用顺序存储结构又可以用链式存储结构表示。<br>遍历是二叉树最重要的一门学问，前序、中序、后序以及层序遍历都是需要熟练掌握的知识。要让自己要学会用计算机的运行思维去模拟递归的实现，可以加深我们对递归的理解。不过，并非二叉树遍历就一定要用到递归，只不过递归的实现比较优雅而已。这点需要明确。<br>二叉树的建立自然也是可以通过递归来实现。<br>研究中也发现，二叉链表有很多浪费的空指针可以利用，查找某个结点的前驱和后继为什么非要每次遍历才可以得到，这就引出了如何构造一棵线索二叉树的问题。<br>线索二叉树给二叉树的结点查找和遍历带来了高效率。<br>树、森林看似复杂，其实它们都可以转化为简单的二叉树来处理，我们提供了树、森林与二叉树的互相转换的办法，这样就使得面对树和森林的数据结构时，编码实现成为了可能。<br>最后，我们提到了关于二叉树的一个应用，赫夫曼树和赫夫曼编码，对于带权路径的二叉树做了详尽地讲述，让你初步理解数据压缩的原理，并明白其是如何做到无损编码和无错解码的。  </p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构第五章 串</title>
    <url>/2019/12/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC5%E7%AB%A0%20%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="5-1-5-2-串的定义"><a href="#5-1-5-2-串的定义" class="headerlink" title="5.1-5.2 串的定义"></a>5.1-5.2 串的定义</h2><p>串(string)是由零个或多个字符组成的有限序列，又名叫字符串。<br>一般记为s=“a1a2……an”(n&gt;0)，其中，s是串的名称，用双引号(有些书中也用单引号)括起来的字符序列是串的值，注意单引号不属于串的内容。ai(1≤i≤n)可以是字母、数字或其他字符，i就是该字符在串中的位置。串中的字符数目n称为串的长度，定义中谈到“有限”是指长度n是一个有限的数值。零个字符的串称为空串(null string)，它的长度为零，可以直接用两双引号“”””表示，也可以用希腊字母“Φ”来表示。所谓的序列，说明串的相邻字符之间具有前驱和后继的关系。<br>还有一些概念需要解释：  </p>
<a id="more"></a>
<ul>
<li>空格串，是只包含空格的串。注意它与空串的区别，空格串是有内容有长度的，而且可以不止一个空格。</li>
<li>子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。</li>
<li>子串在主串中的位置就是子串的第一个字符在主串中的序号。</li>
</ul>
<p>开头我所提到的“over”、“end”、“lie”其实可以认为是“over”、“friend”、“believe”这些单词字符串的子串。  </p>
<h2 id="5-3-串的比较"><a href="#5-3-串的比较" class="headerlink" title="5.3 串的比较"></a>5.3 串的比较</h2><p>两个字符串的长度以及它们每个位置各个对应位置的字符都相等时，才算是相等。<br>那么对于两个串不相等时，如何判定它们的大小呢。我们这样定义：<br>给定两个串：s=“a1a2……an”，t=“b1b2……bm”，当满足以下条件之一时，<code>s&lt;t</code>。</p>
<ol>
<li><code>n&lt;m</code>，且ai=bi(i=1，2，…，n)。<br>例如当s=“hap”，t=“happy”，就有sst。因为t比s多出了两个字母。</li>
<li>存在某个<code>k&lt;min(m，n)</code>，使得ai=bi；(i=1，2，……，k-1)，<code>ak&lt;bk</code>。<br>例如当s=“happen”，t=“happy”，因为两串的前4个子母均相同，间内串第5个字母(k值)，字母e的ASCII码是101，而字母y的ASCII码是121，显然<code>e&lt;y</code>，所以<code>s&lt;t</code>。</li>
</ol>
<h2 id="5-4-串的抽象数据类型"><a href="#5-4-串的抽象数据类型" class="headerlink" title="5.4 串的抽象数据类型"></a>5.4 串的抽象数据类型</h2><pre><code class="c">ADT 串(string)
Data
  串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。
Operation
  strAssign(T，*chars)：生成一个其值等于字符串常量chars的串T。
  StrCopy(T，S)：串S存在，由串S复制得串T。
  ClearString(S)：串S存在，将串清空。
  StringEmpty(S)；若串S为空，返回true，否则返回false。
  StrLength(S)：返回串S的元素个数，即串的长度。
  StrCompare(S，T)：若S&gt;T，返回值&gt;0，若S=T，返回0，若S&lt;T，返回值&lt;0。
  Concat(T，S1，S2)：用T返回由S1和S2联接而成的新串。
  SubString(Sub，S，pos，len)：串S存在，1≤pos≤StrLength(S)，且0≤len≤StrLength(S)-pos+1，用Sub返回串S的第pos个字符起长度为len的子串。
  Index(S，T，pos)：串S和T存在，T是非空串，1≤pos≤StrLength(S)。若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回0。
  Replace(S，T，V)：串S、T和v存在，T是非空串。用V替换主串S中出现的所有与T相等的不重叠的子串。
  StrInsert(S，pos，T)：串s和T存在，1≤pos≤StrLength(S)+1。在串S的第pos个字符之前插入串T。
  StrDelete(S，pos，len)：串S存在，1≤pos≤StrLength(S)-len+1。从串S中删除第pos个字符起长度为len的子串。
endADT</code></pre>
<h2 id="5-5-串的存储结构"><a href="#5-5-串的存储结构" class="headerlink" title="5.5 串的存储结构"></a>5.5 串的存储结构</h2><p>串的存储结构与线性表相同，分为两种。  </p>
<h3 id="5-5-1-串的顺序存储结构"><a href="#5-5-1-串的顺序存储结构" class="headerlink" title="5.5.1 串的顺序存储结构"></a>5.5.1 串的顺序存储结构</h3><p>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义。<br>既然是定长数组，就存在一个预定义的最大串长度，一般可以将实际的串长度值保存在数组的0下标位置，有的书中也会定义存储在数组的最后一个下标位置。但也有些编程语言不想这么干，觉得存个数字占个空间麻烦。它规定在串值后面加一个不计入串长度的结束标记字符，比如“\0”来表示串值的终结，这个时候，你要想知道此时的串长度，就需要遍历计算一下才知道了，其实这还是需要占用一个空间，何必呢。</p>
<h3 id="5-5-2-串的链式存储结构"><a href="#5-5-2-串的链式存储结构" class="headerlink" title="5.5.2 串的链式存储结构"></a>5.5.2 串的链式存储结构</h3><p>对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用“#”或其他非串值字符补全，如图5-5-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/5-5-3.JPG?raw=true" alt="5-5-3"><br>当然，这里一个结点存多少个字符才合适就变得很重要，这会直接影响着串处理的效率，需要根据实际情况做出选择。<br>但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。  </p>
<h2 id="5-6-朴素的模式匹配算法-暴力算法匹配"><a href="#5-6-朴素的模式匹配算法-暴力算法匹配" class="headerlink" title="5.6 朴素的模式匹配算法(暴力算法匹配)"></a>5.6 朴素的模式匹配算法(暴力算法匹配)</h2><p>子串的定位操作通常称做串的模式匹配，也算是串中最重要的操作之一。<br>用基本的数组来实现朴素的模式匹配算法。我们假设主串S和要匹配的子串T的长度存在S[0]与T[0]中。实现代码如下：  </p>
<pre><code class="c">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在,则函数返回值为0。 */
/* 其中,T非空,1≤pos≤StrLength(S)。 */
int Index(String S, String T, int pos)
{
    int i = pos;    /* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */
    int j = 1;                /* j用于子串T中当前位置下标值 */
    while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */
    {
        if (S[i] == T[j])     /* 两字母相等则继续 */
          {
            ++i;
            ++j;
          }
          else                 /* 指针后退重新开始匹配 */
          {  
             i = i-j+2;        /* i退回到上次匹配首位的下一位 */
             j = 1;             /* j退回到子串T的首位 */
          }
    }
    if (j &gt; T[0])
        return i-T[0];
    else
        return 0;
}</code></pre>
<p>非最坏情况下，只需要匹配2个串的首字母，所以根据等概率原则，平均是(n+m)/2次查找，时间复杂度为O(n+m)。<br>而最坏情况就是0000000000000000001，此时时间复杂度为O((n-m+1)*m)。  </p>
<h2 id="5-7-KMP-模式匹配算法"><a href="#5-7-KMP-模式匹配算法" class="headerlink" title="5.7 KMP 模式匹配算法"></a>5.7 KMP 模式匹配算法</h2><p>有三位前辈，D.E.Knuth、J.H.Morris 和V.R.Pratt（其中Knuth和Pratt 共同研究，Morris独立研究）发表一个模式匹配算法，可以大大避免重复遍历的情况，我们把它称之为克努特一莫里斯一普拉特算法，简称KMP算法。  </p>
<h3 id="5-7-1-KMP模式匹配算法原理"><a href="#5-7-1-KMP模式匹配算法原理" class="headerlink" title="5.7.1 KMP模式匹配算法原理"></a>5.7.1 KMP模式匹配算法原理</h3><p>首先要理解上面的朴素模式的匹配算法，主串设为S，要匹配的模式串设为T。<br>对于在子串中有与首字符相等的字符，也是可以省略一部分不必要的判断步骤。<br>我们在朴素的模式匹配算法中，主串的i值是不断地回溯来完成的。而我们的分析发现，这种回溯其实是可以不需要的，我们的KMP模式匹配算法就是为了让这没必要的回溯不发生。<br>既然i值不回溯，也就是不可以变小，那么要考虑的变化就是j(j在模式串中所在的位置)值了。通过观察也可发现，我们屡屡提到了T串的首字符与自身后面字符的比较，发现如果有相等字符，j(j在模式串中所在的位置)值的变化就会不相同。也就是说，这个j(j在模式串中所在的位置)值的变化与主串其实没什么关系，关键就取决于T串的结构中是否有重复的问题。<br>我们可以得出规律，j(j在模式串中所在的位置)值的多少取决于当前字符之前的串的前后缀的相似度。<br>我们把T串各个位置的j(j在模式串中所在的位置)值的变化定义为一个数组next，那么next的长度就是T串的长度。于是我们可以得到下面的函数定义：<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/5-7-6.JPG?raw=true" alt="5-7-6"></p>
<h3 id="5-7-2-next数组值推导"><a href="#5-7-2-next数组值推导" class="headerlink" title="5.7.2 next数组值推导"></a>5.7.2 next数组值推导</h3><p>“前缀”指除了最后一个字符以外，一个字符串的全部头部组合；<br>“后缀”指除了第一个字符以外，一个字符串的全部尾部组合。<br>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例，</p>
<ul>
<li>“A”的前缀和后缀都为空集，共有元素的长度为0；</li>
<li>“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</li>
<li>“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</li>
<li>“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</li>
<li>“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</li>
<li>“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</li>
<li>“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。  </li>
</ul>
<p>我们可以根据经验得到:如果前缀后缀最长共有元素的长度为1，k值是2，最长的共有元素的长度为2，k值是3。<br><strong>最长的共有元素的长度为n，k值就是n+1</strong>。  </p>
<h3 id="5-7-3KMP模式匹配算法实现"><a href="#5-7-3KMP模式匹配算法实现" class="headerlink" title="5.7.3KMP模式匹配算法实现"></a>5.7.3KMP模式匹配算法实现</h3><p>next代码如下：</p>
<pre><code class="c">/* 通过计算返回子串T的next数组。 */
void get_next(String T, int *next)
{
    int i, j;
    i = 1;
    j = 0;
    next[1] = 0;
    while (i &lt; T[0])  /* 此处T[0]表示串T的长度 */
    {
        if (j == 0 || T[i] == T[j])     /* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */
        {
            ++i;
            ++j;
            next[i] = j;
        }
        else
            j = next[j];    /* 若字符不相同，则j值回溯 */
    }
}</code></pre>
<p>这段代码的目的就是为了计算出当前要匹配的串T的next数组。  </p>
<pre><code class="c">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。 */
/*  T非空，1≤pos≤StrLength(S)。 */
int Index_KMP(String S, String T, int pos)
{
    int i = pos;        /* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */
    int j = 1;            /* j用于子串T中当前位置下标值 */
    int next[255];        /* 定义一next数组 */
    get_next(T, next);    /* 对串T作分析，得到next数组 */
    while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */
    {
        if (j == 0 || S[i] == T[j])     /* 两字母相等则继续，与朴素算法增加了j=0判断 */
        {
            ++i;
            ++j;
        }
        else             /* 指针后退重新开始匹配 */
            j = next[j];/* j退回合适的位置，i值不变 */
    }
    if (j &gt; T[0])
        return i - T[0];
    else
        return 0;
}</code></pre>
<p>对于get_next函数来说，若模式串的长度为m，因只涉及到简单的单循环，其时间复杂度为O(m)，而由于i值的不回溯，使得indexKMP算法效率得到了提高，while 循环的时间复杂度为O(n)。因此，整个算法的时间复杂度为O(n+m)。相较于朴素模式匹配算法的O((n-m+1)*m)来说，是要好一些。  </p>
<h3 id="5-7-4-KMP模式匹配算法改进"><a href="#5-7-4-KMP模式匹配算法改进" class="headerlink" title="5.7.4 KMP模式匹配算法改进"></a>5.7.4 KMP模式匹配算法改进</h3><pre><code class="c">/* 求模式串T的next函数修正值并存入数组nextval */
void get_nextval(String T, int *nextval)
{
    int i, j;
    i = 1;
    j = 0;
    nextval[1] = 0;
    while (i &lt; T[0])  /* 此处T[0]表示串T的长度 */
    {
        if (j == 0 || T[i] == T[j])     /* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */
        {
            ++i;
            ++j;
            if (T[i] != T[j])      /* 若当前字符与前缀字符不同 */
                nextval[i] = j;    /* 则当前的j为nextval在i位置的值 */
            else
                nextval[i] = nextval[j];    /* 如果与前缀字符相同，则将前缀字符的 */
                                            /* nextval值赋值给nextval在i位置的值 */
        }
        else
            j = nextval[j];            /* 若字符不相同，则j值回溯 */
    }
}</code></pre>
<h3 id="5-7-5-nextval-数组值推导"><a href="#5-7-5-nextval-数组值推导" class="headerlink" title="5.7.5 nextval 数组值推导"></a>5.7.5 nextval 数组值推导</h3><p>总结改进过的KMP算法，它是在计算出next值的同时，如果a位字符与它next值指向的b位字符相等，则该a位的nextval就指向b位的nextval值，如果不等，则该a位的nextval值就是它自己a位的next的值。  </p>
<h2 id="5-8-总结回顾"><a href="#5-8-总结回顾" class="headerlink" title="5.8 总结回顾"></a>5.8 总结回顾</h2><p>这一章节我们重点讲了“串”这样的数据结构，串（string）是由零个或多个字符组成的有限序列，又名叫字符串。本质上，它是一种线性表的扩展，但相对于线性表关注一个个元素来说，我们对串这种结构更多的是关注它子串的应用问题，如查找、替换等操作。现在的高级语言都有针对串的函数可以调用。我们在使用这些函数的时候，同时也应该要理解它当中的原理，以便于在碰到复杂的问题时，可以更加灵活的使用，比如KMP模式匹配算法的学习，就是更有效地去理解index函数当中的实现细节。  </p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo next主题导航栏图标显示问号解决方案</title>
    <url>/2019/12/10/hexo/hexo-next%E4%B8%BB%E9%A2%98%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA%E9%97%AE%E5%8F%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>导航栏图标显示问号，当修改<code>hexo\themes\next\_config.yml</code>主题配置文件后，图标显示正常，但是点击链接不能打开相应主页、标签页、归档页…<br>经研究，应该把menu下面的不同页面的/后面的空格删掉，即可。<br>具体配置如下：  </p>
<a id="more"></a>
<pre><code class="yml">menu:
  home: /|| home                  #主页
  archives: /archives/|| archive  #归档
  categories: /categories/|| th   #分类
  tags: /tags/|| tags             #标签
  about: /about/|| user           #关于我
  #search: /search
  #schedule: /schedule/ || calendar
  #sitemap: /sitemap.xml || sitemap
  #commonweal: /404.html

# Enable/Disable menu icons.
menu_icons:
  enable: true
  # Icon Mapping.
  home: home
  archives: archive
  categories: th
  tags: tags
  about: user
  #commonweal: heartbeat
  #search: search
</code></pre>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 多客户端上更新博客</title>
    <url>/2019/12/09/hexo/hexo%20%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><code>git add source/ &amp;&amp; git commit -m &quot;博客更新&quot; &amp;&amp; git push origin hexo &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; exit</code></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>静态网页文件存放在<code>master主分支</code>，个人文件存放在<code>hexo分支</code>。  </p>
<h2 id="一、本地电脑设置"><a href="#一、本地电脑设置" class="headerlink" title="一、本地电脑设置"></a>一、本地电脑设置</h2><p>先新建一个hexo文件夹，在git bash下cd进入hexo文件夹。</p>
<ol>
<li><code>git init</code></li>
<li><code>git checkout -b hexo</code> //新建hexo分支并切换到hexo</li>
<li>将原来博客文件夹里面的<code>_config.yml</code>，<code>theme/</code>，<code>source/</code>，<code>scaffolds/</code>，<code>package.json</code>，<code>.gitignore</code>，共6个文件/文件夹 拷贝到hexo文件夹下面。<br>需要拷贝的文件如下:  <a id="more"></a></li>
</ol>
<ul>
<li>_config.yml（站点配置）；</li>
<li>theme文件夹里面的主题；</li>
<li>source文件夹；</li>
<li>scaffolds文件夹（文章的模板）；</li>
<li>package.json（说明使用哪些包）；</li>
<li>.gitignore（限定在提交的时候哪些文件可以忽略）；  </li>
<li><strong>注意：不要<code>hexo init</code>去整体初始化，因为需要的文件我们已经拷贝过来了。</strong>  </li>
</ul>
<ol start="4">
<li>将theme文件夹里面的你的主题文件夹下的.git文件夹删除。</li>
<li><code>git add scaffolds/ source/ themes .gitignore _config.yml package.json</code><br><code>git commit -m &quot;init&quot;</code>  </li>
<li><code>git remote add origin git@github.com:你的ID/你的仓库名字</code>  //添加本地hexo和远程仓库的关联  </li>
<li>登录github，将分支仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为hexo，Update保存。 </li>
<li><code>git push origin hexo</code>  //上传更新</li>
</ol>
<h2 id="二、另外一台电脑上配置"><a href="#二、另外一台电脑上配置" class="headerlink" title="二、另外一台电脑上配置"></a>二、另外一台电脑上配置</h2><ol>
<li>官网下载安装：  </li>
</ol>
<ul>
<li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">安装 Node.js；</a></li>
<li><a href="https://git-scm.com/" target="_blank" rel="noopener">安装 Git。</a></li>
</ul>
<ol start="2">
<li>新建hexo目录，cd进入。</li>
<li><code>git clone https://github.com/你的ID/你的ID.github.io.git</code>  //克隆到本地</li>
<li>将新电脑生成的ssh key添加到gitHub账户上。<br>需要配置 git。</li>
</ol>
<ul>
<li><code>git config --global user.email &quot;xxx@qq.com&quot;</code> 引号内的<a href="mailto:xxx@qq.com">xxx@qq.com</a>改为你github注册并且验证的邮箱；</li>
<li><code>git config --global user.name &quot;xxxx&quot;</code>   引号内的xxxx改为你的 github 用户名；</li>
<li><code>ssh-keygen</code> 会出现下面的内容，一直按Enter键就行；</li>
<li>打开用户目录下的 <code>.ssh</code>目录下面生成 <code>id_rsa(私钥)id_rsa.pub(公钥)</code>两个文件，打开<code>id_rsa.pub</code>，复制里面的内容,到 github: <code>Settings -&gt; SSH and GPG keys -&gt; SSH keys -&gt; New SSH key -&gt; (填写)Title -&gt; (粘贴)Key -&gt; Add SSH Key</code>；</li>
<li>测试 <code>ssh -T git@github.com</code>，输出 <strong>You’ve successfully authenticated</strong> 表示添加key 成功。</li>
</ul>
<ol start="5">
<li><code>npm install hexo-cli -g</code> //安装hexo</li>
<li><code>npm install</code> //安装依赖包  </li>
</ol>
<ul>
<li>如果出现报错<code>ERROR Try runing: &#39;npm install hexo --save</code>则执行命令<code>npm install hexo --save</code>，如果没有，则忽略。</li>
</ul>
<h2 id="三、发布博客"><a href="#三、发布博客" class="headerlink" title="三、发布博客"></a>三、发布博客</h2><ol>
<li>cd进入博客目录</li>
<li><code>git pull origin hexo</code> //保证和分支同步</li>
<li><code>hexo n &quot;新建博客&quot;</code></li>
<li><code>git add source/</code>      //因为博客文件是在source文件夹下面的</li>
<li><code>git commit -m &quot;博客更新&quot;</code></li>
<li><code>git push origin hexo</code>//长传更新</li>
<li><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>//部署博客</li>
</ol>
<p>至此，多终端发布博客已经配置完成。</p>
<h2 id="四、更新主题"><a href="#四、更新主题" class="headerlink" title="四、更新主题"></a>四、更新主题</h2><p>配置好主题文件后，执行：<br><code>git add scaffolds/ source/ themes .gitignore _config.yml package.json</code><br><code>git commit -m &quot;更新主题&quot;</code><br><code>git push origin hexo</code>  //上传更新</p>
<h2 id="五、快速上传部署命令"><a href="#五、快速上传部署命令" class="headerlink" title="五、快速上传部署命令"></a>五、快速上传部署命令</h2><p>只更新博客内容，可以从上述第 三 大步第 4 步后可以这样子发布：<br><code>git add source/ &amp;&amp; git commit -m &quot;博客更新&quot; &amp;&amp; git push origin hexo &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; exit</code><br>把所有命令用<code>&amp;&amp;</code>串起来，有一个失败就会停止；成功，最后一条命令就会退出终端。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>多客户端</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo配置文件设置</title>
    <url>/2019/12/09/hexo/hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="hexo配置文件设置"><a href="#hexo配置文件设置" class="headerlink" title="hexo配置文件设置"></a>hexo配置文件设置</h2><p>hexo配置文件<code>_config.yml</code>基本配置</p>
<a id="more"></a>
<pre><code class="yml"># Hexo Configuration
## Docs: https://hexo.io/docs/configuration.html
## Source: https://github.com/hexojs/hexo/

# Site 网站
title: closer的个人博客
subtitle: welcome!
description: 非专业初学者码农一枚
keywords:
author: closer
language: zh-Hans #语言
timezone: &#39;&#39;

# URL 网址
## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;
url: https://closer_laps.gitee.io/
root: / #根目录位置，如果只是github pages的子目录需要更改
permalink: :year/:month/:day/:title/
permalink_defaults:

# Directory #文件结构 默认即可
source_dir: source
public_dir: public
tag_dir: tags
archive_dir: archives
category_dir: categories
code_dir: downloads/code
i18n_dir: lang
skip_render:

# Writing #编辑博文的选项
new_post_name: :title.md # File name of new posts
default_layout: post
auto_spacing: false
titlecase: false # 把标题转换为 title case 
external_link:
  enable: true # Open external links in new tab
  field: site # Apply to the whole site
  exclude: &#39;&#39;
filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写 
render_drafts: false #显示草稿 
post_asset_folder: false #启动 Asset 文件夹 
relative_link: false #把链接改为与根目录的相对位址 
future: true #显示未来的文章 
highlight:  #代码块的设置 
 enable: false  #开启代码块高亮 
 auto_detect: false #如果未指定语言，则启用自动检测 
 line_number: true #显示行数 
 tab_replace: &#39;&#39; #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs 

# Home page setting
# path: Root path for your blogs index page. (default = &#39;&#39;)
# per_page: Posts displayed per page. (0 = disable pagination)
# order_by: Posts order. (Order by date descending by default)
index_generator:
  path: &#39;&#39;
  per_page: 10
  order_by: -date

# Category &amp; Tag #分类 &amp; 标签
default_category: uncategorized
category_map:
tag_map:

# Metadata elements
## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta
meta_generator: true

# Date / Time format #日期显示格式
## Hexo uses Moment.js to parse and display date
## You can customize the date format as defined in
## http://momentjs.com/docs/#/displaying/format/
date_format: YYYY-MM-DD #日期格式 
time_format: HH:mm:ss #时间格式
## Use post&#39;s date for updated date unless set in front-matter
use_date_for_updated: false

# Pagination #分页器
## Set per_page to 0 to disable pagination
per_page: 10 #每页显示的文章量 (0 = 关闭分页功能) 10
pagination_dir: page #分页目录 

# Include / Exclude file(s)
## include:/exclude: options only apply to the &#39;source/&#39; folder
include:
exclude:
ignore:

# Extensions #拓展
## Plugins: http://hexo.io/plugins/
## Themes: http://hexo.io/themes/
theme: next #主题更换

# Deployment #部署参数
## Docs: http://hexo.io/docs/deployment.html
deploy:
  type: git
  repo: https://github.com/closer2018/closer2018.github.io.git
  #repo: https://gitee.com/closer_laps/closer_laps.git
  branch: master

# 搜索设置
search:
  path: search.xml
  field: post
  format: html
  limit: 10000</code></pre>
<p>以上就是配置文件的基础设置。</p>
<h2 id="更换主题NexT"><a href="#更换主题NexT" class="headerlink" title="更换主题NexT"></a>更换主题NexT</h2><p>Hexo安装主题的方式非常简单，只需要将主题文件放置于站点目录的themes下，然后修改下配置文件即可。这里我以NexT主题为例。<br>在git bash操作下cd至博客根目录，执行如下代码：  </p>
<p><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p>
<p>等待下载完成后，修改根目录下_config.yml文件的theme字段为next即可启用NexT主题，十分简单便捷。<br>其它具体设置可参照<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT官方文档</a>。</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>cd至blog根目录。  </p>
<pre><code class="yml">npm install hexo-generator-searchdb --save  #搜索插件
npm install --save hexo-generator-feed   #RSS插件
npm install hexo-wordcount --save   #字符统计及阅读时长估计
npm install hexo-generator-sitemap --save  #博客添加网站地图sitemap
npm install hexo-generator-index-pin-top --save   #置顶插件</code></pre>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo上传部署命令</title>
    <url>/2019/12/01/hexo/hexo%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="hexo上传部署三连杀命令-先cd进入git目录"><a href="#hexo上传部署三连杀命令-先cd进入git目录" class="headerlink" title="hexo上传部署三连杀命令(先cd进入git目录)"></a>hexo上传部署三连杀命令(先<code>cd</code>进入git目录)</h2><pre><code class="bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre>
<a id="more"></a>
<h3 id="我们运行测试时，经常用到的有三个命令"><a href="#我们运行测试时，经常用到的有三个命令" class="headerlink" title="我们运行测试时，经常用到的有三个命令"></a>我们运行测试时，经常用到的有三个命令</h3><pre><code class="bash">hexo clean #用来清理缓存文件
hexo g      #生成文件
hexo  d   #上传到服务器</code></pre>
<h4 id="本地检测时运行"><a href="#本地检测时运行" class="headerlink" title="本地检测时运行"></a>本地检测时运行</h4><pre><code class="bash">hexo s</code></pre>
<p>然后打开浏览器，输入localhost:4000，就能看到博客了。<br>这样说明本地环境搭建完成。</p>
<h3 id="特别感谢B站up主CodeSheep的帮助和细心指导"><a href="#特别感谢B站up主CodeSheep的帮助和细心指导" class="headerlink" title="特别感谢B站up主CodeSheep的帮助和细心指导"></a>特别感谢<a href="https://space.bilibili.com/384068749/" target="_blank" rel="noopener">B站up主CodeSheep</a>的帮助和细心指导</h3>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构第四章 栈与队列</title>
    <url>/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC4%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="4-1-4-2-栈的定义"><a href="#4-1-4-2-栈的定义" class="headerlink" title="4.1-4.2 栈的定义"></a>4.1-4.2 栈的定义</h2><h3 id="4-2-1-栈的定义"><a href="#4-2-1-栈的定义" class="headerlink" title="4.2.1 栈的定义"></a>4.2.1 栈的定义</h3><p><strong>栈是限定仅在表尾进行插入和删除操作的线性表。</strong><br>我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简尔LIFO结构。<br>它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。<br>栈的插入操作，叫作进栈，也称压栈、入栈(push)。<br>栈的删除操作，叫作出栈，也有的叫作弹栈(pop)。  </p>
<h2 id="4-3-栈的抽象数据类型"><a href="#4-3-栈的抽象数据类型" class="headerlink" title="4.3 栈的抽象数据类型"></a>4.3 栈的抽象数据类型</h2><a id="more"></a>
<pre><code class="c">ADT 栈(stack)
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
    InitStack(*s)：初始化操作，建立一个空栈s。
    DestroyStack(*s)：若楼存在，则销毁它。
    ClearStack(*s)：将栽清空。
    StackEmpty(S)：若为空，返回true，否则返回false。
    GetTop(s，*e)：若栽存在且非空，用e返回s的栽顶元素。
    Push(*s，e)：若栈S存在，插入新元素e到栈S中并成为栈顶元素。
    Pop(*S，*e)：删除栈S中栈顶元素，并用e返回其值。
    StackLength(s)：返回栈s的元素个数。
endADT</code></pre>
<h2 id="4-4-栈的顺序存储结构及实现"><a href="#4-4-栈的顺序存储结构及实现" class="headerlink" title="4.4 栈的顺序存储结构及实现"></a>4.4 栈的顺序存储结构及实现</h2><h3 id="4-4-1-栈的顺序存储结构"><a href="#4-4-1-栈的顺序存储结构" class="headerlink" title="4.4.1 栈的顺序存储结构"></a>4.4.1 栈的顺序存储结构</h3><p>栈是线性表的特例，那么栈的顺序存储其实也是线性表顺序存储的简化，我们简称为顺序栈。线性表是用数组来实现的。<br>我们定义一个top变量来指示栈顶元素在数组中的位置，它可以来回移动，意味着栈顶的top可以变大变小，但无论如何游标不能超出栈的长度。同理，若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判定条件定为top等于-1。</p>
<p>栈的结构定义：  </p>
<pre><code class="c">typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */
/* 顺序栈结构 */
typedef struct
{
        SElemType data[MAXSIZE];
        int top; /* 用于栈顶指针 */
}SqStack;</code></pre>
<p>若现在有一个栈，StackSize是5，则栈普通情况、空栈和栈满的情况示意图如图4-4-2所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-4-2.JPG?raw=true" alt="4-4-2">  </p>
<h3 id="4-4-2-栈的顺序存储结构——进栈操作"><a href="#4-4-2-栈的顺序存储结构——进栈操作" class="headerlink" title="4.4.2 栈的顺序存储结构——进栈操作"></a>4.4.2 栈的顺序存储结构——进栈操作</h3><p>对于栈的插入，即进栈操作，其实就是在栈顶插入一个元素。<br>进栈操作push，其代码如下：  </p>
<pre><code class="c">/* 插入元素e为新的栈顶元素 */
Status Push(SqStack *S,SElemType e)
{
        if(S-&gt;top == MAXSIZE -1) /* 栈满 */
        {
            return ERROR;
        }
        S-&gt;top++;   /* 栈顶指针增加一 */
        S-&gt;data[S-&gt;top]=e;  /* 将新插入元素赋值给栈顶空间 */
        return OK;
}</code></pre>
<h3 id="4-4-3-栈的顺序存储结构——出栈操作"><a href="#4-4-3-栈的顺序存储结构——出栈操作" class="headerlink" title="4.4.3 栈的顺序存储结构——出栈操作"></a>4.4.3 栈的顺序存储结构——出栈操作</h3><p>出栈操作pop，代码如下：  </p>
<pre><code class="c">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */
Status Pop(SqStack *S,SElemType *e)
{
        if(S-&gt;top==-1)
                return ERROR;
        *e=S-&gt;data[S-&gt;top]; /* 将要删除的栈顶元素赋值给e */
        S-&gt;top--;   /* 栈顶指针减一 */
        return OK;
}</code></pre>
<p>两者没有涉及到任何循环语句，因此时间复杂度均是O(1)。  </p>
<h2 id="4-5-两栈共享空间"><a href="#4-5-两栈共享空间" class="headerlink" title="4.5 两栈共享空间"></a>4.5 两栈共享空间</h2><p>如果我们有两个相同类型的栈，我们为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。这又何必呢？我们完全可以用一个数组来存储两个栈，只不过需要点小技巧。<br>数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为栈的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。<br>其实关键思路是：它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。<br>从这里也就可以分析出来，栈1为空时，就是top1等于-1时；而当top2等于n时，即是栈2为空时，那什么时候栈满呢？<br>想想极端的情况，若栈2是空栈，栈1的top1等于n-1时，就是栈1满了。反之，当栈1为空栈时，top2等于0时，为栈2满。但更多的情况，其实就是我刚才说的，两个栈见面之时，也就是两个指针之间相差1时，即top1+1==top2为栈满。<br>两栈共享空间的结构的代码如下：</p>
<pre><code class="c">/* 两栈共享空间结构 */
typedef struct
{
    SElemType data[MAXSIZE];
    int top1;    /* 栈1栈顶指针 */
    int top2;    /* 栈2栈顶指针 */
}SqDoubleStack;</code></pre>
<p>对于两栈共享空间的push方法，我们除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber。插入元素的代码如下：</p>
<pre><code class="c">/* 插入元素e为新的栈顶元素 */
Status Push(SqDoubleStack *S, SElemType e, int stackNumber)
{
    if (S-&gt;top1 + 1 == S-&gt;top2)    /* 栈已满，不能再push新元素了 */
        return ERROR;
    if (stackNumber == 1)            /* 栈1有元素进栈 */
        S-&gt;data[++S-&gt;top1] = e; /* 若是栈1则先top1+1后给数组元素赋值。 */
    else if (stackNumber == 2)    /* 栈2有元素进栈 */
        S-&gt;data[--S-&gt;top2] = e; /* 若是栈2则先top2-1后给数组元素赋值。 */
    return OK;
}</code></pre>
<p>因为在开始已经判断了是否有栈满的情况，所以后面的top1+1或top2-1是不担心溢出问题的。<br>对于两栈共享空间的pop方法，参数就只是判断栈1栈2的参数stackNumber，代码如下：</p>
<pre><code class="c">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */
Status Pop(SqDoubleStack *S, SElemType *e, int stackNumber)
{
    if (stackNumber == 1)
    {
        if (S-&gt;top1 == -1)
            return ERROR; /* 说明栈1已经是空栈，溢出 */
        *e = S-&gt;data[S-&gt;top1--]; /* 将栈1的栈顶元素出栈 */
    }
    else if (stackNumber == 2)
    {
        if (S-&gt;top2 == MAXSIZE)
            return ERROR; /* 说明栈2已经是空栈，溢出 */
        *e = S-&gt;data[S-&gt;top2++]; /* 将栈2的栈顶元素出栈 */
    }
    return OK;
}</code></pre>
<p>事实上，使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。就像买卖股票一样，你买入时，一定是有一个你不知道的人在做卖出操作。有人赚钱，就一定是有人赔钱。这样使用两栈共享空间存储方法才有比较大的意义。否则两个栈都在不停地增长，那很快就会因栈满而溢出了。  </p>
<h2 id="4-6-栈的链式存储结构及实现"><a href="#4-6-栈的链式存储结构及实现" class="headerlink" title="4.6 栈的链式存储结构及实现"></a>4.6 栈的链式存储结构及实现</h2><h3 id="4-6-1-栈的链式存储结构"><a href="#4-6-1-栈的链式存储结构" class="headerlink" title="4.6.1 栈的链式存储结构"></a>4.6.1 栈的链式存储结构</h3><p>栈的链式存储结构，简称为链栈。<br>链栈的结构代码如下：  </p>
<pre><code class="c">/* 链栈结构 */
typedef struct StackNode
{
    SElemType data;
    struct StackNode *next;
}StackNode,*LinkStackPtr;

typedef struct LinkStack
{
    LinkStackPtr top;
    int count;
}LinkStack;</code></pre>
<h3 id="4-6-2-栈的链式存储结构-进栈操作"><a href="#4-6-2-栈的链式存储结构-进栈操作" class="headerlink" title="4.6.2 栈的链式存储结构-进栈操作"></a>4.6.2 栈的链式存储结构-进栈操作</h3><p>对于链栈的进栈push操作，假设元素值为e的新结点是s，top为栈顶指针，示意图如图4-6-2所示代码如下。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-6-2.JPG?raw=true" alt="4-6-2">  </p>
<pre><code class="c">/* 插入元素e为新的栈顶元素 */
Status Push(LinkStack *S,SElemType e)
{
    LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode));
    s-&gt;data=e;
    s-&gt;next=S-&gt;top;/* 把当前的栈顶元素赋值给新结点的直接后继，见图中① */
    S-&gt;top=s;         /* 将新的结点s赋值给栈顶指针，见图中② */
    S-&gt;count++;
    return OK;
}</code></pre>
<h3 id="4-6-3-栈的链式存储结构——出栈操作"><a href="#4-6-3-栈的链式存储结构——出栈操作" class="headerlink" title="4.6.3 栈的链式存储结构——出栈操作"></a>4.6.3 栈的链式存储结构——出栈操作</h3><p>至于链栈的出栈pop操作，也是很简单的三句操作。假设变量p用来存储要删除的栈顶结点，将栈顶指针下移一位，最后释放p即可，如图4-6-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-6-3.JPG?raw=true" alt="4-6-3">  </p>
<pre><code class="c">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */
Status Pop(LinkStack *S,SElemType *e)
{
        LinkStackPtr p;
        if(StackEmpty(*S))
                return ERROR;
        *e=S-&gt;top-&gt;data;
        p=S-&gt;top;               /* 将栈顶结点赋值给p，见图中③ */
        S-&gt;top=S-&gt;top-&gt;next;    /* 使得栈顶指针下移一位，指向后一结点，见图中④ */
        free(p);                    /* 释放结点p */
        S-&gt;count--;
        return OK;
}</code></pre>
<p>链栈的进栈push和出栈pop操作都很简单，时间复杂度均是O(1)。<br>对比一下顺序栈与链栈，它们在时间复杂度上是一样的，均为O(1)。对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以它们的区别是如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。  </p>
<h2 id="4-7-栈的作用"><a href="#4-7-栈的作用" class="headerlink" title="4.7 栈的作用"></a>4.7 栈的作用</h2><p>栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。  </p>
<h2 id="4-8-栈的应用——递归"><a href="#4-8-栈的应用——递归" class="headerlink" title="4.8 栈的应用——递归"></a>4.8 栈的应用——递归</h2><h3 id="4-8-1-4-8-2递归定义"><a href="#4-8-1-4-8-2递归定义" class="headerlink" title="4.8.1-4.8.2递归定义"></a>4.8.1-4.8.2递归定义</h3><p>我们<strong>把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数</strong>。<br>当然，写递归程序最怕的就是陷入永不结束的无穷递归中，所以，<strong>每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出</strong>。  </p>
<h2 id="4-9-栈的应用——四则运算表达式求值"><a href="#4-9-栈的应用——四则运算表达式求值" class="headerlink" title="4.9 栈的应用——四则运算表达式求值"></a>4.9 栈的应用——四则运算表达式求值</h2><h3 id="4-9-1-后缀-逆波兰-表示法定义"><a href="#4-9-1-后缀-逆波兰-表示法定义" class="headerlink" title="4.9.1 后缀(逆波兰)表示法定义"></a>4.9.1 后缀(逆波兰)表示法定义</h3><p>栈的现实应用也很多，我们再来重点讲一个比较常见的应用：数学表达式的求值。<br>一种不需要括号的后缀表达法，我们也把它称为逆波兰(Reverse Polish Notation，RPN)表示。<br>我们先来看看，对于“<code>9+(3-1)×3+10÷2</code>”，如果要用后缀表示法应该是：“<code>9 3 1-3*+10 2/+</code>”，这样的表达式称为后缀表达式，叫后缀的原因在于<strong>所有的符号都是在要运算数字的后面出现</strong>。  </p>
<h3 id="4-9-2-后缀表达式计算结果"><a href="#4-9-2-后缀表达式计算结果" class="headerlink" title="4.9.2 后缀表达式计算结果"></a>4.9.2 后缀表达式计算结果</h3><p>后缀表达式：<code>9 3 1-3*+10 2/+</code><br>规则：<strong>从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</strong>  </p>
<h3 id="4-9-3-中缀表达式转后缀表达式"><a href="#4-9-3-中缀表达式转后缀表达式" class="headerlink" title="4.9.3 中缀表达式转后缀表达式"></a>4.9.3 中缀表达式转后缀表达式</h3><p>我们把平时所用的标准四则运算表达式，即“<code>9+(3-1)×3+10÷2</code>”叫做中缀表达式。因为所有的运算符号都在两数字的中间。<br>中缀表达式“<code>9+(3-1)×3+10÷2</code>”转化为后缀表达式“<code>9 3 1-3*+10 2/+</code>”。<br>规则：<strong>从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号(乘除优先加减)则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</strong>  </p>
<h2 id="4-10-队列的定义"><a href="#4-10-队列的定义" class="headerlink" title="4.10 队列的定义"></a>4.10 队列的定义</h2><p>队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。  </p>
<h2 id="4-11-队列的抽象数据类型"><a href="#4-11-队列的抽象数据类型" class="headerlink" title="4.11 队列的抽象数据类型"></a>4.11 队列的抽象数据类型</h2><pre><code class="c">ADT 队列(Queue)
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
    InitQueue(*Q)：初始化操作，建立一个空队列Q。
    DestroyQueue(*Q)：若队列Q存在，则销毁它。
    ClearQueue(*Q)：将队列Q清空。
    QueueEmpty(Q)：若队列Q为空，返回true，否则返回false。
    GetHead(Q，*e)：若队列Q存在且非空，用e返回队列Q的队头元素。
    EnQueue(*Q，e)：若队列Q存在，插入新元素e到队列Q中并成为队尾元素。
    DeQueue(*Q，*e)：删除队列Q中队头元素，并用e返回其值。
    QueueLength(Q)：返回队列Q的元素个数
endADT</code></pre>
<h2 id="4-12-循环队列"><a href="#4-12-循环队列" class="headerlink" title="4.12 循环队列"></a>4.12 循环队列</h2><h3 id="4-12-1-队列顺序存储的不足"><a href="#4-12-1-队列顺序存储的不足" class="headerlink" title="4.12.1 队列顺序存储的不足"></a>4.12.1 队列顺序存储的不足</h3><p>入队的时间复杂度为O(1)。<br>与栈不同的是，队列元素的出列是在队头，即下标为0的位置，那也就意味着，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为0的位置不为空，此时时间复杂度为出队的时间复杂度为O(n)，效率太低。<br>如果队列前面的位置空的，后面的位置排满了，那么新进的元素可以排到前面，这就引进了循环队列的概念。<br>为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列是空队列。  </p>
<h3 id="4-12-2-循环队列定义"><a href="#4-12-2-循环队列定义" class="headerlink" title="4.12.2 循环队列定义"></a>4.12.2 循环队列定义</h3><p>队列中头尾相接的顺序存储结构称为循环队列。<br>此时问题又出来了，空队列时，front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？</p>
<ol>
<li>办法一是设置一个标志变量flag，当<code>front==rear</code>，且flag=0时为队列空，当<code>front==rear</code>，且flag=1时为队列满。</li>
<li>办法二是当队列空时，条件就是<code>front=rear</code>，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。<br>我们重点来讨论第二种方法，由于rear可能比front大，也可能比front小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的最大尺寸为QueueSize，那么队列满的条件是“<code>(rear+1)%QueueSize==front</code>”(取模“%”的目的就是为了整合rear与front大小为一个问题)。<br>通用的计算队列长度公式为：<code>(rear-front+QueueSize)%QueueSize</code>。<br>循环队列的顺序存储结构代码如下：</li>
</ol>
<pre><code class="c">typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */
/* 循环队列的顺序存储结构 */
typedef struct
{
    QElemType data[MAXSIZE];
    int front;      /* 头指针 */
    int rear;       /* 尾指针，若队列不空，指向队列尾元素的下一个位置 */
}SqQueue;</code></pre>
<p>循环队列的初始化代码如下：</p>
<pre><code class="c">/* 初始化一个空队列Q */
Status InitQueue(SqQueue *Q)
{
    Q-&gt;front = 0;
    Q-&gt;rear = 0;
    return  OK;
}</code></pre>
<p>循环队列求队列长度代码如下：</p>
<pre><code class="c">/* 返回Q的元素个数，也就是队列的当前长度 */
int QueueLength(SqQueue Q)
{
    return  (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
}</code></pre>
<p>循环队列的入队列操作代码如下：</p>
<pre><code class="c">/* 若队列未满，则插入元素e为Q新的队尾元素 */
Status EnQueue(SqQueue *Q, QElemType e)
{
    if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front)    /* 队列满的判断 */
        return ERROR;
    Q-&gt;data[Q-&gt;rear] = e;               /* 将元素e赋值给队尾 */
    Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE;/* rear指针向后移一位置， */
                                      /* 若到最后则转到数组头部 */
    return  OK;
}</code></pre>
<p>循环队列的出队列操作代码如下：</p>
<pre><code class="c">/* 若队列不空，则删除Q中队头元素，用e返回其值 */
Status DeQueue(SqQueue *Q, QElemType *e)
{
    if (Q-&gt;front == Q-&gt;rear)            /* 队列空的判断 */
        return ERROR;
    *e = Q-&gt;data[Q-&gt;front];                /* 将队头元素赋值给e */
    Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;    /* front指针向后移一位置 */
                                    /* 若到最后则转到数组头部 */
    return  OK;
}</code></pre>
<h2 id="4-13-队列的链式存储结构及实现"><a href="#4-13-队列的链式存储结构及实现" class="headerlink" title="4.13 队列的链式存储结构及实现"></a>4.13 队列的链式存储结构及实现</h2><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。<br>为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点，如图4-13-1所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-1.JPG?raw=true" alt="4-13-1"><br>空队列时，front和rear都指向头结点，如图4-13-2所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-2.JPG?raw=true" alt="4-13-2"><br>链队列的结构为：  </p>
<pre><code class="c">typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */

typedef struct QNode    /* 结点结构 */
{
    QElemType data;
    struct QNode *next;
}QNode, *QueuePtr;

typedef struct            /* 队列的链表结构 */
{
    QueuePtr front, rear; /* 队头、队尾指针 */
}LinkQueue;</code></pre>
<h3 id="4-13-1-队列的链式存储结构——入队操作"><a href="#4-13-1-队列的链式存储结构——入队操作" class="headerlink" title="4.13.1 队列的链式存储结构——入队操作"></a>4.13.1 队列的链式存储结构——入队操作</h3><p>入队操作时，其实就是在链表尾部插入结点，如图4-13-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-3.JPG?raw=true" alt="4-13-3"><br>入队代码如下：</p>
<pre><code class="c">/* 插入元素e为Q的新的队尾元素 */
Status EnQueue(LinkQueue *Q, QElemType e)
{
    QueuePtr s = (QueuePtr)malloc(sizeof(QNode));
    if (!s) /* 存储分配失败 */
        exit(OVERFLOW);
    s-&gt;data = e;
    s-&gt;next = NULL;
    Q-&gt;rear-&gt;next = s;    /* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */
    Q-&gt;rear = s;        /* 把当前的s设置为队尾结点，rear指向s，见图中② */
    return OK;
}</code></pre>
<h3 id="4-13-2-队列的链式存储结构——出队操作"><a href="#4-13-2-队列的链式存储结构——出队操作" class="headerlink" title="4.13.2 队列的链式存储结构——出队操作"></a>4.13.2 队列的链式存储结构——出队操作</h3><p>出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将rear指向头结点，如图4-13-4所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-4.JPG?raw=true" alt="4-13-4">  </p>
<p>出队代码如下：</p>
<pre><code class="c">/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */
Status DeQueue(LinkQueue *Q, QElemType *e)
{
    QueuePtr p;
    if (Q-&gt;front == Q-&gt;rear)
        return ERROR;
    p = Q-&gt;front-&gt;next;        /* 将欲删除的队头结点暂存给p，见图中① */
    *e = p-&gt;data;                /* 将欲删除的队头结点的值赋值给e */
    Q-&gt;front-&gt;next = p-&gt;next;/* 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中② */
    if (Q-&gt;rear == p)/* 空队列的时候 */ /* 若队头就是队尾，则删除后将rear指向头结点，见图中③ */
        Q-&gt;rear = Q-&gt;front;
    free(p);
    return OK;
}</code></pre>
<p>对于循环队列与链队列的比较，可以从两方面来考虑，从时间上，其实它们的基本操作都是常数时间，即都为O(1)的，不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。对于空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。<br>总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。  </p>
<h2 id="4-14-总结回顾"><a href="#4-14-总结回顾" class="headerlink" title="4.14 总结回顾"></a>4.14 总结回顾</h2><p>这一章讲的是栈和队列，它们都是特殊的线性表，只不过对插入和删除操作做了限制。<br>栈(stack)是限定仅在表尾进行插入和删除操作的线性表。<br>队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。因此它们各自有各自的技巧来解决这个问题。<br>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。<br>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。<br>它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同如图4-14-1所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-14-1.JPG?raw=true" alt="4-14-1">  </p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构第三章 线性表</title>
    <url>/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC3%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<p>线性表：零个或多个数据元素的有限序列。</p>
<h2 id="3-1-3-2线性表的定义"><a href="#3-1-3-2线性表的定义" class="headerlink" title="3.1-3.2线性表的定义"></a>3.1-3.2线性表的定义</h2><p>线性表（List）：零个或多个数据元素的有限序列。</p>
<p>若将线性表记为（a_1，…，a_(i−1)，a_i，a_(i+1)，…，a_n），则表中a_(i−1) 领先于a_i，a_i 领先于a_(i+1)，称a_(i−1) 是a_i 的直接前驱元素，a_(i+1) 是a_i 的直接后继元素。当i=1，2，…，n-1时，a_i 有且仅有一个直接后继，当i=2，3，…，n时，a_i 有且仅有一个直接前驱。<br>如图3-2-1所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.2.1.GIF?raw=true" alt="3-2-1"></p>
<p>所以线性表元素的个数n（n&gt;0）定义为线性表的长度，当n=0时，称为空表。<br>在较复杂的线性表中，一个数据元素可以由若干个数据项组成。</p>
<a id="more"></a>
<h2 id="3-3线性表的抽象数据类型"><a href="#3-3线性表的抽象数据类型" class="headerlink" title="3.3线性表的抽象数据类型"></a>3.3线性表的抽象数据类型</h2><p>线性表的抽象数据类型定义如下：</p>
<pre><code class="c">ADT线性表（List）
Data
    线性表的数据对象集合为{a1，a2…，an），每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
Operation
    InitList（*L）；初始化操作，建立一个空的线性表L。
    ListEmpty（L）；若线性表为空，返回true，否则返回false。
    ClearList（*L）；将线性表清空。
    GetElem（L，i，*e）；将线性表L中的第i个位置元素值返回给e。
    LocateElem（L，e）；在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。
    ListInsert（*L，i，e）；在线性表L中的第i个位置插入新元素e。
    ListDelete（*L，i，*e）；删除线性表L中第i个位置元素，并用e返回其值。
    ListLength（L）；返回线性表L的元素个数。
endADT</code></pre>
<h3 id="3-3-1两个线性表集合的并集操作"><a href="#3-3-1两个线性表集合的并集操作" class="headerlink" title="3.3.1两个线性表集合的并集操作"></a>3.3.1两个线性表集合的并集操作</h3><p>要使得集合A=AUB。说白了，就是把存在集合B中但并不存在A中的数据元素插入到A中即可。<br>仔细分析一下这个操作，发现我们只要循环集合B中的每个元素，判断当前元素是否存在A中，若不存在，则插入到A中即可。思路应该是很容易想到的。<br>我们假设La表示集合A，Lb表示集合B，则实现的代码如下：</p>
<pre><code class="c">    /*将所有的在线性表Lb中但不在La中的数据元素插入到La中*/
    void unionL(SqList *La, SqList Lb)
    {
        int La_len, Lb_len, i;
        ElemType e;                          /*声明与La和Lb相同的数据元素e*/
        La_len = ListLength(*La);                /*求线性表的长度*/
        Lb_len = ListLength(Lb);
        for (i = 1; i &lt;= Lb_len; i++)
        {
            GetElem(Lb, i, &amp;e);           /*取Lb中第i个数据元素赋给e*/
            if (!LocateElem(*La, e))           /*La中不存在和e相同数据元素*/
                ListInsert(La, ++La_len, e);          /*插入*/
        }
    }</code></pre>
<h2 id="3-4线性表的顺序存储结构"><a href="#3-4线性表的顺序存储结构" class="headerlink" title="3.4线性表的顺序存储结构"></a>3.4线性表的顺序存储结构</h2><h3 id="3-4-1顺序存储定义"><a href="#3-4-1顺序存储定义" class="headerlink" title="3.4.1顺序存储定义"></a>3.4.1顺序存储定义</h3><p>线性表的两种物理结构的第一种——顺序存储结构。<br>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p>
<h3 id="3-4-2顺序存储方式"><a href="#3-4-2顺序存储方式" class="headerlink" title="3.4.2顺序存储方式"></a>3.4.2顺序存储方式</h3><p>可以用C语言（其他语言也相同）的一维数组来实现顺序存储结构。<br>线性表的顺序存储的结构代码如下</p>
<pre><code class="c">    #define MAXSIZE 20/*存储空间初始分配量*/
    typedef int ElemType;  /*ElemType 类型根据实际情况而定，这里假设为int*/
    typedef struct
    {
        ElemType data[MAXSIZE];/*数组存储数据元素，最大值为MAXSIZE*/
        int length;  /*线性表当前长度*/
    }SqList;</code></pre>
<p>这里，我们就发现描述顺序存储结构需要三个属性：<br>    • 存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。<br>    • 线性表的最大存储容量：数组长度MaxSize。<br>    • 线性表的当前长度：length。</p>
<h3 id="3-4-3数据长度与线性表长度区别"><a href="#3-4-3数据长度与线性表长度区别" class="headerlink" title="3.4.3数据长度与线性表长度区别"></a>3.4.3数据长度与线性表长度区别</h3><p>数组的长度是存放线性表的存储空间的长度，存储分配后这个量是一般是不变的。<br>线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。<br>在任意时刻，线性表的长度应该小于等于数组的长度。</p>
<h3 id="3-4-4地址计算方法"><a href="#3-4-4地址计算方法" class="headerlink" title="3.4.4地址计算方法"></a>3.4.4地址计算方法</h3><p>存储器中的每个存储单元都有自己的编号，这个编号称为地址。<br>假设占用的是c个存储单元，那么线性表中第i+1个数据元素的存储位置和第i个数据元素的存储位置满足下列关系（LOC表示获得存储位置的函数）。<br>    LOC（a_(i+1)）=LOC（a_i）+c<br>所以对于第i个数据元素ai的存储位置可以由a1推算得出：<br>    LOC（a_i）=LOC（a_1）+（i-1）*c</p>
<h2 id="3-5顺序存储结构的插入与删除"><a href="#3-5顺序存储结构的插入与删除" class="headerlink" title="3.5顺序存储结构的插入与删除"></a>3.5顺序存储结构的插入与删除</h2><h3 id="3-5-1获得元素操作"><a href="#3-5-1获得元素操作" class="headerlink" title="3.5.1获得元素操作"></a>3.5.1获得元素操作</h3><p>我们要实现GetElem操作，即将线性表L中的第i个位置元素值返回。只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。</p>
<pre><code class="c">    #define OK 1
    #define ERROR 0
    #define TRUE 1
    #define FALSE 0
    typedef int Status;          /* Status是函数的类型,其值是函数结果状态代码，如OK等 */
    /* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
    /* 操作结果：用e返回L中第i个数据元素的值,注意i是指位置，第1个位置的数组是从0开始 */
    Status GetElem(SqList L, int i, ElemType *e)
    {
        if (L.length == 0 || i&lt;1 || i&gt;L.length)
            return ERROR;
        *e = L.data[i - 1];
        return OK;
    }</code></pre>
<h3 id="3-5-2插入操作"><a href="#3-5-2插入操作" class="headerlink" title="3.5.2插入操作"></a>3.5.2插入操作</h3><p>插入算法的思路：<br>    • 如果插入位置不合理，抛出异常；<br>    • 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；<br>    • 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；<br>    • 将要插入元素填入位置i处；<br>    • 表长加1。<br>实现代码如下：</p>
<pre><code class="c">    /* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */
    /* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */
    Status ListInsert(SqList *L, int i, ElemType e)
    {
        int k;
        if (L-&gt;length == MAXSIZE)  /* 顺序线性表已经满 */
            return ERROR;
        if (i&lt;1 || i&gt;L-&gt;length + 1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */
            return ERROR;
        if (i &lt;= L-&gt;length)        /* 若插入数据位置不在表尾 */
        {
            for (k = L-&gt;length - 1; k &gt;= i - 1; k--)  /* 将要插入位置之后的数据元素向后移动一位 */
                L-&gt;data[k + 1] = L-&gt;data[k];
        }
        L-&gt;data[i - 1] = e;          /* 将新元素插入 */
        L-&gt;length++;
        return OK;
    }</code></pre>
<h3 id="3-5-3删除操作"><a href="#3-5-3删除操作" class="headerlink" title="3.5.3删除操作"></a>3.5.3删除操作</h3><p>删除算法的思路：<br>    • 如果删除位置不合理，抛出异常；<br>    • 取出删除元素；<br>    • 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；<br>    • 表长减1。<br>实现代码如下：</p>
<pre><code class="c">    /* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
    /* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */
    Status ListDelete(SqList *L, int i, ElemType *e)
    {
        int k;
        if (L-&gt;length == 0)               /* 线性表为空 */
            return ERROR;
        if (i&lt;1 || i&gt;L-&gt;length)         /* 删除位置不正确 */
            return ERROR;
        *e = L-&gt;data[i - 1];
        if (i &lt; L-&gt;length)                /* 如果删除不是最后位置 */
        {
            for (k = i; k &lt; L-&gt;length; k++)/* 将删除位置后继元素前移 */
                L-&gt;data[k - 1] = L-&gt;data[k];
        }
        L-&gt;length--;
        return OK;
    }</code></pre>
<p>线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O（1）；而插入或删除时，时间复杂度都是O（n）。</p>
<h3 id="3-5-4线性表顺序存储结构的优缺点"><a href="#3-5-4线性表顺序存储结构的优缺点" class="headerlink" title="3.5.4线性表顺序存储结构的优缺点"></a>3.5.4线性表顺序存储结构的优缺点</h3><p>线性表的顺序存储结构的优缺点如图3-5-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.5.3.GIF?raw=true" alt="3-5-3"></p>
<h3 id="3-6线性表的链式存储结构"><a href="#3-6线性表的链式存储结构" class="headerlink" title="3.6线性表的链式存储结构"></a>3.6线性表的链式存储结构</h3><h3 id="3-6-2线性表链式存储结构定义"><a href="#3-6-2线性表链式存储结构定义" class="headerlink" title="3.6.2线性表链式存储结构定义"></a>3.6.2线性表链式存储结构定义</h3><p>为了表示每个数据元素a_i 与其直接后继数据元素a_(i+1) 之间的逻辑关系，对数据元素a1来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素a_i 的存储映像，称为结点（Node）。<br>n个结点（a_i 的存储映像）链结成一个链表，即为线性表（a_1，a_2，…，a_n）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。<br>我们把链表中第一个结点的存储位置叫做头指针,线性链表的最后一个结点指针为“空”（通常用NULL或“^”符号表示）。<br>有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息。</p>
<h3 id="3-6-3头指针与头结点的异同"><a href="#3-6-3头指针与头结点的异同" class="headerlink" title="3.6.3头指针与头结点的异同"></a>3.6.3头指针与头结点的异同</h3><p><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.6.3.GIF?raw=true" alt="3-6-3"></p>
<h3 id="3-6-4线性表链式存储结构代码描述"><a href="#3-6-4线性表链式存储结构代码描述" class="headerlink" title="3.6.4线性表链式存储结构代码描述"></a>3.6.4线性表链式存储结构代码描述</h3><pre><code class="c">//线性表的单链表存储结构
typedef struct Node
{
    ElemType data;
    struct Node *next;
}Node;
typedef struct Node *LinkList;/* 定义LinkList */</code></pre>
<p>节点Node是由存放数据元素的数据域和存放后继节点地址的指针域组成。  </p>
<h2 id="3-7单链表的读取"><a href="#3-7单链表的读取" class="headerlink" title="3.7单链表的读取"></a>3.7单链表的读取</h2><p>获得链表第i个的数据的算法思路：  </p>
<ol>
<li>声明一个结点p指向链表第一个结点，初始化j从1开始;  </li>
<li>当<code>j&lt;i</code>时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1;  </li>
<li>若到链表末尾p为空，则说明第i个元素不存在;  </li>
<li>否则查找成功，返回结点p的数据。  </li>
</ol>
<p>实现代码算法如下：</p>
<pre><code class="c">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
/* 操作结果：用e返回L中第i个数据元素的值 */
Status GetElem(LinkList L,int i,ElemType *e)
{
    int j;
    LinkList p;  /* 声明一结点p */
    p = L-&gt;next;  /* 让p指向链表L的第一个结点 */
    j = 1;        /*  j为计数器 */
    while (p &amp;&amp; j&lt;i)  /* p不为空或者计数器j还没有等于i时，循环继续 */
    {
        p = p-&gt;next;  /* 让p指向下一个结点 */
        ++j;
    }
    if ( !p || j&gt;i )
        return ERROR;  /*  第i个元素不存在 */
    *e = p-&gt;data;   /*  取第i个元素的数据 */
    return OK;
}</code></pre>
<p>这个算法的最坏情况时间复杂度为O(n)。  </p>
<h2 id="3-8-单链表的插入和删除"><a href="#3-8-单链表的插入和删除" class="headerlink" title="3.8 单链表的插入和删除"></a>3.8 单链表的插入和删除</h2><h3 id="3-8-1-单链表的插入"><a href="#3-8-1-单链表的插入" class="headerlink" title="3.8.1 单链表的插入"></a>3.8.1 单链表的插入</h3><p><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.8.1.GIF?raw=true" alt="图3-8-1"><br>假设上一个结点是p，下一个结点是p-&gt;next,现在要把结点s插入这两个结点中去。只需要2行代码：<br><code>s-&gt;next=p-&gt;next;//先让s的指针域指向p-&gt;next</code><br><code>p-&gt;next=s;//把s的地址赋给p的指针域</code></p>
<p>ps:这两句顺序不能交换。<br>如果先<code>p-&gt;next=s</code>;再<code>s-&gt;next=p-&gt;next</code>;就等于<code>s-&gt;next=s</code>;<br>所以这2句如论如何都不能反，这点初学者一定要注意。  </p>
<p>单链表第i个数据插入结点的算法思路：</p>
<ol>
<li>声明一结点p指向链表第一个结点，初始化j从1开始;</li>
<li>当j&lt;1时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1;</li>
<li>若到链表末尾p为空，则说明第i个元素不存在;</li>
<li>否则查找成功，在系统中生成一个空结点s;</li>
<li>将数据元素e赋值给<code>s-&gt;data</code>;</li>
<li>单链表的插入标准语句<code>s-&gt;next=p-&gt;next;p-&gt;next=s;</code>;</li>
<li>返回成功;  </li>
</ol>
<p>实现代码算法如下:</p>
<pre><code class="c">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */
/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */
Status ListInsert(LinkList *L,int i,ElemType e)
{
    int j;
    LinkList p,s;
    p = *L;
    j = 1;
    while (p &amp;&amp; j &lt; i)     /* 寻找第i个结点 */
    {
        p = p-&gt;next;
        ++j;
    }
    if (!p || j &gt; i)
        return ERROR;   /* 第i个元素不存在 */
    s = (LinkList)malloc(sizeof(Node));  /*  生成新结点(C语言标准函数) */
    s-&gt;data = e;  
    s-&gt;next = p-&gt;next;      /* 将p的后继结点赋值给s的后继  */
    p-&gt;next = s;          /* 将s赋值给p的后继 */
    return OK;
}</code></pre>
<h3 id="3-8-2-单链表的删除"><a href="#3-8-2-单链表的删除" class="headerlink" title="3.8.2 单链表的删除"></a>3.8.2 单链表的删除</h3><p><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.8.5.GIF?raw=true" alt="3-8-5"><br>要删除节点q，其实就是要让<code>p-&gt;next=q-&gt;next</code>;<br>单链表第i个数据删除结点的算法思路：</p>
<ol>
<li>声明一结点p指向链表第一个结点，初始化j从1开始</li>
<li>当<code>j&lt;i</code>时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；</li>
<li>若到链表末尾p为空，则说明第i个元素不存在；</li>
<li>否则查找成功，将欲删除的结点<code>p-&gt;next</code>赋值给q；</li>
<li>单链表的删除标准语句<code>p-&gt;next=q-&gt;next</code>；</li>
<li>将q结点中的数据赋值给e，作为返回；</li>
<li>释放q结点；</li>
<li>返回成功。  </li>
</ol>
<p>实现代码算法如下：</p>
<pre><code class="c">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */
Status ListDelete(LinkList *L,int i,ElemType *e)
{
    int j;
    LinkList p,q;
    p = *L;
    j = 1;
    while (p-&gt;next &amp;&amp; j &lt; i)    /* 遍历寻找第i个元素 */
    {
        p = p-&gt;next;
        ++j;
    }
    if (!(p-&gt;next) || j &gt; i)
        return ERROR;           /* 第i个元素不存在 */
    q = p-&gt;next;              //q结点指向要删除的结点（即要删除的结点地址赋值给q）
    p-&gt;next = q-&gt;next;            /* 将q的后继(第三个结点)赋值给p的后继 */
    *e = q-&gt;data;               /* 将q结点中的数据给e */
    free(q);                    /* 让系统回收此结点，释放内存 */
    return OK;
}</code></pre>
<p>分析一下刚才我们讲解的单链表插入和删除算法，我们很容易推导出：它们的时间复杂度都是O（n）。<br>显然，对于<strong>插入或删除数据越频繁的操作，单链表的效率优势就越是明显</strong>。</p>
<h2 id="3-9单链表的整表创建"><a href="#3-9单链表的整表创建" class="headerlink" title="3.9单链表的整表创建"></a>3.9单链表的整表创建</h2><p>单链表整表创建的算法思路：</p>
<ol>
<li>声明一结点p和计数器变量i；</li>
<li>初始化一空链表L；</li>
<li>让L的头结点的指针指向NULL，即建立一个带头结点的单链表；</li>
<li>循环：<ul>
<li>生成一新结点赋值给p；</li>
<li>随机生成一数字赋值给p的数据域p&gt;data；  </li>
<li>将p插入到头结点与前一新结点之间。  </li>
</ul>
</li>
</ol>
<p>实现头插法的代码算法如下(这段算法代码里,我们用插队的办法，始终让新结点在第一的位置。这种算法简称为头插法)：</p>
<pre><code class="c">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */
void CreateListHead(LinkList *L, int n)
{
    LinkList p;
    int i;
    srand(time(0));                         /* 初始化随机数种子 */
    *L = (LinkList)malloc(sizeof(Node));
    (*L)-&gt;next = NULL;                      /*  先建立一个带头结点的单链表 */
    for (i=0; i&lt;n; i++)
    {
        p = (LinkList)malloc(sizeof(Node)); /*  生成新结点 */
        p-&gt;data = rand()%100+1;             /*  随机生成100以内的数字 */
        p-&gt;next = (*L)-&gt;next;
        (*L)-&gt;next = p;                        /*  插入到表头 */
    }
}</code></pre>
<p>事实上，我们一般插队都是放在最后的。如果我们把每次的新结点都插在终端结点的后面，这种算法称之为尾插法。  </p>
<p>实现尾插法代码算法如下：</p>
<pre><code class="c">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */
void CreateListTail(LinkList *L, int n)
{
    LinkList p,r;
    int i;
    srand(time(0));                      /* 初始化随机数种子 */
    *L = (LinkList)malloc(sizeof(Node)); /* L为整个线性表 */
    r=*L;                                /* r为指向尾部的结点 */
    for (i=0; i&lt;n; i++)
    {
        p = (Node *)malloc(sizeof(Node)); /*  生成新结点 */
        p-&gt;data = rand()%100+1;           /*  随机生成100以内的数字 */
        r-&gt;next=p;                        /* 将表尾终端结点的指针指向新结点 */
        r = p;                            /* 将当前的新结点定义为表尾终端结点 */
    }
    r-&gt;next = NULL;                       /* 表示当前链表结束 */
}</code></pre>
<p>PS：这里需解释一下，<code>r-&gt;next=p</code>的意思，其实就是将刚才的表尾终端结点r的指针指向新结点p，如图3-9-2所示，当中①位置的连线就是表示这个意思。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.9.2.GIF?raw=true" alt="3-9-2"><br><code>r=p</code>的意思请看图3-9-3，就是本来r是a_(i-1)元素的结点，现在它已经不是最后的结点了，现在最后的结点是a_i，所以应该将p结点这个最后的结点赋值给r。此时r又是最终的尾结点了。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.9.3.GIF?raw=true" alt="3-9-3">  </p>
<p>循环结束后，那么应该让这个链表的指针域置空，因此有了<code>r-&gt;next=NULL</code>，以便以后遍历时可以确认其是尾部。  </p>
<h2 id="3-10单链表的整表删除"><a href="#3-10单链表的整表删除" class="headerlink" title="3.10单链表的整表删除"></a>3.10单链表的整表删除</h2><p>单链表整表删除的算法思路如下：</p>
<ol>
<li>声明一结点p和q；</li>
<li>将第一个结点赋值给p；</li>
<li>循环：<ul>
<li>将下一结点赋值给q；</li>
<li>释放p；将q赋值给p。  </li>
</ul>
</li>
</ol>
<p>实现代码算法如下：  </p>
<pre><code class="c">/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */
Status ClearList(LinkList *L)
{
    LinkList p,q;
    p=(*L)-&gt;next;           /*  p指向第一个结点 */
    while(p)                /*  没到表尾 */
    {
        q=p-&gt;next;   //下一个结点地址赋值给临时结点q
        free(p);     //释放p结点内存
        p=q;         //临时结点q的地址赋值给p，使p能够指向继续指向下一个结点
    }
    (*L)-&gt;next=NULL;        /* 头结点指针域为空 */
    return OK;
}</code></pre>
<h2 id="3-11单链表结构与顺序存储结构优缺点"><a href="#3-11单链表结构与顺序存储结构优缺点" class="headerlink" title="3.11单链表结构与顺序存储结构优缺点"></a>3.11单链表结构与顺序存储结构优缺点</h2><p>简单地对单链表结构和顺序存储结构做对比,如图3-11-1：<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.11.1.GIF?raw=true" alt="3-11-1">  </p>
<p>通过上面的对比，我们可以得出一些经验性的结论：</p>
<ul>
<li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。</li>
<li>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。  </li>
</ul>
<p>总之，线性表的顺序存储结构和单链表结构各有其优缺点，不能简单的说哪个好，哪个不好，需要根据实际情况，来综合平衡采用哪种数据结构更能满足和达到需求和性能。  </p>
<h2 id="3-12静态链表"><a href="#3-12静态链表" class="headerlink" title="3.12静态链表"></a>3.12静态链表</h2><p>静态链表是由数组组成。<br>我们让数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下标都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而游标cur相当于单链表中的next 指针，存放该元素的后继在数组中的下标。<br>我们把这种用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。<br>静态链表的结构定义如下：  </p>
<pre><code class="c">/* 线性表的静态链表存储结构 */
typedef struct
{
    ElemType data;
    int cur;  /* 游标(Cursor) ，为0时表示无指向 */
} Component,StaticLinkList[MAXSIZE];</code></pre>
<p>另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据。我们通常把未被使用的数组元素称为备用链表。而数组第一个元素，即<strong>下标为0的元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标</strong>，相当于单链表中的头结点作用，当整个链表为空时，则为0<sup>2</sup>。如图3-12-1所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.12.1.GIF?raw=true" alt="3-12-1">  </p>
<p>初始化数组状态，代码如下：  </p>
<pre><code class="c">/* 将一维数组space中各分量链成一个备用链表，space[0].cur为头指针，&quot;0&quot;表示空指针 */
Status InitList(StaticLinkList space)
{
    int i;
    for (i=0; i&lt;MAXSIZE-1; i++)  
        space[i].cur = i+1;
    space[MAXSIZE-1].cur = 0; /* 目前静态链表为空，最后一个元素的cur为0 */
    return OK;
}</code></pre>
<h3 id="3-12-1静态链表的插入操作"><a href="#3-12-1静态链表的插入操作" class="headerlink" title="3.12.1静态链表的插入操作"></a>3.12.1静态链表的插入操作</h3><p>在静态链表中，需要我们自己实现结点的申请和释放这2个函数，才可以做插入和删除的操作。<br>为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。  </p>
<pre><code class="c">/* 若备用空间链表非空，则返回分配的结点下标，否则返回0 */
int Malloc_SSL(StaticLinkList space)
{
    int i = space[0].cur;                   /* 当前数组第一个元素的cur存的值 */
                                            /* 就是要返回的第一个备用空闲的下标 */
    if (space[0]. cur)
        space[0]. cur = space[i].cur;       /* 由于要拿出一个分量来使用了， */
                               ll             /* 所以我们就得把它的下一个 */
                                            /* 分量用来做备用 */
    return i;
}</code></pre>
<p>这段代码有意思，它的作用就是返回一个下标值，这个值就是数组头元素的cur存的第一个空闲的下标,同时把这个空闲的下标给<code>space[0].cur</code>，之后就可以继续分配新的空闲分量，实现类似mallbc（）函数的作用。<br>插入操作的实现代码如下：  </p>
<pre><code class="c">/*  在L中第i个元素之前插入新的数据元素e   */
Status ListInsert(StaticLinkList L, int i, ElemType e)
{  
    int j, k, l;
    k = MAXSIZE - 1;   /* 注意k首先是最后一个元素的下标 */
    if (i &lt; 1 || i &gt; ListLength(L) + 1)
        return ERROR;
    j = Malloc_SSL(L);   /* 获得空闲分量的下标 */
    if (j)
    {
        L[j].data = e;   /* 将数据赋值给此分量的data */
        for(l = 1; l &lt;= i - 1; l++)   /* 找到第i个元素之前的位置 */
           k = L[k].cur;
        L[j].cur = L[k].cur;    /* 把第i个元素之前的cur赋值给新元素的cur */
        L[k].cur = j;           /* 把新元素的下标赋值给第i个元素之前元素的ur */
        return OK;
    }
    return ERROR;
}</code></pre>
<h3 id="3-12-2静态链表的删除操作"><a href="#3-12-2静态链表的删除操作" class="headerlink" title="3.12.2静态链表的删除操作"></a>3.12.2静态链表的删除操作</h3><p>删除元素时，实现的代码如下：  </p>
<pre><code class="c">/*  删除在L中第i个数据元素   */
Status ListDelete(StaticLinkList L, int i)
{
    int j, k;
    if (i &lt; 1 || i &gt; ListLength(L))
        return ERROR;
    k = MAXSIZE - 1;
    for (j = 1; j &lt;= i - 1; j++)
        k = L[k].cur;
    j = L[k].cur;
    L[k].cur = L[j].cur;
    Free_SSL(L, j);
    return OK;
}</code></pre>
<p>释放结点的函数代码如下：  </p>
<pre><code class="c">/*  将下标为k的空闲结点回收到备用链表 */
void Free_SSL(StaticLinkList space, int k)
{  
    space[k].cur = space[0].cur;    /* 把第一个元素的cur值赋给要删除的分量cur */
    space[0].cur = k;               /* 把要删除的分量下标赋值给第一个元素的cur */
}</code></pre>
<p>返回静态链表长度的代码实现如下：  </p>
<pre><code class="c">/* 初始条件：静态链表L已存在。操作结果：返回L中数据元素个数 */
int ListLength(StaticLinkList L)
{
    int j=0;
    int i=L[MAXSIZE-1].cur;
    while(i)
    {
        i=L[i].cur;
        j++;
    }
    return j;
}</code></pre>
<h3 id="3-12-3静态链表优缺点"><a href="#3-12-3静态链表优缺点" class="headerlink" title="3.12.3静态链表优缺点"></a>3.12.3静态链表优缺点</h3><p>总结一下静态链表的优缺点（见图3-12-5）：<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.12.5.GIF?raw=true" alt="3-12-5"><br>总的来说，静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。尽管大家不一定会用得上，但这样的思考方式是非常巧妙的，应该理解其思想，以备不时之需。  </p>
<h2 id="3-13循环链表"><a href="#3-13循环链表" class="headerlink" title="3.13循环链表"></a>3.13循环链表</h2><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。<br>其实循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断<code>p-&gt;next</code>是否为空，现在则是<code>p-&gt;next</code>不等于头结点，则循环未结束。<br>在单链表中，我们有了头结点时，我们可以用O（1）的时间访问第一个结点，但如果想要用O（1）的时间访问到最后一个结点，则需要改造一下这个循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表（如图3-13-5）。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.5.GIF?raw=true" alt="3-13-5"><br>从上图可以看出，终端结点用尾指针rear指示，则查找终端结点是O（1），而开始结点，其实就是<code>rear-&gt;next-&gt;next</code>，其时间复杂也为O（1）。<br>举个程序的例子，要将两个循环链表合并成一个表时，有了尾指针就非常简单了。比如下面的这两个循环链表，它们的尾指针分别是rearA和rearB，如图3-13-6所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.6.GIF?raw=true" alt="3-13-6"><br>要想把它们合并，只需要如下的操作即可，如图3-13-7所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.7.GIF?raw=true" alt="3-13-7"><br>具体代码如下：  </p>
<pre><code class="c">p=rearA-&gt;next;     /*保存A表的头结点，即①*/
rearA-&gt;next=rearB-&gt;next-&gt;next;     /*将本是指向B表的第一个结点（不是头结点）赋值给reaA-&gt;next,即②*/
rearB-&gt;next=p;/*将原A表的头结点赋值给rearB-&gt;next，即③**/
free(p);/*释放p*/</code></pre>
<h2 id="3-14双向链表"><a href="#3-14双向链表" class="headerlink" title="3.14双向链表"></a>3.14双向链表</h2><p>双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。<br>所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。  </p>
<pre><code class="c">/*线性表的双向链表存储结构*/
typedef struct DulNode
{
    ElemType data；
    struct DuLNode *prior；/*直接前驱指针*/
    struct DuLNode *next；/*直接后继指针*/
}DulNode，*DuLinkList；</code></pre>
<p>既然单链表也可以有循环链表，那么双向链表当然也可以是循环表。<br>双向链表的循环带头结点的空链表如图3-14-3所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.3.GIF?raw=true" alt="3-14-3"><br>非空的循环的带头结点的双向链表如图3-14-4所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.4.GIF?raw=true" alt="3-14-4"><br>PS：双向链表在插入和删除时，需要更改两个指针变量。<br>插入操作时，其实并不复杂，不过<strong>顺序很重要，千万不能写反了</strong>。<br>我们现在假设存储元素e的结点为s，要实现将结点s插入到结点p和<code>p-&gt;next</code>之间需要下面几步，如图3-14-5所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.5.GIF?raw=true" alt="3-14-5">  </p>
<pre><code class="c">s-&gt;prior=p;/*把p赋值给s的前驱，如图中①*/
s-&gt;next=p-&gt;next;/*把p-&gt;next赋值给s的后继，如图中②*/
p-&gt;next-&gt;prior=s;/*把s赋值给p-&gt;next的前驱，如图中③*/
p-&gt;next=s;/*把s赋值给p的后继，如图中④*/</code></pre>
<p>关键在于它们的顺序，由于第2步和第3步都用到了<code>p-&gt;next</code>。如果第4步先执行，则会使得<code>p-&gt;next</code>提前变成了s，使得插入的工作完不成。所以我们不妨把上面这张图在理解的基础上记忆，顺序是先搞定s的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。  </p>
<p>若要删除结点p，只需要下面两步骤，如图3-14-6所示。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.6.GIF?raw=true" alt="3-14-6">  </p>
<pre><code class="c">p-&gt;prior-&gt;next=p-&gt;next；/*把p-&gt;next赋值给p-&gt;prior的后继，如图中①*/
p-&gt;next-&gt;prior=p-&gt;prior；/*把p-&gt;prior 赋值给p-&gt;next的前驱，如图中②*/
free（p）；/*释放结点*/</code></pre>
<h2 id="3-15总结回顾"><a href="#3-15总结回顾" class="headerlink" title="3.15总结回顾"></a>3.15总结回顾</h2><p>这一章，主要讲的是线性表。<br>先谈了它的定义，线性表是零个或多个具有相同类型的数据元素的有限序列。然后谈了线性表的抽象数据类型，如它的一些基本操作。<br>之后我们就线性表的两大结构做了讲述，先讲的是比较容易的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。通常我们都是用数组来实现这一结构。<br>后来是我们的重点，由顺序存储结构的插入和删除操作不方便，引出了链式存储结构。它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。然后我们分别就链式存储结构的不同形式，如单链表、循环链表和双向链表做了讲解，另外我们还讲了若不使用指针如何处理链表结构的静态链表方法。<br>总的来说，线性表的这两种结构（如图3-15-1所示）是后面其他数据结构的基础，把它们学明白了，对后面的学习有着至关重要的作用。<br><img src="https://github.com/closer2018/picture/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.15.1.GIF?raw=true" alt="3-15-1">  </p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
</search>
