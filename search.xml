<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ubuntu安装完以后的基础配置</title>
    <url>/2020/02/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ubuntu/ubuntu%E5%AE%89%E8%A3%85%E5%AE%8C%E4%BB%A5%E5%90%8E%E7%9A%84%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="一：-安装类型">一： 安装类型</h2>
<ol>
<li>/boot分区（引导）-&gt;512MB-&gt;主分区-&gt;空间起始位置-&gt;Ext4日志文件系统-&gt;/boot。</li>
<li>/ 根分区（相当于windows的c盘）-&gt;102400MB-&gt;主分区-&gt;空间起始位置-&gt;XFS日志文件系统-&gt;/。</li>
<li>swap分区（桌面系统不分，服务器必分）-&gt;2048MB-&gt;逻辑分区-&gt;空间起始位置-&gt;交换空间。</li>
<li>/home分区（存储空间，剩余都给它）-&gt;max MB-&gt;主分区-&gt;空间起始位置-&gt;XFS日志文件系统-&gt;/home。</li>
<li>现在安装。</li>
</ol>
<h2 id="二：-基础配置">二： 基础配置</h2>
<ol>
<li>设置root用户密码<br>
<code>sudo passwd root</code><br>
<code>su</code></li>
<li>修改镜像源  <a id="more"></a>
<ol>
<li><code>sudo nano /etc/apt/sources.list</code></li>
<li>将原文件所有内容注释掉；</li>
<li>复制<a href="https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.2f191b11mRGGjV" target="_blank" rel="noopener">阿里巴巴镜像源</a></li>
<li>黏贴到终端，<code>ctrl</code>+<code>o</code>保存，回车确定,<code>ctrl</code>+<code>x</code>。</li>
</ol>
</li>
<li>更新源和系统<br>
<code>sudo apt update</code><br>
<code>sudo apt upgrade</code><br>
<code>sudo apt dist-upgrade</code><br>
<code>sudo apt autoremove</code>  # 清理不需要的旧组件<br>
<code>reboot</code>  # 重启</li>
<li>安装输入法
<ol>
<li><code>sudo apt remove ibus</code>  # 卸载自带ibus</li>
<li><code>sudo apt install fcitx-bin fcitx-table</code>  # 安装fcitx</li>
<li><code>sudo apt install fcitx-googlepinyin</code>  # 安装Google拼音</li>
<li><code>sudo im-config</code>-&gt;确定-&gt;yes-&gt;选择fcitx,确定-&gt;reboot重启。</li>
</ol>
</li>
<li>安装Google浏览器
<ol>
<li>打开 <a href="https://www.google.cn/intl/zh-CN/chrome/" target="_blank" rel="noopener">https://www.google.cn/intl/zh-CN/chrome/</a></li>
<li>下载-&gt;64位.deb-&gt;接受并安装。</li>
<li>在下载文件夹内打开终端。</li>
<li><code>sudo dpkg -i google-chrome-stable_current_amd64.deb</code></li>
</ol>
</li>
<li>设置-&gt;区域和语言-&gt;管理已安装的语言-&gt;安装。</li>
<li><code>sudo apt install vlc</code>  # 安装vlc</li>
<li>关闭ubuntu内部错误
<ol>
<li><code>sudo nano /etc/default/apport</code></li>
<li>enable=1改为0</li>
<li><code>ctrl</code>+<code>o</code>保存，回车确定,<code>ctrl</code>+<code>x</code>。</li>
</ol>
</li>
<li>安装新立得软件包<br>
<code>sudo apt install synaptic</code></li>
</ol>
<h2 id="三：-参考视频">三： 参考视频</h2>
<p><strong><a href="https://www.bilibili.com/video/av48233413" target="_blank" rel="noopener">https://www.bilibili.com/video/av48233413</a></strong></p>
]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>利用python实现Gitee Pages定时自动部署/自动签到</title>
    <url>/2020/02/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/%E5%88%A9%E7%94%A8python%E5%AE%9E%E7%8E%B0Gitee-Pages%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E3%80%81%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0/</url>
    <content><![CDATA[<h2 id="一：-前期准备">一： 前期准备</h2>
<h3 id="1-1-基础环境">1.1 基础环境</h3>
<ol>
<li>python3 + selenium + chrome浏览器。<br>
如果有不懂的可以查阅<a href="https://python-selenium-zh.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">selenium-python中文文档</a></li>
<li>chrome-&gt;设置-&gt;关于chrome-&gt;查看版本（我的版本是 80.0.3987.106（正式版本） （64 位））。</li>
<li>需要下载跟你的chrome版本一致的<a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">ChromeDriver可执行驱动</a><br>
下载完解压放在python根目录(即跟python.exe放在一起)。</li>
<li>最好有一台云主机，没有的话需要自己的电脑设定定时开机，定时任务，定时关机。  <a id="more"></a></li>
</ol>
<h3 id="1-2-安装环境">1.2 安装环境</h3>
<ol>
<li>安装python3,不懂的请查阅我的相关blog文。</li>
<li>打开windows命令行，安装selenium<br>
<code>pip install selenium -i https://pypi.tuna.tsinghua.edu.cn/simple</code></li>
</ol>
<h2 id="二：-代码">二： 代码</h2>
<h3 id="2-1-源码">2.1 源码</h3>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: utf-8 -*-
import time
from selenium import webdriver
from selenium.webdriver.common.alert import Alert

# 模拟浏览器打开到gitee登录界面
driver = webdriver.Chrome()
driver.get('https://gitee.com/login')
# 将窗口最大化
driver.maximize_window()
time.sleep(2)

# 输入账号--通过html的id属性定位输入位置--改为你的账号
user_login = driver.find_element_by_id('user_login')
user_login.send_keys(&quot;此处改为你的账号&quot;)
# 输入密码--通过html的id属性定位输入位置--改为你的密码
driver.find_element_by_id('user_password').send_keys(&quot;此处改为你的密码&quot;)
# 点击登录按钮--通过xpath确定点击位置
driver.find_element_by_xpath(
    '/html/body/div[2]/div[2]/div[1]/div/div[2]/div/form[1]/div[2]/div/div/div[4]/input').click()

time.sleep(2)

# 切换到gitee pages界面--改为you_gitee_id
driver.get('https://gitee.com/此处改为you_gitee_id/此处改为you_gitee_id/pages')
# 点击更新按钮--通过xpath确定点击位置
driver.find_element_by_xpath('/html/body/div[3]/div[2]/div/div[2]/div[1]/form/div[7]').click()
# 确认更新提示框--这个函数的作用是确认提示框
Alert(driver).accept()

# 等待5秒更新
time.sleep(5)

# 这个print其实没事什么用,如果真的要测试脚本是否运行成功，可以用try来抛出异常
print(&quot;成功&quot;)

# 脚本运行成功,退出浏览器
driver.quit()

# 写上更新日志
# 我这里是写在D盘，可以改为自己喜欢的目录
fp = open(&quot;D:\log.txt&quot;, &quot;a+&quot;)
now_time = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())
fp.write(&quot;auto update time:{0}\n&quot;.format(now_time))
fp.close()
</code></pre>
<p>把源码黏贴到<code>gitee.py</code>文件内，备用。</p>
<h3 id="2-2-注意事项">2.2 注意事项</h3>
<ul>
<li>
<p>html的id属性、xpath可以通过在chrome的网页里面按F12 -&gt; 选择一个元素进行检查(快捷键Ctrl + Shift + C)查看，如图就是<code>百度一下</code>的div块元素属性。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/CopyFullXPath.png" srcset="/img/loading.gif" alt="CopyXPath"></p>
</li>
<li>
<p>python selenium模块的具体函数使用方法请参考官方文档。</p>
</li>
<li>
<p>编写自动签到脚本也差不多同样的道理。</p>
</li>
</ul>
<h2 id="三：-添加定时任务自动部署">三： 添加定时任务自动部署</h2>
<pre><code class="language-bat">@echo off

d:

python gitee.py

echo &quot;等待更新完成再关闭窗口... ...&quot;

timeout /t 300
rem 上面的代码是等待三分钟。

</code></pre>
<ol>
<li>编写windows批处理脚本，代码如上。注意编码要是windows特有的GBK编码，否则会有乱码，保存为<code>gitee.bat</code>。</li>
<li>登录云主机，复制<code>gitee.py</code>、<code>gitee.bat</code>到D盘根目录。</li>
<li>云主机内-&gt;右键我的电脑-&gt;管理-&gt;工具-&gt;任务计划程序-&gt;创建基本任务…添加任务每天执行一次，实在不会的请<a href="https://jingyan.baidu.com/article/154b463130041128ca8f41c7.html" target="_blank" rel="noopener">百度</a></li>
<li>在自己电脑上的话也可以把上述部署代码添加到<a href="https://8hn9w5.coding-pages.com/2020/02/15/hexo/hexo%E4%B8%80%E9%94%AE%E4%B8%8A%E4%BC%A0%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC%E7%9A%84%E6%9E%84%E5%BB%BA/" target="_blank" rel="noopener">hexo一键上传部署脚本</a>的后面，每次git push后自动在gitee的pages界面部署。</li>
</ol>
<h2 id="四：-参考文献">四： 参考文献</h2>
<ul>
<li><a href="https://python-selenium-zh.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://python-selenium-zh.readthedocs.io/zh_CN/latest/</a></li>
<li><a href="https://blog.csdn.net/ydydyd00/article/details/80882183" target="_blank" rel="noopener">https://blog.csdn.net/ydydyd00/article/details/80882183</a></li>
<li><a href="https://jingyan.baidu.com/article/154b463130041128ca8f41c7.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/154b463130041128ca8f41c7.html</a></li>
</ul>
<p><strong>enjoy.</strong></p>
]]></content>
      <categories>
        <category>hexo</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>python</tag>
        <tag>自动签到</tag>
      </tags>
  </entry>
  <entry>
    <title>you-get下载视频</title>
    <url>/2020/02/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/you-get%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<h2 id="一：-简介">一： 简介</h2>
<p>You-Get 乃一小小哒命令行程序，提供便利的方式来下载网络上的媒体信息，通过python来安装。<br>
支持主流视频网站如：YouTube、Google+、bilibili哔哩哔哩、163/网易视频/网易云音乐、斗鱼、爱奇艺、Youku、AcFun等等</p>
<h2 id="二：-安装及其使用">二： 安装及其使用</h2>
<h3 id="2-1-安装">2.1 安装</h3>
<p>1） 安装python3  <a id="more"></a><br>
安装教程这里推荐：<a href="http://www.runoob.com/python3/python3-install.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-install.html</a><br>
win下载地址：<a href="https://www.python.org/downloads/windows" target="_blank" rel="noopener">https://www.python.org/downloads/windows</a><br>
Linux下载地址：<a href="https://www.python.org/downloads/source" target="_blank" rel="noopener">https://www.python.org/downloads/source</a></p>
<p>2） 安装you-get<br>
然后打开win的cmd命令行、Linux为终端，输入以下命令：</p>
<ul>
<li>升级pip<br>
<code>python -m pip install --upgrade pip -i https://pypi.tuna.tsinghua.edu.cn/simple</code></li>
<li>安装you-get<br>
<code>pip install you-get -i https://pypi.tuna.tsinghua.edu.cn/simple</code></li>
<li>升级you-get<br>
<code>pip install --upgrade you-get -i https://pypi.tuna.tsinghua.edu.cn/simple</code></li>
</ul>
<p>3） 安装<a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a><br>
FFmpeg用于转换视频格式、播放视频等，下载下来的视频有可能播放格式不支持，不需要也可不装。<br>
FFmpeg下载地址：<a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">https://www.ffmpeg.org/</a><br>
windows下载地址：<a href="https://ffmpeg.zeranoe.com/builds/" target="_blank" rel="noopener">https://ffmpeg.zeranoe.com/builds/</a><br>
ps：windows下载，选择默认选项即可</p>
<h3 id="2-2-下载">2.2 下载</h3>
<h4 id="2-2-1-下载默认画质和格式">2.2.1 下载默认画质和格式</h4>
<p><code>you-get https://www.bilibili.com/video/av77151622/</code></p>
<p>下载路径默认为文件所在当前路径。<br>
所以要下载在指定路径需要先cd到指定路径。</p>
<h4 id="2-2-2-下载指定画质和格式">2.2.2 下载指定画质和格式</h4>
<p>1） 先用<code>-i</code>以查看所有可用画质与格式。<br>
<code>you-get -i https://www.bilibili.com/video/av77151622/</code><br>
最上面的标有<code>[ DASH(也可能是 DEFAULT ） ]</code>为默认画质。如认同，可下载。</p>
<p>2） 或，您希望下载其他播放格式或者其他清晰度，请追加屏幕上面提示的参数，如本视频是:<br>
<code>you-get --format=flv720 https://www.bilibili.com/video/av77151622/</code></p>
<ul>
<li>目前，格式选择没有大规模铺开；默认选项为最高画质.</li>
<li>如不希望you-get合并视频，使用<code>-n</code>。</li>
<li>如YouTube视频带有字幕，将被一同下载，以SubRip格式保存.</li>
</ul>
<h4 id="2-2-3-下载其他内容">2.2.3 下载其他内容</h4>
<p>1） 如你有URL，可以直接使用，如下载you-get:<br>
<code>you-get https://github.com/soimort/you-get/archive/master.zip</code></p>
<p>2） 或者, you-get将自动检查网页，下载一切有可能感兴趣的内容:<br>
<code>you-get http://kopasas.tumblr.com/post/69361932517</code></p>
<ul>
<li>此功能为测试性，远未完成。对于类似Tumblr和Blogger的大图有效，但是没有办法为所有网站建立通用格式.</li>
</ul>
<p>3） 在Google Videos搜索并下载<br>
you-get可以下载任何东西. 如果不是合法的URL, you-get将在Google查找并下载最相关视频. (可能不是最心仪的，但是很有可能)<br>
<code>you-get &quot;Richard Stallman eats&quot;</code></p>
<h4 id="2-2-4-暂停与恢复下载">2.2.4 暂停与恢复下载</h4>
<p>可以使用<code>Ctrl</code>+<code>C</code> 暂停下载.<br>
临时的<code>.download</code>文件将保存于输出目录。下次使用you-get传入相同参数时，下载将从上次继续开始. 如果下载已经完成 (临时的<code>.download</code> 扩展名消失), you-get将忽略下载.<br>
用<code>-f</code>强行重下载. (注意: 将覆盖同名文件或临时文件!)</p>
<h4 id="2-2-5-设置输出文件名或路径">2.2.5 设置输出文件名或路径</h4>
<p>使用<code>-o</code> 设定路径为d:, <code>-O</code> 设定输出文件名为out:<br>
<code>you-get -o d:\ -O out https://www.bilibili.com/video/av77151622/</code><br>
提示:</p>
<ul>
<li>如果原视频标题含有与系统不兼容字符，十分有效.</li>
<li>也可以帮助使用脚本批量下载于指定目录和文件名.</li>
</ul>
<h4 id="2-2-6-批量下载">2.2.6 批量下载</h4>
<p>两种方法：</p>
<ol>
<li>把视频URL用空格隔开<br>
<code>you-get 视频A网址 视频B网址</code></li>
<li>用<code>--playlist</code><br>
<code>you-get --playlist https://www.bilibili.com/video/av5123229</code></li>
<li>下载视频的同时会下载xml格式弹幕，需要将其转换为ass格式，有一个工具可以帮你：<a href="https://github.com/ikde/danmu2ass/releases/download/v1.1/Danmu2Ass1.1.zip" target="_blank" rel="noopener">Danmu2Ass</a>。</li>
</ol>
<h3 id="2-3-观看视频">2.3 观看视频</h3>
<p>使用 <code>-p</code> 将视频喂进播放器, 例如 mPlayer 或者 vlc,而不是下载:<br>
<code>you-get -p vlc 'https://www.youtube.com/watch?v=jNQXAC9IVRw'</code><br>
或者你想在浏览器中观看而不希望看广告或评论区:<br>
<code>you-get -p chromium 'https://www.youtube.com/watch?v=jNQXAC9IVRw'</code></p>
<h2 id="三：-官方文档">三： 官方文档</h2>
<p><a href="https://github.com/soimort/you-get/wiki/%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">官方中文文档</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>you-get</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬图攻略</title>
    <url>/2020/02/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/python%E7%88%AC%E5%9B%BE%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<h2 id="一：-软件工具">一： 软件工具</h2>
<h3 id="1-1-Python3">1.1 Python3</h3>
<p>这里选择的是最新版 Python3<br>
安装教程这里推荐：<a href="http://www.runoob.com/python3/python3-install.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-install.html</a><br>
win下载地址：<a href="https://www.python.org/downloads/windows" target="_blank" rel="noopener">https://www.python.org/downloads/windows</a><br>
Linux下载地址：<a href="https://www.python.org/downloads/source" target="_blank" rel="noopener">https://www.python.org/downloads/source</a>  <a id="more"></a></p>
<h3 id="1-2-PyCharm">1.2 PyCharm</h3>
<p>可视化开发工具IDE：<a href="https://www.jetbrains.com/pycharm/download/" target="_blank" rel="noopener">https://www.jetbrains.com/pycharm/download/</a></p>
<h2 id="二：原理">二：原理</h2>
<h3 id="2-1-实现步骤">2.1 实现步骤</h3>
<p>以图片为例，其实很简单，分以下四步：</p>
<ul>
<li>获取首页的页码数，并创建与页码对应的文件夹</li>
<li>获取页面的栏目地址</li>
<li>进入栏目，获取栏目页码数(每个栏目下有多张图片，分页显示)</li>
<li>获取到栏目下对用标签容器中的图片并下载</li>
</ul>
<h3 id="2-2-注意事项">2.2 注意事项</h3>
<p>这里以爬取某个网站的套路为例，详细见代码，这里主要说以下几点注意事项：</p>
<p>1）导库，其实就类似于Java中框架或者是工具类，底层都被封装好了</p>
<p>安装第三方库：</p>
<pre><code class="language-py"># Win下直接装的 python3
pip install BeautifulSoup4 -i https://pypi.tuna.tsinghua.edu.cn/simple
pip install requests -i https://pypi.tuna.tsinghua.edu.cn/simple
# Linux python2 python3 共存
pip3 install BeautifulSoup4 -i https://pypi.tuna.tsinghua.edu.cn/simple
pip3 install requests -i https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>
<p>导入第三方库：</p>
<pre><code class="language-py"># 导入requests库
import requests
# 导入文件操作库
import os
# bs4全名BeautifulSoup4，是编写python爬虫常用库之一，主要用来解析html标签。
import bs4
from bs4 import BeautifulSoup
# 基础类库
import sys
# Python 3.x 解决中文编码问题
import importlib
importlib.reload(sys)
</code></pre>
<p>2）定义方法函数，一个爬虫可能会几百行，所以尽量不要写成一坨</p>
<pre><code class="language-py">def download(page_no, file_path):
    # 这里写代码逻辑
</code></pre>
<p>3）定义全局变量</p>
<pre><code class="language-py"># 给请求指定一个请求头来模拟chrome浏览器
global headers # 告诉编译器这是全局变量 headers 
headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36'}

# 函数内使用之前需要
# 告诉编译器我在这个方法中使用的a是刚才定义的全局变量 headers ，而不是方法内部的局部变量。
global headers
</code></pre>
<p>4）防盗链</p>
<p>有些网站加入了防盗链，无所不能的 python  解决方案：</p>
<pre><code class="language-py">headers = {'Referer': href}
img = requests.get(url, headers=headers)
</code></pre>
<p>5）切换版本</p>
<p>Linux服务器使用的是阿里云服务器（centos7.4），默认版本 python2，python3 自行安装</p>
<pre><code class="language-py">[root@AY140216131049Z mzitu]# python2 -V
Python 2.7.5
[root@AY140216131049Z mzitu]# python3 -V
Python 3.7.1
# 默认版本
[root@AY140216131049Z mzitu]# python -V
Python 2.7.5
# 临时切换版本 &lt;whereis python&gt;
[root@AY140216131049Z mzitu]# alias python='/usr/local/bin/python3.7'
[root@AY140216131049Z mzitu]# python -V
Python 3.7.1

</code></pre>
<p>6）异常捕获</p>
<p>在爬取的过程中可能存在异常页面，这里我们进行捕获，不影响后续操作：</p>
<pre><code class="language-py">try:
    # 业务逻辑
except Exception as e:
   print(e)
</code></pre>
<h3 id="2-3-执行脚本">2.3 执行脚本</h3>
<pre><code class="language-py">python3 mzitu.py

# 或者后台执行

nohup python3 -u mzitu.py &gt; mzitu.log 2&gt;&amp;1 &amp;
</code></pre>
<h2 id="三：-源码">三： 源码</h2>
<h3 id="3-1-win下代码">3.1 win下代码</h3>
<pre><code class="language-py">#coding=utf-8
#!/usr/bin/python
# 导入requests库
import requests
# 导入文件操作库
import os
import bs4
from bs4 import BeautifulSoup
import sys
import importlib
import random
import time
importlib.reload(sys)


# 越多越好
meizi_headers = [
    &quot;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36&quot;,
    &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36&quot;,
    &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0&quot;,
    &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/537.75.14&quot;,
    &quot;Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Win64; x64; Trident/6.0)&quot;,
    'Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11',
    'Opera/9.25 (Windows NT 5.1; U; en)',
    'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
    'Mozilla/5.0 (compatible; Konqueror/3.5; Linux) KHTML/3.5.5 (like Gecko) (Kubuntu)',
    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.0.12) Gecko/20070731 Ubuntu/dapper-security Firefox/1.5.0.12',
    'Lynx/2.8.5rel.1 libwww-FM/2.14 SSL-MM/1.4.1 GNUTLS/1.2.9',
    &quot;Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.7 (KHTML, like Gecko) Ubuntu/11.04 Chromium/16.0.912.77 Chrome/16.0.912.77 Safari/535.7&quot;,
    &quot;Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:10.0) Gecko/20100101 Firefox/10.0&quot;,
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36'
]
# 给请求指定一个请求头来模拟chrome浏览器
global headers
headers = {'User-Agent': random.choice(meizi_headers)}
# 爬图网址
mziTu = 'http://www.mzitu.com/'
# 定义图片存储位置
global save_path
save_path = 'D:\BeautifulPictures'

# 创建文件夹
def createFile(file_path):
    if os.path.exists(file_path) is False:
        os.makedirs(file_path)
    # 切换路径至上面创建的文件夹
    os.chdir(file_path)

# 下载文件
def download(page_no, file_path):
    global headers
    res_sub = requests.get(page_no, headers=headers)
    # 解析html
    soup_sub = BeautifulSoup(res_sub.text, 'html.parser')
    # 获取页面的栏目地址
    all_a = soup_sub.find('div',class_='postlist').find_all('a',target='_blank')
    count = 0
    for a in all_a:
        count = count + 1
        if (count % 2) == 0:
            headers = {'User-Agent': random.choice(meizi_headers)}
            print(&quot;内页第几页：&quot; + str(count))
            # 提取href
            href = a.attrs['href']
            print(&quot;套图地址：&quot; + href)
            res_sub_1 = requests.get(href, headers=headers)
            soup_sub_1 = BeautifulSoup(res_sub_1.text, 'html.parser')
            # ------ 这里最好使用异常处理 ------
            try:
                # 获取套图的最大数量
                pic_max = soup_sub_1.find('div', class_='pagenavi').find_all('span')[6].text
                print(&quot;套图数量：&quot; + pic_max)
                for j in range(1, int(pic_max) + 1):
                    # 单位为秒，1-3 随机数
                    time.sleep(random.randint(1, 3))
                    headers = {'User-Agent': random.choice(meizi_headers)}
                    # print(&quot;子内页第几页：&quot; + str(j))
                    # j int类型需要转字符串
                    href_sub = href + &quot;/&quot; + str(j)
                    print(&quot;图片地址：&quot;+href_sub)
                    res_sub_2 = requests.get(href_sub, headers=headers)
                    soup_sub_2 = BeautifulSoup(res_sub_2.text, &quot;html.parser&quot;)
                    img = soup_sub_2.find('div', class_='main-image').find('img')
                    if isinstance(img, bs4.element.Tag):
                        # 提取src
                        url = img.attrs['src']
                        array = url.split('/')
                        file_name = array[len(array)-1]
                        # 防盗链加入Referer
                        headers = {'User-Agent': random.choice(meizi_headers), 'Referer': url}
                        img = requests.get(url, headers=headers)
                        print('开始保存图片', img)
                        f = open(file_name, 'ab')
                        f.write(img.content)
                        print(file_name, '图片保存成功！')
                        f.close()
            except Exception as e:
                print(e)


# 主方法
def main():
    res = requests.get(mziTu, headers=headers)
    # 使用自带的html.parser解析
    soup = BeautifulSoup(res.text, 'html.parser')
    # 创建文件夹
    createFile(save_path)
    # 获取首页总页数
    img_max = soup.find('div', class_='nav-links').find_all('a')[3].text
    # print(&quot;总页数:&quot;+img_max)
    for i in range(1, int(img_max) + 1):
        # 获取每页的URL地址
        if i == 1:
            page = mziTu
        else:
            page = mziTu + 'page/' + str(i)
        file = save_path + '\\' + str(i)
        createFile(file)
        # 下载每页的图片
        print(&quot;套图页码：&quot; + page)
        download(page, file)


if __name__ == '__main__':
    main()
</code></pre>
<h3 id="3-2-linux下代码">3.2 linux下代码</h3>
<pre><code class="language-py">#coding=utf-8
#!/usr/bin/python
# 导入requests库
import requests
# 导入文件操作库
import os
import bs4
from bs4 import BeautifulSoup
import sys
import importlib
importlib.reload(sys)

# 给请求指定一个请求头来模拟chrome浏览器
global headers
headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36'}
# 爬图地址
mziTu = 'http://www.mzitu.com/'
# 定义存储位置
global save_path
save_path = ​'/mnt/data/mzitu'

# 创建文件夹
def createFile(file_path):
    if os.path.exists(file_path) is False:
        os.makedirs(file_path)
    # 切换路径至上面创建的文件夹
    os.chdir(file_path)

# 下载文件
def download(page_no, file_path):
    global headers
    res_sub = requests.get(page_no, headers=headers)
    # 解析html
    soup_sub = BeautifulSoup(res_sub.text, 'html.parser')
    # 获取页面的栏目地址
    all_a = soup_sub.find('div',class_='postlist').find_all('a',target='_blank')
    count = 0
    for a in all_a:
        count = count + 1
        if (count % 2) == 0:
            print(&quot;内页第几页：&quot; + str(count))
            # 提取href
            href = a.attrs['href']
            print(&quot;套图地址：&quot; + href)
            res_sub_1 = requests.get(href, headers=headers)
            soup_sub_1 = BeautifulSoup(res_sub_1.text, 'html.parser')
            # ------ 这里最好使用异常处理 ------
            try:
                # 获取套图的最大数量
                pic_max = soup_sub_1.find('div',class_='pagenavi').find_all('span')[6].text
                print(&quot;套图数量：&quot; + pic_max)
                for j in range(1, int(pic_max) + 1):
                    # print(&quot;子内页第几页：&quot; + str(j))
                    # j int类型需要转字符串
                    href_sub = href + &quot;/&quot; + str(j)
                    print(href_sub)
                    res_sub_2 = requests.get(href_sub, headers=headers)
                    soup_sub_2 = BeautifulSoup(res_sub_2.text, &quot;html.parser&quot;)
                    img = soup_sub_2.find('div', class_='main-image').find('img')
                    if isinstance(img, bs4.element.Tag):
                        # 提取src
                        url = img.attrs['src']
                        array = url.split('/')
                        file_name = array[len(array)-1]
                        # print(file_name)
                        # 防盗链加入Referer
                        headers = {'Referer': href}
                        img = requests.get(url, headers=headers)
                        # print('开始保存图片')
                        f = open(file_name, 'ab')
                        f.write(img.content)
                        # print(file_name, '图片保存成功！')
                        f.close()
            except Exception as e:
                print(e)


# 主方法
def main():
    res = requests.get(mziTu, headers=headers)
    # 使用自带的html.parser解析
    soup = BeautifulSoup(res.text, 'html.parser')
    # 创建文件夹
    createFile(save_path)
    # 获取首页总页数
    img_max = soup.find('div', class_='nav-links').find_all('a')[3].text
    # print(&quot;总页数:&quot;+img_max)
    for i in range(1, int(img_max) + 1):
        # 获取每页的URL地址
        if i == 1:
            page = mziTu
        else:
            page = mziTu + 'page/' + str(i)
        file = save_path + '/' + str(i)
        createFile(file)
        # 下载每页的图片
        print(&quot;套图页码：&quot; + page)
        download(page, file)


if __name__ == '__main__':
    main()
</code></pre>
<h2 id="四：-参考文献">四： 参考文献</h2>
<p><a href="https://gitee.com/52itstyle/Python" target="_blank" rel="noopener">小柒2012 / 从零学Python / Day01</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬图</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo一键上传部署脚本的构建</title>
    <url>/2020/02/15/hexo/hexo%E4%B8%80%E9%94%AE%E4%B8%8A%E4%BC%A0%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<ol>
<li>windows先右键新建一个文本文档，后缀改为<code>git push hexo.bat</code>；Linux新建一个<code>git push hexo.sh</code>文档;</li>
<li>注意：编码要是windows默认编码GBK；Linux上是UTF-8；</li>
<li>然后复制黏贴，话不多说，直接上代码。  <a id="more"></a></li>
</ol>
<h2 id="Windows">Windows</h2>
<pre><code class="language-bat">@echo off

cd G:\code\hexo
REM 改为hexo根目录
echo &quot;当前目录是： G:\code\hexo&quot;
REM 改为hexo根目录
echo &quot;正在add... ...&quot;
git add source/ 
REM 只添加了blog文件目录，需要的可自行添加...
echo;
echo &quot;add complete.&quot;
echo;
echo;

echo &quot;正在commit... ...&quot;
set now=%date% %time%
echo %now%
git commit -m &quot;blog update at %now%&quot;
echo;
echo &quot;commit complete.&quot;
echo;
echo;
 
echo &quot;正在将更改提交到远程git服务器... ...&quot;
git push githuborigin hexo &amp;&amp; git push giteeorigin hexo &amp;&amp; git push codingorigin hexo
echo;
echo &quot;git push complete.&quot;
echo;
echo;

echo &quot;正在部署blog... ...&quot;
hexo clean &amp;&amp; hexo g &amp;&amp; hexo d
echo;
echo &quot;部署 complete.&quot;
echo;
echo;

pause
</code></pre>
<h2 id="Linux">Linux</h2>
<p>先提升权限，<code>chmod +x ./git\ push\ hexo.sh</code>。</p>
<pre><code class="language-sh">cd /home/zs/文档/hexo/closer_laps
# 改为hexo根目录
echo &quot;当前目录是： /home/zs/文档/hexo/closer_laps&quot;

# 改为hexo根目录
echo &quot;正在add... ...&quot;
git add source/ 
echo;
echo &quot;add complete.&quot;
echo;
echo;

echo &quot;正在commit... ...&quot;
now=`date '+%Y-%m-%d %H:%M:%S'`
echo &quot;$now&quot;
git commit -m &quot;blog update at $now&quot;
echo;
echo &quot;commit complete.&quot;
echo;
echo;
 
echo &quot;正在push... ...&quot;
git push githuborigin hexo &amp;&amp; git push giteeorigin hexo &amp;&amp; git push codingorigin hexo
echo;
echo &quot;git push complete.&quot;
echo;
echo;

echo &quot;正在部署blog... ...&quot;
hexo clean &amp;&amp; hexo g &amp;&amp; hexo d
echo;
echo &quot;部署 complete.&quot;
echo;
echo;
</code></pre>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>一键部署</tag>
      </tags>
  </entry>
  <entry>
    <title>同时在Github、Gitee、Coding上部署Hexo</title>
    <url>/2020/02/14/hexo/%E5%90%8C%E6%97%B6%E5%9C%A8Github%E3%80%81Gitee%E3%80%81Coding%E4%B8%8A%E9%83%A8%E7%BD%B2Hexo/</url>
    <content><![CDATA[<h2 id="一、创建托管仓库">一、创建托管仓库</h2>
<ul>
<li>
<p>GitHub <a href="https://github.com" target="_blank" rel="noopener">https://github.com</a><br>
与用户名相同，<a href="http://xn--YouID-dq1hm91h5lp.github.io" target="_blank" rel="noopener">格式为YouID.github.io</a></p>
</li>
<li>
<p>Gitee <a href="https://gitee.com" target="_blank" rel="noopener">https://gitee.com</a><br>
与用户名相同，格式为YouID</p>
</li>
<li>
<p>Coding <a href="https://coding.net" target="_blank" rel="noopener">https://coding.net</a><br>
与用户名相同，<a href="http://xn--YouID-dq1hm91h5lp.coding.me" target="_blank" rel="noopener">格式为YouID.coding.me</a></p>
</li>
</ul>
<a id="more"></a>
<h2 id="二、在Github、Gitee、Coding上添加SSH，并push">二、在Github、Gitee、Coding上添加SSH，并push</h2>
<ol>
<li>获取id_rsa.pub文件内的公匙;具体如何获取请百度<code>id_rsa.pub</code></li>
<li>在 Github、Gitee、Coding平台 - 设置 - 添加SSH Keys。</li>
<li>将博客分支master和分支hexo里的内容push到仓库，并设定hexo为主分支（hexo分支的好处请参考<a href="https://closer_laps.gitee.io/2019/12/09/hexo/hexo%20%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/"> hexo 多客户端上更新博客</a>）。</li>
</ol>
<h2 id="三、开启Pages服务并绑定域名">三、开启Pages服务并绑定域名</h2>
<ul>
<li>GitHub 进入托管的仓库 -&gt; Settings -&gt; Options 往下拉-&gt;GitHub Pages</li>
<li>Gitee 进入托管的仓库 -&gt; 服务-&gt; Gitee Pages (绑定域名需要升级Gitee Pro，普通版每次部署更新需要手动点更新！！！)</li>
<li>Coding 进入托管的仓库 -&gt; Pages服务 -&gt; 设置</li>
</ul>
<h2 id="四、Hexo推送设置">四、Hexo推送设置</h2>
<p>在博客根目录下，打开<code>_config.yml</code>,deploy设置如下所示</p>
<pre><code class="language-yml">deploy:
  type: git
  repo:
        github: git@github.com:YouID/YouID.github.io.git
        gitee: git@gitee.com:YouID/YouID.git
        coding: git@e.coding.net:YouID/YouID.coding.me.git
  branch: master
</code></pre>
<h2 id="五：将本地仓库和远程仓库连接">五：将本地仓库和远程仓库连接</h2>
<ul>
<li>
<p>GitHub<br>
<code>git remote add githuborigin git@github.com:YouID/YouID.github.io.git</code></p>
</li>
<li>
<p>Gitee<br>
<code>git remote add giteeorigin git@gitee.com:YouID/YouID.git</code></p>
</li>
<li>
<p>Coding<br>
<code>git remote add codingorigin git@e.coding.net:YouID/YouID.coding.me.git</code></p>
</li>
</ul>
<p>输入<code>git remote -v</code>，成功的话会显示3个你关联的远程库：<code>codingorigin</code>、<code>githuborigin</code>、<code>giteeorigin</code>。如下：</p>
<pre><code>codingorigin    git@e.coding.net:YouID/YouID.coding.me.git (fetch)
codingorigin    git@e.coding.net:YouID/YouID.coding.me.git (push)
giteeorigin     git@gitee.com:YouID/YouID.git (fetch)
giteeorigin     git@gitee.com:YouID/YouID.git (push)
githuborigin  git@github.com:YouID/YouID.github.io.git (fetch)
githuborigin  git@github.com:YouID/YouID.github.io.git (push)
</code></pre>
<h2 id="六、一键部署必杀命令">六、一键部署必杀命令</h2>
<p><code>git add source/ &amp;&amp; git commit -m &quot;blog update&quot; &amp;&amp; git push githuborigin hexo &amp;&amp; git push giteeorigin hexo &amp;&amp; git push codingorigin hexo &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; exit</code><br>
把所有命令用<code>&amp;&amp;</code>串起来，有一个失败就会停止；成功，最后一条命令就会退出终端。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>多平台部署</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习之路 二：项目实战</title>
    <url>/2020/02/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%20%E4%BA%8C%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>本文分为3个项目：</p>
<ol>
<li>外星人入侵</li>
<li>数据可视化</li>
<li>web应用程序</li>
</ol>
<blockquote>
<p><code>pip install</code>安装很慢的时候，可以临时改为pip国内源，<code>pip install PythonPackages -i https://mirrors.aliyun.com/pypi/simple/</code>(阿里源)</p>
</blockquote>
<a id="more"></a>
<h2 id="2-1-外星人入侵">2.1 外星人入侵</h2>
<h2 id="2-2-数据可视化">2.2 数据可视化</h2>
<h2 id="2-3-web应用程序">2.3 web应用程序</h2>
]]></content>
      <categories>
        <category>python</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在markdown中优雅的编辑数学公式</title>
    <url>/2020/02/12/hexo/%E5%A6%82%E4%BD%95%E5%9C%A8markdown%E4%B8%AD%E4%BC%98%E9%9B%85%E7%9A%84%E7%BC%96%E8%BE%91%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="IDE">IDE</h2>
<p>下载IDE软件vscode，安装插件<code>Markdown Preview Enhanced</code>(简称MPE)。<br>
<a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/" target="_blank" rel="noopener">MPE官方使用文档</a>。</p>
<h2 id="hexo博客中使用-KaTeX-来渲染数学表达式">hexo博客中使用 KaTeX 来渲染数学表达式</h2>
<ol>
<li>在Next主题配置下面开启mathjax。（不知道怎么开启的小伙伴请查询官方文档或者github）</li>
<li>在博客需要用到公式的md文件的头文件中添加一句：<code>mathjax: true</code>。</li>
</ol>
<h2 id="上下标及标记">上下标及标记</h2>
<a id="more"></a>
<ol>
<li>默认下的分隔符：<br>
<code>$...$</code> 或者<code>\(...\)</code>中的数学表达式将会在行内显示。<br>
<code>$$...$$</code> 或者 <code>\[...\]</code> 或者 <code> ```math</code> 中的数学表达式将会在块内显示。</li>
<li>公式两边用2个<code>$</code>符号标记为公式，如:<br>
<code>$a^2$</code>显示为$a^2$<br>
<code>$H_2O$</code>显示为$H_2O$<br>
<code>==marked==</code>显示为==marked==</li>
</ol>
<h2 id="数学公式">数学公式</h2>
<p>Markdown Preview Enhanced 使用 KaTeX 来渲染数学表达式。<br>
如这个公式：$f(x)=\int_{-\infty}^\infty\widehat f\xi,e^{2\pi i\xi x},d\xi$<br>
想要正确地写出它的文本形式可不容易：<br>
<code>f(x)=\int_{-\infty}^\infty\widehat f\xi\,e^{2\pi i\xi x}\,d\xi</code><br>
如果仅仅为了写个公式，就去学LaTeX语法，那没有十天半月的肯定不行。这个时候，你需要一个<a href="http://www.wiris.com/editor/demo/en/developers#output-formats" target="_blank" rel="noopener">可视化公式编辑器</a>的神器，它可以让我们可视化地编辑公式，然后自动得到它的LaTeX文本：<br>
<img src="https://www.liaoxuefeng.com/files/attachments/1280023417847873/l" srcset="/img/loading.gif" alt="使用说明"></p>
<p>在线转换地址1：<a href="http://www.wiris.com/editor/demo/en/developers#output-formats" target="_blank" rel="noopener">http://www.wiris.com/editor/demo/en/developers#output-formats</a><br>
在线转换地址2：<a href="https://latex.91maths.com/" target="_blank" rel="noopener">https://latex.91maths.com/</a></p>
]]></content>
      <categories>
        <category>数学公式</category>
      </categories>
      <tags>
        <tag>数学公式</tag>
        <tag>markdown语法</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习之路 一：基础知识</title>
    <url>/2020/02/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%20%E4%B8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>本文适合有基础c、c++语言知识的人学习，同时也可当作python工具书查阅。</p>
<h2 id="前言">前言</h2>
<ol>
<li>
<p>这里选择的是最新版 Python3<br>
安装教程这里推荐：<a href="http://www.runoob.com/python3/python3-install.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-install.html</a><br>
win下载地址：<a href="https://www.python.org/downloads/windows" target="_blank" rel="noopener">https://www.python.org/downloads/windows</a><br>
Linux下载地址：<a href="https://www.python.org/downloads/source" target="_blank" rel="noopener">https://www.python.org/downloads/source</a></p>
</li>
<li>
<p>可视化开发工具IDE：<a href="https://www.jetbrains.com/pycharm/download/" target="_blank" rel="noopener">https://www.jetbrains.com/pycharm/download/</a></p>
</li>
<li>
<p><strong>因国内pip速度较慢，安装完python后建议改为国内清华大学镜像源，以下：</strong></p>
<ul>
<li>
<p>临时使用<br>
<code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 模块名字</code><a id="more"></a></p>
</li>
<li>
<p>设为默认<br>
升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置：<br>
<code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U</code><br>
<code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
</li>
</ul>
</li>
<li>
<p>指定目录 pip下载及离线安装包</p>
<ul>
<li>将pip安装的包导出至requirements文件列表<br>
cd进入想要下载的目录。<br>
<code>pip freeze &gt; requirements.txt</code></li>
<li>批量下载pip包<br>
<code>pip download -d d:\0\package -r requirements.txt</code></li>
<li>pip批量安装包及通过列表文件安装（先cd进入requirements所在目录）<br>
<code>pip install -r requirements.txt</code></li>
</ul>
</li>
</ol>
<h2 id="1-1基础语法">1.1基础语法</h2>
<h3 id="1-1-1-输出">1.1.1 输出</h3>
<p>打印 <code>print (&quot;Hello, Python!&quot;)</code><br>
print 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号<code>,</code>。<br>
不换行输出 <code>print('*', end=' ')</code>。</p>
<h3 id="1-1-2-字符串转义">1.1.2 字符串转义</h3>
<p>特殊字符会使用反斜杠<code>\</code>来转义。比如<code>\n</code>表示换行，<code>\t</code>表示制表符，字符<code>\</code>本身也要转义，所以\表示的字符就是\<br>
<code>print('Isn\'t, they said.')</code><br>
如果不希望前置了 \ 的字符转义成特殊字符，而是使用<em>原始字符串</em>方式，在引号前添加 r 即可。<br>
<code>print(r'C:\软件\python')</code><br>
用三重引号可以跨行连续输入。<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>或<code>'''...'''</code><br>
字符串可以用 + 进行连接（粘到一起），也可以用 * 进行重复:<code>3 * 'io' + ' so easy'</code></p>
<h3 id="1-1-3-脚本式编程">1.1.3 脚本式编程</h3>
<p>Python 文件将以 <code>.py</code> 为扩展名。<br>
在linux和mac上面编程时，已经设置了PATH变量，头文件加入<code>#!/usr/bin/python</code>，可以直接执行。</p>
<pre><code class="language-python">#!/usr/bin/python
# -*- coding: utf-8 -*-
print (&quot;Hello, Python!&quot;)
</code></pre>
<p>这里，假定您的Python解释器在/usr/bin目录中，使用以下命令执行脚本：</p>
<pre><code class="language-py">chmod +x test.py     # 脚本文件添加可执行权限
./test.py
</code></pre>
<h3 id="1-1-4-行和缩进">1.1.4 行和缩进</h3>
<p>Python与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。<br>
缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量(一般是四个空格)，这个必须严格执行。</p>
<h3 id="1-1-5-注释">1.1.5 注释</h3>
<p>python中单行注释采用 # 开头。<br>
python 中多行注释使用三个单引号(’’’)或三个双引号(&quot;&quot;&quot;)。</p>
<h3 id="1-1-6-同一行显示多条语句">1.1.6 同一行显示多条语句</h3>
<p>Python可以在同一行中使用多条语句，语句之间使用分号(;)分割。</p>
<h3 id="1-1-7-多个语句构成代码组">1.1.7 多个语句构成代码组</h3>
<p>缩进相同的一组语句构成一个代码块，我们称之代码组。<br>
像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。<br>
我们将首行及后面的代码组称为一个子句(clause)。<br>
如下实例：</p>
<pre><code class="language-py">if expression :
   suite
elif expression :  
   suite  
else :  
   suite
</code></pre>
<h2 id="1-2-变量类型">1.2 变量类型</h2>
<h3 id="1-2-1-变量赋值">1.2.1 变量赋值</h3>
<p>Python 中的变量赋值不需要类型声明。<br>
Python允许你同时为多个变量赋值。例如：<br>
<code>a, b, c = 1, 2, &quot;john&quot;</code></p>
<h3 id="1-2-2-标准数据类型">1.2.2 标准数据类型</h3>
<p>Python 定义了一些标准类型，用于存储各种类型的数据。<br>
Python有五个标准的数据类型：</p>
<ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Dictionary（字典）</li>
</ul>
<p>bool类型有True和False和None（等于NULL）。</p>
<h3 id="1-2-2-1-Python数字">1.2.2.1 Python数字</h3>
<p>数字数据类型用于存储数值。他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。<br>
当你指定一个值时，Number对象就会被创建：<br>
<code>var1 = 1</code><br>
您也可以使用del语句删除一些对象的引用。del语句的语法是：<br>
<code>del var1[,var2[,var3[....,varN]]]]</code><br>
您可以通过使用del语句删除单个或多个对象的引用。例如：<br>
<code>del var_a, var_b</code><br>
Python支持四种不同的数字类型：</p>
<ul>
<li>int（有符号整型,如<code>0112L</code>,<code>0xDEFL</code>,<code>0x69</code>）# long 类型只在Python2.X版本中。在Python3.X版本中 long 类被 int 替代。</li>
<li>float（浮点型,<code>-32.54e100</code>）</li>
<li>complex（复数,<code>4.53e-7j</code>）</li>
</ul>
<h3 id="1-2-2-2-Python字符串">1.2.2.2 Python字符串</h3>
<p>字符串或串(String)是由数字、字母、下划线组成的一串字符。<br>
python的字串列表有2种取值顺序:</p>
<ul>
<li>从左到右索引默认0开始的，最大范围是字符串长度少1</li>
<li>从右到左索引默认-1开始的，最大范围是字符串开头</li>
</ul>
<p>如果你要实现从字符串中获取一段子字符串的话，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。<br>
[头下标:尾下标] 获取的子字符串包含头下标的字符，但不包含尾下标的字符。</p>
<pre><code class="language-py">&gt;&gt;&gt; s = 'abcdef'
&gt;&gt;&gt; print('s[1:5]  ',s[1:5])
&gt;&gt;&gt; print('s[-6:-4]  ',s[-6:-4])
s[1:5]   bcde
s[-6:-4]   ab
</code></pre>
<p>字符串格式化<br>
在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。</p>
<pre><code class="language-py">&gt;&gt;&gt; print(&quot;My name is %s and weight is %d kg!&quot; % ('Zara', 21))
My name is Zara and weight is 21 kg!
</code></pre>
<h3 id="1-2-2-3-Python列表">1.2.2.3 Python列表</h3>
<p>List（列表）相当于c语言中的数组。 是 Python 中使用最频繁的数据类型。<br>
列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。<br>
列表用 <code>[ ]</code> 标识，是 python 最通用的复合数据类型。<br>
列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。<br>
加号 + 是列表连接运算符，星号 * 是重复操作。如下实例：</p>
<pre><code class="language-py">&gt;&gt;&gt; list = [ 'runoob', 786 , 2.23, 'john', 70.2 ]
&gt;&gt;&gt; tinylist = [123, 'john']
&gt;&gt;&gt; print ('输出第1个至第三个元素  ', list[1:3]) 
&gt;&gt;&gt; print ('输出从第2个开始至列表末尾的所有元素   ', list[2:])
&gt;&gt;&gt; print ('输出列表两次    ', tinylist * 2)
&gt;&gt;&gt; print ('打印组合的列表    ', list + tinylist)
输出第1个至第三个元素   [786, 2.23]
输出从第2个开始至列表末尾的所有元素    [2.23, 'john', 70.2]
输出列表两次     [123, 'john', 123, 'john']
打印组合的列表     ['runoob', 786, 2.23, 'john', 70.2, 123, 'john']
</code></pre>
<p>每当需要访问最后一个列表元素时，都可使用索引-1，来获取最后一个元素。如<code>list[-1]</code>。<br>
<code>squares = [value**2 for value in range(1,11)]</code>此列表解析生成1-10的平方数存入数组。<br>
<code>list[1]=list[:]</code>可以复制列表。</p>
<h3 id="1-2-2-4-Python-元组">1.2.2.4 Python 元组</h3>
<p>元组是另一个数据类型，类似于 List（列表）。<br>
元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。<br>
<strong>元组是不允许更新的。而列表是允许更新的。</strong></p>
<h3 id="1-2-2-5-Python-字典">1.2.2.5 Python 字典</h3>
<p>字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。<br>
两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。<br>
字典用&quot;{ }&quot;标识。字典由索引(key)和它对应的值value组成。</p>
<pre><code class="language-py">&gt;&gt;&gt; dict = {}
&gt;&gt;&gt; dict['one'] = &quot;This is one&quot;
&gt;&gt;&gt; dict[2] = &quot;This is two&quot;
&gt;&gt;&gt; tinydict = {'name': 'john','code':6734, 'dept': 'sales'}
&gt;&gt;&gt; print (dict['one'])          # 输出键为'one' 的值
&gt;&gt;&gt; print (dict[2])              # 输出键为 2 的值
&gt;&gt;&gt; print (tinydict)             # 输出完整的字典
&gt;&gt;&gt; print (tinydict.keys())      # 输出所有键
&gt;&gt;&gt; print (tinydict.values())    # 输出所有值
This is one
This is two
{'name': 'john', 'code': 6734, 'dept': 'sales'}
dict_keys(['name', 'code', 'dept'])
dict_values(['john', 6734, 'sales'])
</code></pre>
<ol>
<li>
<p>修改字典中的值<br>
<code>dict['color'] = 'yellow'</code></p>
</li>
<li>
<p>删除键-值对<br>
<code>del dict['color']</code> # 删除键’color’<br>
<code>dict.clear()</code> # 清空字典<br>
<code>del dict</code> # 删除字典</p>
</li>
<li>
<p>遍历字典</p>
<pre><code class="language-py">for key, value in dict.items():
  print(&quot;\nKey: &quot; + key)
  print(&quot;Value: &quot; + value)
</code></pre>
</li>
</ol>
<h3 id="1-2-3-Python数据类型转换">1.2.3 Python数据类型转换</h3>
<p>和c语言一样。当我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。<br>
<code>float(2)</code></p>
<h3 id="1-2-4-如何查看模块及其方法的使用和它们的源码">1.2.4 如何查看模块及其方法的使用和它们的源码</h3>
<ol>
<li>进入cmd或者终端，python交互模式。</li>
<li><code>import 模块名</code>  # 导入模块</li>
<li><code>dir(模块名)</code> # 查看模块拥有的方法</li>
<li><code>help(模块名)</code> # 查看模块介绍及其所含方法、拉到最后file后面查看源码路径</li>
<li><code>help(方法名)</code> # 查看方法的内置帮助、用法</li>
</ol>
<h2 id="1-3-运算符">1.3 运算符</h2>
<p><code>+、-、*、/、%</code>和c语言一样<br>
<code>**</code>是幂，<code>2**3=8</code><br>
<code>//</code>是取整除,<code>9//2=4</code><br>
比较运算符和c语言一样<br>
赋值运算符和c语言一样，多了<code>**=</code>,<code>//=</code><br>
位运算符和c语言一样<br>
逻辑运算符:<code>and</code>等同于c语言中的<code>&amp;&amp;</code>，<code>or</code>等于c语言中的<code>||</code>，<code>not</code>等于c语言中的<code>!</code></p>
<h3 id="1-3-1-成员运算符">1.3.1 成员运算符</h3>
<p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p>
<ul>
<li>in<br>
如果在指定的序列中找到值返回 True，否则返回 False。例子：x in y , 如果 x 在 y 序列中返回 True。</li>
<li>not in<br>
如果在指定的序列中没有找到值返回 True，否则返回 False。例子：x not in y , 如果 x 不在 y 序列中返回 True。</li>
</ul>
<h3 id="1-3-2-身份运算符">1.3.2 身份运算符</h3>
<p>身份运算符用于比较两个对象的存储单元.</p>
<ul>
<li>is<br>
is 是判断两个标识符是不是引用自一个对象。例子：x is y, 类似 id(x) == id(y)</li>
<li>is not<br>
is not 是判断两个标识符是不是引用自不同对象。例子：x is not y ， 类似 id(a) != id(b)</li>
</ul>
<h2 id="1-4-条件语句">1.4 条件语句</h2>
<p><code>if</code>等用于c语言中<code>if</code>，<code>else</code>等同于c语言中<code>else</code>，<code>elif</code>等同于c语言中<code>else if</code><br>
Python程序语言指定任何非0和非空（null）值为True，0 或者 null为False。<br>
Python 编程中 if 语句用于控制程序的执行，基本形式为：</p>
<pre><code class="language-py">if 判断条件1:
    执行语句1……
elif 判断条件2:
    执行语句2……
elif 判断条件3:
    执行语句3……
else:
    执行语句4……
</code></pre>
<h2 id="1-5-循环语句">1.5 循环语句</h2>
<p>有while，for循环，循环控制语句有break，continue，pass。</p>
<h3 id="1-5-1-while">1.5.1 while</h3>
<p>while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。其基本形式为：</p>
<pre><code class="language-py">while 判断条件(condition)：
    执行语句(statements)……
</code></pre>
<p>例子：</p>
<pre><code class="language-py">pets = ['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat']
while 'cat' in pets:
    pets.remove('cat')
print(pets)
</code></pre>
<h3 id="1-5-2-for">1.5.2 for</h3>
<p>for循环的语法格式如下：</p>
<pre><code class="language-py">for 迭代变量(iterating_var) in 数列、序列(sequence):
   执行语句(statements)
</code></pre>
<pre><code class="language-py">sum = 0
for x in range(101):
    sum = sum + x
print(sum) #1-100的和，等于5050
</code></pre>
<pre><code class="language-py">L = ['Bart', 'Lisa', 'Adam']
for i in L:
    print(i)
</code></pre>
<h3 id="1-5-3-循环控制语句">1.5.3 循环控制语句</h3>
<p>break,continue和c语言相同。pass就是一个空语句,不做任何事情，一般用做占位语句。。</p>
<h2 id="1-6-函数">1.6 函数</h2>
<p>Python内置了很多有用的函数，我们可以直接调用。可以直接从Python的官方网站查看文档：<br>
<a href="https://docs.python.org/zh-cn/3/library/functions.html#abs" target="_blank" rel="noopener">Python的官方网站查看内置函数</a><br>
比如求绝对值的函数abs，只有一个参数。<br>
也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。</p>
<h3 id="1-6-1-定义函数">1.6.1 定义函数</h3>
<p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p>
<ol>
<li>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。</li>
<li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li>
<li>函数内容以冒号起始，并且缩进。</li>
<li>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li>
</ol>
<p>一般格式如下：</p>
<pre><code class="language-py">def 函数名（参数列表）:
    函数体
</code></pre>
<p>python函数的使用方法基本上和c语言相同，不用指定返回类型，可以返回列表，字典等。</p>
<p>一、python可以给函数指定默认值。<br>
<code>def student(name='Li Ming', age=18):</code><br>
如果函数有一个实参默认值为空，则必须确保为空的实参在最后一个。如：<br>
<code>def get_name(first_name, last_name, middle_name=''):</code></p>
<p>二、将列表传递给函数后，函数就可对其进行修改。在函数中对这个列表所做的任何修改都是永久性的，这让你能够高效地处理大量的数据。<br>
有时候，需要禁止函数修改列表。这时候，可向函数传递列表的副本而不是原件。<br>
<code>def stu(name[:], age[:])</code></p>
<p>三、Python允许函数从调用语句中收集任意数量的实参。<br>
<code>def make_pizza(*toppings):</code><br>
形参名 *toppings 中的星号让Python创建一个名为 toppings 的空元组，并将收到的所有值都封装到这个元组中。<br>
如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。<br>
<code>def make_pizza(size, *toppings):</code></p>
<p>四、使用任意数量的关键字实参<br>
<code>def build_profile(first, last, **user_info):</code></p>
<h3 id="1-6-2-将函数存储在模块中">1.6.2 将函数存储在模块中</h3>
<p>可以将函数存储在被称为模块的独立文件中，再将模块导入到主程序中。跟c语言差不多，c语言中用头文件，函数文件。</p>
<ol>
<li>导入整个模块<br>
假设<code>xxx.py</code>所在目录内有另外一个<code>pizza.py</code>，添加<code>import pizza</code>语句<br>
导入名为模块 module_name.py 的的整个模块通用语法：<code>import module_name</code><br>
可使用下面的语法来使用其中任何一个函数：<code>module_name.function_name ()</code></li>
<li>导入特定的函数<br>
<code>from module_name import function_0 , function_1 , function_2</code><br>
通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数。<br>
若使用这种语法，调用函数时就无需使用句点。<code>make_pizza(16, 'pepperoni')</code></li>
<li>使用 as 给函数指定别名<br>
指定别名的通用语法如下：<code>from module_name import function_name as fn</code></li>
<li>使用 as 给模块指定别名<br>
给模块指定别名的通用语法如下：<code>import module_name as mn</code></li>
<li>导入模块中的所有函数<br>
最好只导入你需要用的函数，或者导入整个模块并使用句点表示法。<br>
导入模块 module_name 中的所有函数通用语法如下：<code>from module_name import *</code></li>
</ol>
<p>所有的 import 语句都应放在文件开头，唯一例外的情形是，在文件开头使用了注释来描述整个程序。</p>
<h2 id="1-7-类">1.7 类</h2>
<h3 id="1-7-1-创建类">1.7.1 创建类</h3>
<p>根据约定，在Python中，首字母大写的名称指的是类。</p>
<pre><code class="language-py">class Dog():
    &quot;&quot;&quot;一次模拟小狗的简单尝试&quot;&quot;&quot;
    def __init__(self, name, age):
        &quot;&quot;&quot;初始化属性name和age&quot;&quot;&quot;
        self.name = name
        self.age = age
        self.son = 'zero'
    def sit(self):
        &quot;&quot;&quot;模拟小狗被命令时蹲下&quot;&quot;&quot;
        print(self.name.title() + &quot; is now sitting.&quot;)
    def roll_over(self):
        &quot;&quot;&quot;模拟小狗被命令时打滚&quot;&quot;&quot;
        print(self.name.title() + &quot; rolled over!&quot;)
my_dog = Dog('willie', 6)
print(&quot;My dog's name is &quot; + my_dog.name.title() + &quot;.&quot;)
print(&quot;My dog is &quot; + str(my_dog.age) + &quot; years old.&quot;)
my_dog.sit()
print(my_dog.son)
</code></pre>
<p>一 方法 <strong>init</strong>()<br>
可参考c++中的构造函数。</p>
<ol>
<li>我们将方法 <strong>init</strong>() 定义成了包含三个形参： self 、 name 和 age 。在这个方法的定义中，形参 self 必不可少，还必须位于其他形参的前面，相当于c++中的This指针。</li>
<li>因为Python调用这个 <strong>init</strong>() 方法来创建 Dog 实例时，将自动传入实参 self 。每个与类相关联的方法调用都自动传递实参 self ，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。</li>
<li>我们将通过实参向 Dog() 传递名字和年龄； self 会自动传递，因此我们不需要传递它。每当我们根据 Dog 类创建实例时，都只需给最后两个形参（ name 和 age ）提供值。</li>
<li>Dog 类还定义了另外两个方法： sit() 和 roll_over() 。由于这些方法不需要额外的信息，如名字，因此它们只有一个形参 self 。</li>
</ol>
<p>二 根据类创建实例</p>
<ol>
<li>访问属性<br>
要访问实例的属性，可使用句点表示法。<code>my_dog.name</code></li>
<li>调用方法<br>
用句点表示法来调用 Dog 类中定义的任何方法。<code>my_dog.roll_over()</code></li>
<li>给属性指定默认值<br>
可以在方法 <strong>init</strong>()中添加默认值<br>
如果你对某个属性这样做了，就无需包含为它提供初始值的形参。</li>
</ol>
<p>三 修改属性的值</p>
<ol>
<li>直接修改属性的值<br>
<code>my_dog.son='kuku'</code></li>
<li>通过方法修改属性的值<br>
等于在类里面新建一个方法，来修改类里面属性的值<br>
<code>def update_name(self, mile):</code><br>
<code>self.name = mile</code></li>
<li>通过方法对属性的值进行递增<br>
跟2差不多，用方法里面的实参来修改。</li>
</ol>
<h3 id="1-7-2-继承">1.7.2 继承</h3>
<pre><code class="language-py">class ElectricCar(Car):
    &quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;
   def __init__(self, make, model, year):
      &quot;&quot;&quot;初始化父类的属性&quot;&quot;&quot;
      super().__init__(make, model, year)
      self.battery_size = 70
</code></pre>
<p>一 给子类定义属性和方法<br>
<strong>super() 是一个特殊函数，帮助Python将父类和子类关联起来。这行代码让Python调用ElectricCar 的父类的方法 <strong>init</strong>() ，让 ElectricCar 实例包含父类的所有属性。父类也称为超类（superclass），名称super因此而得名。</strong></p>
<p>二 重写父类的方法</p>
<p>可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。</p>
<h3 id="1-7-3-导入类">1.7.3 导入类</h3>
<p>Python允许你将类存储在模块中，然后在主程序中导入所需的模块。</p>
<ol>
<li>导入类<br>
<code>from car import Car</code></li>
<li>从一个模块中导入多个类<br>
<code>from car import Car, ElectricCar</code></li>
<li>导入整个模块<br>
你还可以导入整个模块，再使用句点表示法访问需要的类。<code>import car</code></li>
<li>导入模块中的所有类<br>
<code>from module_name import *</code> #不推荐这种方式</li>
<li>在一个模块中导入另一个模块</li>
</ol>
<h3 id="1-7-4-类编码风格">1.7.4 类编码风格</h3>
<p>类名应采用驼峰命名法，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。</p>
<h2 id="1-8-文件和异常">1.8 文件和异常</h2>
<h3 id="1-8-1-从文件中读取数据">1.8.1 从文件中读取数据</h3>
<h4 id="1-8-1-1-读取整个文件">1.8.1.1 读取整个文件</h4>
<p>open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。<br>
<code>open(file, mode='r')</code><br>
完整的语法格式为：<br>
<code>open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code><br>
参数说明:</p>
<ul>
<li>file: 必需，文件路径（相对或者绝对路径）。</li>
<li>mode: 可选，文件打开模式</li>
<li>buffering: 设置缓冲</li>
<li>encoding: 一般使用utf8</li>
<li>errors: 报错级别</li>
<li>newline: 区分换行符</li>
<li>closefd: 传入的file参数类型</li>
<li>opener:</li>
</ul>
<pre><code class="language-py">with open('pi_digits.txt') as file_object:
   contents = file_object.read()
   print(contents)
</code></pre>
<p>函数 open() 接受一个参数：要打开的文件的名称。 函数 open()返回一个表示文件的对象。Python将这个对象存储在我们将在后面使用的变量中。<br>
关键字 ==with== 在不再需要访问文件后将其关闭。在这个程序中，我们没有调用 close() ；你只管打开文件，并在需要时使用它，Python自会在合适的时候自动将其关闭。<br>
有了表示 pi_digits.txt 的文件对象后，我们使用方法 read() （前述程序的第2行）读取这个文件的全部内容，并将其作为一个长长的字符串存储在变量 contents 中。这样，通过打印 contents 的值，就可将这个文本文件的全部内容显示出来。<br>
相比于原始文件，该输出唯一不同的地方是末尾多了一个空行。为何会多出这个空行呢？因为 read() 到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除多出来的空行，可在 print 语句中使用 rstrip() ：<code>print(contents.rstrip())</code></p>
<h4 id="1-8-1-2-文件路径">1.8.1.2 文件路径</h4>
<p>在Linux和OS X中，你可以这样编写代码：<br>
<code>file_path = '/home/ehmatthes/other_files/text_files/filename.txt'</code><br>
<code>with open(file_path) as file_object:</code><br>
Windows系统中，在文件路径中使用反斜杠（ \ ）而不是斜杠（ / ）：<br>
<code>file_path = 'C:\Users\ehmatthes\other_files\text_files\filename.txt'</code><br>
<code>with open(file_path) as file_object:</code></p>
<h4 id="1-8-1-3-逐行读取">1.8.1.3 逐行读取</h4>
<pre><code class="language-py">filename = 'pi_digits.txt'
with open(filename) as file_object:
   for a in file_object:
      print(a.rstrip())
</code></pre>
<h4 id="1-8-1-4-创建一个包含文件各行内容的列表">1.8.1.4 创建一个包含文件各行内容的列表</h4>
<pre><code class="language-py">filename = 'pi_digits.txt'
with open(filename) as file_object:
   lines = file_object.readlines()
for line in lines:
   print(line.rstrip())
</code></pre>
<h4 id="1-8-1-5-使用文件的内容">1.8.1.5 使用文件的内容</h4>
<pre><code class="language-py">filename = 'pi_digits.txt'
with open(filename) as file_object:
   lines = file_object.readlines()
pi_string = ''
for line in lines:
   pi_string += line.strip()
print(pi_string)
</code></pre>
<p>输出3.141592653589793238462643383279<br>
在变量 pi_string 存储的字符串中，包含原来位于每行左边的空格，为删除这些空格，可使用 strip() 函数消除空格。<br>
<code>print str.strip( '0' );  # 去除首尾字符 0</code></p>
<h3 id="1-8-2-写入文件">1.8.2 写入文件</h3>
<h4 id="1-8-2-1-写入空文件">1.8.2.1 写入空文件</h4>
<pre><code class="language-py">filename = 'a.txt'
with open(filename, 'w') as file_object:
   file_object.write(&quot;I love programming.\n&quot;)
</code></pre>
<p>打开文件时，可指定<strong>读取模式（ ‘r’ ）、写入模式（ ‘w’ ）、附加模式（ ‘a’ ）或让你能够读取和写入文件的模式（ ‘r+’ ）</strong>。如果<br>
你省略了模式实参，Python将以默认的只读模式打开文件。<br>
<strong>Python只能将字符串写入文本文件。要将数值数据存储到文本文件中，必须先使用函数str() 将其转换为字符串格式。</strong></p>
<h4 id="1-8-2-2-写入多行">1.8.2.2 写入多行</h4>
<p>每句后面加上换行符。</p>
<h3 id="1-8-3-异常">1.8.3 异常</h3>
<p>Python使用被称为异常的特殊对象来管理程序执行期间发生的错误。每当发生错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继续运行；如果你未对异常进行处理，程序将停止，并显示一个traceback，其中包含有关异常的报告。<br>
异常是使用 try-except 代码块处理的。 try-except 代码块让Python执行指定的操作，同时告诉Python发生异常时怎么办。使用了 try-except 代码块时，即便出现异常，程序也将继续运行：显示你编写的友好的错误消息，而不是令用户迷惑的traceback。</p>
<h4 id="1-8-3-1-使用-try-except-else-代码块">1.8.3.1 使用 try-except-else 代码块</h4>
<pre><code class="language-py">print(&quot;Give me two numbers, and I'll divide them.&quot;)
print(&quot;Enter 'q' to quit.&quot;)
while True:
   first_number = input(&quot;\nFirst number: &quot;)
   if first_number == 'q':
     break
   second_number = input(&quot;Second number: &quot;)
   try:
      answer = int(first_number) / int(second_number)
   except ZeroDivisionError:
      print(&quot;You can't divide by 0!&quot;)
   else:
      print(answer)
</code></pre>
<p>当你认为可能发生了错误时，可编写一个 try-except 代码块来处理可能引发的异常。<br>
通过将可能引发错误的代码放在 try-except 代码块中，可提高这个程序抵御错误的能力。这个示例还包含一个 else 代码块；依赖于 try 代码块成功执行的代码都应放到 else 代码块中。<br>
try-except-else 代码块的工作原理大致如下：<strong>Python尝试执行 try 代码块中的代码；只有可能引发异常的代码才需要放在 try 语句中。有时候，有一些仅在 try 代码块成功执行时才需要运行的代码；这些代码应放在 else 代码块中。 except 代码块告诉Python，如果它尝试运行 try 代码块中的代码时引发了指定的异常，该怎么办。</strong></p>
<h4 id="1-8-3-2-分析多个文本">1.8.3.2 分析多个文本</h4>
<pre><code class="language-py">def count_words(filename):
   &quot;&quot;&quot;计算一个文件大致包含多少个单词&quot;&quot;&quot;
   try:
      with open(filename) as f_obj:
         contents = f_obj.read()
   except FileNotFoundError:
      print(&quot;Sorry, the file &quot; + filename + &quot; does not exist.&quot;)
   else:
      # 计算文件大致包含多少个单词
      words = contents.split()
      num_words = len(words)
      print(&quot;The file &quot; + filename + &quot; has about &quot; + str(num_words) + &quot; words.&quot;)

filenames = ['0.txt', '1.txt', '2.txt', '3.txt']
for filename in filenames:
   count_words(filename)
</code></pre>
<p>如果你希望失败的时候不提示用户，可以在 except xxxError 后面添加一句pass。</p>
<h3 id="1-8-4-存储数据">1.8.4 存储数据</h3>
<p>模块 json 让你能够将简单的Python数据结构转储到文件中，并在程序再次运行时加载该文件中的数据。还可以使用 json 在Python程序之间分享数据。更重要的是，JSON数据格式并非Python专用的，这让你能够将以JSON格式存储的数据与使用其他编程语言的人分享。</p>
<h4 id="1-8-4-1-使用-json-dump-和-json-load-保存和读取用户生成的数据">1.8.4.1 使用 json.dump() 和 json.load() 保存和读取用户生成的数据</h4>
<pre><code class="language-py">import json
# 如果以前存储了用户名，就加载它
# 否则，就提示用户输入用户名并存储它
filename = 'username.json'
try:
   with open(filename) as f_obj:
      username = json.load(f_obj)
except FileNotFoundError:
   username = input(&quot;What is your name? &quot;)
   with open(filename, 'w') as f_obj:
      json.dump(username, f_obj)
      print(&quot;We'll remember you when you come back, &quot; + username + &quot;!&quot;)
else:
   print(&quot;Welcome back, &quot; + username + &quot;!&quot;)
</code></pre>
<p>先导入模块json，通过方法json.dump() 和 json.load()来保存用户名。<br>
上面的程序，如果第一次执行，保存用户名到username，第二次执行则显示欢迎回来。</p>
<h4 id="1-8-4-2-重构">1.8.4.2 重构</h4>
<p>有时候，我们要保证高内聚，低耦合，需要将各个模块代码分为一系列完成具体工作的函数，这样的过程称为重构。<br>
下面我们来重构上一节的代码：</p>
<pre><code class="language-py">import json
def get_stored_username():
   &quot;&quot;&quot;如果存储了用户名，就获取它&quot;&quot;&quot;
   filename = 'username.json'
   try:
      with open(filename) as f_obj:
         username = json.load(f_obj)
   except FileNotFoundError:
      return None
   else:
      return username

def get_new_username():
   &quot;&quot;&quot;提示用户输入用户名&quot;&quot;&quot;
   username = input(&quot;What is your name? &quot;)
   filename = 'username.json'
   with open(filename, 'w') as f_obj:
      json.dump(username, f_obj)
   return username

def greet_user():
   &quot;&quot;&quot;问候用户，并指出其名字&quot;&quot;&quot;
   username = get_stored_username()
   if username:
      print(&quot;Welcome back, &quot; + username + &quot;!&quot;)
   else:
      username = get_new_username()
      print(&quot;We'll remember you when you come back, &quot; + username + &quot;!&quot;)

greet_user()
</code></pre>
<p>在这个最终版本中，每个函数都执行单一而清晰的任务。要编写出清晰而易于维护和扩展的代码，划分工作必不可少。</p>
<h2 id="1-9-测试代码">1.9 测试代码</h2>
<p>这章中我们学习如何使用Python模块 unittest 中的工具来测试代码。</p>
<h3 id="1-9-1-测试函数">1.9.1 测试函数</h3>
<h4 id="1-9-1-1-单元测试和测试用例">1.9.1.1 单元测试和测试用例</h4>
<p>Python标准库中的模块 unittest 提供了代码测试工具。单元测试用于核实函数的某个方面没有问题；测试用例是一组单元测试，这些单元测试一起核实函数在各种情形下的行为都符合要求。良好的测试用例考虑到了函数可能收到的各种输入，包含针对所有这些情形的测试。全覆盖式测试用例包含一整套单元测试，涵盖了各种可能的函数使用方式。对于大型项目，要实现全覆盖可能很难。通常，最初只要针对代码的重要行为编写测试即可，等项目被广泛使用时再考虑全覆盖。</p>
<h4 id="1-9-1-2-如何测试">1.9.1.2 如何测试</h4>
<p>要为函数编写测试用例，可先导入模块 unittest 以及要测试的函数，再创建一个继承 unittest.TestCase 的类，并编写一系列方法对函数行为的不同方面进行测试。<br>
下面是一个只包含一个方法的测试用例，它检查函数 get_formatted_name() 在给定名和姓时能否正确地工作：</p>
<pre><code class="language-py">#文件名name_function.py
def get_formatted_name(first, last, middle=''):
    &quot;&quot;&quot;生成整洁的姓名&quot;&quot;&quot;
    if middle:
        full_name = first + ' ' + middle + ' ' + last
    else:
        full_name = first + ' ' + last
    return full_name.title()
</code></pre>
<pre><code class="language-py">import unittest
from name_function import get_formatted_name
#文件名test_name_ function.py
class NamesTestCase(unittest.TestCase):
    &quot;&quot;&quot;测试name_function.py&quot;&quot;&quot;
    def test_first_last_name(self):
        &quot;&quot;&quot;能够正确地处理像Janis Joplin这样的姓名吗？&quot;&quot;&quot;
        formatted_name = get_formatted_name('janis', 'joplin')
        self.assertEqual(formatted_name, 'Janis Joplin')

    def test_first_last_middle_name(self):
        &quot;&quot;&quot;能够正确地处理像Wolfgang Amadeus Mozart这样的姓名吗？&quot;&quot;&quot;
        formatted_name = get_formatted_name('wolfgang', 'mozart', 'amadeus')
        self.assertEqual(formatted_name, 'Wolfgang Amadeus Mozart')

unittest.main()
</code></pre>
<p>首先，我们导入了模块 unittest 和要测试的函数 get_formatted_ name() 。我们创建了一个名为 NamesTestCase（名字随便） 的类，用于包含一系列针对 get_formatted_name() 的单元测试。这个类必须继承unittest.TestCase 类，这样Python才知道如何运行你编写的测试。<br>
我们运行 test_name_function.py 时，所有以 test_ 打头的方法都将自动运行。<br>
在这个方法中，我们调用了要测试的函数，并存储了要测试的返回值。<br>
最后我们使用了 unittest 类最有用的功能之一：一个断言方法。断言方法用来核实得到的结果是否与期望的结果一致。<br>
我们调用 <strong>unittest 的方法 assertEqual()</strong> ，并向它传递 formatted_name 和 ‘Janis Joplin’ 。代码行 <code>self.assertEqual(formatted_name, 'Janis Joplin')</code> 的意思是说：“将 formatted_name 的值同字符串 ‘Janis Joplin’ 进行比较，如果它们相等，就万事大吉，如果它们不相等，跟我说一声！”</p>
<h3 id="1-9-2-测试类">1.9.2 测试类</h3>
<h4 id="1-9-2-1-各种断言方法">1.9.2.1 各种断言方法</h4>
<p>Python在 unittest.TestCase 类中提供了很多断言方法。如下：</p>
<table>
<thead>
<tr>
<th>方 法</th>
<th>用 途</th>
</tr>
</thead>
<tbody>
<tr>
<td>assertEqual(a, b)</td>
<td>核实 a == b</td>
</tr>
<tr>
<td>assertNotEqual(a, b)</td>
<td>核实 a != b</td>
</tr>
<tr>
<td>assertTrue(x)</td>
<td>核实 x 为 True</td>
</tr>
<tr>
<td>assertFalse(x)</td>
<td>核实 x 为 False</td>
</tr>
<tr>
<td>assertIn( item , list )</td>
<td>核实 item 在 list 中</td>
</tr>
<tr>
<td>assertNotIn( item , list )</td>
<td>核实 item 不在 list 中</td>
</tr>
</tbody>
</table>
<h4 id="1-9-2-2-方法-setUp">1.9.2.2 方法 setUp()</h4>
<pre><code class="language-py">class AnonymousSurvey():
    &quot;&quot;&quot;收集匿名调查问卷的答案&quot;&quot;&quot;
    def __init__(self, question):
        &quot;&quot;&quot;存储一个问题，并为存储答案做准备&quot;&quot;&quot;
        self.question = question
        self.responses = []

    def show_question(self):
        &quot;&quot;&quot;显示调查问卷&quot;&quot;&quot;
        print(question)

    def store_response(self, new_response):
        &quot;&quot;&quot;存储单份调查答卷&quot;&quot;&quot;
        self.responses.append(new_response)

    def show_results(self):
        &quot;&quot;&quot;显示收集到的所有答卷&quot;&quot;&quot;
        print(&quot;Survey results:&quot;)
        for response in responses:
            print('- ' + response)
</code></pre>
<pre><code class="language-py">import unittest
from survey import AnonymousSurvey
class TestAnonymousSurvey(unittest.TestCase):
    &quot;&quot;&quot;针对AnonymousSurvey类的测试&quot;&quot;&quot;
    def setUp(self):
    # 创建一个调查对象和一组答案，供使用的测试方法使用
        question = &quot;What language did you first learn to speak?&quot;
        self.my_survey = AnonymousSurvey(question)
        self.responses = ['English', 'Spanish', 'Mandarin']

    def test_store_single_response(self):
        &quot;&quot;&quot;测试单个答案会被妥善地存储&quot;&quot;&quot;
        self.my_survey.store_response(self.responses[0])
        self.assertIn(self.responses[0], self.my_survey.responses)

    def test_store_three_responses(self):
        &quot;&quot;&quot;测试三个答案会被妥善地存储&quot;&quot;&quot;
        for response in self.responses:
            self.my_survey.store_response(response)
        for response in self.responses:
            self.assertIn(response, self.my_survey.responses)

unittest.main()
</code></pre>
<p>使用 setUp() 来创建一个调查对象和一组答案，供方法 <code>test_store_single_response()</code> 和 <code>test_store_three_responses()</code> 使用。<br>
方法 setUp() 做了两件事情：创建一个调查对象（见方法setUp()第4行）；创建一个答案列表（见方法setUp()第5行）。<br>
这让两个测试方法都更简单，因为它们都不用创建调查对象和答案。方法 <code>test_store_three_response()</code> 核实 self.responses 中的第一个答案—— self.responses[0] ——被妥善地存储，而方法 <code>test_store_three_response()</code> 核实 self.responses 中的全部三个答案都被妥善地存储。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构第九章 排序</title>
    <url>/2020/02/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC9%E7%AB%A0%20%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>排序的定义：</strong><br>
<strong>假设含有n个记录的序列为{$r_1$，$r_2$，…，$r_n$}，其相应的关键字分别为{$k_1$，$k_2$，…，$k_n$}，需确定1，2，……，n的一种排列$p_1$，$p_2$，……，$p_n$，使其相应的关键字满足$k_{p1}$≤$k_{p2}$≤······≤$k_{pn}$（非递减或非递增）关系，即使得序列成为一个按关键字有序的序列{$r_{p1}$，$r_{p2}$，······，$r_{pn}$}，这样的操作就称为排序。</strong></p>
<a id="more"></a>
<h2 id="9-1-9-2-排序的基本概念与分类">9.1-9.2 排序的基本概念与分类</h2>
<p>我们在排序问题中，通常将数据元素称为记录。显然我们输入的是一个记录集合，输出的也是一个记录集合，所以说，可以将排序看成是线性表的一种操作。</p>
<p>排序的依据是关键字之间的大小关系，那么，对同一个记录集合，针对不同的关键字进行排序，可以得到不同序列。</p>
<p>这里关键字k可以是记录r的主关键字，也可以是次关键字，甚至是若干数据项的组合。</p>
<h3 id="9-2-1-排序的稳定性">9.2.1 排序的稳定性</h3>
<p>假设$k_i=k_y(1≤i≤n，1≤j≤n，i≠j)$，且在排序前的序列中$r_i$领先于$r_j$（即$i&lt;j$）。如果排序后$r_i$仍领先于$r_j$，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中$r_j$领先$r_i$，则称所用的排序方法是不稳定的。</p>
<h3 id="9-2-2-内排序与外排序">9.2.2 内排序与外排序</h3>
<p>根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为：内排序和外排序。</p>
<p>**内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。**我们这里主要就介绍内排序的多种方法。</p>
<p>对于内排序来说，排序算法的性能主要是受3个方面影响：</p>
<ol>
<li><strong>时间性能</strong><br>
排序是数据处理中经常执行的一种操作，往往属于系统的核心部分，因此排序算法的时间开销是衡量其好坏的最重要的标志。在内排序中，主要进行两种操作：比较和移动。比较指关键字之间的比较，这是要做排序最起码的操作。移动指记录从一个位置移动到另一个位置，事实上，移动可以通过改变记录的存储方式来予以避免（这个我们在讲解具体的算法时再谈）。总之，高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。</li>
<li><strong>辅助空间</strong><br>
评价排序算法的另一个主要标准是执行算法所需要的辅助存储空间。辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。</li>
<li><strong>算法的复杂性</strong><br>
注意这里指的是算法本身的复杂度，而不是指算法的时间复杂度。显然算法过于复杂也会影响排序的性能。</li>
</ol>
<p>根据排序过程中借助的主要操作，我们把<strong>内排序分为：插入排序、交换排序、选择排序和归并排序。</strong></p>
<p>本章一共要讲解七种排序的算法，按照算法的复杂度分为两大类，冒泡排序、简单选择排序和直接插入排序属于简单算法，而希尔排序、堆排序、归并排序、快速排序属于改进算法。</p>
<h3 id="9-2-3-排序用到的结构与函数">9.2.3 排序用到的结构与函数</h3>
<p>为了讲清楚排序算法的代码，我先提供一个用于排序用的顺序表结构，此结构也将用于之后我们要讲的所有排序算法。</p>
<pre><code class="language-c">#define MAXSIZE 10  /* 用于要排序数组个数最大值，可根据需要修改 */
typedef struct
{
    int r[MAXSIZE + 1];    /* 用于存储要排序数组，r[0]用作哨兵或临时变量 */
    int length;            /* 用于记录顺序表的长度 */
}SqList;
</code></pre>
<p>另外，由于排序最最常用到的操作是数组两元素的交换，我们将它写成函数，在之后的讲解中会大量的用到。</p>
<pre><code class="language-c">/* 交换L中数组r的下标为i和j的值 */
void swap(SqList *L, int i, int j)
{
    int temp = L-&gt;r[i];
    L-&gt;r[i] = L-&gt;r[j];
    L-&gt;r[j] = temp;
}
</code></pre>
<h2 id="9-3-冒泡排序">9.3 冒泡排序</h2>
<h3 id="9-3-1-最简单排序实现">9.3.1 最简单排序实现</h3>
<p>**冒泡排序（Bubble Sort）一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。**冒泡的实现在细节上可以有很多种变化，我们将分别就3种不同的冒泡实现代码，来讲解冒泡排序的思想。</p>
<pre><code class="language-c">/* 对顺序表L作交换排序（冒泡排序初级版） */
void BubbleSort0(SqList *L)
{
    int i, j;
    for (i = 1; i &lt; L-&gt;length; i++)
    {
        for (j = i + 1; j &lt;= L-&gt;length; j++)
        {
            if (L-&gt;r[i] &gt; L-&gt;r[j])
            {
                swap(L, i, j);/* 交换L-&gt;r[i]与L-&gt;r[j]的值 */
            }
        }
    }
}
</code></pre>
<h3 id="9-3-2-冒泡排序算法">9.3.2 冒泡排序算法</h3>
<p>我们来看看正宗的冒泡算法，有没有什么改进的地方。</p>
<pre><code class="language-c">/* 对顺序表L作冒泡排序 */
void BubbleSort(SqList *L)
{
    int i, j;
    for (i = 1; i &lt; L-&gt;length; i++)
    {
        for (j = L-&gt;length - 1; j &gt;= i; j--)  /* 注意j是从后往前循环 */
        {
            if (L-&gt;r[j] &gt; L-&gt;r[j + 1]) /* 若前者大于后者（注意这里与上一算法的差异）*/
            {
                swap(L, j, j + 1);/* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */
            }
        }
    }
}
</code></pre>
<h3 id="9-3-3-冒泡排序优化">9.3.3 冒泡排序优化</h3>
<pre><code class="language-c">/* 对顺序表L作改进冒泡算法 */
void BubbleSort2(SqList *L)
{
    int i, j;
    Status flag = TRUE;            /* flag用来作为标记 */
    for (i = 1; i &lt; L-&gt;length &amp;&amp; flag; i++) /* 若flag为true说明有过数据交换，否则停止循环 */
    {
        flag = FALSE;                /* 初始为False */
        for (j = L-&gt;length - 1; j &gt;= i; j--)
        {
            if (L-&gt;r[j] &gt; L-&gt;r[j + 1])
            {
                swap(L, j, j + 1);    /* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */
                flag = TRUE;        /* 如果有数据交换，则flag为true */
            }
        }
    }
}
</code></pre>
<p>代码改动的关键就是在i变量的for循环中，增加了对flag是否为true的判断。</p>
<p>经过这样的改进，冒泡排序在性能上就有了一些提升，可以避免因已经有序的情况下的无意义循环判断。</p>
<h3 id="9-3-4-冒泡排序复杂度分析">9.3.4 冒泡排序复杂度分析</h3>
<p>分析一下它的时间复杂度。当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以推断出就是n-1次的比较，没有数据交换，时间复杂度为 O（n）。当最坏的情况，即待排序表是逆序的情况，此时需要比较$\sum_{i=2}^n(i-1)=1+2+3+…+（n-1）=\frac{n(n-1)}2$次，并作等数量级的记录移动。因此，a的时间复杂度为O（n²）。</p>
<h2 id="9-4-简单选择排序">9.4 简单选择排序</h2>
<p>冒泡排序的思想就是不断地在交换，通过交换完成最终的排序，这和做股票短线频繁操作的人是类似的。我们可不可以像只有在时机非常明确到来时才出手的股票高手一样，也就是在排序时找到合适的关键字再做交换，并且只移动一次就完成相应关键字的排序定位工作呢？这就是选择排序法的初步思想。</p>
<p>选择排序的基本思想是每一趟在<code>n-i+1（i=1，2,…，n-1）</code>个记录中选取关键字最小的记录作为有序序列的第i个记录。我们这里先介绍的是简单选择排序法。</p>
<h3 id="9-4-1-简单选择排序算法">9.4.1 简单选择排序算法</h3>
<p><strong>简单选择排序法（Simple Selection Sort）就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i（1≤i≤n）个记录交换之。</strong></p>
<pre><code class="language-c">/* 对顺序表L作简单选择排序 */
void SelectSort(SqList *L)
{
    int i, j, min;
    for (i = 1; i &lt; L-&gt;length; i++)
    {
        min = i;                        /* 将当前下标定义为最小值下标 */
        for (j = i + 1; j &lt;= L-&gt;length; j++)/* 循环之后的数据 */
        {
            if (L-&gt;r[min] &gt; L-&gt;r[j])    /* 如果有小于当前最小值的关键字 */
                min = j;                /* 将此关键字的下标赋值给min */
        }
        if (i != min)                        /* 若min不等于i，说明找到最小值，交换 */
            swap(L, i, min);                /* 交换L-&gt;r[i]与L-&gt;r[min]的值 */
    }
}
</code></pre>
<p>简单选择排序会先找到最小值的下标，然后交换。接着迭代循环。</p>
<h3 id="9-4-2-简单选择排序复杂度分析">9.4.2 简单选择排序复杂度分析</h3>
<p>从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第i趟排序需要进行n-i次关键字的比较，此时需要比较$\sum_{i=1}^{n-1}(n-i)=n-1+n-2+…+1=\frac{n(n-1)}{2}$次。而对于交换次数而言，当最好的时候，交换为0次，最差的时候，也就初始降序时，交换次数为n-1次，基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为O（n²）。</p>
<p>应该说，尽管与冒泡排序同为O（n²），但简单选择排序的性能上还是要略优于冒泡排序。</p>
<h2 id="9-5-直接插入排序">9.5 直接插入排序</h2>
<h3 id="9-5-1-直接插入排序算法">9.5.1 直接插入排序算法</h3>
<p><strong>直接插入排序（Straight Insertion Sort）的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。</strong></p>
<pre><code class="language-c">/* 对顺序表L作直接插入排序 */
void InsertSort(SqList *L)
{
    int i, j;
    for (i = 2; i &lt;= L-&gt;length; i++)
    {
        if (L-&gt;r[i] &lt; L-&gt;r[i - 1]) /* 需将L-&gt;r[i]插入有序子表 */
        {
            L-&gt;r[0] = L-&gt;r[i]; /* 设置哨兵 */
            for (j = i - 1; L-&gt;r[j] &gt; L-&gt;r[0]; j--)
                L-&gt;r[j + 1] = L-&gt;r[j]; /* 记录后移 */
            L-&gt;r[j + 1] = L-&gt;r[0]; /* 插入到正确位置 */
        }
    }
}
</code></pre>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构第八章 查找</title>
    <url>/2020/01/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC8%E7%AB%A0%20%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><strong>查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</strong></p>
<h2 id="8-1-8-2-查找概论">8.1-8.2 查找概论</h2>
<p>查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合。例如图8-2-1就是一个查找表。</p>
<a id="more"></a>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-2-1.JPG?raw=true" srcset="/img/loading.gif" alt="8-2-1"><br>
关键字（Key）是数据元素中某个数据项的值，又称为键值，用它可以标识一个数据元素。也可以标识一个记录的某个数据项（字段），我们称为关键码，如图8-2-1中①和②所示。<br>
若此关键字可以唯一地标识一个记录，则称此关键字为主关键字（Primary Key）。注意这也就意味着，对不同的记录，其主关键字均不相同。主关键字所在的数据项称为主关键码，如图8-2-1中③和④所示。<br>
那么对于那些可以识别多个数据元素（或记录）的关键字，我们称为次关键字（Secondary Key），如图8-2-1中⑤所示。次关键字也可以理解为是不以唯一标识一个数据元素（或记录）的关键字，它对应的数据项就是次关键码。<br>
查找表按照操作方式来分有两大种：<strong>静态查找表和动态查找表</strong>。<br>
静态查找表（Static Search Table）：只作查找操作的查找表。它的主要操作有：</p>
<ol>
<li>查询某个“特定的”数据元素是否在查找表中。</li>
<li>检索某个“特定的”数据元素和各种属性。</li>
</ol>
<p>动态查找表（Dynamic Search Table）：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。显然动态查找表的操作就是两个：</p>
<ol>
<li>查找时插入数据元素。</li>
<li>查找时删除数据元素。</li>
</ol>
<p>为了提高查找的效率，我们需要专门为查找操作设置数据结构，这种<strong>面向查找操作的数据结构称为查找结构</strong>。<br>
从逻辑上来说，查找所基于的数据结构是集合，集合中的记录之间没有本质关系。可是要想获得较高的查找性能，我们就不能不改变数据元素之间的关系，在存储时可以将查找集合组织成表、树等结构。<br>
例如，对于静态查找表来说，我们不妨应用线性表结构来组织数据，这样可以使用顺序查找算法，如果再对主关键字排序，则可以应用折半查找等技术进行高效的查找。<br>
如果是需要动态查找，则会复杂一些，可以考虑二叉排序树的查找技术。</p>
<h2 id="8-3-顺序表查找">8.3 顺序表查找</h2>
<p><strong>顺序查找（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。</strong></p>
<h3 id="8-3-1-顺序表查找算法">8.3.1 顺序表查找算法</h3>
<p>顺序查找的算法实现如下：</p>
<pre><code class="language-c">/* 无哨兵顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字 */
int Sequential_Search(int *a,int n,int key)
{
    int i;
    for(i=1;i&lt;=n;i++){
        if (a[i]==key)
            return i;
    }
    return 0;
}
</code></pre>
<h3 id="8-3-2-顺序表查找优化">8.3.2 顺序表查找优化</h3>
<p>到这里并非足够完美，因为每次循环时都需要对i是否小于等于n作判断。事实上，设置一个哨兵，就不需要每次让i与n作比较。看下面的改进后的顺序查找算法代码。</p>
<pre><code class="language-c">/* 有哨兵顺序查找 */
int Sequential_Search2(int *a,int n,int key)
{
    int i;
    a[0]=key;
    i=n;
    while(a[i]!=key){
        i--;
    }
    return i;
}
</code></pre>
<p>这种在查找方向的尽头放置“哨兵”免去了在查找过程中每一次比较后都要判断查找位置是否越界的小技巧，看似与原先差别不大，但在总数据较多时，效率提高很大，是非常好的编码技巧。当然，“哨兵”也不一定就一定要在数组开始，也可以在末端。<br>
对于这种顺序查找算法来说，平均查找次数为（n+1）/2，所以最终时间复杂度还是O（n）。<br>
很显然，顺序查找技术是有很大缺点的，n很大时，查找效率极为低下，不过优点也是有的，算法非常简单，对静态查找表的记录没有任何要求，在一些小型数据的查找时，是可以适用的。<br>
另外，也正由于查找概率的不同，我们完全可以将容易查找到的记录放在前面，而不常用的记录放置在后面，效率就可以有大幅提高。</p>
<h2 id="8-4-有序表查找">8.4 有序表查找</h2>
<h3 id="8-4-1-折半查找">8.4.1 折半查找</h3>
<p><strong>折半查找（Binary Search）技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。</strong><br>
折半查找代码如下：</p>
<pre><code class="language-c">/* 折半查找 */
int Binary_Search(int *a,int n,int key){
    int low,high,mid;
    low=1;    /* 定义最低下标为记录首位 */
    high=n;    /* 定义最高下标为记录末位 */
    while(low&lt;=high){
        mid=(low+high)/2;    /* 折半 */
        if (key&lt;a[mid])        /* 若查找值比中值小 */
            high=mid-1;        /* 最高下标调整到中位下标小一位 */
        else if (key&gt;a[mid])/* 若查找值比中值大 */
            low=mid+1;        /* 最低下标调整到中位下标大一位 */
        else
            return mid;        /* 若相等则说明mid即为查找到的位置 */
    }
    return 0;
}
</code></pre>
<p>折半算法的时间复杂度为O（㏒n），它显然远远好于顺序查找的O（n）时间复杂度。<br>
不过由于折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，这样的算法已经比较好了。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p>
<h3 id="8-4-2-插值查找">8.4.2 插值查找</h3>
<p>折半查找代码的第6句，我们略微等式变换后得到：<br>
<code>mid=(low+high)/2=low+1/2(high-low);</code><br>
我们将在折半查找算法的代码中更改一下，第6行代码如下：<br>
<code>mid=low+ (high-low)*(key-a[low])/(a[high]-a[low]); /* 插值 */</code><br>
<strong>插值查找（Interpolation Search）是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式<code>(key-a[low])/(a[high]-a[low])</code>。</strong><br>
应该说，从时间复杂度来看，它也是O（㏒n），但对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多。反之，数组中如果分布类似{0，1，2，2000，2001……，999998，999999}这种极端不均匀的数据，用插值查找未必是很合适的选择。</p>
<h3 id="8-4-3-斐波那契查找">8.4.3 斐波那契查找</h3>
<p>斐波那契查找（Fibonacci Search），它是利用了黄金分割原理来实现的。<br>
下面我们根据代码来看程序是如何运行的。</p>
<pre><code class="language-c">/* 斐波那契查找 */
int Fibonacci_Search(int *a,int n,int key)
{
    int low,high,mid,i,k=0;
    low=1;    /* 定义最低下标为记录首位 */
    high=n;    /* 定义最高下标为记录末位 */
    while(n&gt;F[k]-1) /* 计算n位于斐波那契数列的位置 */
        k++;
    for (i=n;i&lt;F[k]-1;i++) /* 将不满的数值补全 */
        a[i]=a[n];
    while(low&lt;=high){
        mid=low+F[k-1]-1;
        if (key&lt;a[mid]){
            high=mid-1;
            k=k-1;
        }
        else if (key&gt;a[mid]){
            low=mid+1;
            k=k-2;
        }
        else{
            if (mid&lt;=n)
                return mid;        /* 若相等则说明mid即为查找到的位置 */
            else
                return n;
        }
    }
    return 0;
}
</code></pre>
<p>斐波那契查找算法的核心在于：</p>
<ol>
<li>当<code>key=a[mid]</code>时，查找就成功；</li>
<li>当<code>key&lt;a[mid]</code>时，新范围是第low个到第mid-1个，此时范围个数为F[k-1]-1个；</li>
<li>当<code>key&gt;a[mid]</code>时，新范围是第m+1个到第high个，此时范围个数为F[k-2]-1个。</li>
</ol>
<p>也就是说，如果要查找的记录在右侧，则左侧的数据都不用再判断了，不断反复进行下去，对处于当中的大部分数据，其工作效率要高一些。所以尽管斐波那契查找的时间复杂也为O（㏒n），但就平均性能来说，斐波那契查找要优于折半查找。可惜如果是最坏情况，比如这里key=1，那么始终都处于左侧长半区在查找，则查找效率要低于折半查找。<br>
还有比较关键的一点，折半查找是进行加法与除法运算<code>（mid=（low+high）/2）</code>，插值查找进行复杂的四则运算<code>mid=low+ (high-low)*(key-a[low])/(a[high]-a[low])</code>，而斐波那契查找只是最简单加减法运算<code>（mid=low+F[k-1]-1）</code>，在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率。<br>
应该说，三种有序表的查找本质上是分隔点的选择不同，各有优劣，实际开发时可根据数据的特点综合考虑再做出选择。</p>
<h2 id="8-5-线性索引查找">8.5 线性索引查找</h2>
<p>数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构。<strong>索引就是把一个关键字与它对应的记录相关联的过程</strong>，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。<br>
索引按照结构可以分为线性索引、树形索引和多级索引。我们这里就只介绍线性索引技术。<strong>所谓线性索引就是将索引项集合组织为线性结构，也称为索引表</strong>。我们重点介绍三种线性索引：稠密索引、分块索引和倒排索引。</p>
<h3 id="8-5-1-稠密索引">8.5.1 稠密索引</h3>
<p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项。，如图8-5-2所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-5-2.JPG?raw=true" srcset="/img/loading.gif" alt="8-5-2"><br>
对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。</p>
<h3 id="8-5-2-分块索引">8.5.2 分块索引</h3>
<p>稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大。为了减少索引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。</p>
<p><strong>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：</strong></p>
<ul>
<li><strong>块内无序</strong>，即每一块内的记录不要求有序。当然，你如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间的代价，因此通常我们不要求块内有序。</li>
<li><strong>块间有序</strong>，例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字……因为只有块间有序，才有可能在查找时带来效率。</li>
</ul>
<p>对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。</p>
<p>如图8-5-4所示，我们定义的分块索引的索引项结构分三个数据项：</p>
<ul>
<li>最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大；</li>
<li>存储了块中的记录个数，以便于循环时使用；</li>
<li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</li>
</ul>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-5-4.JPG?raw=true" srcset="/img/loading.gif" alt="8-5-4"></p>
<p>在分块索引表中查找，就是分两步进行：</p>
<ol>
<li>在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的，因此很容易利用折半、插值等算法得到结果。例如，在图8-5-4的数据集中查找62，我们可以很快可以从左上角的索引表中由<code>57&lt;62&lt;96</code>得到62在第三个块中。</li>
<li>根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查找。</li>
</ol>
<p>分块索引查找的平均查找长度为：（√n）+1。<br>
可见，分块索引的效率比之顺序查找的O（n）是高了不少，不过显然它与折半查找的O（㏒n）相比还有不小的差距。因此在确定所在块的过程中，由于块间有序，所以可以应用折半、插值等手段来提高效率。<br>
总的来说，分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于<strong>数据库表查找</strong>等技术的应用当中。</p>
<h3 id="8-5-3-倒排索引">8.5.3 倒排索引</h3>
<p>搜索引擎常用的最简单的，也算是最基础的搜索技术——倒排索引。<br>
比如不同的文章，将所有单词整理出一张单词表，并排序，出现该单词的则标记为后面的文章编号。</p>
<p>索引项的通用结构是：</p>
<ul>
<li>次关键码，例如“英文单词”；</li>
<li>记录号表，例如“文章编号”。</li>
</ul>
<p>**其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。这样的索引方法就是倒排索引（inverted index）。**倒排索引源于实际应用中需要根据属性（或字段、次关键码）的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引。<br>
倒排索引的优点显然就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果。但它的缺点是这个记录号不定长，比如上例有7个单词的文章编号只有一个，而“book”、“friend”、“good”有两个文章编号，若是对多篇文章所有单词建立倒排索引，那每个单词都将对应相当多的文章编号，维护比较困难，插入和删除操作都需要作相应的处理。</p>
<h2 id="8-6-二叉排序树">8.6 二叉排序树</h2>
<p>二叉排序树（Binary Sort Tree），又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树。</li>
</ul>
<p>这样我们就得到了一棵二叉树，并且当我们对它进行中序遍历时，就可以得到一个有序的序列，所以我们通常称它为二叉排序树。</p>
<h3 id="8-6-1-二叉排序树查找操作">8.6.1 二叉排序树查找操作</h3>
<p>首先我们提供一个二叉树的结构。</p>
<pre><code class="language-c">/* 二叉树的二叉链表结点结构定义 */
typedef  struct BiTNode    /* 结点结构 */
{
    int data;    /* 结点数据 */
    struct BiTNode *lchild, *rchild;    /* 左右孩子指针 */
} BiTNode, *BiTree;
</code></pre>
<p>然后我们来看看二叉排序树的查找是如何实现的。</p>
<pre><code class="language-c">/* 递归查找二叉排序树T中是否存在key, */
/* 指针f指向T的双亲，其初始调用值为NULL */
/* 若查找成功，则指针p指向该数据元素结点，并返回TRUE */
/* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE */
Status SearchBST(BiTree T, int key, BiTree f, BiTree *p)
{
    if (!T)    /*  查找不成功 */
    {
        *p = f;
        return FALSE;
    }
    else if (key == T-&gt;data) /*  查找成功 */
    {
        *p = T;
        return TRUE;
    }
    else if (key &lt; T-&gt;data)
        return SearchBST(T-&gt;lchild, key, T, p);  /*  在左子树中继续查找 */
    else
        return SearchBST(T-&gt;rchild, key, T, p);  /*  在右子树中继续查找 */
}
</code></pre>
<h3 id="8-6-2-二叉排序树插入操作">8.6.2 二叉排序树插入操作</h3>
<p>有了二叉排序树的查找函数，那么所谓的二叉排序树的插入，其实也就是将关键字放到树中的合适位置而已，来看代码。</p>
<pre><code class="language-c">/*  当二叉排序树T中不存在关键字等于key的数据元素时， */
/*  插入key并返回TRUE，否则返回FALSE */
Status InsertBST(BiTree *T, int key)
{
    BiTree p, s;
    if (!SearchBST(*T, key, NULL, &amp;p)) /* 查找不成功 */
    {
        s = (BiTree)malloc(sizeof(BiTNode));
        s-&gt;data = key;
        s-&gt;lchild = s-&gt;rchild = NULL;
        if (!p) /* 此时因为已经查找过了，所有p指向最后查找的根结点 */
            *T = s;            /*  插入s为新的根结点 */
        else if (key &lt; p-&gt;data)
            p-&gt;lchild = s;    /*  插入s为左孩子 */
        else
            p-&gt;rchild = s;  /*  插入s为右孩子 */
        return TRUE;
    }
    else
        return FALSE;  /*  树中已有关键字相同的结点，不再插入 */
}
</code></pre>
<p>有了二叉排序树的插入代码，我们要实现二叉排序树的构建就非常容易了。</p>
<pre><code class="language-c">int i;
    int a[10] = { 62,88,58,47,35,73,51,99,37,93 };
    BiTree T = NULL;
    for (i = 0; i &lt; 10; i++)
        InsertBST(&amp;T, a[i]);
</code></pre>
<h3 id="8-6-3-二叉排序树删除操作">8.6.3 二叉排序树删除操作</h3>
<p>对于要删除的结点只有左子树或只有右子树的情况，相对也比较好解决。那就是结点删除后，将它的左子树或右子树整个移动到删除结点的位置即可，可以理解为独子继承父业。最终，整个结构还是一个二叉排序树。<br>
但是对于要删除的结点既有左子树又有右子树的情况怎么办呢？<br>
比较好的办法就是，找到需要删除的结点p的直接前驱（或直接后继）s，用s来替换结点p，然后再删除此结点s。</p>
<p>根据我们对删除结点三种情况的分析：</p>
<ul>
<li>叶子结点；</li>
<li>仅有左或右子树的结点；</li>
<li>左右子树都有的结点。</li>
</ul>
<p>我们来看代码，下面这个算法是递归方式对二叉排序树T查找key，查找到时删除。</p>
<pre><code class="language-c">/* 若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点, */
/* 并返回TRUE；否则返回FALSE。 */
Status DeleteBST(BiTree *T, int key)
{
    if (!*T) /* 不存在关键字等于key的数据元素 */
        return FALSE;
    else
    {
        if (key == (*T)-&gt;data) /* 找到关键字等于key的数据元素 */
            return Delete(T);
        else if (key &lt; (*T)-&gt;data)
            return DeleteBST(&amp;(*T)-&gt;lchild, key);
        else
            return DeleteBST(&amp;(*T)-&gt;rchild, key);
    }
}
</code></pre>
<p>这段代码和前面的二叉排序树查找几乎完全相同，唯一的区别就在于第8行，此时执行的是Delete方法，对当前结点进行删除操作。我们来看Delete的代码。</p>
<pre><code class="language-c">/* 从二叉排序树中删除结点p，并重接它的左或右子树。 */
Status Delete(BiTree *p)
{
    BiTree q, s;//q、s为临时结点
    if ((*p)-&gt;rchild == NULL) /* 右子树空则只需重接它的左子树(待删结点是叶子也走此分支) */
    {
        q = *p; *p = (*p)-&gt;lchild; free(q);
    }
    else if ((*p)-&gt;lchild == NULL) /* 只需重接它的右子树 */
    {
        q = *p; *p = (*p)-&gt;rchild; free(q);
    }
    else /* 左右子树均不空 */
    {
        q = *p; s = (*p)-&gt;lchild;
        while (s-&gt;rchild) /* 转左，然后向右到尽头（找待删结点NULL的前驱） */
        {//根结点*p的左子树中最右的叶结点为直接前驱
            q = s;
            s = s-&gt;rchild;
        }
        (*p)-&gt;data = s-&gt;data; /*  s指向被删结点的直接前驱（将被删结点前驱的值取代被删结点的值） */
        if (q != *p)
            q-&gt;rchild = s-&gt;lchild; /*  重接q的右子树 */
        else
            q-&gt;lchild = s-&gt;lchild; /*  重接q的左子树 */
        free(s);
    }
    return TRUE;
}
</code></pre>
<p>从这段代码也可以看出，我们其实是在找删除结点的前驱结点替换的方法，对于用后继结点来替换，方法上是一样的。</p>
<h3 id="8-6-4-二叉排序树总结">8.6.4 二叉排序树总结</h3>
<p>总之，二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可。插入删除的时间性能比较好。而对于二叉排序树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。极端情况，最少为1次，即根结点就是要找的结点，最多也不会超过树的深度。也就是说，二叉排序树的查找性能取决于二叉排序树的形状。可问题就在于，二叉排序树的形状是不确定的。<br>
如果，数组元素的次序是从小到大有序，则二叉排序树就成了极端的右斜树，查找时间复杂度为O（n），等同于顺序查找。<br>
因此，如果我们希望对一个集合按二叉排序树查找，最好是把它构建成一棵平衡的二叉排序树。即其深度与完全二叉树相同，那么查找的时间复杂就为O（㏒n），近似于折半查找。</p>
<h2 id="8-7-平衡二叉树（AVL树）">8.7 平衡二叉树（AVL树）</h2>
<p><strong>平衡二叉树（Self-Balancing Binary Search Tree 或Height-Balanced Binary Search Tree），是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1</strong>。<br>
从平衡二叉树的英文名字，你也可以体会到，它是<strong>一种高度平衡的二叉排序树。<strong>那什么叫做高度平衡呢？意思是说，要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。我们</strong>将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF（Balance Factor）</strong>，那么平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。<br>
<strong>距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为最小不平衡子树。</strong></p>
<h3 id="8-7-1-平衡二叉树实现原理">8.7.1 平衡二叉树实现原理</h3>
<p>平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。<br>
所谓的平衡二叉树，其实就是在二叉排序树创建过程中保证它的平衡性，一旦发现有不平衡的情况，马上处理，这样就不会造成不可收拾的情况出现。通过刚才这个例子，你会发现，<strong>当最小不平衡子树根结点的平衡因子BF是大于1时，就右旋，小于-1时就左旋。当插入结点后，最小不平衡子树的BF与它的子树的BF符号相反时，就需要对结点先进行一次旋转以使得符号相同后，再反向旋转一次才能够完成平衡操作。</strong></p>
<h3 id="8-7-2-平衡二叉树实现算法">8.7.2 平衡二叉树实现算法</h3>
<p>首先是需要改进二叉排序树的结点结构，增加一个bf，用来存储平衡因子。</p>
<pre><code class="language-c">/* 二叉树的二叉链表结点结构定义 */
typedef  struct BiTNode    /* 结点结构 */
{
    int data;    /* 结点数据 */
    int bf; /*  结点的平衡因子 */
    struct BiTNode *lchild, *rchild;    /* 左右孩子指针 */
} BiTNode, *BiTree;
</code></pre>
<p>然后，对于右旋操作，我们的代码如下。</p>
<pre><code class="language-c">/* 对以p为根的二叉排序树作右旋处理， */
/* 处理之后p指向新的树根结点，即旋转处理之前的左子树的根结点 */
void R_Rotate(BiTree *P)
{
    BiTree L;
    L = (*P)-&gt;lchild; /*  L指向P的左子树根结点 */
    (*P)-&gt;lchild = L-&gt;rchild; /*  L的右子树挂接为P的左子树 */
    L-&gt;rchild = (*P);
    *P = L; /*  P指向新的根结点 */
}
</code></pre>
<p>此函数代码的意思是说，当传入一个二叉排序树P，将它的左孩子结点定义为L，将L的右子树变成P的左子树，再将P改成L的右子树，最后将L替换P成为根结点。这样就完成了一次右旋操作，如图8-7-9所示。图中三角形代表子树，N代表新增结点。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-7-9.JPG?raw=true" srcset="/img/loading.gif" alt="8-7-9"></p>
<p>左旋操作代码如下。</p>
<pre><code class="language-c">/* 对以P为根的二叉排序树作左旋处理， */
/* 处理之后P指向新的树根结点，即旋转处理之前的右子树的根结点0  */
void L_Rotate(BiTree *P)
{
    BiTree R;
    R = (*P)-&gt;rchild; /*  R指向P的右子树根结点 */
    (*P)-&gt;rchild = R-&gt;lchild; /* R的左子树挂接为P的右子树 */
    R-&gt;lchild = (*P);
    *P = R; /*  P指向新的根结点 */
}
</code></pre>
<p>这段代码与右旋代码是对称的，在此不做解释了。<br>
现在我们来看左平衡旋转处理的函数代码。</p>
<pre><code class="language-c">#define LH +1 /*  左高 */
#define EH 0  /*  等高 */
#define RH -1 /*  右高 */

/*  对以指针T所指结点为根的二叉树作左平衡旋转处理 */
/*  本算法结束时，指针T指向新的根结点 */
void LeftBalance(BiTree *T)
{
    BiTree L, Lr;
    L = (*T)-&gt;lchild; /*  L指向T的左子树根结点 */
    switch (L-&gt;bf)
    { /*  检查T的左子树的平衡度，并作相应平衡处理 */
    case LH: /*  新结点插入在T的左孩子的左子树上，要作单右旋处理 */
        (*T)-&gt;bf = L-&gt;bf = EH;
        R_Rotate(T);
        break;
    case RH: /*  新结点插入在T的左孩子的右子树上，要作双旋处理 */
        Lr = L-&gt;rchild; /*  Lr指向T的左孩子的右子树根 */
        switch (Lr-&gt;bf)
        { /*  修改T及其左孩子的平衡因子 */
        case LH: (*T)-&gt;bf = RH;
            L-&gt;bf = EH;
            break;
        case EH: (*T)-&gt;bf = L-&gt;bf = EH;
            break;
        case RH:
            (*T)-&gt;bf = EH;
            L-&gt;bf = LH;
            break;
        }
        Lr-&gt;bf = EH;
        L_Rotate(&amp;(*T)-&gt;lchild); /*  对T的左子树作左旋平衡处理 */
        R_Rotate(T); /*  对T作右旋平衡处理 */
    }
}
</code></pre>
<p>首先，我们定义了三个常数变量，分别代表1、0、-1。</p>
<ol>
<li>函数被调用，传入一个需调整平衡性的子树T。由于LeftBalance 函数被调用时，其实是已经确认当前子树是不平衡状态，且左子树的高度大于右子树的高度。换句话说，此时T的根结点应该是平衡因子BF的值大于1的数。</li>
<li>第4行，我们将T的左孩子赋值给L。</li>
<li>第5~27行是分支判断。</li>
<li>当L的平衡因子为LH，即为1时，表明它与根结点的BF值符号相同，因此，第8行，将它们的BF值都改为0，并且第9行，进行右旋操作。操作的方式如图8-7-9所示。</li>
<li>当L的平衡因子为RH，即为-1时，表明它与根结点的BF值符号相反，此时需要做双旋处理。第13~22行，针对L的右孩子Lr的BF作判断，修改根结点T和L的BF值。第24行将当前Lr的BF改为0。</li>
<li>第25行，对根结点的左子树进行左旋，如图8-7-10第二图所示。</li>
<li>第26行，对根结点进行右旋，如图8-7-10的第三图所示，完成平衡操作。</li>
</ol>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-7-10.JPG?raw=true" srcset="/img/loading.gif" alt="8-7-10"></p>
<p>同样的，右平衡旋转处理的函数代码非常类似。</p>
<pre><code class="language-c">/*  对以指针T所指结点为根的二叉树作右平衡旋转处理， */
/*  本算法结束时，指针T指向新的根结点 */
void RightBalance(BiTree *T)
{
    BiTree R, Rl;
    R = (*T)-&gt;rchild; /*  R指向T的右子树根结点 */
    switch (R-&gt;bf)
    { /*  检查T的右子树的平衡度，并作相应平衡处理 */
    case RH: /*  新结点插入在T的右孩子的右子树上，要作单左旋处理 */
        (*T)-&gt;bf = R-&gt;bf = EH;
        L_Rotate(T);
        break;
    case LH: /*  新结点插入在T的右孩子的左子树上，要作双旋处理 */
        Rl = R-&gt;lchild; /*  Rl指向T的右孩子的左子树根 */
        switch (Rl-&gt;bf)
        { /*  修改T及其右孩子的平衡因子 */
        case RH:
            (*T)-&gt;bf = LH; R-&gt;bf = EH; break;
        case EH:
            (*T)-&gt;bf = R-&gt;bf = EH; break;
        case LH:
            (*T)-&gt;bf = EH; R-&gt;bf = RH; break;
        }
        Rl-&gt;bf = EH;
        R_Rotate(&amp;(*T)-&gt;rchild); /*  对T的右子树作右旋平衡处理 */
        L_Rotate(T); /*  对T作左旋平衡处理 */
    }
}
</code></pre>
<p>有了这些准备，我们的主函数才算是正式登场了。</p>
<pre><code class="language-c">/*  若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个 */
/*  数据元素为e的新结点，并返回1，否则返回0。若因插入而使二叉排序树 */
/*  失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否。 */
Status InsertAVL(BiTree *T, int e, Status *taller)
{
    if (!*T)
    { /*  插入新结点，树“长高”，置taller为TRUE */
        *T = (BiTree)malloc(sizeof(BiTNode));
        (*T)-&gt;data = e; (*T)-&gt;lchild = (*T)-&gt;rchild = NULL; (*T)-&gt;bf = EH;
        *taller = TRUE;
    }
    else
    {
        if (e == (*T)-&gt;data)
        { /*  树中已存在和e有相同关键字的结点则不再插入 */
            *taller = FALSE; return FALSE;
        }
        if (e &lt; (*T)-&gt;data)
        { /*  应继续在T的左子树中进行搜索 */
            if (!InsertAVL(&amp;(*T)-&gt;lchild, e, taller)) /*  未插入 */
                return FALSE;
            if (*taller) /*   已插入到T的左子树中且左子树“长高” */
                switch ((*T)-&gt;bf) /*  检查T的平衡度 */
                {
                case LH: /*  原本左子树比右子树高，需要作左平衡处理 */
                    LeftBalance(T);    *taller = FALSE; break;
                case EH: /*  原本左、右子树等高，现因左子树增高而使树增高 */
                    (*T)-&gt;bf = LH; *taller = TRUE; break;
                case RH: /*  原本右子树比左子树高，现左、右子树等高 */
                    (*T)-&gt;bf = EH; *taller = FALSE; break;
                }
        }
        else
        { /*  应继续在T的右子树中进行搜索 */
            if (!InsertAVL(&amp;(*T)-&gt;rchild, e, taller)) /*  未插入 */
                return FALSE;
            if (*taller) /*  已插入到T的右子树且右子树“长高” */
                switch ((*T)-&gt;bf) /*  检查T的平衡度 */
                {
                case LH: /*  原本左子树比右子树高，现左、右子树等高 */
                    (*T)-&gt;bf = EH; *taller = FALSE;    break;
                case EH: /*  原本左、右子树等高，现因右子树增高而使树增高  */
                    (*T)-&gt;bf = RH; *taller = TRUE; break;
                case RH: /*  原本右子树比左子树高，需要作右平衡处理 */
                    RightBalance(T); *taller = FALSE; break;
                }
        }
    }
    return TRUE;
}
</code></pre>
<p>不容易，终于讲完了，本算法代码很长，是有些复杂，编程中容易在很多细节上出错，要想真正掌握它，需要同学们自己多练习。不过其思想还是不难理解的，总之就是把不平衡消灭在最早时刻。<br>
如果我们需要查找的集合本身没有顺序，在频繁查找的同时也需要经常的插入和删除操作，显然我们需要构建一棵二叉排序树，但是不平衡的二叉排序树，查找效率是非常低的，因此我们需要在构建时，就让这棵二叉排序树是平衡二叉树，此时我们的查找时间复杂度就为O（㏒n），而插入和删除也为O（㏒n）。这显然是比较理想的一种动态查找表算法。</p>
<h2 id="8-8-多路查找树（B树）">8.8 多路查找树（B树）</h2>
<p><strong>多路查找树（muitl-way search tree），其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素</strong>。<br>
在这里，每一个结点可以存储多少个元素，以及它的孩子数的多少是非常关键的。为此，我们讲解它的4种特殊形式：2-3树、2-3-4树、B树和B+树。</p>
<h3 id="8-8-1-2-3树">8.8.1 2-3树</h3>
<p><strong>2-3树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为3结点）。</strong><br>
<strong>一个2结点包含一个元素和两个孩子（或没有孩子）</strong>，且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。不过，与二叉排序树不同的是，这个2结点要么没有孩子，要有就有两个，不能只有一个孩子。<br>
<strong>一个3结点包含一小一大两个元素和三个孩子（或没有孩子）</strong>，一个3结点要么没有孩子，要么具有3个孩子。如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。<br>
并且2-3树中所有的叶子都在同一层次上。如图8-8-2所示，就是一棵有效的2-3树。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-8-2.JPG?raw=true" srcset="/img/loading.gif" alt="8-8-2"></p>
<p>一 2-3树的插入实现<br>
对于2-3树的插入来说，与二叉排序树相同，插入操作一定是发生在叶子结点上。可与二叉排序树不同的是，2-3树插入一个元素的过程有可能会对该树的其余结构产生连锁反应。<br>
2-3树插入可分为三种情况。</p>
<ol>
<li>对于空树，插入一个2结点即可，这很容易理解。</li>
<li>插入结点到一个2结点的叶子上。应该说，由于其本身就只有一个元素，所以只需要将其升级为3结点即可。如图8-8-3所示。我们希望从左图的2-3树中插入元素3，根据遍历可知，3比8小、比4小，于是就只能考虑插入到叶子结点1所在的位置，因此很自然的想法就是将此结点变成一个3结点，即右图这样完成插入操作。当然，要视插入的元素与当前叶子结点的元素比较大小后，决定谁在左谁在右。例如，若插入的是0，则此结点就是“0”在左“1”在右了。</li>
<li>要往3结点中插入一个新元素。因为3结点本身已经是2-3树的结点最大容量（已经有两个元素），因此就需要将其拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-8-3.JPG?raw=true" srcset="/img/loading.gif" alt="8-8-3"></li>
</ol>
<p>二 2-3树的删除实现<br>
删除情况较多，具体请见大话数据结构P348。</p>
<p>当然，如果对2-3树的插入和删除等所有的情况进行讲解，既占篇幅，又没必要，总的来说它是有规律的，需要你们在上面的这些例子中多去体会后掌握。</p>
<h3 id="8-8-2-2-3-4树">8.8.2 2-3-4树</h3>
<p>有了2-3树的讲解，2-3-4树就很好理解了，它其实就是2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素。<br>
由于2-3-4树和2-3树是类似的，我们这里就简单介绍一下，如果我们构建一个数组为{7，1，2，5，6，9，8，4，3}的2-3-4树的过程，如图8-8-15所示。图1是在分别插入7、1、2时的结果图，因为3个元素满足2-3-4树的单个4结点定义，因此此时不需要拆分，接着插入元素5，因为已经超过了4结点的定义，因此拆分为图2的形状。之后的图其实就是在元素不断插入时最后形成了图7的2-3-4树。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-8-15.JPG?raw=true" srcset="/img/loading.gif" alt="8-8-15"><br>
图8-8-16是对一个2-3-4树的删除结点的演变过程，删除顺序是1、6、3、4、5、2、9。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-8-16.JPG?raw=true" srcset="/img/loading.gif" alt="8-8-16"></p>
<h3 id="8-8-3-B树">8.8.3 B树</h3>
<p><strong>B树（B-tree）是一种平衡的多路查找树</strong>，2-3树和2-3-4树都是B树的特例。<strong>结点最大的孩子数目称为B树的阶（order）</strong>，因此，2-3树是3阶B树，2-3-4树是4阶B树。<br>
一个m阶的B树具有如下属性：<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-8-16.5.JPG?raw=true" srcset="/img/loading.gif" alt="8-8-16.5"><br>
在B树上查找的过程是一个顺指针查找结点和在结点中查找关键字的交叉过程。<br>
比方说，我们要查找数字7，首先从外存（比如硬盘中）读取得到根结点3、5、8三个元素，发现7不在当中，但在5和8之间，因此就通过Az再读取外存的6、7结点，查找到所要的元素。<br>
至于B树的插入和删除，方式是与2-3树和2-3-4树相类似的，只不过阶数可能会很大而已。<br>
我们在本节的开头提到，如果内存与外存交换数据次数频繁，会造成了时间效率上的瓶颈，那么B树结构怎么就可以做到减少次数呢？<br>
我们的外存，比如硬盘，是将所有的信息分割成相等大小的页面，每次硬盘读写的都是一个或多个完整的页面，对于一个硬盘来说，一页的长度可能是211到214个字节。<br>
在一个典型的B树应用中，要处理的硬盘数据量很大，因此无法一次全部装入内存。因此我们会对B树进行调整，使得B树的阶数（或结点的元素）与硬盘存储的页面大小相匹配。比如说一棵B树的阶为1001（即1个结点包含1000个关键字），高度为2，它可以储存超过10亿个关键字，我们只要让根结点持久地保留在内存中，那么在这棵树上，寻找某一个关键字至多需要两次硬盘的读取即可。<br>
通过这种方式，在有限内存的情况下，每一次磁盘的访问我们都可以获得最大数量的数据。由于B树每结点可以具有比二叉树多得多的元素，所以与二叉树的操作不同，它们减少了必须访问结点和数据块的数量，从而提高了性能。可以说，B树的数据结构就是为内外存的数据交互准备的。<br>
那么对于n个关键字的m阶B树，最坏情况是要查找几次呢？我们来作一分析。<br>
也就是说，在含有n个关键字的B树上查找时，从根结点到关键字结点的路径上涉及的结点数不超过$\log_\frac m2\left(\frac{n+1}2\right)+1$。</p>
<h3 id="8-8-4-B-树">8.8.4 B+树</h3>
<p>B+树是应文件系统所需而出的一种B树的变形树，注意严格意义上讲，它其实已经不是第六章定义的树了。在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。<br>
例如图8-8-19所示，就是一棵B+树的示意，灰色关键字即是根结点中的关键字在叶子结点再次列出，并且所有叶子结点都链接在一起。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-8-19.JPG?raw=true" srcset="/img/loading.gif" alt="8-8-19"><br>
一棵m阶的B+树和m阶的B树的差异在于：</p>
<ul>
<li>有n棵子树的结点中包含有n个关键字；</li>
<li>所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接；</li>
<li>所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字。</li>
</ul>
<p>这样的数据结构最大的好处就在于，如果是要随机查找，我们就从根结点出发，与B树的查找方式相同，只不过即使在分支结点找到了待查找的关键字，它也只是用来索引的，不能提供实际记录的访问，还是需要到达包含此关键字的终端结点。如果我们是需要从最小关键字进行从小到大的顺序查找，我们就可以从最左侧的叶子结点出发，不经过分支结点，而是延着指向下一叶子的指针就可遍历所有的关键字。<br>
B+树的结构特别适合带有范围的查找。比如查找我们学校18~22岁的学生人数，我们可以通过从根结点出发找到第一个18岁的学生，然后再在叶子结点按顺序查找到符合范围的所有记录。<br>
B+树的插入、删除过程也都与B树类似，只不过插入和删除的元素都是在叶子结点上进行而已。</p>
<h2 id="8-9-散列表查找（哈希表）概述">8.9 散列表查找（哈希表）概述</h2>
<p>能否直接通过关键字key得到要查找的记录内存存储位置呢,而不是挨个查找下标，再通过顺序存储的存储位置计算内存地址？</p>
<h3 id="8-9-1-散列表查找定义">8.9.1 散列表查找定义</h3>
<p>我们只要通过某个函数f，使得<br>
<code>存储位置=f（关键字）</code><br>
那样我们可以通过查找关键字不需要比较就可获得需要的记录的存储位置。这就是一种新的存储技术——散列技术。<br>
<strong>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f（key）</strong>。查找时，根据这个确定的对应关系找到给定值key的映射f（key），若查找集合中存在这个记录，则必定在f（key）的位置上。<br>
这里我们把这种对应<strong>关系f称为散列函数，又称为哈希（Hash）函数</strong>。按这个思想，<strong>采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）</strong>。那么关键字对应的记录存储位置我们称为散列地址。</p>
<h3 id="8-9-2-散列表查找步骤">8.9.2 散列表查找步骤</h3>
<p>整个散列过程其实就是两步:</p>
<ol>
<li>在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。不管什么记录，我们都需要用同一个散列函数计算出地址再存储。</li>
<li>当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。说起来很简单，在哪存的，上哪去找，由于存取用的是同一个散列函数，因此结果当然也是相同的。</li>
</ol>
<p>**散列技术既是一种存储方法，也是一种查找方法。**然而它与线性表、树、图等结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，可以用连线图示表示出来，而散列技术的记录之间不存在什么逻辑关系，它只与关键字有关联。因此，散列主要是面向查找的存储结构。<br>
**散列技术最适合的求解问题是查找与给定值相等的记录。**对于查找来说，简化了比较过程，效率就会大大提高。但万事有利就有弊，散列技术不具备很多常规数据结构的能力。<br>
比如那种同样的关键字，它能对应很多记录的情况，却不适合用散列技术；散列表也不适合范围查找，无法排序，无法计算最大值、最小值等结果。<br>
设计一个简单、均匀、存储利用率高的散列函数是散列技术中最关键的问题。<br>
另一个问题是冲突。在理想的情况下，每一个关键字，通过散列函数计算出来的地址都是不一样的，可现实中，这只是一个理想。我们时常会碰到两个关键字key1≠key2，但是却有f（key1）=f（key2），这种现象我们称为冲突（collsion），并把key1和key2称为这个散列函数的同义词（synonym）。出现了冲突当然非常糟糕，那将造成数据查找错误。尽管我们可以通过精心设计的散列函数让冲突尽可能的少，但是不能完全避免。于是如何处理冲突就成了一个很重要的课题，这在我们后面也需要详细讲解。</p>
<h2 id="8-10-散列函数的构造方法">8.10 散列函数的构造方法</h2>
<p>那么什么才算是好的散列函数呢？<br>
1.计算简单。  2.散列地址分布均匀</p>
<h3 id="8-10-1-直接定址法">8.10.1 直接定址法</h3>
<p>可以取关键字的某个线性函数值为散列地址，即<br>
<code>f（key）=a x key+b（a、b为常数）</code><br>
这样的散列函数优点就是简单、均匀，也不会产生冲突，但问题是这需要事先知道关键字的分布情况，适合查找表较小且连续的情况。由于这样的限制，在现实应用中，此方法虽然简单，但却并不常用。</p>
<h3 id="8-10-2-数字分析法">8.10.2 数字分析法</h3>
<p>比如手机号码作为关键字，那么我们抽取手机号码后面的四位成为散列地址。<br>
这里我们提到了一个关键词——抽取。抽取方法是使用关键字的一部分来计算散列存储位置的方法，这在散列函数中是常常用到的手段。<br>
数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布较均匀，就可以考虑用这个方法。</p>
<h3 id="8-10-3-平方取中法">8.10.3 平方取中法</h3>
<p>这个方法计算很简单，假设关键字是1234，那么它的平方就是1522756，再抽取中间的3位就是227，用做散列地址。再比如关键字是4321，那么它的平方就是18671041，抽取中间的3位就可以是671，也可以是710，用做散列地址。平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况。</p>
<h3 id="8-10-4-折叠法">8.10.4 折叠法</h3>
<p>折叠法是将关键字从左到右分割成位数相等的几部分（注意最后一部分位数不够时可以短些），然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。<br>
比如我们的关键字是9876543210，散列表表长为三位，我们将它分为四组，987|654|321|0，然后将它们叠加求和987+654+321+0=1962，再取后3位得到散列地址为962。<br>
折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。</p>
<h3 id="8-10-5-除留余数法">8.10.5 除留余数法</h3>
<p>此方法为最常用的构造散列函数方法。对于散列表长为m的散列函数公式为：<br>
<code>f（key）=key mod p（p ≤ m）</code><br>
mod是取模（求余数）的意思。事实上，这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。<br>
很显然，本方法的关键就在于选择合适的p，p如果选得不好，就可能会容易产生同义词。<br>
根据前辈们的经验，若散列表表长为m，通常p为小于或等于表长（最好接近m）的最小质数或不包含小于20质因子的合数。</p>
<h3 id="8-10-6-随机数法">8.10.6 随机数法</h3>
<p>选择一个随机数，取关键字的随机函数值为它的散列地址。也就是<code>f（key）=random（key）</code>。这里random是随机函数。当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。<br>
总之，现实中，应该视不同的情况采用不同的散列函数。我们只能给出一些考虑的因素来提供参考：</p>
<ol>
<li>计算散列地址所需的时间。</li>
<li>关键字的长度。</li>
<li>散列表的大小。</li>
<li>关键字的分布情况。</li>
<li>记录查找的频率。</li>
</ol>
<p>综合这些因素，才能决策选择哪种散列函数更合适。</p>
<h2 id="8-11-处理散列冲突的方法">8.11 处理散列冲突的方法</h2>
<h3 id="8-11-1-开放定址法">8.11.1 开放定址法</h3>
<p>所谓的<strong>开放定址法就是一旦发生了冲突，就代入公式去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</strong><br>
公式是： <code>fi(key)=(f(key)+di) MOD m   (di=1,2,3,……,m-1)</code><br>
我们把这种解决冲突的开放定址法称为线性探测法。<br>
从这个例子我们也看到，我们在解决冲突的时候，还会碰到如48和37这种本来都不是同义词却需要<strong>争夺一个地址的情况，我们称这种现象为堆积</strong>。很显然，堆积的出现，使得我们需要不断处理冲突，无论是存入还是查找效率都会大大降低。<br>
我们可以把di该进为(di)²，增加平方运算的目的是<strong>为了不让关键字都聚集在某一块区域。我们称这种方法为二次探测法</strong>。<br>
<code>fi（key）=（f（key）+di）MOD m  （di=1²，(-1)²，2²,(-2)²,…，q²，(-q)²,q≤m/2）</code><br>
还有一种方法是，<strong>在冲突时，对于位移量d采用随机函数计算得到，我们称之为随机探测法。</strong><br>
<code>fi（key）=（f（key）+di）MOD m   （di是一个随机数列）</code></p>
<h3 id="8-11-2-再散列函数法">8.11.2 再散列函数法</h3>
<p>对于我们的散列表来说，我们事先准备多个散列函数。<br>
f$_i$（key）=RH$_i$（key）（i=1,2,…,k）<br>
这里RH$_i$，就是不同的散列函数，你可以把我们前面说的什么除留余数、折叠、平方取中全部用上。每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一个可以把冲突解决掉。这种方法能够使得关键字不产生聚集，当然，相应地也增加了计算的时间。</p>
<h3 id="8-11-3-链地址法">8.11.3 链地址法</h3>
<p>将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。对于关键字集合{12，67，56，16，25，37，22，29，15，47，48，34}，我们用前面同样的12为除数，进行除留余数法，可得到如图8-11-1结构，此时，已经不存在什么冲突换址的问题，无论有多少个冲突，都只是在当前位置给单链表增加结点的问题。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-11-1.JPG?raw=true" srcset="/img/loading.gif" alt="8-11-1"><br>
链地址法对于可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障。当然，这也就带来了查找时需要遍历单链表的性能损耗。</p>
<h3 id="8-11-4-公共溢出区法">8.11.4 公共溢出区法</h3>
<p>这个方法其实就更加好理解，你不是冲突吗？好吧，凡是冲突的都跟我走，我给你们这些冲突找个地儿待着。这就如同孤儿院收留所有无家可归的孩子一样，我们为所有冲突的关键字建立了一个公共的溢出区来存放。<br>
就前面的例子而言，我们共有三个关键字{37，48，34}与之前的关键字位置有冲突，那么就将它们存储到溢出表中，如图8-11-2所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-11-2.JPG?raw=true" srcset="/img/loading.gif" alt="8-11-2"><br>
图8-11-2在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功；如果不相等，则到溢出表去进行顺序查找。如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。</p>
<h2 id="8-12-散列表查找实现">8.12 散列表查找实现</h2>
<h3 id="8-12-1-散列表查找算法实现">8.12.1 散列表查找算法实现</h3>
<p>首先是需要定义一个散列表的结构以及一些相关的常数。其中HashTable 就是散列表结构。结构当中的elem为一个动态数组。</p>
<pre><code class="language-c">#define SUCCESS 1
#define UNSUCCESS 0
#define HASHSIZE 12 /* 定义散列表长为数组的长度 */
#define NULLKEY -32768
typedef struct{
    int *elem; /* 数据元素存储基址，动态分配数组 */
    int count; /*  当前数据元素个数 */
}HashTable;
int m = 0; /* 散列表表长，全局变量 */
</code></pre>
<p>有了结构的定义，我们可以对散列表进行初始化。</p>
<pre><code class="language-c">/* 初始化散列表 */
Status InitHashTable(HashTable *H){
    int i;
    m = HASHSIZE;
    H-&gt;count = m;
    H-&gt;elem = (int *)malloc(m * sizeof(int));
    for (i = 0; i &lt; m; i++)
        H-&gt;elem[i] = NULLKEY;
    return OK;
}
</code></pre>
<p>为了插入时计算地址，我们需要定义散列函数，散列函数可以根据不同情况更改算法。</p>
<pre><code class="language-c">/* 散列函数 */
int Hash(int key)
{
    return key % m; /* 除留余数法 */
}
</code></pre>
<p>初始化完成后，我们可以对散列表进行插入操作。假设我们插入的关键字集合就是前面的{12，67，56，16，25，37，22，29，15，47，48，34}。</p>
<pre><code class="language-c">/* 插入关键字进散列表 */
void InsertHash(HashTable *H, int key)
{
    int addr = Hash(key); /* 求散列地址 */
    while (H-&gt;elem[addr] != NULLKEY) /* 如果不为空，则冲突 */
        addr = (addr + 1) % m; /* 开放定址法的线性探测 */
    H-&gt;elem[addr] = key; /* 直到有空位后插入关键字 */
}
</code></pre>
<p>代码中插入关键字时，首先算出散列地址，如果当前地址不为空关键字，则说明有冲突。此时我们应用开放定址法的线性探测进行重新寻址，此处也可更改为链地址法等其他解决冲突的办法。<br>
散列表存在后，我们在需要时就可以通过散列表查找要的记录。</p>
<pre><code class="language-c">/* 散列表查找关键字 */
Status SearchHash(HashTable H, int key, int *addr)
{
    *addr = Hash(key);  /* 求散列地址 */
    while (H.elem[*addr] != key) /* 如果不为空，则冲突 */
    {
        *addr = (*addr + 1) % m; /* 开放定址法的线性探测 */
        if (H.elem[*addr] == NULLKEY || *addr == Hash(key)) /* 如果循环回到原点 */
            return UNSUCCESS;    /* 则说明关键字不存在 */
    }
    return SUCCESS;
}
</code></pre>
<p>查找的代码与插入的代码非常类似，只需做一个不存在关键字的判断而已。</p>
<h3 id="8-12-2-散列表查找性能分析">8.12.2 散列表查找性能分析</h3>
<p>最后，我们对散列表查找的性能作一个简单分析。如果没有冲突，散列查找是我们本章介绍的所有查找中效率最高的，因为它的时间复杂度为O(1)。可惜，我说的只是“如果”，没有冲突的散列只是一种理想，在实际的应用中，冲突是不可避免的。那么散列查找的平均查找长度取决于哪些因素呢？</p>
<ol>
<li>散列函数是否均匀<br>
散列函数的好坏直接影响着出现冲突的频繁程度，不过，由于不同的散列函数对同一组随机的关键字，产生冲突的可能性是相同的，因此我们可以不考虑它对平均查找长度的影响。</li>
<li>处理冲突的方法<br>
相同的关键字、相同的散列函数，但处理冲突的方法不同，会使得平均查找长度不同。比如线性探测处理冲突可能会产生堆积，显然就没有二次探测法好，而链地址法处理冲突不会产生任何堆积，因而具有更佳的平均查找性能。</li>
<li>散列表的装填因子<br>
所谓的装填因子α=填入表中的记录个数/散列表长度。α标志着散列表的装满的程度。当填入表中的记录越多，α就越大，产生冲突的可能性就越大。比如我们前面的例子，如图8-11-5所示，如果你的散列表长度是12，而填入表中的记录个数为11，那么此时的装填因子α=11/12=0.9167，再填入最后一个关键字产生冲突的可能性就非常之大。也就是说，散列表的平均查找长度取决于装填因子，而不是取决于查找集合中的记录个数。</li>
</ol>
<p>不管记录个数n有多大，我们总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围之内，此时我们散列查找的时间复杂度就真的是O(1)了。为了做到这一点，通常我们都是将散列表的空间设置得比查找集合大，此时虽然是浪费了一定的空间，但换来的是查找效率的大大提升，总的来说，还是非常值得的。</p>
<h2 id="8-13-总结回顾">8.13 总结回顾</h2>
<p>我们这一章全都是围绕一个主题“查找”来作文章的。<br>
首先我们要弄清楚查找表、记录、关键字、主关键字、静态查找表、动态查找表等这些概念。<br>
然后，对于顺序表查找来说，尽管很土（简单），但它却是后面很多查找的基础，注意设置“哨兵”的技巧，可以使得本已经很难提升的简单算法里还是提高了性能。<br>
有序查找，我们着重讲了折半查找的思想，它在性能上比原来的顺序查找有了质的飞跃，由O（n）变成了O（㏒n）。之后我们又讲解了另外两种优秀的有序查找：插值查找和斐波那契查找，三者各有优缺点，望大家要仔细体会。<br>
线性索引查找，我们讲解了稠密索引、分块索引和倒排索引。索引技术被广泛的用于文件检索、数据库和搜索引擎等技术领域，是进一步学习这些技术的基础。<br>
二叉排序树是动态查找最重要的数据结构，它可以在兼顾查找性能的基础上，让插入和删除也变得效率较高。不过为了达到最优的状态，二叉排序树最好是构造成平衡的二叉树才最佳。因此我们就需要再学习关于平衡二叉树（AVL树）的数据结构，了解AVL树是如何处理平衡性的问题。这部分是本章重点，需要认真学习掌握。<br>
B树这种数据结构是针对内存与外存之间的存取而专门设计的。由于内外存的查找性能更多取决于读取的次数，因此在设计中要考虑B树的平衡和层次。我们讲解时是先通过最最简单的B树（2-3树）来理解如何构建、插入、删除元素的操作，再通过2-3-4树的深化，最终来理解B树的原理。之后，我们还介绍了B+树的设计思想。<br>
散列表是一种非常高效的查找数据结构，在原理上也与前面的查找不尽相同，它回避了关键字之间反复比较的烦琐，而是直接一步到位查找结果。当然，这也就带来了记录之间没有任何关联的弊端。应该说，散列表对于那种查找性能要求高，记录之间关系无要求的数据有非常好的适用性。在学习中要注意的是散列函数的选择和处理冲突的方法。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>缪雪峰MySQL教程</title>
    <url>/2020/01/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/MySQL/%E7%BC%AA%E9%9B%AA%E5%B3%B0MySQL%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1>一 ：MySQL执行外部sql脚本文件的命令</h1>
<p>sql脚本是包含一到多个sql命令的sql语句，我们可以将这些sql脚本放在一个文本文件中（我们称之为“sql脚本文件”），然后通过相关的命令执行这个sql脚本文件。基本步骤如下：</p>
<h2 id="1-1-创建包含sql命令的sql脚本文件">1.1 创建包含sql命令的sql脚本文件</h2>
<p>文件中包含一些列的sql语句，每条语句最后以;结尾，文件内容示例如下：<br>
–创建表，使用“–”进行注释</p>
<pre><code class="language-sql">create table 表名称
(                   
  Guid Varchar(38) not null primary key,  
  Title Varchar(255),       
              
) TYPE=InnoDB;
</code></pre>
<a id="more"></a>
<ul>
<li>在表A中增加字段Status<br>
<code>alter table A add Status TinyInt default '0';</code></li>
<li>在表A上创建索引<br>
<code>create index XX_TaskId_1 on A(Id_);</code></li>
<li>在A表中添加一条记录<br>
<code>Insert into A (Id,ParentId, Name) values(1,0,'名称');</code></li>
<li>添加、修改、删除数据后，有可能需要提交事务<br>
<code>Commit;</code></li>
</ul>
<h2 id="1-2-执行sql脚本文件">1.2 执行sql脚本文件</h2>
<h3 id="1-2-1-方法一-：使用cmd命令执行-windows下，unix或linux在的其控制台下">1.2.1 方法一 ：使用cmd命令执行(windows下，unix或linux在的其控制台下)</h3>
<p>【Mysql的bin目录】\mysql –u用户名 –p密码 –D数据库&lt;【sql脚本文件路径全名】，示例：<br>
<code>D:\mysql\bin\mysql –uroot –p123456 -Dtest&lt;d:\test\ss.sql</code><br>
注意：<br>
A、如果在sql脚本文件中使用了use 数据库，则-D数据库选项可以忽略<br>
B、如果【Mysql的bin目录】中包含空格，则需要使用“”包含，如：<code>“C:\Program Files\mysql\bin\mysql” –u用户名 –p密码 –D数据库&lt;【sql脚本文件路径全名】</code></p>
<h3 id="1-2-2-方法二-：进入mysql的控制台后，使用source命令执行">1.2.2 方法二 ：进入mysql的控制台后，使用source命令执行</h3>
<p>Mysql&gt;source 【sql脚本文件的路径全名】 或 Mysql&gt;. 【sql脚本文件的路径全名】，示例：<code>source d:\test\ss.sql</code> 或者 <code>\. d:\test\ss.sql</code></p>
<h1>二：关系数据库概述</h1>
<p>数据库按照数据结构来组织、存储和管理数据，实际上，数据库一共有三种模型：</p>
<ul>
<li>层次模型</li>
<li>网状模型</li>
<li>关系模型</li>
</ul>
<p>随着时间的推移和市场竞争，最终，基于<strong>关系模型</strong>的关系数据库获得了绝对市场份额。</p>
<h2 id="2-1-数据类型">2.1 数据类型</h2>
<p>对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>INT</td>
<td>整型</td>
<td>4字节整数类型，范围约+/-21亿</td>
</tr>
<tr>
<td>BIGINT</td>
<td>长整型</td>
<td>8字节整数类型，范围约+/-922亿亿</td>
</tr>
<tr>
<td>REAL</td>
<td>浮点型</td>
<td>4字节浮点数，范围约+/-1038</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>浮点型</td>
<td>8字节浮点数，范围约+/-10308</td>
</tr>
<tr>
<td>DECIMAL(M,N)</td>
<td>高精度小数</td>
<td>由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算</td>
</tr>
<tr>
<td>CHAR(N)</td>
<td>定长字符串</td>
<td>存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串</td>
</tr>
<tr>
<td>VARCHAR(N)</td>
<td>变长字符串</td>
<td>存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串</td>
</tr>
<tr>
<td>BOOLEAN</td>
<td>布尔类型</td>
<td>存储True或者False</td>
</tr>
<tr>
<td>DATE</td>
<td>日期类型</td>
<td>存储日期，例如，2018-06-22</td>
</tr>
<tr>
<td>TIME</td>
<td>时间类型</td>
<td>存储时间，例如，12:20:59</td>
</tr>
<tr>
<td>DATETIME</td>
<td>日期和时间类型</td>
<td>存储日期+时间，例如，2018-06-22 12:20:59</td>
</tr>
</tbody>
</table>
<h2 id="2-1-1-SQL-DML-和-DDL">2.1.1 <strong>SQL DML 和 DDL</strong></h2>
<p>总的来说，可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。<br>
SQL (结构化查询语言)是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。<br>
查询和更新指令构成了 SQL 的 DML 部分：</p>
<ol>
<li>SELECT - 从数据库表中获取数据</li>
<li>UPDATE - 更新数据库表中的数据</li>
<li>DELETE - 从数据库表中删除数据</li>
<li>INSERT INTO - 向数据库表中插入数据</li>
</ol>
<p>SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。<br>
SQL 中最重要的 DDL 语句:</p>
<ol>
<li>CREATE DATABASE - 创建新数据库</li>
<li>ALTER DATABASE - 修改数据库</li>
<li>CREATE TABLE - 创建新表</li>
<li>ALTER TABLE - 变更（改变）数据库表</li>
<li>DROP TABLE - 删除表</li>
<li>CREATE INDEX - 创建索引（搜索键）</li>
<li>DROP INDEX - 删除索引</li>
</ol>
<h2 id="2-2-安装MySQL">2.2 安装MySQL</h2>
<p>要在Windows或Mac上安装MySQL，首先从MySQL官方网站下载最新的MySQL Community Server版本：<br>
<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">MySQL官方网站</a><br>
选择对应的操作系统版本，下载安装即可。在安装过程中，MySQL会自动创建一个root用户，并提示输入root口令。<br>
要在Linux上安装MySQL，可以使用发行版的包管理器。例如，Debian和Ubuntu用户可以简单地通过命令<code>apt-get install mysql-server</code>安装最新的MySQL版本。</p>
<h2 id="2-3-运行MySQL">2.3 运行MySQL</h2>
<p>MySQL安装后会自动在后台运行。为了验证MySQL安装是否正确，我们需要通过mysql这个命令行程序来连接MySQL服务器。<br>
在命令提示符下输入mysql -u root -p，然后输入口令，如果一切正确，就会连接到MySQL服务器，同时提示符变为mysql&gt;。<br>
输入exit退出MySQL命令行。注意，MySQL服务器仍在后台运行。</p>
<h1>三： 关系模型</h1>
<p>我们已经知道，关系数据库是建立在关系模型上的。而关系模型本质上就是若干个存储数据的二维表，可以把它们看作很多Excel表。<br>
表的每一行称为记录（Record），记录是一个逻辑意义上的数据。<br>
表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。<br>
字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL。注意NULL表示字段数据不存在。一个整型字段如果为NULL不表示它的值为0，同样的，一个字符串型字段为NULL也不表示它的值为空串’’。</p>
<blockquote>
<p>通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。</p>
</blockquote>
<p>在关系数据库中，关系是通过主键和外键来维护的。</p>
<h2 id="3-1-主键">3.1 主键</h2>
<p>在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。<br>
每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。<br>
<strong>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为主键。</strong><br>
对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。<br>
由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。<br>
所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。<br>
因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。<br>
作为主键最好是完全业务无关的字段，我们一般把这个字段命名为id。常见的可作为id字段的类型有：</p>
<ul>
<li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li>
<li>全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li>
</ul>
<p>对于大部分应用来说，通常自增类型的主键就能满足需求。</p>
<blockquote>
<p>PS:如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。</p>
</blockquote>
<p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为<strong>联合主键</strong>。<br>
对于联合主键，允许一列有重复，只要不是所有主键列都重复即可。<br>
没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。</p>
<p><strong>小结</strong><br>
<strong>主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用<code>BIGINT自增</code>或者<code>GUID类型</code>。主键也不应该允许<code>NULL</code>。可以使用多个列作为联合主键，但联合主键并不常用。</strong></p>
<h2 id="3-2-外键">3.2 外键</h2>
<p>由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个<code>classes</code>的记录可以对应多个<code>students</code>表的记录。<br>
为了表达这种一对多的关系，我们需要在<code>students</code>表中加入一列<code>class_id</code>，让它的值与<code>classes</code>表的某条记录相对应。<br>
这样，我们就可以根据<code>class_id</code>这个列直接定位出一个<code>students</code>表的记录应该对应到<code>classes</code>的哪条记录。<br>
在<code>students</code>表中，通过<code>class_id</code>的字段，可以把数据与另一张表关联起来，这种列称为外键。<br>
外键并不是通过列名实现的，而是通过定义外键约束实现的：</p>
<pre><code class="language-sql">ALTER TABLE students
ADD CONSTRAINT fk_class_id
FOREIGN KEY (class_id)
REFERENCES classes (id);
</code></pre>
<p>其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的id列（即<code>classes</code>表的主键）。<br>
通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果<code>classes</code>表不存在id=99的记录，<code>students</code>表就无法插入<code>class_id=99</code>的记录。<br>
由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，<code>class_id</code>仅仅是一个普通的列，只是它起到了外键的作用而已。<br>
要删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</p>
<pre><code class="language-sql">ALTER TABLE students
DROP FOREIGN KEY fk_class_id;
</code></pre>
<blockquote>
<p>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。</p>
</blockquote>
<p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。<br>
多对多关系实际上是通过两个一对多关系实现的，即<strong>通过一个中间表，关联两个一对多关系，就形成了多对多关系</strong>。<br>
一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。  目的是把经常读取和不经常读取的字段分开，提高查询速度，以获得更高的性能。</p>
<p><strong>小结</strong><br>
<strong>关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。</strong></p>
<h2 id="3-3-索引">3.3 索引</h2>
<p>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。<br>
索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。<br>
如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引：</p>
<pre><code class="language-sql">ALTER TABLE students
ADD INDEX idx_score (score);
</code></pre>
<p>使用<code>ADD INDEX idx_score (score)</code>就创建了一个名称为<code>idx_score</code>，使用列<code>score</code>的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：</p>
<pre><code class="language-sql">ALTER TABLE students
ADD INDEX idx_name_score (name, score);
</code></pre>
<p>索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如<code>gender</code>列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。<br>
可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。<br>
对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。</p>
<p><strong>小结</strong><br>
<strong>通过对数据库表创建索引，可以提高查询速度。</strong><br>
<strong>通过创建唯一索引，可以保证某一列的值具有唯一性。</strong><br>
<strong>数据库索引对于用户和应用程序来说都是透明的。</strong></p>
<h1>四： 查询数据</h1>
<p>在关系数据库中，最常用的操作就是查询。</p>
<h2 id="4-1-基本查询">4.1 基本查询</h2>
<p>要查询数据库表的数据，我们使用如下的SQL语句：<br>
<code>SELECT * FROM &lt;表名&gt;</code><br>
假设表名是<code>students</code>，要查询<code>students</code>表的所有行，我们用如下SQL语句：<br>
<code>SELECT * FROM students;</code>。<br>
使用<code>SELECT * FROM students</code>时，<code>SELECT</code>是关键字，表示将要执行一个查询，<code>*</code>表示“所有列”，<code>FROM</code>表示将要从哪个表查询，本例中是<code>students</code>表。<br>
该SQL将查询出<code>students</code>表的所有数据。注意：查询结果也是一个二维表，它包含列名和每一行的数据。</p>
<p>在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。<br>
关键词 DISTINCT 用于返回唯一不同的值。语法：</p>
<pre><code class="language-sql">SELECT DISTINCT 列名称 FROM 表名称
</code></pre>
<p><strong>小结</strong><br>
<strong>使用<code>SELECT(选择、挑选、选拔)</code>查询的基本语句<code>SELECT * FROM &lt;表名&gt;</code>可以查询一个表的所有行和所有列的数据。<code>SELECT</code>查询的结果是一个二维表。</strong></p>
<h2 id="4-2-条件查询">4.2 条件查询</h2>
<p><code>SELECT</code>语句可以通过<code>WHERE（到哪里）</code>条件来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成<code>WHERE</code>条件就是:<br>
<code>SELECT * FROM students WHERE score &gt;= 80;</code>。<br>
其中，<code>WHERE</code>关键字后面的<code>score &gt;= 80</code>就是条件。<code>score</code>是列名，该列存储了学生的成绩，因此，<code>score &gt;= 80</code>就筛选出了指定条件的记录：<br>
<code>SELECT * FROM students WHERE score &gt;= 80;</code>。<br>
因此，条件查询的语法就是：<br>
<code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;</code></p>
<p>条件表达式可以用<code>&lt;条件1&gt; AND &lt;条件2&gt;</code>表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来：</p>
<ul>
<li>条件1：根据score列的数据判断：score &gt;= 80；</li>
<li>条件2：根据gender列的数据判断：gender = ‘M’，注意gender列存储的是字符串，需要用单引号括起来。</li>
</ul>
<p>就可以写出<code>WHERE</code>条件：<br>
<code>SELECT * FROM students WHERE score &gt;= 80 AND gender = 'M';</code>。<br>
第二种条件是&lt;条件1&gt; OR &lt;条件2&gt;，表示满足条件1或者满足条件2。例如：<br>
<code>SELECT * FROM students WHERE score &gt;= 80 OR gender = 'M';</code><br>
第三种条件是NOT &lt;条件&gt;，表示“不符合该条件”的记录。例如：<br>
<code>SELECT * FROM students WHERE NOT class_id = 2;</code>表示不是2班的学生。<br>
要组合三个或者更多的条件，就需要用小括号()表示如何进行条件运算。例如，编写一个复杂的条件：分数在80以下或者90以上，并且是男生：<br>
<code>SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = 'M';</code><br>
如果不加括号，条件运算按照<code>NOT、AND、OR</code>的优先级进行，即<code>NOT</code>优先级最高，其次是<code>AND</code>，最后是<code>OR</code>。加上括号可以改变优先级。</p>
<p>常用的条件表达式：</p>
<table>
<thead>
<tr>
<th>条件</th>
<th>表达式举例1</th>
<th>表达式举例2</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用=判断相等</td>
<td>score = 80</td>
<td>name = ‘abc’</td>
<td>字符串需要用单引号括起来</td>
</tr>
<tr>
<td>使用&gt;判断大于</td>
<td>score &gt; 80</td>
<td>name &gt; ‘abc’</td>
<td>字符串比较根据ASCII码，中文字符比较根据数据库设置</td>
</tr>
<tr>
<td>使用&gt;=判断大于或相等</td>
<td>score &gt;= 80</td>
<td>name &gt;= ‘abc’</td>
<td></td>
</tr>
<tr>
<td>使用&lt;判断小于</td>
<td>score &lt; 80</td>
<td>name &lt;= ‘abc’</td>
<td></td>
</tr>
<tr>
<td>使用&lt;=判断小于或相等</td>
<td>score &lt;= 80</td>
<td>name &lt;= ‘abc’</td>
<td></td>
</tr>
<tr>
<td>使用&lt;&gt;判断不相等</td>
<td>score &lt;&gt; 80</td>
<td>name &lt;&gt; ‘abc’</td>
<td></td>
</tr>
<tr>
<td>使用LIKE判断相似</td>
<td>name LIKE ‘ab%’</td>
<td>name LIKE ‘%bc%’</td>
<td>%表示任意字符，例如’ab%‘将匹配’ab’，‘abc’，‘abcd’</td>
</tr>
</tbody>
</table>
<p><strong>小结</strong><br>
<strong>通过WHERE条件查询，可以筛选出符合指定条件的记录，而不是整个表的所有记录。</strong></p>
<h2 id="4-3-投影查询">4.3 投影查询</h2>
<p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用<code>SELECT 列1, 列2, 列3 FROM ...</code>，让结果集仅包含指定列。这种操作称为投影查询。<br>
例如，从<code>students</code>表中返回<code>id、score和name</code>这三列：<br>
<code>SELECT id, score, name FROM students;</code><br>
这样返回的结果集就只包含了我们指定的列，并且，结果集的列的顺序和原表可以不一样。</p>
<p>使用<code>SELECT 列1, 列2, 列3 FROM ...</code>时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code>。</p>
<p>例如，以下<code>SELECT</code>语句将列名<code>score</code>重命名为<code>points</code>，而<code>id</code>和<code>name</code>列名保持不变：<code>SELECT id, score points, name FROM students;</code><br>
投影查询同样可以接<code>WHERE</code>条件，实现复杂的查询：<br>
<code>SELECT id, score points, name FROM students WHERE gender = 'M';</code></p>
<p><strong>小结</strong><br>
<strong>使用<code>SELECT *</code>表示查询表的所有列，使用<code>SELECT 列1, 列2, 列3</code>则可以仅返回指定列，这种操作称为投影。<code>SELECT</code>语句可以对结果集的列进行重命名。</strong></p>
<h2 id="4-4-排序">4.4 排序</h2>
<p>可以加上<code>ORDER BY</code>子句。可以按照成绩从低到高进行排序：<br>
<code>SELECT id, name, gender, score FROM students ORDER BY score;</code><br>
如果要反过来，按照成绩从高到底排序，我们可以加上DESC表示“倒序”：<br>
<code>SELECT id, name, gender, score FROM students ORDER BY score DESC;</code><br>
如果score列有相同的数据，要进一步排序，可以继续添加列名。例如，使用ORDER BY score DESC, gender表示先按score列倒序，如果有相同分数的，再按gender列排序：<br>
<code>SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;</code><br>
默认的排序规则是<code>ASC</code>：“升序”，即从小到大。<code>ASC</code>可以省略，即<code>ORDER BY score ASC</code>和<code>ORDER BY score</code>效果一样。<br>
如果有<code>WHERE</code>子句，那么<code>ORDER BY</code>子句要放到<code>WHERE</code>子句后面。例如，查询一班的学生成绩，并按照倒序排序：</p>
<pre><code class="language-sql">SELECT id, name, gender, score
FROM students
WHERE class_id = 1
ORDER BY score DESC;
</code></pre>
<p>这样，结果集仅包含符合WHERE条件的记录，并按照ORDER BY的设定排序。<br>
<strong>小结</strong><br>
<strong>使用ORDER BY可以对结果集进行排序；可以对多列进行升序、倒序排序。</strong></p>
<h2 id="4-5-分页查询">4.5 分页查询</h2>
<p>要实现分页功能，实际上就是从结果集中显示第1~100条记录作为第1页，显示第101~200条记录作为第2页，以此类推。<br>
因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>子句实现。我们先把所有学生按照成绩从高到低进行排序，我们把结果集分页，每页3条记录。要获取第1页的记录，可以使用<code>LIMIT 3 OFFSET 0</code>：</p>
<pre><code class="language-sql">SELECT id, name, gender, score
FROM students
ORDER BY score DESC
LIMIT 3 OFFSET 0;
</code></pre>
<p>上述查询<code>LIMIT 3 OFFSET 0</code>表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。<br>
如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3：<code>LIMIT 3 OFFSET 3;</code><br>
LIMIT 3表示的意思是“最多3条记录”。</p>
<p>可见，分页查询的关键在于，首先要确定每页需要显示的结果数量pageSize（这里是3），然后根据当前页的索引pageIndex（从1开始），确定LIMIT和OFFSET应该设定的值：</p>
<ul>
<li>LIMIT总是设定为pageSize；</li>
<li>OFFSET计算公式为pageSize * (pageIndex - 1)。</li>
</ul>
<p>这样就能正确查询出第N页的记录集。</p>
<blockquote>
<p>PS:OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集。<br>
OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。<br>
在MySQL中，<code>LIMIT 15 OFFSET 30</code>还可以简写成<code>LIMIT 30, 15</code>。<br>
使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>分页时，随着N越来越大，查询效率也会越来越低。</p>
</blockquote>
<p><strong>小结</strong><br>
<strong>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>可以对结果集进行分页，每次查询返回结果集的一部分；分页查询需要先确定每页的数量和当前页数，然后确定LIMIT和OFFSET的值。</strong></p>
<h2 id="4-6-聚合查询">4.6 聚合查询</h2>
<h3 id="4-6-1-聚合函数">4.6.1 聚合函数</h3>
<p>对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。<br>
仍然以查询students表一共有多少条记录为例，我们可以使用SQL内置的COUNT()函数查询：<br>
<code>SELECT COUNT(*) FROM students;</code><br>
<code>COUNT(*)</code>表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是<code>COUNT(*)</code>。<br>
通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果：<br>
<code>SELECT COUNT(*) num FROM students;</code><br>
<code>COUNT(*)</code>和<code>COUNT(id)</code>实际上是一样的效果。另外注意，聚合查询同样可以使用WHERE条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等：<br>
<code>SELECT COUNT(*) boys FROM students WHERE gender = 'M';</code><br>
除了COUNT()函数外，SQL还提供了如下聚合函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SUM</td>
<td>计算某一列的合计值，该列必须为数值类型</td>
</tr>
<tr>
<td>AVG</td>
<td>计算某一列的平均值，该列必须为数值类型</td>
</tr>
<tr>
<td>MAX</td>
<td>计算某一列的最大值</td>
</tr>
<tr>
<td>MIN</td>
<td>计算某一列的最小值</td>
</tr>
</tbody>
</table>
<p>注意，MAX()和MIN()函数并不限于数值类型。如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。<br>
要统计男生的平均成绩，我们用下面的聚合查询：<br>
<code>SELECT AVG(score) average FROM students WHERE gender = 'M';</code><br>
要特别注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL。<br>
通过聚合查询获得总页数:<br>
<code>SELECT CEILING(COUNT(*) / 3) FROM students;</code></p>
<h3 id="4-6-2-分组聚合">4.6.2 分组聚合</h3>
<p>对于聚合查询，SQL还提供了“分组聚合”的功能。我们观察下面的聚合查询：<br>
<code>SELECT COUNT(*) num FROM students GROUP BY class_id;</code><br>
执行这个查询，COUNT()的结果不再是一个，而是3个，这是因为，<code>GROUP(组) BY</code>子句指定了按class_id分组，因此，执行该SELECT语句时，会把class_id相同的列先分组，再分别计算，因此，得到了3行结果。<br>
但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把class_id列也放入结果集中：<br>
<code>SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;</code>这下结果集就可以一目了然地看出各个班级的学生人数。<br>
也可以使用多个列进行分组。例如，我们想统计各班的男生和女生人数：<br>
<code>SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;</code><br>
<strong>小结</strong><br>
<strong>使用SQL提供的聚合查询，我们可以方便地计算总数、合计值、平均值、最大值和最小值；聚合查询也可以添加WHERE条件。</strong></p>
<h2 id="4-7-多表查询">4.7 多表查询</h2>
<p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：<code>SELECT * FROM &lt;表1&gt; &lt;表2&gt;</code>。<br>
例如，同时从students表和classes表的“乘积”，即查询数据，可以这么写：<code>SELECT * FROM students, classes;</code><br>
这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。<br>
这种多表查询又称<strong>笛卡尔查询</strong>，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。</p>
<p>上述查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理。要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名：</p>
<pre><code class="language-sql">SELECT
    students.id sid,
    students.name,
    students.gender,
    students.score,
    classes.id cid,
    classes.name cname
FROM students, classes;
</code></pre>
<p>注意，多表查询时，要使用<code>表名.列名</code>这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用<code>表名.列名</code>这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：</p>
<pre><code class="language-sql">SELECT
    s.id sid,
    s.name,
    s.gender,
    s.score,
    c.id cid,
    c.name cname
FROM students s, classes c;
</code></pre>
<p>注意到FROM子句给表设置别名的语法是<code>FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;</code>。这样我们用别名s和c分别表示students表和classes表。<br>
多表查询也是可以添加WHERE条件的：</p>
<pre><code class="language-sql">SELECT
    s.id sid,
    s.name,
    s.gender,
    s.score,
    c.id cid,
    c.name cname
FROM students s, classes c
WHERE s.gender = 'M' AND c.id = 1;
</code></pre>
<p><strong>小结</strong><br>
<strong>使用多表查询可以获取M x N行记录；多表查询的结果集可能非常巨大，要小心使用。</strong></p>
<h2 id="4-8-连接查询">4.8 连接查询</h2>
<p>连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。<br>
例如，我们想要选出students表的所有学生信息，可以用一条简单的SELECT语句完成：</p>
<pre><code class="language-sql">SELECT s.id, s.name, s.class_id, s.gender, s.score FROM students s;
</code></pre>
<p>但是，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有class_id列，缺少对应班级的name列。<br>
现在问题来了，存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。<br>
这时，连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现：</p>
<pre><code class="language-sql">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
INNER JOIN classes c
ON s.class_id = c.id;
</code></pre>
<p>注意INNER JOIN查询的写法是：</p>
<ol>
<li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li>
<li>再确定需要连接的表，使用<code>INNER(里面的) JOIN &lt;表2&gt;</code>的语法；</li>
<li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示students表的class_id列与classes表的id列相同的行需要连接；</li>
<li>可选：加上WHERE子句、ORDER BY等子句。</li>
</ol>
<p>那什么是内连接（INNER JOIN）呢？先别着急，有内连接（INNER JOIN）就有外连接（OUTER JOIN）。我们把内连接查询改成外连接查询，看看效果：</p>
<pre><code class="language-SQL">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
RIGHT OUTER JOIN classes c
ON s.class_id = c.id;
</code></pre>
<p>执行上述RIGHT OUTER JOIN可以看到，和INNER JOIN相比，RIGHT OUTER JOIN多了一行，多出来的一行是“四班”，但是，学生相关的列如name、gender、score都为NULL。<br>
这也容易理解，因为根据ON条件<code>s.class_id = c.id</code>，classes表的id=4的行正是“四班”，但是，students表中并不存在class_id=4的行。<br>
有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是：</p>
<ul>
<li>INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件<code>s.class_id = c.id</code>返回的结果集仅包含1，2，3。</li>
<li>RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。</li>
<li>LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的class_name是NULL。</li>
</ul>
<p>对于这么多种JOIN查询，到底什么使用应该用哪种呢？其实我们用图来表示结果集就一目了然了。假设查询语句是：<br>
<code>SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2;</code><br>
我们把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录：<br>
<img src="https://www.liaoxuefeng.com/files/attachments/1246892164662976/l" srcset="/img/loading.gif" alt="inner-join"><br>
LEFT OUTER JOIN是选出左表存在的记录：<br>
<img src="https://www.liaoxuefeng.com/files/attachments/1246893588481376/l" srcset="/img/loading.gif" alt="left-outer-join"><br>
RIGHT OUTER JOIN是选出右表存在的记录：<br>
<img src="https://www.liaoxuefeng.com/files/attachments/1246893609222688/l" srcset="/img/loading.gif" alt="right-outer-join"><br>
FULL OUTER JOIN则是选出左右表都存在的记录：<br>
<img src="https://www.liaoxuefeng.com/files/attachments/1246893632359424/l" srcset="/img/loading.gif" alt="full-outer-join"></p>
<p><strong>小结</strong><br>
<strong>JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上；  INNER JOIN是最常用的一种JOIN查询，它的语法是<code>SELECT ... FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件...&gt;</code>；  JOIN查询仍然可以使用WHERE条件和ORDER BY排序。</strong></p>
<h1>五： 修改数据</h1>
<p>关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。其中，对于查询，我们已经详细讲述了SELECT语句的详细用法。<br>
而对于增、删、改，对应的SQL语句分别是：</p>
<ul>
<li>INSERT：插入新记录；</li>
<li>UPDATE：更新已有记录；</li>
<li>DELETE：删除已有记录。</li>
</ul>
<h2 id="5-1-INSERT">5.1 INSERT</h2>
<p>当我们需要向数据库表中插入一条新记录时，就必须使用<code>INSERT</code>语句。<br>
INSERT语句的基本语法是：<br>
<code>INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</code><br>
例如，我们向students表插入一条新记录，先列举出需要插入的字段名称，然后在VALUES子句中依次写出对应字段的值：<br>
<code>INSERT INTO students (class_id, name, gender, score) VALUES (2, '大牛', 'M', 80);</code><br>
注意到我们并没有列出id字段，也没有列出id字段对应的值，这是因为id字段是一个自增主键，它的值可以由数据库自己推算出来。此外，如果一个字段有默认值，那么在INSERT语句中也可以不出现。<br>
要注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。也就是说，可以写:<br>
<code>INSERT INTO students (score, gender, name, class_id) ...</code>，但是对应的VALUES就得变成<code>(80, 'M', '大牛', 2)</code>。<br>
还可以一次性添加多条记录，只需要在VALUES子句中指定多个记录值，每个记录是由(…)包含的一组值：</p>
<pre><code class="language-sql">INSERT INTO students (class_id, name, gender, score) VALUES
  (1, '大宝', 'M', 87),
  (2, '二宝', 'M', 81);
--
SELECT * FROM students;
</code></pre>
<p><strong>小结</strong><br>
<strong>使用INSERT，我们就可以一次向一个表中插入一条或多条记录。</strong></p>
<h2 id="5-2-UPDATE">5.2 UPDATE</h2>
<p>如果要更新数据库表中的记录，我们就必须使用UPDATE语句。<br>
UPDATE语句的基本语法是：<br>
<code>UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;</code><br>
例如，我们想更新students表id=1的记录的name和score这两个字段：<br>
<code>UPDATE students SET name='大牛', score=66 WHERE id=1;</code><br>
注意到UPDATE语句的WHERE条件和SELECT语句的WHERE条件其实是一样的，因此完全可以一次更新多条记录：<br>
<code>UPDATE students SET name='小牛', score=77 WHERE id&gt;=5 AND id&lt;=7;</code><br>
在UPDATE语句中，更新字段时可以使用表达式。例如，把所有80分以下的同学的成绩加10分：<br>
<code>UPDATE students SET score=score+10 WHERE score&lt;80;</code><br>
其中，SET score=score+10就是给当前行的score字段的值加上了10。<br>
如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新。<br>
最后，要特别小心的是，UPDATE语句可以没有WHERE条件，例如：<br>
<code>UPDATE students SET score=60;</code><br>
这时，整个表的所有记录都会被更新。所以，在执行UPDATE语句时要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新。<br>
在使用MySQL这类真正的关系数据库时，UPDATE语句会返回更新的行数以及WHERE条件匹配的行数。</p>
<p><strong>小结</strong><br>
<strong>使用UPDATE，我们就可以一次更新表中的一条或多条记录。</strong></p>
<h2 id="5-3-DELETE">5.3 DELETE</h2>
<p>如果要删除数据库表中的记录，我们可以使用DELETE语句。<br>
DELETE语句的基本语法是：<br>
<code>DELETE FROM &lt;表名&gt; WHERE ...;</code><br>
例如，我们想删除students表中id=1的记录，就需要这么写：<br>
<code>DELETE FROM students WHERE id=1;</code><br>
注意到DELETE语句的WHERE条件也是用来筛选需要删除的行，因此和UPDATE类似，DELETE语句也可以一次删除多条记录：<br>
<code>DELETE FROM students WHERE id&gt;=5 AND id&lt;=7;</code><br>
如果WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除。<br>
最后，要特别小心的是，和UPDATE类似，不带WHERE条件的DELETE语句会删除整个表的数据：<br>
<code>DELETE FROM students;</code><br>
这时，整个表的所有记录都会被删除。所以，在执行DELETE语句时也要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用DELETE删除。<br>
在使用MySQL这类真正的关系数据库时，DELETE语句也会返回删除的行数以及WHERE条件匹配的行数。</p>
<p><strong>小结</strong><br>
<strong>使用DELETE，我们就可以一次删除表中的一条或多条记录。</strong></p>
<h1>六： MySQL</h1>
<p>安装完MySQL后，除了MySQL Server，即真正的MySQL服务器外，还附赠一个MySQL Client程序。MySQL Client是一个命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行。<br>
打开命令提示符，输入命令<code>mysql -u root -p</code>，提示输入口令。填入MySQL的root口令，如果正确，就连上了MySQL Server，同时提示符变为mysql&gt;：<br>
输入exit断开与MySQL Server的连接并返回到命令提示符。</p>
<blockquote>
<p>MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。</p>
</blockquote>
<p>在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是127.0.0.1:3306。<br>
也可以只安装MySQL Client，然后连接到远程MySQL Server。假设远程MySQL Server的IP地址是10.0.1.99，那么就使用-h指定IP或域名：<br>
<code>mysql -h 10.0.1.99 -u root -p 密码</code></p>
<p><strong>小结</strong><br>
<strong>命令行程序mysql实际上是MySQL客户端，真正的MySQL服务器程序是mysqld，在后台运行。</strong></p>
<h2 id="6-1-管理MySQL">6.1 管理MySQL</h2>
<p>要管理MySQL，可以使用可视化图形界面<a href="https://dev.mysql.com/downloads/workbench/" target="_blank" rel="noopener">MySQL Workbench</a>。<br>
MySQL Workbench可以用可视化的方式查询、创建和修改数据库表，但是，归根到底，MySQL Workbench是一个图形客户端，它对MySQL的操作仍然是发送SQL语句并执行。因此，本质上，MySQL Workbench和MySQL Client命令行都是客户端，和MySQL交互，唯一的接口就是SQL。<br>
因此，MySQL提供了大量的SQL语句用于管理。虽然可以使用MySQL Workbench图形界面来直接管理MySQL，但是，很多时候，通过SSH远程连接时，只能使用SQL命令，所以，了解并掌握常用的SQL管理操作是必须的。</p>
<h3 id="6-1-1-数据库">6.1.1 数据库</h3>
<p>在一个运行MySQL的服务器上，实际上可以创建多个数据库（Database）。要列出所有数据库，使用命令：</p>
<pre><code class="language-sql">SHOW DATABASES;
</code></pre>
<p>其中，<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>和<code>sys</code>四个是系统库，不要去改动它们。其他的是用户创建的数据库。<br>
要创建一个新数据库，使用命令：</p>
<pre><code class="language-sql">CREATE DATABASE test;
</code></pre>
<p>要删除一个数据库，使用命令：</p>
<pre><code class="language-sql">DROP DATABASE test;
</code></pre>
<p><em>注意：删除一个数据库将导致该数据库的所有表全部被删除。</em><br>
对一个数据库进行操作时，要首先将其切换为当前数据库：</p>
<pre><code class="language-sql">USE test;
</code></pre>
<h3 id="6-1-2-表">6.1.2 表</h3>
<p>列出当前数据库的所有表，使用命令：</p>
<pre><code class="language-sql">SHOW TABLES;
</code></pre>
<p>要查看一个表的结构，使用命令：</p>
<pre><code class="language-sql">DESC students;
</code></pre>
<p>还可以使用以下命令查看创建表的SQL语句：</p>
<pre><code class="language-sql">SHOW CREATE TABLE students;
</code></pre>
<p>创建表使用CREATE TABLE语句，而删除表使用DROP TABLE语句：</p>
<pre><code class="language-sql">DROP TABLE students;
</code></pre>
<p>修改表就比较复杂。如果要给students表新增一列birth，使用：</p>
<pre><code class="language-sql">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;
</code></pre>
<p>要修改birth列，例如把列名改为birthday，类型改为VARCHAR(20)：</p>
<pre><code class="language-sql">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;
</code></pre>
<p>要删除列，使用：</p>
<pre><code class="language-sql">ALTER TABLE students DROP COLUMN birthday;
</code></pre>
<h3 id="6-1-3-退出MySQL">6.1.3 退出MySQL</h3>
<p>使用EXIT命令退出MySQL：<br>
<code>EXIT</code><br>
注意EXIT仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。</p>
<h2 id="6-2-实用SQL语句">6.2 实用SQL语句</h2>
<p>在编写SQL时，灵活运用一些技巧，可以大大简化程序逻辑。</p>
<p><strong>一. 插入或替换</strong><br>
如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用<code>REPLACE</code>语句，这样就不必先查询，再决定是否先删除再插入：<br>
<code>REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99);</code><br>
若id=1的记录不存在，REPLACE语句将插入新记录，否则，当前id=1的记录将被删除，然后再插入新记录。</p>
<p><strong>二. 插入或更新</strong><br>
如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用<code>INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code>语句：<br>
<code>INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99) ON DUPLICATE KEY UPDATE name='小明', gender='F', score=99;</code><br>
若id=1的记录不存在，INSERT语句将插入新记录，否则，当前id=1的记录将被更新，更新的字段由UPDATE指定。</p>
<p><strong>三. 插入或忽略</strong><br>
如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用<code>INSERT IGNORE INTO ...</code>语句：<br>
<code>INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99);</code><br>
若id=1的记录不存在，INSERT语句将插入新记录，否则，不执行任何操作。</p>
<p><strong>四. 快照</strong><br>
如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合CREATE TABLE和SELECT：</p>
<pre><code class="language-sql">-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:  
CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id=1;
</code></pre>
<p>新创建的表结构和SELECT使用的表结构完全一致。</p>
<p><strong>五. 写入查询结果集</strong><br>
如果查询结果集需要写入到表中，可以结合INSERT和SELECT，将SELECT语句的结果集直接插入到指定表中。<br>
例如，创建一个统计成绩的表statistics，记录各班的平均成绩：</p>
<pre><code class="language-sql">CREATE TABLE statistics (
    id BIGINT NOT NULL AUTO_INCREMENT,
    class_id BIGINT NOT NULL,
    average DOUBLE NOT NULL,
    PRIMARY KEY (id)
);
</code></pre>
<p>然后，我们就可以用一条语句写入各班的平均成绩：</p>
<pre><code class="language-sql">INSERT INTO statistics (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id;
</code></pre>
<p>确保INSERT语句的列和SELECT语句的列能一一对应，就可以在statistics表中直接保存查询的结果：</p>
<pre><code class="language-sql">SELECT * FROM statistics;
</code></pre>
<p><strong>六. 强制使用指定索引</strong><br>
在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引。例如：</p>
<pre><code class="language-sql">SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC;
</code></pre>
<p>指定索引的前提是索引idx_class_id必须存在。</p>
<h1>七: 事务</h1>
<p>在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：</p>
<pre><code class="language-sql">-- 从id=1的账户给id=2的账户转账100元
-- 第一步：将id=1的A账户余额减去100
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- 第二步：将id=2的B账户余额加上100
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
</code></pre>
<p>这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。<br>
这种把<strong>多条语句作为一个整体进行操作的功能，被称为数据库事务</strong>。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。<br>
可见，数据库事务具有ACID这4个特性：</p>
<ol>
<li>A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li>
<li>C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；</li>
<li>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；</li>
<li>D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li>
</ol>
<p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为隐式事务。<br>
要手动把多条SQL语句作为一个事务执行，使用<code>BEGIN</code>开启一个事务，使用<code>COMMIT</code>提交一个事务，这种事务被称为<strong>显式事务</strong>，例如，把上述的转账操作作为一个显式事务：</p>
<pre><code class="language-sql">BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
</code></pre>
<p>很显然多条SQL语句要想作为一个事务执行，就必须使用显式事务。<br>
COMMIT是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果COMMIT语句执行失败了，整个事务也会失败。<br>
有些时候，我们希望主动让事务失败，这时，可以用ROLLBACK回滚事务，整个事务会失败：</p>
<pre><code class="language-sql">BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
ROLLBACK;
</code></pre>
<p>数据库事务是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以。</p>
<p><strong>隔离级别</strong></p>
<p>对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。<br>
SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p>
<table>
<thead>
<tr>
<th>Isolation Level</th>
<th>脏读（Dirty Read）</th>
<th>不可重复读（Non Repeatable Read）</th>
<th>幻读（Phantom Read）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read Uncommitted</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Read Committed</td>
<td>-</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td>-</td>
<td>-</td>
<td>Yes</td>
</tr>
<tr>
<td>Serializable</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>我们会依次介绍4种隔离级别的数据一致性问题。</p>
<p><strong>小结</strong><br>
<strong>数据库事务具有ACID特性，用来保证多条SQL的全部执行。</strong></p>
<h2 id="7-1-Read-Uncommitted">7.1 Read Uncommitted</h2>
<p>Read Uncommitted是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。<br>
我们来看一个例子。首先，我们准备好students表的数据，该表仅一行记录。<br>
然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td>
<td>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td>
</tr>
<tr>
<td>2</td>
<td>BEGIN;</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td>UPDATE students SET name = ‘Bob’ WHERE id = 1;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td>5</td>
<td>ROLLBACK;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody>
</table>
<p>当事务A执行完第3步时，它更新了id=1的记录，但并未提交，而事务B在第4步读取到的数据就是未提交的数据。<br>
随后，事务A在第5步进行了回滚，事务B再次读取id=1的记录，发现和上一次读取到的数据不一致，这就是脏读。<br>
可见，在Read Uncommitted隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据。</p>
<h2 id="7-2-Read-Committed">7.2 Read Committed</h2>
<p>在Read Committed隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。<br>
不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。<br>
我们仍然先准备好students表的数据，然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td>
<td>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td>
</tr>
<tr>
<td>2</td>
<td>BEGIN;</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td>4</td>
<td>UPDATE students SET name = ‘Bob’ WHERE id = 1;</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>COMMIT;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody>
</table>
<p>当事务B第一次执行第3步的查询时，得到的结果是Alice，随后，由于事务A在第4步更新了这条记录并提交，所以，事务B在第6步再次执行同样的查询时，得到的结果就变成了Bob，因此，在Read Committed隔离级别下，事务不可重复读同一条记录，因为很可能读到的结果不一致。</p>
<h2 id="7-3-Repeatable-Read">7.3 Repeatable Read</h2>
<p>在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。<br>
幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。<br>
我们仍然先准备好students表的数据，然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td>
<td>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td>
</tr>
<tr>
<td>2</td>
<td>BEGIN;</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>SELECT * FROM students WHERE id = 99;</td>
</tr>
<tr>
<td>4</td>
<td>INSERT INTO students (id, name) VALUES (99, ‘Bob’);</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>COMMIT;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>SELECT * FROM students WHERE id = 99;</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>UPDATE students SET name = ‘Alice’ WHERE id = 99;</td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>SELECT * FROM students WHERE id = 99;</td>
</tr>
<tr>
<td>9</td>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody>
</table>
<p>事务B在第3步第一次读取id=99的记录时，读到的记录为空，说明不存在id=99的记录。随后，事务A在第4步插入了一条id=99的记录并提交。事务B在第6步再次读取id=99的记录时，读到的记录仍然为空，但是，事务B在第7步试图更新这条不存在的记录时，竟然成功了，并且，事务B在第8步再次读取id=99的记录时，记录出现了。<br>
可见，幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。</p>
<h2 id="7-4-Serializable">7.4 Serializable</h2>
<p>Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。<br>
虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。</p>
<p><strong>默认隔离级别</strong><br>
<strong>如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read。</strong></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构第七章 图</title>
    <url>/2020/01/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC7%E7%AB%A0%20%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="7-1-7-2-图的定义">7.1-7.2 图的定义</h2>
<p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。<br>
对于图的定义，我们需要明确几个注意的地方。</p>
<a id="more"></a>
<ul>
<li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，<strong>在图中数据元素，我们则称之为顶点（Vertex）</strong>。</li>
<li>线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。我们根本不认为一张空白纸算作画的。同样，在图结构中，不允许没有顶点。在定义中，若V是顶点的集合，则强调了顶点集合V有穷非空。</li>
<li>线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。</li>
</ul>
<h3 id="7-2-1-各种图定义">7.2.1 各种图定义</h3>
<p><strong>无向边：若顶点vi到vj之间的边没有方向，则称这条边为无向边（Edge），用无序偶对（ViVj）来表示</strong>。<br>
如果图中任意两个顶点之间的边都是无向边，则称该图为无向图（Undirected graphs）。<br>
有向边：若从顶点Vi到Vj的边有方向，则称这条边为有向边，也称为弧（Arc）。<br>
用有序偶&lt;vi，vj&gt;来表示，vi称为弧尾（Tail），vj称为弧头（Head）。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图（Directed graphs）。图7-2-3就是一个有向图。连接顶点A到D的有向边就是弧，A是弧尾，D是弧头，&lt;A，D&gt;表示弧，注意不能写成&lt;D，A&gt;。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-2-3.JPG?raw=true" srcset="/img/loading.gif" alt="7-2-3"><br>
对于图7-2-3中的有向图G2来说，G2=(V2,{E2})，其中顶点集合V2={A.B，C，D}；弧集合E2={&lt;A，D&gt;，&lt;B，A&gt;，&lt;C，A&gt;，&lt;B，C&gt;}。<br>
看清楚了，无向边用小括号“（）”表示，而有向边则是用尖括号“&lt;&gt;”表示。<br>
在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。<br>
<strong>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图</strong>。含有n个顶点的无向完全图有（nx(n-1)）/2条边。<br>
<strong>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图</strong>。含有n个顶点的有向完全图有n×（n-1）条边。<br>
<strong>有很少条边或弧的图称为稀疏图，反之称为稠密图</strong>。<br>
有些图的边或弧具有与它相关的数字，这种<strong>与图的边或弧相关的数叫做权（Weight）</strong>。这些权可以表示从一个顶点到另一个顶点的距离或耗费。<strong>这种带权的图通常称为网（Network）</strong>。图7-2-7就是一张带权的图，即标识中国四大城市的直线距离的网，此图中的权就是两地的距离。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-2-7.JPG?raw=true" srcset="/img/loading.gif" alt="7-2-7"><br>
假设有两个图G=（V，{E}）和G’=（V’,{E’}），如果V’⊆V且E’⊆E，则称G’为G的子图（SubGraph）。</p>
<h3 id="7-2-2-图的顶点与边间关系">7.2.2 图的顶点与边间关系</h3>
<p>对于无向图G=（V,{E}），如果边（v,v’）∈E，则称顶点v和v’互为邻接点（Adjacent），即v和v’相邻接。边（v，v’）依附（incident）于顶点v和v’，或者说（v,v’）与顶点v和v’相关联。顶点v的度（Degree）是和v相关联的边的数目，记为TD（v）。<br>
对于有向图G=（V,{E}），如果弧&lt;v,v’&gt;∈E，则称顶点v邻接到顶点v’，顶点v’邻接自顶点v。弧&lt;v，v’&gt;和顶点v，v’相关联。以顶点v为头的弧的数目称为v的入度（InDegree），记为ID（v）；以v为尾的弧的数目称为v的出度（OutDegree），记为OD（v）；顶点v的度为TD（v）=ID（v）+OD（v）。<br>
无向图G=（V，{E}）中从顶点v到顶点v’的路径（Path）是一个顶点序列（v=$v_{i,0}$,$v_{i,1}$,…,$v_{i,m}$=v’），其中（$v_{i,j-1}$，$v_{i,j}$）∈E，1≤j≤m。<br>
树中根结点到任意结点的路径是唯一的，但是图中顶点与顶点之间的路径却是不唯一的。<br>
<strong>路径的长度是路径上的边或弧的数目。</strong><br>
第一个顶点到最后一个顶点相同的路径称为回路或环（Cycle）。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。</p>
<h3 id="7-2-3-连通图相关术语">7.2.3 连通图相关术语</h3>
<p>在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。如果对于图中任意两个顶点$v_i$、$v_j$∈E，$v_i$和$v_j$都是连通的，则称G是连通图（Connected Graph）。<br>
<strong>无向图中的极大连通子图称为连通分量</strong>。注意连通分量的概念，它强调：</p>
<ul>
<li>要是子图；</li>
<li>子图要是连通的；</li>
<li>连通子图含有极大顶点数；</li>
<li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</li>
</ul>
<p><strong>在有向图G中，如果对于每一对$v_i$、$v_j$∈V、$v_i$≠$v_j$，从$v_i$到$v_j$和从$v_j$到$v_i$都存在路径，则称G是强连通图。有向图中的极大强连通子图称做有向图的强连通分量</strong>。<br>
<strong>所谓的一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边</strong>。<br>
如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树。<br>
一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</p>
<h3 id="7-2-4-图的定义与术语总结">7.2.4 图的定义与术语总结</h3>
<p>术语终于介绍得差不多了，可能有不少同学有些头晕，我们再来整理一下。<br>
图按照有无方向分为无向图和有向图。无向图由顶点和边构成，有向图由顶点和弧构成。弧有弧尾和弧头之分。<br>
图按照边或弧的多少分稀疏图和稠密图。如果任意两个顶点之间都存在边叫完全图，有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图。<br>
图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度，有向图顶点分为入度和出度。<br>
图上的边或弧上带权则称为网。<br>
图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复叫简单路径。若任意两顶点都是连通的，则图就是连通图，有向则称强连通图。图中有子图，若子图极大连通则就是连通分量，有向的则称强连通分量。<br>
无向图中连通且n个顶点n-1条边叫生成树。有向图中一顶点入度为0其余顶点入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林。</p>
<h2 id="7-3-图的抽象数据类型">7.3 图的抽象数据类型</h2>
<pre><code class="language-c">ADT图（Graph）
Data
  顶点的有穷非空集合和边的集合。
Operation
  CreateGraph（*G，V，VR）：按照顶点集V和边弧集VR的定义构造图G。
  DestroyGraph（*G）：图G存在则销毁。
  LocateVex（G，u）：若图G中存在顶点u，则返回图中的位置。
  GetVex（G，v）：返回图G中顶点v的值。
  PutVex（G，v，value）：将图G中顶点v赋值value。
  FirstAdjVex（G，*v）：返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。
  NextAdjVex（G，v，*w）：返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后一个邻接点则返回“空”。
  InsertVex（*G，v）：在图G中增添新顶点v。
  DeleteVex（*G，v）：删除图G中顶点v及其相关的弧。
  InsertArc（*G，V，w）：在图G中增添弧&lt;v，w&gt;，若G是无向图，还需要增添对称弧&lt;w，v&gt;。
  DeleteArc（*G，V，w）：在图G中删除弧&lt;v，w&gt;，若G是无向图，则还删除对称弧&lt;w，v&gt;。
  DFSTraverse（G）：对图G中进行深度优先遍历，在遍历过程对每个顶点调用。
  HFSTraverse（G）：对图G中进行广度优先遍历，在遍历过程对每个顶点调用。
endADT
</code></pre>
<h2 id="7-4-图的存储结构">7.4 图的存储结构</h2>
<p>前辈们提供了五种不同的存储结构。</p>
<h3 id="7-4-1-邻接矩阵">7.4.1 邻接矩阵</h3>
<p><strong>图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息</strong>。<br>
无向图的边数组构成的是一个对称矩阵。<br>
有了这个矩阵，我们就可以很容易地知道图中的信息。</p>
<ol>
<li>我们要判定任意两顶点是否有边无边就非常容易了。</li>
<li>我们要知道某个顶点的度，其实就是这个顶点vi在邻接矩阵中第i行（或第i列）的元素之和。比如顶点v1的度就是1+0+1+0=2。</li>
<li>求顶点vi的所有邻接点就是将矩阵中第i行元素扫描一遍，arc[i][j]为1就是邻接点。</li>
</ol>
<p>在图的术语中，我们提到了网的概念，也就是每条边上带有权的图叫做网。那么这些权值就需要存下来，如何处理这个矩阵来适应这个需求呢？我们有办法。<br>
设图G是网图，有n个顶点，则邻接矩阵是一个n×n的方阵，定义为：<br>
arc[i][j]=</p>
<ol>
<li>$W_{ij}$,若（$v_i$，$v_j$）∈E或&lt;$v_i$,$v_j$&gt;∈E</li>
<li>0,若i=j</li>
<li>∞，反之</li>
</ol>
<p>这里$W_{ij}$表示（$v_i$，$v_j$）或&lt;$v_i$,$v_j$&gt;上的权值。∞表示一个计算机允许的、大于所有边上权值的值，也就是一个不可能的极限值。<br>
如图7-4-4左图就是一个有向网图，右图就是它的邻接矩阵。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-4.JPG?raw=true" srcset="/img/loading.gif" alt="7-4-4"></p>
<p>图的邻接矩阵存储的结构，代码如下。</p>
<pre><code class="language-c">typedef char VertexType; /* 顶点类型应由用户定义  */
typedef int EdgeType; /* 边上的权值类型应由用户定义 */
#define MAXVEX 100 /* 最大顶点数，应由用户定义 */
#define INFINITY 65535
typedef struct
{
    VertexType vexs[MAXVEX]; /* 顶点表 */
    EdgeType arc[MAXVEX][MAXVEX];/* 邻接矩阵，可看作边表 */
    int numVertexes, numEdges; /* 图中当前的顶点数和边数  */
}MGraph;
</code></pre>
<p>有了这个结构定义，我们构造一个图，其实就是给顶点表和边表输入数据的过程。我们来看看无向网图的创建代码。</p>
<pre><code class="language-c">/* 建立无向网图的邻接矩阵表示 */
void CreateMGraph(MGraph *G)
{
    int i, j, k, w;
    printf(&quot;输入顶点数和边数:\n&quot;);
    scanf(&quot;%d,%d&quot;, &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges); /* 输入顶点数和边数 */
    for (i = 0; i &lt; G-&gt;numVertexes; i++) /* 读入顶点信息,建立顶点表 */
        scanf(&amp;G-&gt;vexs[i]);
    for (i = 0; i &lt; G-&gt;numVertexes; i++)
        for (j = 0; j &lt; G-&gt;numVertexes; j++)
            G-&gt;arc[i][j] = INFINITY;    /* 邻接矩阵初始化 */
    for (k = 0; k &lt; G-&gt;numEdges; k++) /* 读入numEdges条边，建立邻接矩阵 */
    {
        printf(&quot;输入边(vi,vj)上的下标i，下标j和权w:\n&quot;);
        scanf(&quot;%d,%d,%d&quot;, &amp;i, &amp;j, &amp;w); /* 输入边(vi,vj)上的权w */
        G-&gt;arc[i][j] = w;
        G-&gt;arc[j][i] = G-&gt;arc[i][j]; /* 因为是无向图，矩阵对称 */
    }
}
</code></pre>
<p>从代码中也可以得到，n个顶点和e条边的无向网图的创建，时间复杂度为O（n+n²+e），其中对邻接矩阵Garc的初始化耗费了O（n²）的时间。</p>
<h3 id="7-4-2-邻接表">7.4.2 邻接表</h3>
<p>将结点存入数组，并对结点的数组进行链式存储，不管有多少结点，也不会存在空间浪费问题。我们把这种数组与链表相结合的存储方法称为邻接表（Adjacency List）。<br>
邻接表的处理办法是这样。</p>
<ol>
<li>图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。</li>
<li>图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。</li>
</ol>
<p>例如图7-4-6所示的就是一个无向图的邻接表结构。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-6.JPG?raw=true" srcset="/img/loading.gif" alt="7-4-6"><br>
从图中我们知道，顶点表的各个结点由data和firstedge两个域表示，data是数据域，存储顶点的信息，firstedge是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由adjvex和next两个域组成。adjvex是邻接点域，存储某顶点的邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针。比如v1顶点与v0、v2互为邻接点，则在v1的边表中，adjvex分别为v0的0和v2的2。<br>
若是有向图，邻接表结构是类似的，比如图7-4-7中第一幅图的邻接表就是第二幅图。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-7.JPG?raw=true" srcset="/img/loading.gif" alt="7-4-7"><br>
但要注意的是有向图由于有方向，我们是以顶点为弧尾来存储边表的，这样很容易就可以得到每个顶点的出度。但也有时为了便于确定顶点的入度或以顶点为弧头的弧，我们可以建立一个有向图的逆邻接表，即对每个顶点vi都建立一个链接为vi为弧头的表。如图7-4-7的第三幅图所示。<br>
对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可。<br>
有了这些结构的图，下面关于结点定义的代码就很好理解了。</p>
<pre><code class="language-c">typedef char VertexType; /* 顶点类型应由用户定义 */
typedef int EdgeType; /* 边上的权值类型应由用户定义 */

typedef struct EdgeNode /* 边表结点  */
{
    int adjvex;    /* 邻接点域,存储该顶点对应的下标 */
    EdgeType info;        /* 用于存储权值,对于非网图可以不需要 */
    struct EdgeNode *next; /* 链域,指向下一个邻接点 */
}EdgeNode;

typedef struct VertexNode /* 顶点表结点 */
{
    VertexType data; /* 顶点域,存储顶点信息 */
    EdgeNode *firstedge;/* 边表头指针 */
}VertexNode, AdjList[MAXVEX];

typedef struct
{
    AdjList adjList;
    int numNodes,numEdges; /* 图中当前顶点数和边数 */
}GraphAdjList;
</code></pre>
<p>对于邻接表的创建，也就是顺理成章之事。无向图的邻接表创建代码如下。</p>
<pre><code class="language-c">/* 建立图的邻接表结构 */
void  CreateALGraph(GraphAdjList *G)
{
    int i,j,k;
    EdgeNode *e;
    printf(&quot;输入顶点数和边数:\n&quot;);
    scanf(&quot;%d,%d&quot;,&amp;G-&gt;numNodes,&amp;G-&gt;numEdges); /* 输入顶点数和边数 */
    for(i = 0;i &lt; G-&gt;numNodes;i++) /* 读入顶点信息,建立顶点表 */
    {
        scanf(&amp;G-&gt;adjList[i].data);     /* 输入顶点信息 */
        G-&gt;adjList[i].firstedge=NULL;     /* 将边表置为空表 */
    }
    for(k = 0;k &lt; G-&gt;numEdges;k++)/* 建立边表 */
    {
        printf(&quot;输入边(vi,vj)上的顶点序号:\n&quot;);
        scanf(&quot;%d,%d&quot;,&amp;i,&amp;j); /* 输入边(vi,vj)上的顶点序号 */
        e=(EdgeNode *)malloc(sizeof(EdgeNode)); /* 向内存申请空间,生成边表结点 */
        e-&gt;adjvex=j;                    /* 邻接序号为j */
        e-&gt;next=G-&gt;adjList[i].firstedge;    /* 将e的指针指向当前顶点上指向的结点 */
        G-&gt;adjList[i].firstedge=e;        /* 将当前顶点的指针指向e */
        e=(EdgeNode *)malloc(sizeof(EdgeNode)); /* 向内存申请空间,生成边表结点 */
        e-&gt;adjvex=i;                    /* 邻接序号为i */
        e-&gt;next=G-&gt;adjList[j].firstedge;    /* 将e的指针指向当前顶点上指向的结点 */
        G-&gt;adjList[j].firstedge=e;        /* 将当前顶点的指针指向e */
    }
}
</code></pre>
<p>这里代码，是应用了我们在单链表创建中讲解到的头插法，由于对于无向图，一条边对应都是两个顶点，所以在循环中，一次就针对i和j分别进行了插入。本算法的时间复杂度，对于n个顶点e条边来说，很容易得出是O（n+e）。</p>
<h3 id="7-4-3-十字链表">7.4.3 十字链表</h3>
<p>有向图的一种存储方法：十字链表是邻接表与逆邻接表的结合。<br>
我们重新定义顶点表结点结构如表7-4-1所示。<br>
表7-4-1</p>
<table>
<thead>
<tr>
<th>data</th>
<th>firstin</th>
<th>firstout</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>其中firstin表示入边表头指针，指向该顶点的入边表中第一个结点，firstout表示出边表头指针，指向该顶点的出边表中的第一个结点。<br>
重新定义的边表结点结构如表7-4-2所示。<br>
表7-4-2</p>
<table>
<thead>
<tr>
<th>tailvex</th>
<th>headvex</th>
<th>headlink</th>
<th>taillink</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>其中tailvex是指弧起点在顶点表的下标，headvex是指弧终点在顶点表中的下标，headlink是指入边表指针域，指向终点相同的下一条边，taillink是指边表指针域，指向起点相同的下一条边。如果是网，还可以再增加一个weight域来存储权值。<br>
比如图7-4-10，顶点依然是存入一个一维数组{v0，v1，v2，v3}，实线箭头指针的图示完全与图7-4-7的邻接表相同。就以顶点v0来说，firstout 指向的是出边表中的第一个结点v3。所以v0边表结点的headvex=3，而tailvex其实就是当前顶点v0的下标0，由于v0只有一个出边顶点，所以headlink和taillink都是空。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-10.JPG?raw=true" srcset="/img/loading.gif" alt="7-4-10"><br>
我们重点需要来解释虚线箭头的含义，它其实就是此图的逆邻接表的表示。对于v0来说，它有两个顶点v1和v2的入边。因此v0的firstin指向顶点v1的边表结点中headvex为0的结点，如图7-4-10右图中的①。接着由入边结点的headlink指向下一个入边顶点v2，如图中的②。对于顶点v1，它有一个入边顶点v2，所以它的firstin指向顶点v2的边表结点中headvex为1的结点，如图中的③。顶点v2和v3也是同样有一个入边顶点，如图中④和⑤。<br>
十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以vi为尾的弧，也容易找到以vi为头的弧，因而容易求得顶点的出度和入度。而且它除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的，因此，在有向图的应用中，十字链表是非常好的数据结构模型。</p>
<h3 id="7-4-4-邻接多重表">7.4.4 邻接多重表</h3>
<p>仿照十字链表的方式，对边表结点的结构进行一些改造，可以优化无向图的邻接表的便操作。<br>
重新定义的边表结点结构如表7-4-3所示。</p>
<table>
<thead>
<tr>
<th>ivex</th>
<th>ilink</th>
<th>jvex</th>
<th>jlink</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>其中<strong>ivex和jvex是与某条边依附的两个顶点在顶点表中下标。ilink 指向依附顶点ivex的下一条边，jlink 指向依附顶点jvex的下一条边。这就是邻接多重表结构</strong>。<br>
我们来看结构示意图的绘制过程，理解了它是如何连线的，也就理解邻接多重表构造原理了。如图7-4-12所示，左图告诉我们它有4个顶点和5条边，显然，我们就应该先将4个顶点和5条边的边表结点画出来。由于是无向图，所以ivex是0、jvex是1还是反过来都是无所谓的，不过为了绘图方便，都将ivex值设置得与一旁的顶点下标相同。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-12.JPG?raw=true" srcset="/img/loading.gif" alt="7-4-12"><br>
我们开始连线，如图7-4-13。首先连线的①②③④就是将顶点的firstedge指向一条边，顶点下标要与ivex的值相同，这很好理解。接着，由于顶点v0的（v0，v1）边的邻边有（v0，v3）和（v0，v2）。因此⑤⑥的连线就是满足指向下一条依附于顶点v0的边的目标，注意ilink指向的结点的jvex一定要和它本身的ivex的值相同。同样的道理，连线⑦就是指（v1,v0）这条边，它是相当于顶点v1指向（v1，v2）边后的下一条。v2有三条边依附，所以在③之后就有了⑧⑨。连线⑩的就是顶点v3在连线④之后的下一条边。左图一共有5条边，所以右图有10条连线，完全符合预期。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-13.JPG?raw=true" srcset="/img/loading.gif" alt="7-4-13"><br>
到这里，大家应该可以明白，邻接多重表与邻接表的差别，仅仅是在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。这样对边的操作就方便多了，若要删除左图的（v0，v2）这条边，只需要将右图的⑥⑨的链接指向改为^即可。由于各种基本操作的实现也和邻接表是相似的，这里我们就不讲解代码了。</p>
<h3 id="7-4-5-边集数组">7.4.5 边集数组</h3>
<p>边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标（begin）、终点下标（end）和权（weight）组成。</p>
<h2 id="7-5-图的遍历">7.5 图的遍历</h2>
<p>从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历（Traversing Graph）。<br>
对于图的遍历来说，如何避免因回路陷入死循环，就需要科学地设计遍历方案，通常有两种遍历次序方案：它们是深度优先遍历和广度优先遍历。</p>
<h3 id="7-5-1-深度优先遍历">7.5.1 深度优先遍历</h3>
<p>深度优先遍历（Depth_FirstSearch），也有称为深度优先搜索，简称为DFS。<br>
深度优先遍历其实就是一个递归的过程，就像是一棵树的前序遍历，从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。<br>
若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。<br>
如果我们用的是邻接矩阵的方式，则代码如下：</p>
<pre><code class="language-c">typedef int Boolean; /* Boolean是布尔类型,其值是TRUE或FALSE */
Boolean visited[MAXVEX]; /* 访问标志的数组 */
/* 邻接矩阵的深度优先递归算法 */
void DFS(MGraph G, int i)
{
    int j;
    visited[i] = TRUE;
    printf(&quot;%c &quot;, G.vexs[i]);/* 打印顶点，也可以其它操作 */
    for(j = 0; j &lt; G.numVertexes; j++)
        if(G.arc[i][j] == 1 &amp;&amp; !visited[j])
            DFS(G, j);/* 对为访问的邻接顶点递归调用 */
}

/* 邻接矩阵的深度遍历操作 */
void DFSTraverse(MGraph G)
{
    int i;
    for(i = 0; i &lt; G.numVertexes; i++)
        visited[i] = FALSE; /* 初始所有顶点状态都是未访问过状态 */
    for(i = 0; i &lt; G.numVertexes; i++)
        if(!visited[i]) /* 对未访问过的顶点调用DFS，若是连通图，只会执行一次 */
            DFS(G, i);
}
</code></pre>
<p>代码的执行过程，其实就是我们刚才迷宫找寻所有顶点的过程。<br>
如果图结构是邻接表结构，其DFSTraverse函数的代码是几乎相同的，只是在递归函数中因为将数组换成了链表而有不同，代码如下。</p>
<pre><code class="language-c">/* 邻接表的深度优先递归算法 */
void DFS(GraphAdjList GL, int i)
{
    EdgeNode *p;
    visited[i] = TRUE;
    printf(&quot;%c &quot;,GL-&gt;adjList[i].data);/* 打印顶点,也可以其它操作 */
    p = GL-&gt;adjList[i].firstedge;
    while(p)
    {
        if(!visited[p-&gt;adjvex])
            DFS(GL, p-&gt;adjvex);/* 对为访问的邻接顶点递归调用 */
        p = p-&gt;next;
    }
}

/* 邻接表的深度遍历操作 */
void DFSTraverse(GraphAdjList GL)
{
    int i;
    for(i = 0; i &lt; GL-&gt;numVertexes; i++)
        visited[i] = FALSE; /* 初始所有顶点状态都是未访问过状态 */
    for(i = 0; i &lt; GL-&gt;numVertexes; i++)
        if(!visited[i]) /* 对未访问过的顶点调用DFS,若是连通图,只会执行一次 */ 
            DFS(GL, i);
}
</code></pre>
<p>对比两个不同存储结构的深度优先遍历算法，对于n个顶点e条边的图来说，邻接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此都需要O(n²)的时间。而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是O（n+e）。显然对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。</p>
<h3 id="7-5-2-广度优先遍历">7.5.2 广度优先遍历</h3>
<p>广度优先遍历（Breadth_First_Search），又称为广度优先搜索，简称BFS。<br>
如果说图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树的层序遍历了。我们将图7-5-3的第一幅图稍微变形，变形原则是顶点A放置在最上第一层，让与它有边的顶点B、F为第二层，再让与B和F有边的顶点C、I、G、E为第三层，再将这四个顶点有边的D、H放在第四层，如图7-5-3的第二幅图所示。<br>
此时在视觉上感觉图的形状发生了变化，其实顶点和边的关系还是完全相同的。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-5-3.JPG?raw=true" srcset="/img/loading.gif" alt="7-5-3"><br>
有了这个讲解，我们来看代码就非常容易了。以下是邻接矩阵结构的广度优先遍历算法。</p>
<pre><code class="language-c">/* 邻接矩阵的广度遍历算法 */
void BFSTraverse(MGraph G)
{
    int i, j;
    Queue Q;
    for(i = 0; i &lt; G.numVertexes; i++)
        visited[i] = FALSE;
    InitQueue(&amp;Q);        /* 初始化一辅助用的队列 */
    for(i = 0; i &lt; G.numVertexes; i++)  /* 对每一个顶点做循环 */
    {
        if (!visited[i])    /* 若是未访问过就处理 */
        {
            visited[i]=TRUE;        /* 设置当前顶点访问过 */
            printf(&quot;%c &quot;, G.vexs[i]);/* 打印顶点，也可以其它操作 */
            EnQueue(&amp;Q,i);        /* 将此顶点入队列 */
            while(!QueueEmpty(Q))    /* 若当前队列不为空 */
            {
                DeQueue(&amp;Q,&amp;i);/* 将队对元素出队列，赋值给i */
                for(j=0;j&lt;G.numVertexes;j++) 
                {
                    /* 判断其它顶点若与当前顶点存在边且未访问过  */
                    if(G.arc[i][j] == 1 &amp;&amp; !visited[j])
                    {
                        visited[j]=TRUE;            /* 将找到的此顶点标记为已访问 */
                        printf(&quot;%c &quot;, G.vexs[j]);    /* 打印顶点 */
                        EnQueue(&amp;Q,j);                /* 将找到的此顶点入队列  */
                    }
                }
            }
        }
    }
}
</code></pre>
<p>对于邻接表的广度优先遍历，代码与邻接矩阵差异不大，代码如下。</p>
<pre><code class="language-c">/* 邻接表的广度遍历算法 */
void BFSTraverse(GraphAdjList GL)
{
    int i;
    EdgeNode *p;
    Queue Q;
    for(i = 0; i &lt; GL-&gt;numVertexes; i++)
        visited[i] = FALSE;
    InitQueue(&amp;Q);
    for(i = 0; i &lt; GL-&gt;numVertexes; i++)
    {
        if (!visited[i])
        {
            visited[i]=TRUE;
            printf(&quot;%c &quot;,GL-&gt;adjList[i].data);/* 打印顶点,也可以其它操作 */
            EnQueue(&amp;Q,i);
            while(!QueueEmpty(Q))
            {
                DeQueue(&amp;Q,&amp;i);
                p = GL-&gt;adjList[i].firstedge;    /* 找到当前顶点的边表链表头指针 */
                while(p)
                {
                    if(!visited[p-&gt;adjvex])    /* 若此顶点未被访问 */
                     {
                        visited[p-&gt;adjvex]=TRUE;
                        printf(&quot;%c &quot;,GL-&gt;adjList[p-&gt;adjvex].data);
                        EnQueue(&amp;Q,p-&gt;adjvex);    /* 将此顶点入队列 */
                    }
                    p = p-&gt;next;    /* 指针指向下一个邻接点 */
                }
            }
        }
    }
}
</code></pre>
<p>对比图的深度优先遍历与广度优先遍历算法，你会发现，它们在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同。可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。<br>
不过如果图顶点和边非常多，不能在短时间内遍历完成，遍历的目的是为了寻找合适的顶点，那么选择哪种遍历就要仔细斟酌了。深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况。</p>
<h2 id="7-6-最小生成树">7.6 最小生成树</h2>
<p>我们把构造连通网的最小代价生成树称为最小生成树（Minimum Cost Spanning Tree）。</p>
<h3 id="7-6-1-普里姆（Prim）算法">7.6.1 普里姆（Prim）算法</h3>
<p>普里姆（Prim）算法代码如下，左侧数字为行号。其中INFINITY为权值极大值，不妨是65535，MAXVEX为顶点个数最大值，此处大于等于9即可。现在假设我们自己就是计算机，在调用MiniSpanTree_Prim函数，输入上述的邻接矩阵后，看看它是如何运行并打印出最小生成树的。</p>
<pre><code class="language-c">/* Prim算法生成最小生成树  */
void MiniSpanTree_Prim(MGraph G)
{
    int min, i, j, k;
    int adjvex[MAXVEX];        /* 保存相关顶点下标 */
    int lowcost[MAXVEX];    /* 保存相关顶点间边的权值 */
    lowcost[0] = 0;/* 初始化第一个权值为0，即v0加入生成树 */
            /* lowcost的值为0，在这里就是此下标的顶点已经加入生成树 */
    adjvex[0] = 0;            /* 初始化第一个顶点下标为0 */
    for(i = 1; i &lt; G.numVertexes; i++)    /* 循环除下标为0外的全部顶点 */
    {
        lowcost[i] = G.arc[0][i];    /* 将v0顶点与之有边的权值存入数组 */
        adjvex[i] = 0;                    /* 初始化都为v0的下标 */
    }
    for(i = 1; i &lt; G.numVertexes; i++)
    {
        min = INFINITY;    /* 初始化最小权值为∞， */
                        /* 通常设置为不可能的大数字如32767、65535等 */
        j = 1;k = 0;
        while(j &lt; G.numVertexes)    /* 循环全部顶点 */
        {
            if(lowcost[j]!=0 &amp;&amp; lowcost[j] &lt; min)/* 如果权值不为0且权值小于min */
            {
                min = lowcost[j];    /* 则让当前权值成为最小值 */
                k = j;            /* 将当前最小值的下标存入k */
            }
            j++;
        }
        printf(&quot;(%d, %d)\n&quot;, adjvex[k], k);/* 打印当前顶点边中权值最小的边 */
        lowcost[k] = 0;/* 将当前顶点的权值设置为0,表示此顶点已经完成任务 */
        for(j = 1; j &lt; G.numVertexes; j++)    /* 循环所有顶点 */
        {
            if(lowcost[j]!=0 &amp;&amp; G.arc[k][j] &lt; lowcost[j])
            {/* 如果下标为k顶点各边权值小于此前这些顶点未被加入生成树权值 */
                lowcost[j] = G.arc[k][j];/* 将较小的权值存入lowcost相应位置 */
                adjvex[j] = k;                /* 将下标为k的顶点存入adjvex */
            }
        }
    }
}
</code></pre>
<p>假设N=（P,{E}）是连通网，TE是N上最小生成树中边的集合。算法从U={u0}（u0∈V），TE={}开始。重复执行下述操作：在所有u∈U，v∈V-U的边（u，v）∈E中找一条代价最小的边（u0，v0）并入集合TE，同时v0并入U，直至U=V为止。此时TE中必有n-1条边，则T=（V.{TE}）为N的最小生成树。<br>
由算法代码中的循环嵌套可得知此算法的时间复杂度为O(n²)。</p>
<h3 id="7-6-2-克鲁斯卡尔（Kruskal）算法">7.6.2 克鲁斯卡尔（Kruskal）算法</h3>
<p>现在我们来换一种思考方式，普里姆（Prim）算法是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树的。<br>
同样的思路，我们也可以直接就以边为目标去构建，因为权值是在边上，直接去找最小权值的边来构建生成树也是很自然的想法，只不过构建时要考虑是否会形成环路而已。此时我们就用到了图的存储结构中的边集数组结构。以下是edge边集数组结构的定义代码：</p>
<pre><code class="language-c">typedef struct
{
    int begin;
    int end;
    int weight;
}Edge;   /* 对边集数组Edge结构的定义 */
</code></pre>
<p>我们将图7-6-3的邻接矩阵通过程序转化为图7-6-7的右图的边集数组，并且对它们按权值从小到大排序。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-6-7.JPG?raw=true" srcset="/img/loading.gif" alt="7-6-7"><br>
于是克鲁斯卡尔（Kruskal）算法代码如下，左侧数字为行号。其中MAXEDGE为边数量的极大值，此处大于等于15即可，MAXVEX为顶点个数最大值，此处大于等于9即可。现在假设我们自己就是计算机，在调用MiniSpanTree_Kruskal函数，输入图7-6-3右图的邻接矩阵后，看看它是如何运行并打印出最小生成树的。</p>
<pre><code class="language-c">/* 查找连线顶点的尾部下标 */
int Find(int *parent, int f)
{
    while ( parent[f] &gt; 0)
    {
        f = parent[f];
    }
    return f;
}

/* Kruskal算法生成最小生成树 */
void MiniSpanTree_Kruskal(MGraph G)
{
    int i, j, n, m;
    int k = 0;
    int parent[MAXVEX];/* 定义一数组用来判断边与边是否形成环路 */
    Edge edges[MAXEDGE];/* 定义边集数组,edge的结构为begin,end,weight,均为整型 */

    /* 用来构建边集数组并排序********************* */
    for ( i = 0; i &lt; G.numVertexes-1; i++)
    {
        for (j = i + 1; j &lt; G.numVertexes; j++)
        {
            if (G.arc[i][j]&lt;INFINITY)
            {
                edges[k].begin = i;
                edges[k].end = j;
                edges[k].weight = G.arc[i][j];
                k++;
            }
        }
    }
    sort(edges, &amp;G);
    /* ******************************************* */
    for (i = 0; i &lt; G.numVertexes; i++)
        parent[i] = 0;    /* 初始化数组值为0 */
    printf(&quot;打印最小生成树：\n&quot;);
    for (i = 0; i &lt; G.numEdges; i++)    /* 循环每一条边 */
    {
        n = Find(parent,edges[i].begin);
        m = Find(parent,edges[i].end);
        if (n != m) /* 假如n与m不等，说明此边没有与现有的生成树形成环路 */
        {
            parent[n] = m;    /* 将此边的结尾顶点放入下标为起点的parent中。 */
                            /* 表示此顶点已经在生成树集合中 */
            printf(&quot;(%d, %d) %d\n&quot;, edges[i].begin, edges[i].end, edges[i].weight);
        }
    }
}
</code></pre>
<p>好了，我们来把克鲁斯卡尔（Kruskal）算法的实现定义归纳一下结束这一节的讲解。<br>
假设N=（V,{E}）是连通网，则令最小生成树的初始状态为只有n个顶点而无边的非连通图T={V，{}}，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。依次类推，直至T中所有顶点都在同一连通分量上为止。<br>
此算法的Find函数由边数e决定，时间复杂度为O（㏒e），而外面有一个for 循环e次。所以克鲁斯卡尔算法的时间复杂度为O（e㏒e）。<br>
对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以对于稀疏图有很大的优势；而普里姆算法对于稠密图，即边数非常多的情况会更好一些。</p>
<h2 id="7-7-最短路径">7.7 最短路径</h2>
<p>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。</p>
<h3 id="7-7-1-迪杰斯特拉（Djkstra）算法">7.7.1 迪杰斯特拉（Djkstra）算法</h3>
<p>迪杰斯特拉（Dijkstra）算法并不是一下子就求出了v0到Vn的最短路径，而是一步步求出它们之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到你要的结果。</p>
<pre><code class="language-c">#define MAXVEX 20
#define INFINITY 65535
typedef int Patharc[MAXVEX];    /* 用于存储最短路径下标的数组 */
typedef int ShortPathTable[MAXVEX]; /* 用于存储到各点最短路径的权值和 */
/* Dijkstra算法，求有向网G的v0顶点到其余顶点v的最短路径P[v]及带权长度D[v] */
/* P[v]的值为前驱顶点下标,D[v]表示v0到v的最短路径长度和 */  
void ShortestPath_Dijkstra(MGraph G, int v0, Patharc *P, ShortPathTable *D)
{
    int v,w,k,min;
    int final[MAXVEX];/* final[w]=1表示求得顶点v0至vw的最短路径 */
    for(v=0; v&lt;G.numVertexes; v++)    /* 初始化数据 */
    {
        final[v] = 0;            /* 全部顶点初始化为未知最短路径状态 */
        (*D)[v] = G.arc[v0][v];/* 将与v0点有连线的顶点加上权值 */
        (*P)[v] = -1;                /* 初始化路径数组P为-1  */
    }
    (*D)[v0] = 0;  /* v0至v0路径为0 */  
    final[v0] = 1;    /* v0至v0不需要求路径 */
    /* 开始主循环，每次求得v0到某个v顶点的最短路径 */
    for(v=1; v&lt;G.numVertexes; v++)
    {
        min=INFINITY;    /* 当前所知离v0顶点的最近距离 */
        for(w=0; w&lt;G.numVertexes; w++) /* 寻找离v0最近的顶点 */
        {
            if(!final[w] &amp;&amp; (*D)[w]&lt;min)
            {
                k=w;
                min = (*D)[w];    /* w顶点离v0顶点更近 */
            }
        }
        final[k] = 1;    /* 将目前找到的最近的顶点置为1 */
        for(w=0; w&lt;G.numVertexes; w++) /* 修正当前最短路径及距离 */
        {
            /* 如果经过v顶点的路径比现在这条路径的长度短的话 */
            if(!final[w] &amp;&amp; (min+G.arc[k][w]&lt;(*D)[w]))
            { /*  说明找到了更短的路径，修改D[w]和P[w] */
                (*D)[w] = min + G.arc[k][w];  /* 修改当前路径长度 */
                (*P)[w]=k;
            }
        }
    }
}
</code></pre>
<p>此算法的时间复杂度为O（n²）。</p>
<h3 id="7-7-2-弗洛伊德（Floyd）算法">7.7.2 弗洛伊德（Floyd）算法</h3>
<pre><code class="language-c">typedef int Patharc[MAXVEX][MAXVEX];
typedef int ShortPathTable[MAXVEX][MAXVEX];
/* Floyd算法，求网图G中各顶点v到其余顶点w的最短路径P[v][w]及带权长度D[v][w]。 */
void ShortestPath_Floyd(MGraph G, Patharc *P, ShortPathTable *D)
{
    int v,w,k;
    for(v=0; v&lt;G.numVertexes; ++v) /* 初始化D与P */  
    {
        for(w=0; w&lt;G.numVertexes; ++w)  
        {
            (*D)[v][w]=G.arc[v][w];    /* D[v][w]值即为对应点间的权值 */
            (*P)[v][w]=w;                /* 初始化P */
        }
    }
    for(k=0; k&lt;G.numVertexes; ++k)
    {
        for(v=0; v&lt;G.numVertexes; ++v)  
        {
            for(w=0; w&lt;G.numVertexes; ++w)
            {
                if ((*D)[v][w]&gt;(*D)[v][k]+(*D)[k][w])
                {/* 如果经过下标为k顶点路径比原两点间路径更短 */
                    (*D)[v][w]=(*D)[v][k]+(*D)[k][w];/* 将当前两点间权值设为更小的一个 */
                    (*P)[v][w]=(*P)[v][k];/* 路径设置为经过下标为k的顶点 */
                }
            }
        }
    }
}
</code></pre>
<p>求最短路径的显示代码可以这样写：</p>
<pre><code class="language-c">    for(v=0; v&lt;G.numVertexes; ++v)
    {
        for(w=v+1; w&lt;G.numVertexes; w++)  
        {
            printf(&quot;v%d-v%d weight: %d &quot;,v,w,D[v][w]);
            k=P[v][w];                /* 获得第一个路径顶点下标 */
            printf(&quot; path: %d&quot;,v);    /* 打印源点 */
            while(k!=w)                /* 如果路径顶点下标不是终点 */
            {
                printf(&quot; -&gt; %d&quot;,k);    /* 打印路径顶点 */
                k=P[k][w];            /* 获得下一个路径顶点下标 */
            }
            printf(&quot; -&gt; %d\n&quot;,w);    /* 打印终点 */
        }
        printf(&quot;\n&quot;);
    }
</code></pre>
<p>再次回过头来看看弗洛伊德（Floyd）算法，它的代码简洁到就是一个二重循环初始化加一个三重循环权值修正，就完成了所有顶点到所有顶点的最短路径计算。几乎就如同是我们在学习C语言循环嵌套的样例代码而已。如此简单的实现，真是巧妙之极，在我看来，这是非常漂亮的算法，不知道你们是否喜欢？很可惜由于它的三重循环，因此也是O（n³）时间复杂度。如果你面临需要求所有顶点至所有顶点的最短路径问题时，弗洛伊德（Floyd）算法应该是不错的选择。</p>
<h2 id="7-8-拓扑排序">7.8 拓扑排序</h2>
<p>说了两个有环的图应用，现在我们来谈谈无环的图应用。无环，即是图中没有回路的意思。</p>
<h3 id="7-8-1-拓扑排序介绍">7.8.1 拓扑排序介绍</h3>
<p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网（Activity On Vertex Network）。<br>
设G=（V，E）是一个具有n个顶点的有向图，V中的顶点序列v1，V2，……，Vn，满足若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必在顶点vj之前。则我们称这样的顶点序列为一个拓扑序列。<br>
**所谓拓扑排序，其实就是对一个有向图构造拓扑序列的过程。**构造时会有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环（回路）的AOV网；如果输出顶点数少了，哪怕是少了一个，也说明这个网存在环（回路），不是AOV网。</p>
<h3 id="7-8-2-拓扑排序算法">7.8.2 拓扑排序算法</h3>
<p>对AOV网进行拓扑排序的基本思路是：从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AOV网中不存在入度为0的顶点为止。<br>
首先我们需要确定一下这个图需要使用的数据结构。前面求最小生成树和最短路径时，我们用的都是邻接矩阵，但由于拓扑排序的过程中，需要删除顶点，显然用邻接表会更加方便。因此我们需要为AOV网建立一个邻接表。考虑到算法过程中始终要查找入度为0的顶点，我们在原来顶点表结点结构中，增加一个入度域in，结构如表7-8-1所示，其中in就是入度的数字。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-8-1.JPG?raw=true" srcset="/img/loading.gif" alt="7-8-1"><br>
因此对于图7-8-2的第一幅图AOV网，我们可以得到如第二幅图的邻接表数据结构。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-8-2.JPG?raw=true" srcset="/img/loading.gif" alt="7-8-2"><br>
在拓扑排序算法中，涉及的结构代码如下:</p>
<pre><code class="language-c">typedef struct EdgeNode /* 边表结点  */
{
    int adjvex;    /* 邻接点域，存储该顶点对应的下标 */
    int weight;        /* 用于存储权值，对于非网图可以不需要 */
    struct EdgeNode *next; /* 链域，指向下一个邻接点 */
}EdgeNode;

typedef struct VertexNode /* 顶点表结点 */
{
    int in;    /* 顶点入度 */
    int data; /* 顶点域，存储顶点信息 */
    EdgeNode *firstedge;/* 边表头指针 */
}VertexNode, AdjList[MAXVEX];

typedef struct
{
    AdjList adjList;
    int numVertexes,numEdges; /* 图中当前顶点数和边数 */
}graphAdjList,*GraphAdjList;
</code></pre>
<p>在算法中，我还需要辅助的数据结构一栈，用来存储处理过程中入度为0的顶点，目的是为了避免每个查找时都要去遍历顶点表找有没有入度为0的顶点。<br>
现在我们来看代码:</p>
<pre><code class="language-c">/* 拓扑排序，若GL无回路，则输出拓扑排序序列并返回1，若有回路返回0。 */
Status TopologicalSort(GraphAdjList GL)
{
    EdgeNode *e;
    int i,k,gettop;
    int top=0;  /* 用于栈指针下标  */
    int count=0;/* 用于统计输出顶点的个数  */
    int *stack;    /* 建栈将入度为0的顶点入栈  */
    stack=(int *)malloc(GL-&gt;numVertexes * sizeof(int) );

    for(i = 0; i&lt;GL-&gt;numVertexes; i++)
        if(0 == GL-&gt;adjList[i].in) /* 将入度为0的顶点入栈 */
            stack[++top]=i;
    while(top!=0)
    {
        gettop=stack[top--];  /* 出栈 */
        printf(&quot;%d -&gt; &quot;,GL-&gt;adjList[gettop].data);
        count++;        /* 输出i号顶点，并计数 */
        for(e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next)
        {/* 对此顶点弧表遍历 */
            k=e-&gt;adjvex;
            if( !(--GL-&gt;adjList[k].in) )  /* 将k号顶点的邻接点的入度减1，如果减1后为0，则入栈 */
                stack[++top]=k;
        }
    }
    printf(&quot;\n&quot;);
    if(count &lt; GL-&gt;numVertexes)/* 如果 count小于顶点数，说明存在环 */
        return ERROR;
    else
        return OK;
}
</code></pre>
<p>分析整个算法，对一个具有n个顶点e条弧的AOV网来说，扫描顶点表，将入度为0的顶点入栈的时间复杂为O（n），而之后的while循环中，每个顶点进一次栈，出一次栈，入度减1的操作共执行了e次，所以整个算法的时间复杂度为O（n+e）。</p>
<h2 id="7-9-关键路径">7.9 关键路径</h2>
<p>在前面讲了AOV网的基础上，我们来介绍一个新的概念。在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为AOE网（Activity On Edge Network）。<br>
我们把AOE网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点。<br>
我们把路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动。<br>
如果我们需要缩短整个工期，去改进轮子的生产效率，哪怕改动成0.1也是无益于整个工期的变化，只有缩短关键路径上的关键活动时间才可以减少整个工期长度。<br>
那么现在的问题就是如何找出关键路径。</p>
<h3 id="7-9-1-关键路径算法原理">7.9.1 关键路径算法原理</h3>
<p>我们只需要找到所有活动的最早开始时间和最晚开始时间，并且比较它们，如果相等就意味着此活动是关键活动，活动间的路径为关键路径。如果不等，则就不是。<br>
为此，我们需要定义如下几个参数。</p>
<ol>
<li>事件的最早发生时间etv（earliest time of vertex）：即顶点vk的最早发生时间。</li>
<li>事件的最晚发生时间ltv（latest time of vertex）：即顶点Vk的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期。</li>
<li>活动的最早开工时间ete（earliest time ofedge）：即弧ak的最早发生时间。</li>
<li>活动的最晚开工时间lte（latest time of edge）：即弧ak的最晚发生时间，也就是不推迟工期的最晚开工时间。</li>
</ol>
<p>我们是由1和2可以求得3和4，然后再根据ete[k]是否与lte[k]相等来判断ak是否是关键活动。</p>
<h3 id="7-9-2-关键路径算法">7.9.2 关键路径算法</h3>
<p>我们将图7-9-2的AOE网转化为邻接表结构如图7-9-4所示，注意与拓扑排序时邻接表结构不同的地方在于，这里弧链表增加了weight域，用来存储弧的权值。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-9-4.JPG?raw=true" srcset="/img/loading.gif" alt="7-9-4"><br>
求事件的最早发生时间etv的过程，就是我们从头至尾找拓扑序列的过程，因此，在求关键路径之前，需要先调用一次拓扑序列算法的代码来计算etv和拓扑序列列表。为此，我们首先在程序开始处声明几个全局变量。</p>
<pre><code class="language-c">int *etv,*ltv; /* 事件最早发生时间和最迟发生时间数组，全局变量 */
int *stack2;   /* 用于存储拓扑序列的栈 */
int top2;      /* 用于stack2的指针 */
</code></pre>
<p>其中stack2用来存储拓扑序列，以便后面求关键路径时使用。<br>
下面是改进过的求拓扑序列算法。</p>
<pre><code class="language-c">/* 拓扑排序,用于关键路径计算 */
Status TopologicalSort(GraphAdjList GL)
{    /* 若GL无回路，则输出拓扑排序序列并返回1，若有回路返回0。 */
    EdgeNode *e;
    int i,k,gettop;
    int top=0;  /* 用于栈指针下标  */
    int count=0;/* 用于统计输出顶点的个数 */
    int *stack;    /* 建栈将入度为0的顶点入栈  */
    stack=(int *)malloc(GL-&gt;numVertexes * sizeof(int) );
    for(i = 0; i&lt;GL-&gt;numVertexes; i++)
        if(0 == GL-&gt;adjList[i].in) /* 将入度为0的顶点入栈 */
            stack[++top]=i;

    top2=0;         /* 初始化为0 */
    etv=(int *)malloc(GL-&gt;numVertexes * sizeof(int) ); /* 事件最早发生时间数组 */
    for(i=0; i&lt;GL-&gt;numVertexes; i++)
        etv[i]=0;    /* 初始化为0 */
    stack2=(int *)malloc(GL-&gt;numVertexes * sizeof(int) );/* 初始化拓扑序列栈 */

    printf(&quot;TopologicalSort:\t&quot;);
    while(top!=0)
    {
        gettop=stack[top--];
        printf(&quot;%d -&gt; &quot;,GL-&gt;adjList[gettop].data);
        count++;        /* 输出i号顶点，并计数 */

        stack2[++top2]=gettop;        /* 将弹出的顶点序号压入拓扑序列的栈 */

        for(e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next)
        {
            k=e-&gt;adjvex;
            if( !(--GL-&gt;adjList[k].in) )        /* 将i号顶点的邻接点的入度减1，如果减1后为0，则入栈 */
                stack[++top]=k;

            if((etv[gettop] + e-&gt;weight)&gt;etv[k])    /* 求各顶点事件的最早发生时间etv值 */
                etv[k] = etv[gettop] + e-&gt;weight;
        }
    }
    if(count &lt; GL-&gt;numVertexes)
        return ERROR;
    else
        return OK;
}
</code></pre>
<p>下面我们来看求关键路径的算法代码。</p>
<pre><code class="language-c">/* 求关键路径,GL为有向网，输出G的各项关键活动 */
void CriticalPath(GraphAdjList GL)
{
    EdgeNode *e;
    int i,gettop,k,j;
    int ete,lte;  /* 声明活动最早发生时间和最迟发生时间变量 */
    TopologicalSort(GL);   /* 求拓扑序列，计算数组etv和stack2的值 */
    ltv=(int *)malloc(GL-&gt;numVertexes*sizeof(int));/* 事件最早发生时间数组 */
    for(i=0; i&lt;GL-&gt;numVertexes; i++)
        ltv[i]=etv[GL-&gt;numVertexes-1];    /* 初始化 */
    while(top2!=0)    /* 出栈是求ltv */
    {
        gettop=stack2[top2--];
        for(e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next)
        {/* 求各顶点事件的最迟发生时间ltv值 */
            k=e-&gt;adjvex;
            if(ltv[k] - e-&gt;weight &lt; ltv[gettop])
                ltv[gettop] = ltv[k] - e-&gt;weight;
        }
    }
    for(j=0; j&lt;GL-&gt;numVertexes; j++)        /* 求ete,lte和关键活动 */
    {
        for(e = GL-&gt;adjList[j].firstedge; e; e = e-&gt;next)
        {
            k=e-&gt;adjvex;
            ete = etv[j];        /* 活动最早发生时间 */
            lte = ltv[k] - e-&gt;weight; /* 活动最迟发生时间 */
            if(ete == lte)    /* 两者相等即在关键路径上 */
                printf(&quot;&lt;v%d - v%d&gt; length: %d \n&quot;,GL-&gt;adjList[j].data,GL-&gt;adjList[k].data,e-&gt;weight);
        }
    }
}
</code></pre>
<p>最终求关键路径算法的时间复杂度依然是O（n+e）。<br>
实践证明，通过这样的算法对于工程的前期工期估算和中期的计划调整都有很大的帮助。不过注意，本例是唯一一条关键路径，这并不等于不存在多条关键路径的有向无环图。如果是多条关键路径，则单是提高一条关键路径上的关键活动的速度并不能导致整个工程缩短工期，而必须提高同时在几条关键路径上的活动的速度。这就像仅仅是有事业的成功，而没有健康的身体以及快乐的生活，是根本谈不上幸福的人生一样，三者缺一不可。</p>
<h2 id="7-10-总结回顾">7.10 总结回顾</h2>
<p>图是计算机科学中非常常用的一类数据结构，有许许多多的计算问题都是用图来定义的。由于图也是最复杂的数据结构，对它讲解时，涉及到数组、链表、栈、队列、树等之前学的几乎所有数据结构。因此从某种角度来说，学好了图，基本就等于理解了数据结构这门课的精神。<br>
我们在图的定义这一节，介绍了一大堆定义和术语，一开始可能会有些迷茫，不过一回生二回熟，多读几遍，基本都可以理解并记住它们的特征，在图的定义这一节的末尾，我们已经有所总结，这里就不再赘述了。<br>
图的存储结构我们一共讲了五种，如图7-10-1所示，其中比较重要的是邻接矩阵和邻接表，它们分别代表着边集是用数组还是链表的方式存储。十字链表是邻接矩阵的一种升级，而邻接多重表则是邻接表的升级。边集数组更多考虑的是对边的关注。用什么存储结构需要具体问题具体分析，通常稠密图，或读存数据较多，结构修改较少的图，用邻接矩阵要更合适，反之则应该考虑邻接表。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-10-1.JPG?raw=true" srcset="/img/loading.gif" alt="7-10-1"><br>
图的遍历分为深度和广度两种，各有优缺点，就像人在追求卓越时，是着重深度还是看重广度，总是很难说得清楚。<br>
图的应用是我们这一章浓墨重彩的一部分，一共谈了三种应用：最小生成树、最短路径和有向无环图的应用。<br>
最小生成树，我们讲了两种算法：普里姆（Prim）算法和克鲁斯卡尔（Kruskal）算法。普里姆算法像是走一步看一步的思维方式，逐步生成最小生成树。而克鲁斯卡尔算法则更有全局意识，直接从图中最短权值的边入手，找寻最后的答案。<br>
最短路径的现实应用非常多，我们也介绍了两种算法。迪杰斯特拉（Dijkstra）算法更强调单源顶点查找路径的方式，比较符合我们正常的思路，容易理解原理，但算法代码相对复杂。而弗洛伊德（Floyd）算法则完全抛开了单点的局限思维方式，巧妙地应用矩阵的变换，用最清爽的代码实现了多顶点间最短路径求解的方案，原理理解有难度，但算法编写很简洁。<br>
有向无环图时常应用于工程规划中，对于整个工程或系统来说，我们一方面关心的是工程能否顺利进行的问题，通过拓扑排序的方式，我们可以有效地分析出一个有向图是否存在环，如果不存在，那它的拓扑序列是什么？另一方面关心的是整个工程完成所必须的最短时间问题，利用求关键路径的算法，可以得到最短完成工程的工期以及关键的活动有哪些。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构第六章 树</title>
    <url>/2019/12/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC6%E7%AB%A0%20%E6%A0%91/</url>
    <content><![CDATA[<h2 id="6-1-6-2-树的定义">6.1-6.2 树的定义</h2>
<p><strong>树(Tree)是n(n≥0)个结点的有限集。n=0时称为空树。在任意一棵非空树中：1)有且仅有一个特定的称为根(Root)的结点；2)当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。</strong></p>
<a id="more"></a>
<p>对于树的定义还需要强调两点：</p>
<ol>
<li>n&gt;0时根结点是唯一的，不可能存在多个根结点，数据结构中的树是只能有一个根结点。</li>
<li>m&gt;0时，子树的个数没有限制，但它们一定是互不相交的。</li>
</ol>
<h3 id="6-2-1-结点分类">6.2.1 结点分类</h3>
<p>树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。如图6-2-4所示，因为这棵树结点的度的最大值是结点D的度为3，所以树的度也为3。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-2-4.JPG?raw=true" srcset="/img/loading.gif" alt="6-2-4"></p>
<h3 id="6-2-2-结点间关系">6.2.2 结点间关系</h3>
<p>结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）。同一个双亲的孩子之间互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。</p>
<h3 id="6-2-3-树的其他相关概念">6.2.3 树的其他相关概念</h3>
<p>结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。其双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度。<br>
如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。<br>
森林（Forest）是m（m&gt;0）棵互不相交的树的集合。<br>
对比线性表与树的结构，它们有很大的不同，如图6-2-7所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-2-7.JPG?raw=true" srcset="/img/loading.gif" alt="6-2-7"></p>
<h2 id="6-3-树的抽象数据类型">6.3 树的抽象数据类型</h2>
<pre><code class="language-c">ADT 树（tree）
Data
  树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。
Operation
  InitTree（*T）：构造空树T。
  DestroyTree（*T）：销毁树T。
  CreateTree（*T，definition）：按definition中给出树的定义来构造树。
  ClearTree（*T）：若树T存在，则将树T清为空树。
  TreeEmpty（T）：若T为空树，返回true，否则返回false。
  TreeDepth（T）：返回T的深度。
  Root（T）：返回T的根结点。
  Value（T，cur_e）：cur_e是树T中一个结点，返回此结点的值。
  Assign（T，cur_e，value）：给树T的结点cur_e赋值为value。
  Parent（T，cur_e）：若cur_e是树T的非根结点，则返回它的双亲，否则返回空。
  LeftChild（T，cure）：若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空。
  RightSibling（T，cur_e）：若cur_e有右兄弟，则返回它的右兄弟，否则返回空。
  InsertChild（*T，*p，i，c）：其中p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树。
  DeleteChild（*T，*p，i）：其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树。
endADT
</code></pre>
<h2 id="6-4-树的存储结构">6.4 树的存储结构</h2>
<p>充分利用顺序存储和链式存储结构的特点，可以实现对树的存储结构的表示。我们这里要介绍三种不同的表示法：双亲表示法、孩子表示法、孩子兄弟表示法。</p>
<h3 id="6-4-1-双亲表示法">6.4.1 双亲表示法</h3>
<p>树除了根结点外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲。<br>
我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。<br>
data数据域，存储结点的数据信息。而parent指针域，存储该结点的双亲在数组中的下标。<br>
以下是我们的双亲表示法的结点结构定义代码:</p>
<pre><code class="language-c">/* 树的双亲表示法结点结构定义 */
#define MAX_TREE_SIZE 100 /* 二叉树的最大结点数 */
typedef int TElemType;  /* 树结点的数据类型，目前暂定为整型 */
typedef struct PTNode/*结点结构*/
{
  TElemType data;/*结点数据*/
  int parent;/*双亲位置*/
}PTNode;
typedef struct /* 树结构 */
{
  PTNode nodes[MAX_TREE_SI2E];/* 结点数组 */
  int r，n;/* 根的位置和结点数 */
}PTree;
</code></pre>
<p>有了这样的结构定义，我们就可以来实现双亲表示法了。由于根结点是没有双亲的，所以我们约定根结点的位置域设置为-1，这也就意味着，我们所有的结点都存有它双亲的位置。如图6-4-1中的树结构和表6-4-2中的树双亲表示所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-1.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-1"></p>
<p>这样的存储结构，我们可以根据结点的parent指针很容易找到它的双亲结点，所用的时间复杂度为O(1)，直到parent为-1时，表示找到了树结点的根。可如果我们要知道结点的孩子是什么，请遍历整个结构才行。如何改进呢？<br>
我们增加一个结点最左边孩子的域，不妨叫它长子域，这样就可以很容易得到结点的孩子。如果没有孩子的结点，这个长子域就设置为-1，如表6-4-3所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-3.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-3"></p>
<p>对于有0个或1个孩子结点来说，这样的结构是解决了要找结点孩子的问题了。甚至是有2个孩子，知道了长子是谁，另一个当然就是次子了。<br>
另外一个问题是，我们很关注各兄弟之间的关系，双亲表示法无法体现这样的关系，那我们怎么办？嗯，可以增加一个右兄弟域来体现兄弟关系，也就是说，每一个结点如果它存在右兄弟，则记录下右兄弟的下标。同样的，如果右兄弟不存在，则赋值为-1。<br>
但如果结点的孩子很多，超过了2个。我们又关注结点的双亲、又关注结点的孩子、还关注结点的兄弟，而且对时间遍历要求还比较高，那么我们还可以把此结构扩展为有双亲域、长子域、再有右兄弟域。存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。注意也不是越多越好，有需要时再设计相应的结构。</p>
<h3 id="6-4-2-孩子表示法">6.4.2 孩子表示法</h3>
<p>换一种完全不同的考虑方法。由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。不过，树的每个结点的度，也就是它的孩子个数是不同的。所以可以设计两种方案来解决。</p>
<h4 id="6-4-2-1-方案一">6.4.2.1 方案一</h4>
<p>一种是指针域的个数就等于树的度，复习一下，树的度是树各个结点度的最大值。其结构如表6-4-5所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-5.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-5"><br>
其中data是数据域。child1到child d是指针域，用来指向该结点的孩子结点。<br>
对于图6-4-1的树来说，树的度是3，所以我们的指针域的个数是3，这种方法实现如图6-4-2所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-2.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-2"><br>
这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。不过如果树的各结点度相差很小时，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。<br>
既然很多指针域都可能为空，那么我们可以按需分配空间。</p>
<h4 id="6-4-2-2-方案二">6.4.2.2 方案二</h4>
<p>第二种方案每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数，其结构如表6-4-6所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-6.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-6"><br>
其中data为数据域，degree为度域，也就是存储该结点的孩子结点的个数，child1到child d为指针域，指向该结点的各个孩子的结点。<br>
对于图6-4-2的树来说，这种方法实现如图6-4-3所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-7.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-7"><br>
这种方法克服了浪费空间的缺点，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。</p>
<p>孩子表示法。具体办法是，<strong>把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</strong>，如图6-4-4所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-8.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-8"><br>
以下是我们的孩子表示法的结构定义代码:</p>
<pre><code class="language-c">/*树的孩子表示法结构定义*/
#define MAX_TREE_SIZE 100
typedef struct cTNode/* 孩子结点 */
{
  int child;
  struct CTNode *next;
}*ChildPtr;
typedef struct  /* 表头结构 */
{
  TElemType data;
  ChildPtr firstChild;
}CTBox;
typedef struct  /* 树结构 */
{
  CTBox nodes[MAX_TREE_SIZE];  /* 结点数组 */
  int r，n;  /* 根的位置和结点数 */
}CTree;
</code></pre>
<p>这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。<br>
但是，这也存在着问题，我如何知道某个结点的双亲是谁呢？比较麻烦，需要整棵树遍历才行，难道就不可以把双亲表示法和孩子表示法综合一下吗？当然是可以。如图6-4-5所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-9.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-9"><br>
我们把这种方法称为双亲孩子表示法。</p>
<h3 id="6-4-3-孩子兄弟表示法">6.4.3 孩子兄弟表示法</h3>
<p><strong>我们观察后发现，任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。</strong><br>
结点结构如下所示。</p>
<table>
<thead>
<tr>
<th>data</th>
<th>firstChild</th>
<th>rightSib</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>其中data是数据域，firstChild为指针域，存储该结点的第一个孩子结点的存储地址，rightSib是指针域，存储该结点的右兄弟结点的存储地址。<br>
结构定义代码如下:</p>
<pre><code class="language-c">/*树的孩子兄弟表示法结构定义*/
typedef struct CSNode
{
  TElemType data;
  struct CSNode *firstChild， *rightSib;
}CSNode,*CSTree;
</code></pre>
<p>对于图6-4-1的树来说，这种方法实现的示意图如图6-4-6所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-10.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-10"><br>
这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过firstChild找到此结点的长子，然后再通过长子结点的rightSib找到它的二弟，接着一直下去，直到找到具体的孩子。</p>
<h2 id="6-5-二叉树的定义">6.5 二叉树的定义</h2>
<p><strong>二叉树（Binary Tree）是n（n≥0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</strong></p>
<h3 id="6-5-1-二叉树特点">6.5.1 二叉树特点</h3>
<p>二叉树的特点有：</p>
<ul>
<li>每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。</li>
<li>左子树和右子树是有顺序的，次序不能任意颠倒。</li>
<li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。</li>
</ul>
<p>二叉树具有五种基本形态：</p>
<ol>
<li>空二叉树。</li>
<li>只有一个根结点。</li>
<li>根结点只有左子树。</li>
<li>根结点只有右子树。</li>
<li>根结点既有左子树又有右子树。</li>
</ol>
<h3 id="6-5-2-特殊二叉树">6.5.2 特殊二叉树</h3>
<p>一、斜树:所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p>
<p>二、满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。<br>
满二叉树的特点有：</p>
<ul>
<li>叶子只能出现在最下一层。出现在其他层就不可能达成平衡。</li>
<li>非叶子结点的度一定是2。否则就是“缺胳膊少腿”了。</li>
<li>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li>
</ul>
<p>三、完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。<br>
完全二叉树的特点：</p>
<ol>
<li>叶子结点只能出现在最下两层。</li>
<li>最下层的叶子一定集中在左部连续位置。</li>
<li>倒数二层，若有叶子结点，一定都在右部连续位置。</li>
<li>如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。</li>
<li>同样结点数的二叉树，完全二叉树的深度最小。</li>
</ol>
<h2 id="6-6-二叉树的性质">6.6 二叉树的性质</h2>
<p>二叉树有一些需要理解并记住的特性，以便于我们更好地使用它。</p>
<h3 id="6-6-1-二叉树性质1">6.6.1 二叉树性质1</h3>
<p>性质1：在二叉树的第i层上至多有$2^{i-1}$个结点（i≥1）。</p>
<h3 id="6-6-2-二叉树性质2">6.6.2 二叉树性质2</h3>
<p>性质2：深度为k的二叉树至多有$2^k-1$个结点（k≥1）。</p>
<h3 id="6-6-3-二叉树性质3">6.6.3 二叉树性质3</h3>
<p>性质3：对任何一棵二叉树T，如果其叶子结点数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$。</p>
<h3 id="6-6-4-二叉树性质4">6.6.4 二叉树性质4</h3>
<p>性质4：具有n个结点的完全二叉树的深度为[㏒$_2$n]+1（[x]表示不大于x的最大整数）。</p>
<h3 id="6-6-5-二叉树性质5">6.6.5 二叉树性质5</h3>
<p>性质5：如果对一棵有n个结点的完全二叉树（其深度为[㏒$_2$n]+1）的结点按层序编号（从第1层到第[㏒$_2$n]+1层，每层从左到右），对任一结点i（1≤i≤n）有：</p>
<ol>
<li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点[i/2]。</li>
<li>如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。</li>
<li>如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1。</li>
</ol>
<h2 id="6-7-二叉树的存储结构">6.7 二叉树的存储结构</h2>
<h3 id="6-7-1-二叉树顺序存储结构">6.7.1 二叉树顺序存储结构</h3>
<p>二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系。<br>
所以用来表示完全二叉树比较好。由于它定义的严格，所以用顺序结构也可以表现出二叉树的结构来。<br>
当然对于一般的二叉树，尽管层序编号不能反映逻辑关系，但是可以将其按完全二叉树编号，只不过，把不存在的结点设置为“^”而已。如图6-7-3所示，浅色结点表示不存在。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-7-3.JPG?raw=true" srcset="/img/loading.gif" alt="6-7-3"><br>
但是对于一般二叉树，一棵深度为k的右斜树，它只有k个结点，却需要分配$2^k$-1个存储单元空间，这显然是对存储空间的浪费。<br>
所以，顺序存储结构一般只用于完全二叉树。</p>
<h3 id="6-7-2-二叉链表">6.7.2 二叉链表</h3>
<p>链式存储结构中。二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。结点结构图如表格6-7-1所示。</p>
<table>
<thead>
<tr>
<th>lChild</th>
<th>data</th>
<th>rChild</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>其中data是数据域，lChild和rChild都是指针域，分别存放指向左孩子和右孩子的指针。<br>
以下是我们的二叉链表的结点结构定义代码。</p>
<pre><code class="language-c">typedef struct BiTNode  /* 结点结构 */
{
   TElemType data;    /* 结点数据 */
   struct BiTNode *lchild,*rchild; /* 左右孩子指针 */
}BiTNode,*BiTree;
</code></pre>
<p>就如同树的存储结构中讨论的一样，如果有需要，还可以再增加一个指向其双亲的指针域，那样就称之为三叉链表。</p>
<h2 id="6-8遍历二叉树">6.8遍历二叉树</h2>
<h3 id="6-8-1二叉树遍历原理">6.8.1二叉树遍历原理</h3>
<p>二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p>
<h3 id="6-8-2二叉树遍历方法">6.8.2二叉树遍历方法</h3>
<p>二叉树的遍历方式可以很多，如果我们限制了从左到右的习惯方式，那么主要就分为四种：</p>
<ol>
<li>
<p>前序遍历-根左右<br>
规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</p>
</li>
<li>
<p>中序遍历-左根右<br>
规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。</p>
</li>
<li>
<p>后序遍历-左右根<br>
规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。</p>
</li>
<li>
<p>层序遍历<br>
规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p>
</li>
</ol>
<p>技巧：每个结点单独看。比如后序遍历，每个右结点的左边是该结点的左节点，右边必然是对应的根结点。</p>
<h3 id="6-8-3-前序遍历算法">6.8.3 前序遍历算法</h3>
<p>二叉树的定义是用递归的方式，所以，实现遍历算法也可以采用递归，而且极其简洁明了。先来看看二叉树的前序遍历算法。代码如下：</p>
<pre><code class="language-c">/* 二叉树的前序遍历递归算法 */
void PreOrderTraverse(BiTree T)
{
    if (T == NULL)
        return;
    printf(&quot;%c&quot;, T-&gt;data); /* 显示结点数据，可以更改为其它对结点操作 */
    PreOrderTraverse(T-&gt;lchild); /* 再先序遍历左子树 */
    PreOrderTraverse(T-&gt;rchild); /* 最后先序遍历右子树 */
}
</code></pre>
<h3 id="6-8-4-中序遍历算法">6.8.4 中序遍历算法</h3>
<p>二叉树的中序遍历算法和前序遍历算法仅仅只是代码的顺序上的差异。</p>
<pre><code class="language-c">/* 二叉树的中序遍历递归算法 */
void InOrderTraverse(BiTree T)
{
    if (T == NULL)
        return;
    InOrderTraverse(T-&gt;lchild); /* 中序遍历左子树 */
    printf(&quot;%c&quot;, T-&gt;data);/* 显示结点数据，可以更改为其它对结点操作 */
    InOrderTraverse(T-&gt;rchild); /* 最后中序遍历右子树 */
}
</code></pre>
<h3 id="6-8-5后序遍历算法">6.8.5后序遍历算法</h3>
<p>那么同样的，后序遍历也就很容易想到应该如何写代码了。</p>
<pre><code class="language-c">/* 二叉树的后序遍历递归算法 */
void PostOrderTraverse(BiTree T)
{
    if (T == NULL)
        return;
    PostOrderTraverse(T-&gt;lchild); /* 先后序遍历左子树  */
    PostOrderTraverse(T-&gt;rchild); /* 再后序遍历右子树  */
    printf(&quot;%c&quot;, T-&gt;data);/* 显示结点数据，可以更改为其它对结点操作 */
}
</code></pre>
<h3 id="6-8-6-推导遍历结果">6.8.6 推导遍历结果</h3>
<p>题目是这样：二叉树的中序序列是ABCDEFG，后序序列是BDCAFGE，求前序序列。<br>
这次简单点，由后序的BDCAFG E，得到E是根结点，因此前序首字母是E。<br>
于是根据中序序列分为两棵树ABCD和FG，由后序序列的BDCA FGE，知道A是E的左孩子，前序序列目前分析为EA。<br>
再由中序序列的A BCDEFG，知道BCD是A结点的右子孙，再由后序序列的BDC AFGE知道C结点是A结点的右孩子，前序序列目前分析得到EAC。<br>
中序序列AB C DEFG，得到B是C的左孩子，D是C的右孩子，所以前序序列目前分析结果为EACBD。<br>
由后序序列BDCAF G E，得到G是E的右孩子，于是F就是G的孩子。前序遍历序列的最终结果就是EACBDGF。</p>
<p>两个二叉树遍历的性质。</p>
<ul>
<li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li>
<li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li>
</ul>
<p>但要注意了，已知前序和后序遍历，是不能确定一棵二叉树的，原因也很简单，比如前序序列是ABC，后序序列是CBA。我们可以确定A一定是根结点，但接下来，我们无法知道，哪个结点是左子树，哪个是右子树。这棵树可能有如图6-8-24所示的四种可能。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-8-24.JPG?raw=true" srcset="/img/loading.gif" alt="6-8-24"></p>
<h2 id="6-9-二叉树的建立">6.9 二叉树的建立</h2>
<p>如果我们要在内存中建立一个二叉树，为了能让每个结点确认是否有左右孩子，我们对它进行了扩展，也就是将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，比如“#”。我们称这种处理后的二叉树为原二叉树的扩展二叉树。扩展二叉树就可以做到一个遍历序列确定一棵二叉树了。<br>
前序遍历序列生成二叉树的代码如下：</p>
<pre><code class="language-c">/* 按前序输入二叉树中结点的值（一个字符） */
/* #表示空树，构造二叉链表表示二叉树T。 */
void CreateBiTree(BiTree *T)
{
    TElemType ch;
    /* scanf(&quot;%c&quot;,&amp;ch); */
    ch = str[index++];
    if (ch == '#')
        *T = NULL;
    else
    {
        *T = (BiTree)malloc(sizeof(BiTNode));
        if (!*T)
            exit(OVERFLOW);
        (*T)-&gt;data = ch; /* 生成根结点 */
        CreateBiTree(&amp;(*T)-&gt;lchild); /* 构造左子树 */
        CreateBiTree(&amp;(*T)-&gt;rchild); /* 构造右子树 */
    }
}
</code></pre>
<p>当然，你完全也可以用中序或后序遍历的方式实现二叉树的建立，只不过代码里生成结点和构造左右子树的代码顺序交换一下。另外，输入的字符也要做相应的更改。</p>
<h2 id="6-10-线索二叉树">6.10 线索二叉树</h2>
<h3 id="6-10-1-线索二叉树原理">6.10.1 线索二叉树原理</h3>
<p><strong>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）。</strong><br>
其实线索二叉树，等于是把一棵二叉树转变成了一个双向链表，这样对我们的插入删除结点、查找某个结点都带来了方便。所以<strong>我们对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化</strong>。<br>
但是变为线索二叉树，我们并不知道某个结点的lChild是指向它的左孩子还是指向前驱…<br>
因此，我们在每个结点再增设两个标志域lTag和rTag，注意lTag和rTag只是存放0或1数字的布尔型变量，其占用的内存空间要小于像lchild和rchild的指针变量。结点结构如下表所示。</p>
<table>
<thead>
<tr>
<th>lChild</th>
<th>lTag</th>
<th>data</th>
<th>rTag</th>
<th>rChild</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>其中：</p>
<ul>
<li>lTag为0时指向该结点的左孩子，为1时指向该结点的前驱。</li>
<li>rTag为0时指向该结点的右孩子，为1时指向该结点的后继。</li>
</ul>
<h3 id="6-10-2-线索二叉树结构实现">6.10.2 线索二叉树结构实现</h3>
<p>由此二叉树的线索存储结构定义代码如下：</p>
<pre><code class="language-c">/* 二叉树的二叉线索存储结构定义 */
typedef enum { Link, Thread } PointerTag; /* Link==0表示指向左右孩子指针, */
                                          /* Thread==1表示指向前驱或后继的线索 */
typedef  struct BiThrNode                 /* 二叉线索存储结点结构 */
{
    TElemType data;    /* 结点数据 */
    struct BiThrNode *lchild, *rchild;    /* 左右孩子指针 */
    PointerTag LTag;
    PointerTag RTag;        /* 左右标志 */
} BiThrNode, *BiThrTree;
</code></pre>
<p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以<strong>线索化的过程就是在遍历的过程中修改空指针的过程</strong>。<br>
中序遍历线索化的递归函数代码如下：</p>
<pre><code class="language-c">BiThrTree pre; /* 全局变量,始终指向刚刚访问过的结点 */
/* 中序遍历进行中序线索化 */
void InThreading(BiThrTree p)
{
    if (p)
    {
        InThreading(p-&gt;lchild); /* 递归左子树线索化 */
        if (!p-&gt;lchild) /* 没有左孩子 */
        {
            p-&gt;LTag = Thread; /* 前驱线索 */
            p-&gt;lchild = pre; /* 左孩子指针指向前驱 */
        }
        if (!pre-&gt;rchild) /* 前驱没有右孩子 */
        {
            pre-&gt;RTag = Thread; /* 后继线索 */
            pre-&gt;rchild = p; /* 前驱右孩子指针指向后继(当前结点p) */
        }
        pre = p; /* 保持pre指向p的前驱 */
        InThreading(p-&gt;rchild); /* 递归右子树线索化 */
    }
}
</code></pre>
<p>if（!p-&gt;lChild）表示如果某结点的左指针域为空，因为其前驱结点刚刚访问过，赋值给了pre，所以可以将pre赋值给p-&gt;lChild，并修改p-&gt;LTag=Thread（也就是定义为1）以完成前驱结点的线索化。<br>
后继就要稍稍麻烦一些。因为此时p结点的后继还没有访问到，因此只能对它的前驱结点pre的右指针rchild做判断，if（!pre-&gt;rchild）表示如果为空，则p就是pre的后继，于是pre-&gt;rchild=p，并且设置pre-&gt;RTag=Thread，完成后继结点的线素化。<br>
完成前驱和后继的判断后，别忘记将当前的结点p赋值给pre，以便于下一次使用。<br>
有了线索二叉树后，我们对它进行遍历时发现，其实就等于是操作一个双向链表结构。<br>
和双向链表结构一样，在二叉树线素链表上添加一个头结点，如图6-10-6所示，并令其lchild域的指针指向二叉树的根结点（图中的①），其rchild域的指针指向中序遍历时访问的最后一个结点（图中的②）。反之，令二叉树的中序序列中的第一个结点中，lchild 域指针和最后一个结点的rchild 域指针均指向头结点（图中的③和④）。这样定义的好处就是我们既可以从第一个结点起顺后继进行遍历，也可以从最后一个结点起顺前驱进行遍历。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-10-6.JPG?raw=true" srcset="/img/loading.gif" alt="6-10-6"></p>
<p>遍历的代码如下：</p>
<pre><code class="language-c">/*T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的*/
/*最后一个结点。中序遍历二叉线索链表表示的二叉树T*/
Status InOrderTraverse_Thr(BiThrTree T)
{
    BiThrTree p;
    p = T-&gt;lchild; /* p指向根结点 */
    while (p != T) /* 空树或遍历结束时，p==T */
    { /* 空树或遍历结束时,p==T */
        while (p-&gt;LTag == Link) /*当LTag==0时循环到中序序列第一个结点 */
            p = p-&gt;lchild;
        printf(&quot;%c&quot;,p-&gt;data); /* 显示结点数据，可以更改为其他对结点操作 */
        while (p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != T)
        {
            p = p-&gt;rchild;
            printf(&quot;%c&quot;,p-&gt;data);
        }
        p = p-&gt;rchild; /* p进至其右子树根 */
    }
    return OK;
}
</code></pre>
<p>从这段代码也可以看出，它等于是一个链表的扫描，所以时间复杂度为O(n)。<br>
由于它充分利用了空指针域的空间（这等于节省了空间），又保证了创建时的一次遍历就可以终生受用前驱后继的信息（这意味着节省了时间）。所以在实际问题中，<strong>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择</strong>。</p>
<h2 id="6-11-树、森林与二叉树的转换">6.11 树、森林与二叉树的转换</h2>
<h3 id="6-11-1-树转换为二叉树">6.11.1 树转换为二叉树</h3>
<p>将树转换为二叉树的步骤如下</p>
<ol>
<li>加线。在所有兄弟结点之间加一条连线。</li>
<li>去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。</li>
<li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</li>
</ol>
<h3 id="6-11-2-森林转换为二叉树">6.11.2 森林转换为二叉树</h3>
<p>森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。步骤如下：</p>
<ol>
<li>把每个树转换为二叉树。</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。</li>
</ol>
<h3 id="6-11-3-二叉树转换为树">6.11.3 二叉树转换为树</h3>
<p>二叉树转换为树是树转换为二叉树的逆过程，也就是反过来做而已。如图6-11-4所示。步骤如下：</p>
<ol>
<li>加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……哈，反正就是左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。</li>
<li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li>
<li>层次调整。使之结构层次分明。</li>
</ol>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-11-4.JPG?raw=true" srcset="/img/loading.gif" alt="6-11-4"></p>
<h3 id="6-11-4-二叉树转换为森林">6.11.4 二叉树转换为森林</h3>
<p>判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。<br>
那么如果是转换成森林，步骤如下：</p>
<ol>
<li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。</li>
<li>再将每棵分离后的二叉树转换为树即可。</li>
</ol>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-11-5.JPG?raw=true" srcset="/img/loading.gif" alt="6-11-5"></p>
<h3 id="6-11-5-树与森林的遍历">6.11.5 树与森林的遍历</h3>
<p>树的遍历分为两种方式。</p>
<ol>
<li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。</li>
<li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。比如图6-11-4中最右侧的树，它的先根遍历序列为ABEFCDG，后根遍历序列为EFBCGDA。</li>
</ol>
<p>森林的遍历也分为两种方式：</p>
<ol>
<li>前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。比如图6-11-5右侧三棵树的森林，前序遍历序列的结果就是ABCDEFGHJI。</li>
<li>后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。比如图6-11-5右侧三棵树的森林，后序遍历序列的结果就是BCDAFEJHIG。</li>
</ol>
<p>可如果我们对二叉树进行分析就会发现，森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。<br>
这也就告诉我们，当以二叉链表作树的存储结构时，树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现。这其实也就证实，我们找到了对树和森林这种复杂问题的简单解决办法。</p>
<h2 id="6-12-赫夫曼树及其应用">6.12 赫夫曼树及其应用</h2>
<h3 id="6-12-1-赫夫曼树">6.12.1 赫夫曼树</h3>
<p>压缩软件如何做到压缩而不出错的呢？简单说，就是把我们要压缩的文本进行重新编码，以减少不必要的空间。我们今天就来介绍一下最基本的压缩编码方法——赫夫曼编码。<br>
由美国数学家赫夫曼（David Huffman）在1952年发明了赫夫曼编码。他在编码中用到的特殊的二叉树称之为赫夫曼树，他的编码方法称为赫夫曼编码。</p>
<h3 id="6-12-2-赫夫曼树定义与原理">6.12.2 赫夫曼树定义与原理</h3>
<p><strong>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度。</strong><br>
<strong>树的路径长度就是从树根到每一结点的路径长度之和。</strong><br>
如果考虑到带权的结点，结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。假设有n个权值{w1，w2，…，Wn}，构造一棵有n个叶子结点的二叉树，每个叶子结点带权Wk，每个叶子的路径长度为lk，我们通常记作，则其中<strong>带权路径长度WPL最小的二叉树称做赫夫曼树</strong>。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-12-4.JPG?raw=true" srcset="/img/loading.gif" alt="6-12-4"><br>
有了赫夫曼对带权路径长度的定义，我们来计算一下图6-12-4这两棵树的WPL值。<br>
二叉树a的WPL=5×1+15×2+40×3+30×4+10×4=315<br>
注意：这里5是A结点的权，1是A结点的路径长度，其他同理。<br>
二叉树b的WPL=5×3+15×3+40×2+30×2+10×2=220<br>
参考图6-12-4的二叉树b，最优赫夫曼树的解法如下：</p>
<ol>
<li>先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即：A5，E10，B15，D30，C40。</li>
<li>取头两个最小权值的结点作为一个新节点N1的两个子结点，注意相对较小的是左孩子，这里就是A为N1的左孩子，E为N1的右孩子，如图6-12-5所示。新结点的权值为两个叶子权值的和5+10=15。</li>
<li>将N1替换A与E，插入有序序列中，保持从小到大排列。即：N1 15，B15，D30，C40。</li>
<li>重复步骤2。将N1与B作为一个新节点N2的两个子结点。如图6-12-6所示。N2的权值=15+15=30。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-12-5.JPG?raw=true" srcset="/img/loading.gif" alt="6-12-5"></li>
<li>将N2替换N1与B，插入有序序列中，保持从小到大排列。即：N2 30，D30，C40。</li>
<li>重复步骤2。将N2与D作为一个新节点N3的两个子结点。如图6-12-7所示。N3的权值=30+30=60。</li>
<li>将N3替换N2与D，插入有序序列中，保持从小到大排列。即：C40，N3 60。</li>
<li>重复步骤2。将C与N3作为一个新节点T的两个子结点，如图6-12-8所示。由于T即是根结点，完成赫夫曼树的构造。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-12-7.JPG?raw=true" srcset="/img/loading.gif" alt="6-12-7"></li>
</ol>
<p>此时的图6-12-8二叉树的带权路径长度WPL=40×1+30×2+15×3+10×4+5×4=205。与图6-12-4的二叉树b的WPL值220相比，还少了15。显然此时构造出来的二叉树才是最优的赫夫曼树。<br>
通过刚才的步骤，我们可以得出构造赫夫曼树的赫夫曼算法描述。</p>
<ol>
<li>根据给定的n个权值{w1，W2，…，Wn}构成n棵二叉树的集合F={T1，T2，…，Tn}，其中每棵二叉树Ti中只有一个带权为wi根结点，其左右子树均为空。</li>
<li>在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li>
<li>在F中删除这两棵树，同时将新得到的二叉树加入F中。</li>
<li>重复2和3步骤，直到F只含一棵树为止。这棵树便是赫夫曼树。</li>
</ol>
<h3 id="6-12-3-赫夫曼编码">6.12.3 赫夫曼编码</h3>
<p>按照不同字母出现的频率重新按照赫夫曼树来规划它们。将规划出来的树权值左分支改为0，右分支改为1后。对字母从树根到叶子所经过路径的0或1来编码，可以看出结果串变小了，编码得到了压缩，节约了存储和传输成本。<br>
当我们接收到压缩过的新编码时，我们应该如何把它解码出来呢？<br>
编码中非0即1，长短不等的话其实是很容易混淆的，所以<strong>若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称做前缀编码</strong>。<br>
可仅仅是这样不足以让我们去方便地解码的，因此在解码时，还是要用到赫夫曼树，即发送方和接收方必须要约定好同样的赫夫曼编码规则。<br>
<strong>一般地，设需要编码的字符集为{d1，d2，…，dn}，各个字符在电文中出现的次数或频率集合为{W1，w2，…，Wn}，以d1，d2，…，dn作为叶子结点，以w1，W2，Wn作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是赫夫曼编码</strong>。</p>
<h2 id="6-13-总结回顾">6.13 总结回顾</h2>
<p>终于到了总结的时间，这一章与前面章节相比，显得过于庞大了些，原因也就在于树的复杂性和变化丰富度是前面的线性表所不可比拟的。即使在本章之后，我们还要讲解关于树这一数据结构的相关知识，可见它的重要性。<br>
开头我们提到了树的定义，讲到了递归在树定义中的应用。提到了如子树、结点、度、叶子、分支结点、双亲、孩子、层次、深度、森林等诸多概念，这些都是需要在理解的基础上去记忆的。<br>
我们谈到了树的存储结构时，讲了双亲表示法、孩子表示法、孩子兄弟表示法等不同的存储结构。<br>
并由孩子兄弟表示法引出了我们这章中最重要一种树，二叉树。<br>
二叉树每个结点最多两棵子树，有左右之分。提到了斜树，满二叉树、完全二叉树等特殊二叉树的概念。<br>
我们接着谈到它的各种性质，这些性质给我们研究二叉树带来了方便。<br>
二叉树的存储结构由于其特殊性使得既可以用顺序存储结构又可以用链式存储结构表示。<br>
遍历是二叉树最重要的一门学问，前序、中序、后序以及层序遍历都是需要熟练掌握的知识。要让自己要学会用计算机的运行思维去模拟递归的实现，可以加深我们对递归的理解。不过，并非二叉树遍历就一定要用到递归，只不过递归的实现比较优雅而已。这点需要明确。<br>
二叉树的建立自然也是可以通过递归来实现。<br>
研究中也发现，二叉链表有很多浪费的空指针可以利用，查找某个结点的前驱和后继为什么非要每次遍历才可以得到，这就引出了如何构造一棵线索二叉树的问题。<br>
线索二叉树给二叉树的结点查找和遍历带来了高效率。<br>
树、森林看似复杂，其实它们都可以转化为简单的二叉树来处理，我们提供了树、森林与二叉树的互相转换的办法，这样就使得面对树和森林的数据结构时，编码实现成为了可能。<br>
最后，我们提到了关于二叉树的一个应用，赫夫曼树和赫夫曼编码，对于带权路径的二叉树做了详尽地讲述，让你初步理解数据压缩的原理，并明白其是如何做到无损编码和无错解码的。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构第五章 串</title>
    <url>/2019/12/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC5%E7%AB%A0%20%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="5-1-5-2-串的定义">5.1-5.2 串的定义</h2>
<p>串(string)是由零个或多个字符组成的有限序列，又名叫字符串。<br>
一般记为s=“a1a2……an”(n&gt;0)，其中，s是串的名称，用双引号(有些书中也用单引号)括起来的字符序列是串的值，注意单引号不属于串的内容。ai(1≤i≤n)可以是字母、数字或其他字符，i就是该字符在串中的位置。串中的字符数目n称为串的长度，定义中谈到“有限”是指长度n是一个有限的数值。零个字符的串称为空串(null string)，它的长度为零，可以直接用两双引号“”””表示，也可以用希腊字母“Φ”来表示。所谓的序列，说明串的相邻字符之间具有前驱和后继的关系。</p>
<a id="more"></a>
<p>还有一些概念需要解释：</p>
<ul>
<li>空格串，是只包含空格的串。注意它与空串的区别，空格串是有内容有长度的，而且可以不止一个空格。</li>
<li>子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。</li>
<li>子串在主串中的位置就是子串的第一个字符在主串中的序号。</li>
</ul>
<p>开头我所提到的“over”、“end”、“lie”其实可以认为是“over”、“friend”、“believe”这些单词字符串的子串。</p>
<h2 id="5-3-串的比较">5.3 串的比较</h2>
<p>两个字符串的长度以及它们每个位置各个对应位置的字符都相等时，才算是相等。<br>
那么对于两个串不相等时，如何判定它们的大小呢。我们这样定义：<br>
给定两个串：s=“a1a2……an&quot;，t=“b1b2……bm”，当满足以下条件之一时，<code>s&lt;t</code>。</p>
<ol>
<li><code>n&lt;m</code>，且ai=bi(i=1，2，…，n)。<br>
例如当s=“hap”，t=“happy”，就有sst。因为t比s多出了两个字母。</li>
<li>存在某个<code>k&lt;min(m，n)</code>，使得ai=bi；(i=1，2，……，k-1)，<code>ak&lt;bk</code>。<br>
例如当s=“happen&quot;，t=“happy&quot;，因为两串的前4个子母均相同，间内串第5个字母(k值)，字母e的ASCII码是101，而字母y的ASCII码是121，显然<code>e&lt;y</code>，所以<code>s&lt;t</code>。</li>
</ol>
<h2 id="5-4-串的抽象数据类型">5.4 串的抽象数据类型</h2>
<pre><code class="language-c">ADT 串(string)
Data
  串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。
Operation
  strAssign(T，*chars)：生成一个其值等于字符串常量chars的串T。
  StrCopy(T，S)：串S存在，由串S复制得串T。
  ClearString(S)：串S存在，将串清空。
  StringEmpty(S)；若串S为空，返回true，否则返回false。
  StrLength(S)：返回串S的元素个数，即串的长度。
  StrCompare(S，T)：若S&gt;T，返回值&gt;0，若S=T，返回0，若S&lt;T，返回值&lt;0。
  Concat(T，S1，S2)：用T返回由S1和S2联接而成的新串。
  SubString(Sub，S，pos，len)：串S存在，1≤pos≤StrLength(S)，且0≤len≤StrLength(S)-pos+1，用Sub返回串S的第pos个字符起长度为len的子串。
  Index(S，T，pos)：串S和T存在，T是非空串，1≤pos≤StrLength(S)。若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回0。
  Replace(S，T，V)：串S、T和v存在，T是非空串。用V替换主串S中出现的所有与T相等的不重叠的子串。
  StrInsert(S，pos，T)：串s和T存在，1≤pos≤StrLength(S)+1。在串S的第pos个字符之前插入串T。
  StrDelete(S，pos，len)：串S存在，1≤pos≤StrLength(S)-len+1。从串S中删除第pos个字符起长度为len的子串。
endADT
</code></pre>
<h2 id="5-5-串的存储结构">5.5 串的存储结构</h2>
<p>串的存储结构与线性表相同，分为两种。</p>
<h3 id="5-5-1-串的顺序存储结构">5.5.1 串的顺序存储结构</h3>
<p>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义。<br>
既然是定长数组，就存在一个预定义的最大串长度，一般可以将实际的串长度值保存在数组的0下标位置，有的书中也会定义存储在数组的最后一个下标位置。但也有些编程语言不想这么干，觉得存个数字占个空间麻烦。它规定在串值后面加一个不计入串长度的结束标记字符，比如“\0”来表示串值的终结，这个时候，你要想知道此时的串长度，就需要遍历计算一下才知道了，其实这还是需要占用一个空间，何必呢。</p>
<h3 id="5-5-2-串的链式存储结构">5.5.2 串的链式存储结构</h3>
<p>对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用“#”或其他非串值字符补全，如图5-5-3所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0/5-5-3.JPG?raw=true" srcset="/img/loading.gif" alt="5-5-3"><br>
当然，这里一个结点存多少个字符才合适就变得很重要，这会直接影响着串处理的效率，需要根据实际情况做出选择。<br>
但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。</p>
<h2 id="5-6-朴素的模式匹配算法-暴力算法匹配">5.6 朴素的模式匹配算法(暴力算法匹配)</h2>
<p>子串的定位操作通常称做串的模式匹配，也算是串中最重要的操作之一。<br>
用基本的数组来实现朴素的模式匹配算法。我们假设主串S和要匹配的子串T的长度存在S[0]与T[0]中。实现代码如下：</p>
<pre><code class="language-c">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在,则函数返回值为0。 */
/* 其中,T非空,1≤pos≤StrLength(S)。 */
int Index(String S, String T, int pos)
{
    int i = pos;    /* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */
    int j = 1;                /* j用于子串T中当前位置下标值 */
    while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */
    {
        if (S[i] == T[j])     /* 两字母相等则继续 */
          {
            ++i;
            ++j;
          }
          else                 /* 指针后退重新开始匹配 */
          {  
             i = i-j+2;        /* i退回到上次匹配首位的下一位 */
             j = 1;             /* j退回到子串T的首位 */
          }
    }
    if (j &gt; T[0])
        return i-T[0];
    else
        return 0;
}
</code></pre>
<p>非最坏情况下，只需要匹配2个串的首字母，所以根据等概率原则，平均是(n+m)/2次查找，时间复杂度为O(n+m)。<br>
而最坏情况就是0000000000000000001，此时时间复杂度为O((n-m+1)*m)。</p>
<h2 id="5-7-KMP-模式匹配算法">5.7 KMP 模式匹配算法</h2>
<p>有三位前辈，D.E.Knuth、J.H.Morris 和V.R.Pratt（其中Knuth和Pratt 共同研究，Morris独立研究）发表一个模式匹配算法，可以大大避免重复遍历的情况，我们把它称之为克努特一莫里斯一普拉特算法，简称KMP算法。</p>
<h3 id="5-7-1-KMP模式匹配算法原理">5.7.1 KMP模式匹配算法原理</h3>
<p>首先要理解上面的朴素模式的匹配算法，主串设为S，要匹配的模式串设为T。<br>
对于在子串中有与首字符相等的字符，也是可以省略一部分不必要的判断步骤。<br>
我们在朴素的模式匹配算法中，主串的i值是不断地回溯来完成的。而我们的分析发现，这种回溯其实是可以不需要的，我们的KMP模式匹配算法就是为了让这没必要的回溯不发生。<br>
既然i值不回溯，也就是不可以变小，那么要考虑的变化就是j(j在模式串中所在的位置)值了。通过观察也可发现，我们屡屡提到了T串的首字符与自身后面字符的比较，发现如果有相等字符，j(j在模式串中所在的位置)值的变化就会不相同。也就是说，这个j(j在模式串中所在的位置)值的变化与主串其实没什么关系，关键就取决于T串的结构中是否有重复的问题。<br>
我们可以得出规律，j(j在模式串中所在的位置)值的多少取决于当前字符之前的串的前后缀的相似度。<br>
我们把T串各个位置的j(j在模式串中所在的位置)值的变化定义为一个数组next，那么next的长度就是T串的长度。于是我们可以得到下面的函数定义：<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0/5-7-6.JPG?raw=true" srcset="/img/loading.gif" alt="5-7-6"></p>
<h3 id="5-7-2-next数组值推导">5.7.2 next数组值推导</h3>
<p>&quot;前缀&quot;指除了最后一个字符以外，一个字符串的全部头部组合；<br>
&quot;后缀&quot;指除了第一个字符以外，一个字符串的全部尾部组合。<br>
&quot;部分匹配值&quot;就是&quot;前缀&quot;和&quot;后缀&quot;的最长的共有元素的长度。以&quot;ABCDABD&quot;为例，</p>
<ul>
<li>&quot;A&quot;的前缀和后缀都为空集，共有元素的长度为0；</li>
<li>&quot;AB&quot;的前缀为[A]，后缀为[B]，共有元素的长度为0；</li>
<li>&quot;ABC&quot;的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</li>
<li>&quot;ABCD&quot;的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</li>
<li>“ABCDA&quot;的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为&quot;A”，长度为1；</li>
<li>“ABCDAB&quot;的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为&quot;AB”，长度为2；</li>
<li>&quot;ABCDABD&quot;的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</li>
</ul>
<p>我们可以根据经验得到:如果前缀后缀最长共有元素的长度为1，k值是2，最长的共有元素的长度为2，k值是3。<br>
<strong>最长的共有元素的长度为n，k值就是n+1</strong>。</p>
<h3 id="5-7-3KMP模式匹配算法实现">5.7.3KMP模式匹配算法实现</h3>
<p>next代码如下：</p>
<pre><code class="language-c">/* 通过计算返回子串T的next数组。 */
void get_next(String T, int *next)
{
    int i, j;
    i = 1;
    j = 0;
    next[1] = 0;
    while (i &lt; T[0])  /* 此处T[0]表示串T的长度 */
    {
        if (j == 0 || T[i] == T[j])     /* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */
        {
            ++i;
            ++j;
            next[i] = j;
        }
        else
            j = next[j];    /* 若字符不相同，则j值回溯 */
    }
}
</code></pre>
<p>这段代码的目的就是为了计算出当前要匹配的串T的next数组。</p>
<pre><code class="language-c">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。 */
/*  T非空，1≤pos≤StrLength(S)。 */
int Index_KMP(String S, String T, int pos)
{
    int i = pos;        /* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */
    int j = 1;            /* j用于子串T中当前位置下标值 */
    int next[255];        /* 定义一next数组 */
    get_next(T, next);    /* 对串T作分析，得到next数组 */
    while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */
    {
        if (j == 0 || S[i] == T[j])     /* 两字母相等则继续，与朴素算法增加了j=0判断 */
        {
            ++i;
            ++j;
        }
        else             /* 指针后退重新开始匹配 */
            j = next[j];/* j退回合适的位置，i值不变 */
    }
    if (j &gt; T[0])
        return i - T[0];
    else
        return 0;
}
</code></pre>
<p>对于get_next函数来说，若模式串的长度为m，因只涉及到简单的单循环，其时间复杂度为O(m)，而由于i值的不回溯，使得indexKMP算法效率得到了提高，while 循环的时间复杂度为O(n)。因此，整个算法的时间复杂度为O(n+m)。相较于朴素模式匹配算法的O((n-m+1)*m)来说，是要好一些。</p>
<h3 id="5-7-4-KMP模式匹配算法改进">5.7.4 KMP模式匹配算法改进</h3>
<pre><code class="language-c">/* 求模式串T的next函数修正值并存入数组nextval */
void get_nextval(String T, int *nextval)
{
    int i, j;
    i = 1;
    j = 0;
    nextval[1] = 0;
    while (i &lt; T[0])  /* 此处T[0]表示串T的长度 */
    {
        if (j == 0 || T[i] == T[j])     /* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */
        {
            ++i;
            ++j;
            if (T[i] != T[j])      /* 若当前字符与前缀字符不同 */
                nextval[i] = j;    /* 则当前的j为nextval在i位置的值 */
            else
                nextval[i] = nextval[j];    /* 如果与前缀字符相同，则将前缀字符的 */
                                            /* nextval值赋值给nextval在i位置的值 */
        }
        else
            j = nextval[j];            /* 若字符不相同，则j值回溯 */
    }
}
</code></pre>
<h3 id="5-7-5-nextval-数组值推导">5.7.5 nextval 数组值推导</h3>
<p>总结改进过的KMP算法，它是在计算出next值的同时，如果a位字符与它next值指向的b位字符相等，则该a位的nextval就指向b位的nextval值，如果不等，则该a位的nextval值就是它自己a位的next的值。</p>
<h2 id="5-8-总结回顾">5.8 总结回顾</h2>
<p>这一章节我们重点讲了“串”这样的数据结构，串（string）是由零个或多个字符组成的有限序列，又名叫字符串。本质上，它是一种线性表的扩展，但相对于线性表关注一个个元素来说，我们对串这种结构更多的是关注它子串的应用问题，如查找、替换等操作。现在的高级语言都有针对串的函数可以调用。我们在使用这些函数的时候，同时也应该要理解它当中的原理，以便于在碰到复杂的问题时，可以更加灵活的使用，比如KMP模式匹配算法的学习，就是更有效地去理解index函数当中的实现细节。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo next主题导航栏图标显示问号解决方案</title>
    <url>/2019/12/10/hexo/hexo-next%E4%B8%BB%E9%A2%98%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA%E9%97%AE%E5%8F%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>导航栏图标显示问号，当修改<code>hexo\themes\next\_config.yml</code>主题配置文件后，图标显示正常，但是点击链接不能打开相应主页、标签页、归档页…<br>
经研究，应该把menu下面的不同页面的/后面的空格删掉，即可。<br>
具体配置如下：</p>
<a id="more"></a>
<pre><code class="language-yml">menu:
  home: /|| home                  #主页
  archives: /archives/|| archive  #归档
  categories: /categories/|| th   #分类
  tags: /tags/|| tags             #标签
  about: /about/|| user           #关于我
  #search: /search
  #schedule: /schedule/ || calendar
  #sitemap: /sitemap.xml || sitemap
  #commonweal: /404.html

# Enable/Disable menu icons.
menu_icons:
  enable: true
  # Icon Mapping.
  home: home
  archives: archive
  categories: th
  tags: tags
  about: user
  #commonweal: heartbeat
  #search: search

</code></pre>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 多客户端上更新博客</title>
    <url>/2019/12/09/hexo/hexo%20%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><code>git add source/ &amp;&amp; git commit -m &quot;blog update&quot; &amp;&amp; git push githuborigin hexo &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; exit</code></p>
<h2 id="原理">原理</h2>
<p>静态网页文件存放在<code>master主分支</code>，个人文件存放在<code>hexo分支</code>。</p>
<a id="more"></a>
<h2 id="一、本地电脑设置">一、本地电脑设置</h2>
<p>先新建一个hexo文件夹，在git bash下cd进入hexo文件夹。</p>
<p>1.<code>git init</code></p>
<p>2.<code>git checkout -b hexo</code> //新建hexo分支并切换到hexo</p>
<p>3.将原来博客文件夹里面的<code>_config.yml</code>，<code>theme/</code>，<code>source/</code>，<code>scaffolds/</code>，<code>package.json</code>，<code>.gitignore</code>，共6个文件/文件夹 拷贝到hexo文件夹下面。</p>
<p>需要拷贝的文件如下:</p>
<ul>
<li>_config.yml（站点配置）；</li>
<li>theme文件夹里面的主题；</li>
<li>source文件夹；</li>
<li>scaffolds文件夹（文章的模板）；</li>
<li>package.json（说明使用哪些包）；</li>
<li>.gitignore（限定在提交的时候哪些文件可以忽略）；</li>
<li><strong>注意：不要<code>hexo init</code>去整体初始化，因为需要的文件我们已经拷贝过来了。</strong></li>
</ul>
<p>4.将theme文件夹里面的你的主题文件夹下的.git文件夹删除。</p>
<p>5.<code>git add scaffolds/ source/ themes/ .gitignore _config.yml package.json</code><br>
<code>git commit -m &quot;init&quot;</code></p>
<p>6.<code>git remote add githuborigin git@github.com:你的ID/你的仓库名字</code>  //添加本地hexo和远程仓库的关联</p>
<p>7.登录github，将分支仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为hexo，Update保存。</p>
<p>8.<code>git push githuborigin hexo</code>  //上传更新</p>
<h2 id="二、另外一台电脑上配置">二、另外一台电脑上配置</h2>
<ol>
<li>官网下载安装：</li>
</ol>
<ul>
<li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">安装 Node.js；</a></li>
<li><a href="https://git-scm.com/" target="_blank" rel="noopener">安装 Git。</a></li>
</ul>
<ol start="2">
<li>新建hexo目录，cd进入。</li>
<li><code>git clone https://github.com/你的ID/你的ID.github.io.git</code>  //克隆到本地</li>
<li>将新电脑生成的ssh key添加到gitHub账户上。<br>
需要配置 git。</li>
</ol>
<ul>
<li><code>git config --global user.email &quot;xxx@qq.com&quot;</code> 引号内的xxx@qq.com改为你github注册并且验证的邮箱；</li>
<li><code>git config --global user.name &quot;xxxx&quot;</code>   引号内的xxxx改为你的 github 用户名；</li>
<li><code>ssh-keygen</code> 会出现下面的内容，一直按Enter键就行；</li>
<li>打开用户目录下的 <code>.ssh</code>目录下面生成 <code>id_rsa(私钥)id_rsa.pub(公钥)</code>两个文件，打开<code>id_rsa.pub</code>，复制里面的内容,到 github: <code>Settings -&gt; SSH and GPG keys -&gt; SSH keys -&gt; New SSH key -&gt; (填写)Title -&gt; (粘贴)Key -&gt; Add SSH Key</code>；</li>
<li>测试 <code>ssh -T git@github.com</code>，输出 <strong>You’ve successfully authenticated</strong> 表示添加key 成功。</li>
</ul>
<ol start="5">
<li><code>npm install hexo-cli -g</code> //安装hexo</li>
<li><code>npm install</code> //安装依赖包</li>
</ol>
<ul>
<li>如果出现报错<code>ERROR Try runing: 'npm install hexo --save</code>则执行命令<code>npm install hexo --save</code>，如果没有，则忽略。</li>
</ul>
<ol start="7">
<li><code>git remote remove origin</code> //和origin远程库解除关联</li>
<li><code>git remote add githuborigin git@github.com:你的ID/你的ID.github.io.git</code> //和GitHuborigin库添加关联</li>
</ol>
<h2 id="三、发布博客">三、发布博客</h2>
<ol>
<li>cd进入博客目录</li>
<li><code>git pull githuborigin hexo</code> //保证和分支同步</li>
<li><code>hexo n &quot;新建博客&quot;</code></li>
<li><code>git add source/</code>      //因为博客文件是在source文件夹下面的</li>
<li><code>git commit -m &quot;博客更新&quot;</code></li>
<li><code>git push githuborigin hexo</code>//上传更新</li>
<li><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>//部署博客</li>
</ol>
<p>至此，多终端发布博客已经配置完成。</p>
<h2 id="四、更新主题">四、更新主题</h2>
<p>配置好主题文件后，执行：<br>
<code>git add scaffolds/ source/ themes/ .gitignore _config.yml package.json</code><br>
<code>git commit -m &quot;更新主题&quot;</code><br>
<code>git push githuborigin hexo</code>  //上传更新</p>
<h2 id="五、快速上传部署命令">五、快速上传部署命令</h2>
<p>只更新博客内容，可以从上述第 三 大步第 4 步后可以这样子发布：<br>
<code>git add source/ &amp;&amp; git commit -m &quot;blog update&quot; &amp;&amp; git push githuborigin hexo &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; exit</code><br>
把所有命令用<code>&amp;&amp;</code>串起来，有一个失败就会停止；成功，最后一条命令就会退出终端。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>多客户端</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo配置文件设置</title>
    <url>/2019/12/09/hexo/hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="hexo配置文件设置">hexo配置文件设置</h2>
<p>hexo配置文件<code>_config.yml</code>基本配置</p>
<a id="more"></a>
<pre><code class="language-yml"># Hexo Configuration
## Docs: https://hexo.io/docs/configuration.html
## Source: https://github.com/hexojs/hexo/

# Site 网站
title: closer的个人博客
subtitle: welcome!
description: up up up
keywords:
author: closer
language: zh-CN #语言
timezone: ''

# URL 网址
## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'
url: https://closer_laps.gitee.io/
root: / #根目录位置，如果只是github pages的子目录需要更改
permalink: :year/:month/:day/:title/
permalink_defaults:
pretty_urls:
  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks
  trailing_html: true # Set to false to remove trailing '.html' from permalinks

# Directory #文件结构 默认即可
source_dir: source
public_dir: public
tag_dir: tags
archive_dir: archives
category_dir: categories
code_dir: downloads/code
i18n_dir: lang
skip_render:

# Writing #编辑博文的选项
new_post_name: :title.md # File name of new posts
default_layout: post
auto_spacing: false
titlecase: false # 把标题转换为 title case
external_link:
  enable: true # Open external links in new tab
  field: site # Apply to the whole site
  exclude: ''
filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写 
render_drafts: false #显示草稿
post_asset_folder: false #启动 Asset 文件夹 
relative_link: false #把链接改为与根目录的相对位址 
future: true #显示未来的文章 
highlight:  #代码块的设置 
 enable: false  #开启代码块高亮 
 auto_detect: false #如果未指定语言，则启用自动检测 
 line_number: true #显示行数 
 tab_replace: '' #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs 
 wrap: true
 hljs: false

# Home page setting
# path: Root path for your blogs index page. (default = '')
# per_page: Posts displayed per page. (0 = disable pagination)
# order_by: Posts order. (Order by date descending by default)
index_generator:
  path: ''
  per_page: 10
  order_by: -date

# Category &amp; Tag #分类 &amp; 标签
default_category: uncategorized
category_map:
tag_map:

# Metadata elements
## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta
meta_generator: true

# Date / Time format #日期显示格式
## Hexo uses Moment.js to parse and display date
## You can customize the date format as defined in
## http://momentjs.com/docs/#/displaying/format/
date_format: YYYY-MM-DD #日期格式 
time_format: HH:mm:ss #时间格式
## Use post's date for updated date unless set in front-matter
use_date_for_updated: false

# Pagination #分页器
## Set per_page to 0 to disable pagination
per_page: 10 #每页显示的文章量 (0 = 关闭分页功能) 10
pagination_dir: page #分页目录 

# Include / Exclude file(s)
## include:/exclude: options only apply to the 'source/' folder
include:
exclude:
ignore:

# Extensions #拓展
## Plugins: http://hexo.io/plugins/
## Themes: http://hexo.io/themes/
theme: hexo-theme-next-7.7.0 #主题更换

# Deployment #部署参数
## Docs: http://hexo.io/docs/deployment.html
deploy:
  type: git
  repo:
        github: git@github.com:closer2018/closer2018.github.io.git
        gitee: git@gitee.com:closer_laps/closer_laps.git
        coding: git@e.coding.net:closer2018/closer2018.coding.me.git
  branch: master

# 搜索设置
search:
  path: search.xml
  field: post
  format: html
  limit: 10000

# 发布字数统计
symbols_count_time:
    symbols: true
    time: true
    total_symbols: true
    total_time: true
</code></pre>
<p>以上就是配置文件的基础设置。</p>
<h2 id="更换主题NexT">更换主题NexT</h2>
<p>Hexo安装主题的方式非常简单，只需要将主题文件放置于站点目录的themes下，然后修改下配置文件即可。这里我以NexT主题为例。<br>
在git bash操作下cd至博客根目录，执行如下代码：</p>
<p><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p>
<p>等待下载完成后，修改根目录下_config.yml文件的theme字段为next即可启用NexT主题，十分简单便捷。<br>
其它具体设置可参照<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT官方文档</a>。</p>
<h2 id="安装插件">安装插件</h2>
<p>cd至blog根目录。</p>
<pre><code class="language-yml">npm install hexo-generator-searchdb --save  #搜索插件
npm install --save hexo-generator-feed   #RSS插件
npm install hexo-wordcount --save   #字符统计及阅读时长估计
npm install hexo-generator-sitemap --save  #博客添加网站地图sitemap
npm install hexo-generator-index-pin-top --save   #置顶插件
</code></pre>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo上传部署命令</title>
    <url>/2019/12/01/hexo/hexo%E4%B8%8A%E4%BC%A0%E9%83%A8%E7%BD%B2%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="hexo上传部署三连杀命令-先cd进入git目录">hexo上传部署三连杀命令(先<code>cd</code>进入git目录)</h2>
<pre><code class="language-bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d
</code></pre>
<a id="more"></a>
<h2 id="我们运行测试时，经常用到的有三个命令">我们运行测试时，经常用到的有三个命令</h2>
<pre><code class="language-bash">hexo clean #用来清理缓存文件
hexo g      #生成文件
hexo  d   #上传到服务器
</code></pre>
<h2 id="本地检测时运行">本地检测时运行</h2>
<pre><code class="language-bash">hexo s
</code></pre>
<p>然后打开浏览器，输入localhost:4000，就能看到博客了。<br>
这样说明本地环境搭建完成。</p>
<h2 id="特别感谢B站up主CodeSheep的帮助和细心指导">特别感谢<a href="https://space.bilibili.com/384068749/" target="_blank" rel="noopener">B站up主CodeSheep</a>的帮助和细心指导</h2>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构第三章 线性表</title>
    <url>/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC3%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<p>线性表：零个或多个数据元素的有限序列。</p>
<h2 id="3-1-3-2线性表的定义">3.1-3.2线性表的定义</h2>
<p>线性表（List）：零个或多个数据元素的有限序列。</p>
<p>若将线性表记为（a_1，…，a_(i−1)，a_i，a_(i+1)，…，a_n），则表中a_(i−1) 领先于a_i，a_i 领先于a_(i+1)，称a_(i−1) 是a_i 的直接前驱元素，a_(i+1) 是a_i 的直接后继元素。当i=1，2，…，n-1时，a_i 有且仅有一个直接后继，当i=2，3，…，n时，a_i 有且仅有一个直接前驱。<br>
如图3-2-1所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.2.1.GIF?raw=true" srcset="/img/loading.gif" alt="3-2-1"></p>
<p>所以线性表元素的个数n（n&gt;0）定义为线性表的长度，当n=0时，称为空表。</p>
<a id="more"></a>
<p>在较复杂的线性表中，一个数据元素可以由若干个数据项组成。</p>
<h2 id="3-3线性表的抽象数据类型">3.3线性表的抽象数据类型</h2>
<p>线性表的抽象数据类型定义如下：</p>
<pre><code class="language-c">ADT线性表（List）
Data
    线性表的数据对象集合为{a1，a2…，an），每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
Operation
    InitList（*L）；初始化操作，建立一个空的线性表L。
    ListEmpty（L）；若线性表为空，返回true，否则返回false。
    ClearList（*L）；将线性表清空。
    GetElem（L，i，*e）；将线性表L中的第i个位置元素值返回给e。
    LocateElem（L，e）；在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。
    ListInsert（*L，i，e）；在线性表L中的第i个位置插入新元素e。
    ListDelete（*L，i，*e）；删除线性表L中第i个位置元素，并用e返回其值。
    ListLength（L）；返回线性表L的元素个数。
endADT
</code></pre>
<h3 id="3-3-1两个线性表集合的并集操作">3.3.1两个线性表集合的并集操作</h3>
<p>要使得集合A=AUB。说白了，就是把存在集合B中但并不存在A中的数据元素插入到A中即可。<br>
仔细分析一下这个操作，发现我们只要循环集合B中的每个元素，判断当前元素是否存在A中，若不存在，则插入到A中即可。思路应该是很容易想到的。<br>
我们假设La表示集合A，Lb表示集合B，则实现的代码如下：</p>
<pre><code class="language-c">    /*将所有的在线性表Lb中但不在La中的数据元素插入到La中*/
    void unionL(SqList *La, SqList Lb)
    {
        int La_len, Lb_len, i;
        ElemType e;                          /*声明与La和Lb相同的数据元素e*/
        La_len = ListLength(*La);                /*求线性表的长度*/
        Lb_len = ListLength(Lb);
        for (i = 1; i &lt;= Lb_len; i++)
        {
            GetElem(Lb, i, &amp;e);           /*取Lb中第i个数据元素赋给e*/
            if (!LocateElem(*La, e))           /*La中不存在和e相同数据元素*/
                ListInsert(La, ++La_len, e);          /*插入*/
        }
    }
</code></pre>
<h2 id="3-4线性表的顺序存储结构">3.4线性表的顺序存储结构</h2>
<h3 id="3-4-1顺序存储定义">3.4.1顺序存储定义</h3>
<p>线性表的两种物理结构的第一种——顺序存储结构。<br>
线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p>
<h3 id="3-4-2顺序存储方式">3.4.2顺序存储方式</h3>
<p>可以用C语言（其他语言也相同）的一维数组来实现顺序存储结构。<br>
线性表的顺序存储的结构代码如下</p>
<pre><code class="language-c">    #define MAXSIZE 20/*存储空间初始分配量*/
    typedef int ElemType;  /*ElemType 类型根据实际情况而定，这里假设为int*/
    typedef struct
    {
        ElemType data[MAXSIZE];/*数组存储数据元素，最大值为MAXSIZE*/
        int length;  /*线性表当前长度*/
    }SqList;
</code></pre>
<p>这里，我们就发现描述顺序存储结构需要三个属性：<br>
• 存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。<br>
• 线性表的最大存储容量：数组长度MaxSize。<br>
• 线性表的当前长度：length。</p>
<h3 id="3-4-3数据长度与线性表长度区别">3.4.3数据长度与线性表长度区别</h3>
<p>数组的长度是存放线性表的存储空间的长度，存储分配后这个量是一般是不变的。<br>
线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。<br>
在任意时刻，线性表的长度应该小于等于数组的长度。</p>
<h3 id="3-4-4地址计算方法">3.4.4地址计算方法</h3>
<p>存储器中的每个存储单元都有自己的编号，这个编号称为地址。<br>
假设占用的是c个存储单元，那么线性表中第i+1个数据元素的存储位置和第i个数据元素的存储位置满足下列关系（LOC表示获得存储位置的函数）。<br>
LOC（a_(i+1)）=LOC（a_i）+c<br>
所以对于第i个数据元素ai的存储位置可以由a1推算得出：<br>
LOC（a_i）=LOC（a_1）+（i-1）*c</p>
<h2 id="3-5顺序存储结构的插入与删除">3.5顺序存储结构的插入与删除</h2>
<h3 id="3-5-1获得元素操作">3.5.1获得元素操作</h3>
<p>我们要实现GetElem操作，即将线性表L中的第i个位置元素值返回。只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。</p>
<pre><code class="language-c">    #define OK 1
    #define ERROR 0
    #define TRUE 1
    #define FALSE 0
    typedef int Status;          /* Status是函数的类型,其值是函数结果状态代码，如OK等 */
    /* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
    /* 操作结果：用e返回L中第i个数据元素的值,注意i是指位置，第1个位置的数组是从0开始 */
    Status GetElem(SqList L, int i, ElemType *e)
    {
        if (L.length == 0 || i&lt;1 || i&gt;L.length)
            return ERROR;
        *e = L.data[i - 1];
        return OK;
    }
</code></pre>
<h3 id="3-5-2插入操作">3.5.2插入操作</h3>
<p>插入算法的思路：<br>
• 如果插入位置不合理，抛出异常；<br>
• 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；<br>
• 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；<br>
• 将要插入元素填入位置i处；<br>
• 表长加1。<br>
实现代码如下：</p>
<pre><code class="language-c">    /* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */
    /* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */
    Status ListInsert(SqList *L, int i, ElemType e)
    {
        int k;
        if (L-&gt;length == MAXSIZE)  /* 顺序线性表已经满 */
            return ERROR;
        if (i&lt;1 || i&gt;L-&gt;length + 1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */
            return ERROR;
        if (i &lt;= L-&gt;length)        /* 若插入数据位置不在表尾 */
        {
            for (k = L-&gt;length - 1; k &gt;= i - 1; k--)  /* 将要插入位置之后的数据元素向后移动一位 */
                L-&gt;data[k + 1] = L-&gt;data[k];
        }
        L-&gt;data[i - 1] = e;          /* 将新元素插入 */
        L-&gt;length++;
        return OK;
    }
</code></pre>
<h3 id="3-5-3删除操作">3.5.3删除操作</h3>
<p>删除算法的思路：<br>
• 如果删除位置不合理，抛出异常；<br>
• 取出删除元素；<br>
• 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；<br>
• 表长减1。<br>
实现代码如下：</p>
<pre><code class="language-c">    /* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
    /* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */
    Status ListDelete(SqList *L, int i, ElemType *e)
    {
        int k;
        if (L-&gt;length == 0)               /* 线性表为空 */
            return ERROR;
        if (i&lt;1 || i&gt;L-&gt;length)         /* 删除位置不正确 */
            return ERROR;
        *e = L-&gt;data[i - 1];
        if (i &lt; L-&gt;length)                /* 如果删除不是最后位置 */
        {
            for (k = i; k &lt; L-&gt;length; k++)/* 将删除位置后继元素前移 */
                L-&gt;data[k - 1] = L-&gt;data[k];
        }
        L-&gt;length--;
        return OK;
    }
</code></pre>
<p>线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O（1）；而插入或删除时，时间复杂度都是O（n）。</p>
<h3 id="3-5-4线性表顺序存储结构的优缺点">3.5.4线性表顺序存储结构的优缺点</h3>
<p>线性表的顺序存储结构的优缺点如图3-5-3所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.5.3.GIF?raw=true" srcset="/img/loading.gif" alt="3-5-3"></p>
<h3 id="3-6线性表的链式存储结构">3.6线性表的链式存储结构</h3>
<h3 id="3-6-2线性表链式存储结构定义">3.6.2线性表链式存储结构定义</h3>
<p>为了表示每个数据元素a_i 与其直接后继数据元素a_(i+1) 之间的逻辑关系，对数据元素a1来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素a_i 的存储映像，称为结点（Node）。<br>
n个结点（a_i 的存储映像）链结成一个链表，即为线性表（a_1，a_2，…，a_n）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。<br>
我们把链表中第一个结点的存储位置叫做头指针,线性链表的最后一个结点指针为“空”（通常用NULL或“^”符号表示）。<br>
有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息。</p>
<h3 id="3-6-3头指针与头结点的异同">3.6.3头指针与头结点的异同</h3>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.6.3.GIF?raw=true" srcset="/img/loading.gif" alt="3-6-3"></p>
<h3 id="3-6-4线性表链式存储结构代码描述">3.6.4线性表链式存储结构代码描述</h3>
<pre><code class="language-c">//线性表的单链表存储结构
typedef struct Node
{
    ElemType data;
    struct Node *next;
}Node;
typedef struct Node *LinkList;/* 定义LinkList */
</code></pre>
<p>节点Node是由存放数据元素的数据域和存放后继节点地址的指针域组成。</p>
<h2 id="3-7单链表的读取">3.7单链表的读取</h2>
<p>获得链表第i个的数据的算法思路：</p>
<ol>
<li>声明一个结点p指向链表第一个结点，初始化j从1开始;</li>
<li>当<code>j&lt;i</code>时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1;</li>
<li>若到链表末尾p为空，则说明第i个元素不存在;</li>
<li>否则查找成功，返回结点p的数据。</li>
</ol>
<p>实现代码算法如下：</p>
<pre><code class="language-c">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
/* 操作结果：用e返回L中第i个数据元素的值 */
Status GetElem(LinkList L,int i,ElemType *e)
{
    int j;
    LinkList p;  /* 声明一结点p */
    p = L-&gt;next;  /* 让p指向链表L的第一个结点 */
    j = 1;        /*  j为计数器 */
    while (p &amp;&amp; j&lt;i)  /* p不为空或者计数器j还没有等于i时，循环继续 */
    {
        p = p-&gt;next;  /* 让p指向下一个结点 */
        ++j;
    }
    if ( !p || j&gt;i )
        return ERROR;  /*  第i个元素不存在 */
    *e = p-&gt;data;   /*  取第i个元素的数据 */
    return OK;
}
</code></pre>
<p>这个算法的最坏情况时间复杂度为O(n)。</p>
<h2 id="3-8-单链表的插入和删除">3.8 单链表的插入和删除</h2>
<h3 id="3-8-1-单链表的插入">3.8.1 单链表的插入</h3>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.8.1.GIF?raw=true" srcset="/img/loading.gif" alt="图3-8-1"><br>
假设上一个结点是p，下一个结点是p-&gt;next,现在要把结点s插入这两个结点中去。只需要2行代码：<br>
<code>s-&gt;next=p-&gt;next;//先让s的指针域指向p-&gt;next</code><br>
<code>p-&gt;next=s;//把s的地址赋给p的指针域</code></p>
<p>ps:这两句顺序不能交换。<br>
如果先<code>p-&gt;next=s</code>;再<code>s-&gt;next=p-&gt;next</code>;就等于<code>s-&gt;next=s</code>;<br>
所以这2句如论如何都不能反，这点初学者一定要注意。</p>
<p>单链表第i个数据插入结点的算法思路：</p>
<ol>
<li>声明一结点p指向链表第一个结点，初始化j从1开始;</li>
<li>当j&lt;1时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1;</li>
<li>若到链表末尾p为空，则说明第i个元素不存在;</li>
<li>否则查找成功，在系统中生成一个空结点s;</li>
<li>将数据元素e赋值给<code>s-&gt;data</code>;</li>
<li>单链表的插入标准语句<code>s-&gt;next=p-&gt;next;p-&gt;next=s;</code>;</li>
<li>返回成功;</li>
</ol>
<p>实现代码算法如下:</p>
<pre><code class="language-c">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */
/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */
Status ListInsert(LinkList *L,int i,ElemType e)
{
    int j;
    LinkList p,s;
    p = *L;
    j = 1;
    while (p &amp;&amp; j &lt; i)     /* 寻找第i个结点 */
    {
        p = p-&gt;next;
        ++j;
    }
    if (!p || j &gt; i)
        return ERROR;   /* 第i个元素不存在 */
    s = (LinkList)malloc(sizeof(Node));  /*  生成新结点(C语言标准函数) */
    s-&gt;data = e;  
    s-&gt;next = p-&gt;next;      /* 将p的后继结点赋值给s的后继  */
    p-&gt;next = s;          /* 将s赋值给p的后继 */
    return OK;
}
</code></pre>
<h3 id="3-8-2-单链表的删除">3.8.2 单链表的删除</h3>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.8.5.GIF?raw=true" srcset="/img/loading.gif" alt="3-8-5"><br>
要删除节点q，其实就是要让<code>p-&gt;next=q-&gt;next</code>;<br>
单链表第i个数据删除结点的算法思路：</p>
<ol>
<li>声明一结点p指向链表第一个结点，初始化j从1开始</li>
<li>当<code>j&lt;i</code>时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；</li>
<li>若到链表末尾p为空，则说明第i个元素不存在；</li>
<li>否则查找成功，将欲删除的结点<code>p-&gt;next</code>赋值给q；</li>
<li>单链表的删除标准语句<code>p-&gt;next=q-&gt;next</code>；</li>
<li>将q结点中的数据赋值给e，作为返回；</li>
<li>释放q结点；</li>
<li>返回成功。</li>
</ol>
<p>实现代码算法如下：</p>
<pre><code class="language-c">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */
Status ListDelete(LinkList *L,int i,ElemType *e)
{
    int j;
    LinkList p,q;
    p = *L;
    j = 1;
    while (p-&gt;next &amp;&amp; j &lt; i)    /* 遍历寻找第i个元素 */
    {
        p = p-&gt;next;
        ++j;
    }
    if (!(p-&gt;next) || j &gt; i)
        return ERROR;           /* 第i个元素不存在 */
    q = p-&gt;next;              //q结点指向要删除的结点（即要删除的结点地址赋值给q）
    p-&gt;next = q-&gt;next;            /* 将q的后继(第三个结点)赋值给p的后继 */
    *e = q-&gt;data;               /* 将q结点中的数据给e */
    free(q);                    /* 让系统回收此结点，释放内存 */
    return OK;
}
</code></pre>
<p>分析一下刚才我们讲解的单链表插入和删除算法，我们很容易推导出：它们的时间复杂度都是O（n）。<br>
显然，对于<strong>插入或删除数据越频繁的操作，单链表的效率优势就越是明显</strong>。</p>
<h2 id="3-9单链表的整表创建">3.9单链表的整表创建</h2>
<p>单链表整表创建的算法思路：</p>
<ol>
<li>声明一结点p和计数器变量i；</li>
<li>初始化一空链表L；</li>
<li>让L的头结点的指针指向NULL，即建立一个带头结点的单链表；</li>
<li>循环：
<ul>
<li>生成一新结点赋值给p；</li>
<li>随机生成一数字赋值给p的数据域p&gt;data；</li>
<li>将p插入到头结点与前一新结点之间。</li>
</ul>
</li>
</ol>
<p>实现头插法的代码算法如下(这段算法代码里,我们用插队的办法，始终让新结点在第一的位置。这种算法简称为头插法)：</p>
<pre><code class="language-c">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */
void CreateListHead(LinkList *L, int n)
{
    LinkList p;
    int i;
    srand(time(0));                         /* 初始化随机数种子 */
    *L = (LinkList)malloc(sizeof(Node));
    (*L)-&gt;next = NULL;                      /*  先建立一个带头结点的单链表 */
    for (i=0; i&lt;n; i++)
    {
        p = (LinkList)malloc(sizeof(Node)); /*  生成新结点 */
        p-&gt;data = rand()%100+1;             /*  随机生成100以内的数字 */
        p-&gt;next = (*L)-&gt;next;
        (*L)-&gt;next = p;                        /*  插入到表头 */
    }
}
</code></pre>
<p>事实上，我们一般插队都是放在最后的。如果我们把每次的新结点都插在终端结点的后面，这种算法称之为尾插法。</p>
<p>实现尾插法代码算法如下：</p>
<pre><code class="language-c">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */
void CreateListTail(LinkList *L, int n)
{
    LinkList p,r;
    int i;
    srand(time(0));                      /* 初始化随机数种子 */
    *L = (LinkList)malloc(sizeof(Node)); /* L为整个线性表 */
    r=*L;                                /* r为指向尾部的结点 */
    for (i=0; i&lt;n; i++)
    {
        p = (Node *)malloc(sizeof(Node)); /*  生成新结点 */
        p-&gt;data = rand()%100+1;           /*  随机生成100以内的数字 */
        r-&gt;next=p;                        /* 将表尾终端结点的指针指向新结点 */
        r = p;                            /* 将当前的新结点定义为表尾终端结点 */
    }
    r-&gt;next = NULL;                       /* 表示当前链表结束 */
}
</code></pre>
<p>PS：这里需解释一下，<code>r-&gt;next=p</code>的意思，其实就是将刚才的表尾终端结点r的指针指向新结点p，如图3-9-2所示，当中①位置的连线就是表示这个意思。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.9.2.GIF?raw=true" srcset="/img/loading.gif" alt="3-9-2"><br>
<code>r=p</code>的意思请看图3-9-3，就是本来r是a_(i-1)元素的结点，现在它已经不是最后的结点了，现在最后的结点是a_i，所以应该将p结点这个最后的结点赋值给r。此时r又是最终的尾结点了。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.9.3.GIF?raw=true" srcset="/img/loading.gif" alt="3-9-3"></p>
<p>循环结束后，那么应该让这个链表的指针域置空，因此有了<code>r-&gt;next=NULL</code>，以便以后遍历时可以确认其是尾部。</p>
<h2 id="3-10单链表的整表删除">3.10单链表的整表删除</h2>
<p>单链表整表删除的算法思路如下：</p>
<ol>
<li>声明一结点p和q；</li>
<li>将第一个结点赋值给p；</li>
<li>循环：
<ul>
<li>将下一结点赋值给q；</li>
<li>释放p；将q赋值给p。</li>
</ul>
</li>
</ol>
<p>实现代码算法如下：</p>
<pre><code class="language-c">/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */
Status ClearList(LinkList *L)
{
    LinkList p,q;
    p=(*L)-&gt;next;           /*  p指向第一个结点 */
    while(p)                /*  没到表尾 */
    {
        q=p-&gt;next;   //下一个结点地址赋值给临时结点q
        free(p);     //释放p结点内存
        p=q;         //临时结点q的地址赋值给p，使p能够指向继续指向下一个结点
    }
    (*L)-&gt;next=NULL;        /* 头结点指针域为空 */
    return OK;
}
</code></pre>
<h2 id="3-11单链表结构与顺序存储结构优缺点">3.11单链表结构与顺序存储结构优缺点</h2>
<p>简单地对单链表结构和顺序存储结构做对比,如图3-11-1：<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.11.1.GIF?raw=true" srcset="/img/loading.gif" alt="3-11-1"></p>
<p>通过上面的对比，我们可以得出一些经验性的结论：</p>
<ul>
<li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。</li>
<li>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。</li>
</ul>
<p>总之，线性表的顺序存储结构和单链表结构各有其优缺点，不能简单的说哪个好，哪个不好，需要根据实际情况，来综合平衡采用哪种数据结构更能满足和达到需求和性能。</p>
<h2 id="3-12静态链表">3.12静态链表</h2>
<p>静态链表是由数组组成。<br>
我们让数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下标都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而游标cur相当于单链表中的next 指针，存放该元素的后继在数组中的下标。<br>
我们把这种用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。<br>
静态链表的结构定义如下：</p>
<pre><code class="language-c">/* 线性表的静态链表存储结构 */
typedef struct
{
    ElemType data;
    int cur;  /* 游标(Cursor) ，为0时表示无指向 */
} Component,StaticLinkList[MAXSIZE];
</code></pre>
<p>另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据。我们通常把未被使用的数组元素称为备用链表。而数组第一个元素，即<strong>下标为0的元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标</strong>，相当于单链表中的头结点作用，当整个链表为空时，则为0。如图3-12-1所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.12.1.GIF?raw=true" srcset="/img/loading.gif" alt="3-12-1"></p>
<p>初始化数组状态，代码如下：</p>
<pre><code class="language-c">/* 将一维数组space中各分量链成一个备用链表，space[0].cur为头指针，&quot;0&quot;表示空指针 */
Status InitList(StaticLinkList space)
{
    int i;
    for (i=0; i&lt;MAXSIZE-1; i++)  
        space[i].cur = i+1;
    space[MAXSIZE-1].cur = 0; /* 目前静态链表为空，最后一个元素的cur为0 */
    return OK;
}
</code></pre>
<h3 id="3-12-1静态链表的插入操作">3.12.1静态链表的插入操作</h3>
<p>在静态链表中，需要我们自己实现结点的申请和释放这2个函数，才可以做插入和删除的操作。<br>
为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。</p>
<pre><code class="language-c">/* 若备用空间链表非空，则返回分配的结点下标，否则返回0 */
int Malloc_SSL(StaticLinkList space)
{
    int i = space[0].cur;                   /* 当前数组第一个元素的cur存的值 */
                                            /* 就是要返回的第一个备用空闲的下标 */
    if (space[0]. cur)
        space[0]. cur = space[i].cur;       /* 由于要拿出一个分量来使用了， */
                               ll             /* 所以我们就得把它的下一个 */
                                            /* 分量用来做备用 */
    return i;
}
</code></pre>
<p>这段代码有意思，它的作用就是返回一个下标值，这个值就是数组头元素的cur存的第一个空闲的下标,同时把这个空闲的下标给<code>space[0].cur</code>，之后就可以继续分配新的空闲分量，实现类似mallbc（）函数的作用。<br>
插入操作的实现代码如下：</p>
<pre><code class="language-c">/*  在L中第i个元素之前插入新的数据元素e   */
Status ListInsert(StaticLinkList L, int i, ElemType e)
{  
    int j, k, l;
    k = MAXSIZE - 1;   /* 注意k首先是最后一个元素的下标 */
    if (i &lt; 1 || i &gt; ListLength(L) + 1)
        return ERROR;
    j = Malloc_SSL(L);   /* 获得空闲分量的下标 */
    if (j)
    {
        L[j].data = e;   /* 将数据赋值给此分量的data */
        for(l = 1; l &lt;= i - 1; l++)   /* 找到第i个元素之前的位置 */
           k = L[k].cur;
        L[j].cur = L[k].cur;    /* 把第i个元素之前的cur赋值给新元素的cur */
        L[k].cur = j;           /* 把新元素的下标赋值给第i个元素之前元素的ur */
        return OK;
    }
    return ERROR;
}
</code></pre>
<h3 id="3-12-2静态链表的删除操作">3.12.2静态链表的删除操作</h3>
<p>删除元素时，实现的代码如下：</p>
<pre><code class="language-c">/*  删除在L中第i个数据元素   */
Status ListDelete(StaticLinkList L, int i)
{
    int j, k;
    if (i &lt; 1 || i &gt; ListLength(L))
        return ERROR;
    k = MAXSIZE - 1;
    for (j = 1; j &lt;= i - 1; j++)
        k = L[k].cur;
    j = L[k].cur;
    L[k].cur = L[j].cur;
    Free_SSL(L, j);
    return OK;
}
</code></pre>
<p>释放结点的函数代码如下：</p>
<pre><code class="language-c">/*  将下标为k的空闲结点回收到备用链表 */
void Free_SSL(StaticLinkList space, int k)
{  
    space[k].cur = space[0].cur;    /* 把第一个元素的cur值赋给要删除的分量cur */
    space[0].cur = k;               /* 把要删除的分量下标赋值给第一个元素的cur */
}
</code></pre>
<p>返回静态链表长度的代码实现如下：</p>
<pre><code class="language-c">/* 初始条件：静态链表L已存在。操作结果：返回L中数据元素个数 */
int ListLength(StaticLinkList L)
{
    int j=0;
    int i=L[MAXSIZE-1].cur;
    while(i)
    {
        i=L[i].cur;
        j++;
    }
    return j;
}
</code></pre>
<h3 id="3-12-3静态链表优缺点">3.12.3静态链表优缺点</h3>
<p>总结一下静态链表的优缺点（见图3-12-5）：<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.12.5.GIF?raw=true" srcset="/img/loading.gif" alt="3-12-5"><br>
总的来说，静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。尽管大家不一定会用得上，但这样的思考方式是非常巧妙的，应该理解其思想，以备不时之需。</p>
<h2 id="3-13循环链表">3.13循环链表</h2>
<p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。<br>
其实循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断<code>p-&gt;next</code>是否为空，现在则是<code>p-&gt;next</code>不等于头结点，则循环未结束。<br>
在单链表中，我们有了头结点时，我们可以用O（1）的时间访问第一个结点，但如果想要用O（1）的时间访问到最后一个结点，则需要改造一下这个循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表（如图3-13-5）。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.5.GIF?raw=true" srcset="/img/loading.gif" alt="3-13-5"><br>
从上图可以看出，终端结点用尾指针rear指示，则查找终端结点是O（1），而开始结点，其实就是<code>rear-&gt;next-&gt;next</code>，其时间复杂也为O（1）。<br>
举个程序的例子，要将两个循环链表合并成一个表时，有了尾指针就非常简单了。比如下面的这两个循环链表，它们的尾指针分别是rearA和rearB，如图3-13-6所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.6.GIF?raw=true" srcset="/img/loading.gif" alt="3-13-6"><br>
要想把它们合并，只需要如下的操作即可，如图3-13-7所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.7.GIF?raw=true" srcset="/img/loading.gif" alt="3-13-7"><br>
具体代码如下：</p>
<pre><code class="language-c">p=rearA-&gt;next;     /*保存A表的头结点，即①*/
rearA-&gt;next=rearB-&gt;next-&gt;next;     /*将本是指向B表的第一个结点（不是头结点）赋值给reaA-&gt;next,即②*/
rearB-&gt;next=p;/*将原A表的头结点赋值给rearB-&gt;next，即③**/
free(p);/*释放p*/
</code></pre>
<h2 id="3-14双向链表">3.14双向链表</h2>
<p>双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。<br>
所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p>
<pre><code class="language-c">/*线性表的双向链表存储结构*/
typedef struct DulNode
{
    ElemType data；
    struct DuLNode *prior；/*直接前驱指针*/
    struct DuLNode *next；/*直接后继指针*/
}DulNode，*DuLinkList；
</code></pre>
<p>既然单链表也可以有循环链表，那么双向链表当然也可以是循环表。<br>
双向链表的循环带头结点的空链表如图3-14-3所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.3.GIF?raw=true" srcset="/img/loading.gif" alt="3-14-3"><br>
非空的循环的带头结点的双向链表如图3-14-4所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.4.GIF?raw=true" srcset="/img/loading.gif" alt="3-14-4"><br>
PS：双向链表在插入和删除时，需要更改两个指针变量。<br>
插入操作时，其实并不复杂，不过<strong>顺序很重要，千万不能写反了</strong>。<br>
我们现在假设存储元素e的结点为s，要实现将结点s插入到结点p和<code>p-&gt;next</code>之间需要下面几步，如图3-14-5所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.5.GIF?raw=true" srcset="/img/loading.gif" alt="3-14-5"></p>
<pre><code class="language-c">s-&gt;prior=p;/*把p赋值给s的前驱，如图中①*/
s-&gt;next=p-&gt;next;/*把p-&gt;next赋值给s的后继，如图中②*/
p-&gt;next-&gt;prior=s;/*把s赋值给p-&gt;next的前驱，如图中③*/
p-&gt;next=s;/*把s赋值给p的后继，如图中④*/
</code></pre>
<p>关键在于它们的顺序，由于第2步和第3步都用到了<code>p-&gt;next</code>。如果第4步先执行，则会使得<code>p-&gt;next</code>提前变成了s，使得插入的工作完不成。所以我们不妨把上面这张图在理解的基础上记忆，顺序是先搞定s的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。</p>
<p>若要删除结点p，只需要下面两步骤，如图3-14-6所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.6.GIF?raw=true" srcset="/img/loading.gif" alt="3-14-6"></p>
<pre><code class="language-c">p-&gt;prior-&gt;next=p-&gt;next；/*把p-&gt;next赋值给p-&gt;prior的后继，如图中①*/
p-&gt;next-&gt;prior=p-&gt;prior；/*把p-&gt;prior 赋值给p-&gt;next的前驱，如图中②*/
free（p）；/*释放结点*/
</code></pre>
<h2 id="3-15总结回顾">3.15总结回顾</h2>
<p>这一章，主要讲的是线性表。<br>
先谈了它的定义，线性表是零个或多个具有相同类型的数据元素的有限序列。然后谈了线性表的抽象数据类型，如它的一些基本操作。<br>
之后我们就线性表的两大结构做了讲述，先讲的是比较容易的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。通常我们都是用数组来实现这一结构。<br>
后来是我们的重点，由顺序存储结构的插入和删除操作不方便，引出了链式存储结构。它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。然后我们分别就链式存储结构的不同形式，如单链表、循环链表和双向链表做了讲解，另外我们还讲了若不使用指针如何处理链表结构的静态链表方法。<br>
总的来说，线性表的这两种结构（如图3-15-1所示）是后面其他数据结构的基础，把它们学明白了，对后面的学习有着至关重要的作用。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.15.1.GIF?raw=true" srcset="/img/loading.gif" alt="3-15-1"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构第四章 栈与队列</title>
    <url>/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC4%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="4-1-4-2-栈的定义">4.1-4.2 栈的定义</h2>
<h3 id="4-2-1-栈的定义">4.2.1 栈的定义</h3>
<p><strong>栈是限定仅在表尾进行插入和删除操作的线性表。</strong><br>
我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简尔LIFO结构。<br>
它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。<br>
栈的插入操作，叫作进栈，也称压栈、入栈(push)。</p>
<a id="more"></a>
<p>栈的删除操作，叫作出栈，也有的叫作弹栈(pop)。</p>
<h2 id="4-3-栈的抽象数据类型">4.3 栈的抽象数据类型</h2>
<pre><code class="language-c">ADT 栈(stack)
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
    InitStack(*s)：初始化操作，建立一个空栈s。
    DestroyStack(*s)：若楼存在，则销毁它。
    ClearStack(*s)：将栽清空。
    StackEmpty(S)：若为空，返回true，否则返回false。
    GetTop(s，*e)：若栽存在且非空，用e返回s的栽顶元素。
    Push(*s，e)：若栈S存在，插入新元素e到栈S中并成为栈顶元素。
    Pop(*S，*e)：删除栈S中栈顶元素，并用e返回其值。
    StackLength(s)：返回栈s的元素个数。
endADT
</code></pre>
<h2 id="4-4-栈的顺序存储结构及实现">4.4 栈的顺序存储结构及实现</h2>
<h3 id="4-4-1-栈的顺序存储结构">4.4.1 栈的顺序存储结构</h3>
<p>栈是线性表的特例，那么栈的顺序存储其实也是线性表顺序存储的简化，我们简称为顺序栈。线性表是用数组来实现的。<br>
我们定义一个top变量来指示栈顶元素在数组中的位置，它可以来回移动，意味着栈顶的top可以变大变小，但无论如何游标不能超出栈的长度。同理，若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判定条件定为top等于-1。</p>
<p>栈的结构定义：</p>
<pre><code class="language-c">typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */
/* 顺序栈结构 */
typedef struct
{
        SElemType data[MAXSIZE];
        int top; /* 用于栈顶指针 */
}SqStack;
</code></pre>
<p>若现在有一个栈，StackSize是5，则栈普通情况、空栈和栈满的情况示意图如图4-4-2所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-4-2.JPG?raw=true" srcset="/img/loading.gif" alt="4-4-2"></p>
<h3 id="4-4-2-栈的顺序存储结构——进栈操作">4.4.2 栈的顺序存储结构——进栈操作</h3>
<p>对于栈的插入，即进栈操作，其实就是在栈顶插入一个元素。<br>
进栈操作push，其代码如下：</p>
<pre><code class="language-c">/* 插入元素e为新的栈顶元素 */
Status Push(SqStack *S,SElemType e)
{
        if(S-&gt;top == MAXSIZE -1) /* 栈满 */
        {
            return ERROR;
        }
        S-&gt;top++;   /* 栈顶指针增加一 */
        S-&gt;data[S-&gt;top]=e;  /* 将新插入元素赋值给栈顶空间 */
        return OK;
}
</code></pre>
<h3 id="4-4-3-栈的顺序存储结构——出栈操作">4.4.3 栈的顺序存储结构——出栈操作</h3>
<p>出栈操作pop，代码如下：</p>
<pre><code class="language-c">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */
Status Pop(SqStack *S,SElemType *e)
{
        if(S-&gt;top==-1)
                return ERROR;
        *e=S-&gt;data[S-&gt;top]; /* 将要删除的栈顶元素赋值给e */
        S-&gt;top--;   /* 栈顶指针减一 */
        return OK;
}
</code></pre>
<p>两者没有涉及到任何循环语句，因此时间复杂度均是O(1)。</p>
<h2 id="4-5-两栈共享空间">4.5 两栈共享空间</h2>
<p>如果我们有两个相同类型的栈，我们为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。这又何必呢？我们完全可以用一个数组来存储两个栈，只不过需要点小技巧。<br>
数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为栈的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。<br>
其实关键思路是：它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。<br>
从这里也就可以分析出来，栈1为空时，就是top1等于-1时；而当top2等于n时，即是栈2为空时，那什么时候栈满呢？<br>
想想极端的情况，若栈2是空栈，栈1的top1等于n-1时，就是栈1满了。反之，当栈1为空栈时，top2等于0时，为栈2满。但更多的情况，其实就是我刚才说的，两个栈见面之时，也就是两个指针之间相差1时，即top1+1==top2为栈满。<br>
两栈共享空间的结构的代码如下：</p>
<pre><code class="language-c">/* 两栈共享空间结构 */
typedef struct
{
    SElemType data[MAXSIZE];
    int top1;    /* 栈1栈顶指针 */
    int top2;    /* 栈2栈顶指针 */
}SqDoubleStack;
</code></pre>
<p>对于两栈共享空间的push方法，我们除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber。插入元素的代码如下：</p>
<pre><code class="language-c">/* 插入元素e为新的栈顶元素 */
Status Push(SqDoubleStack *S, SElemType e, int stackNumber)
{
    if (S-&gt;top1 + 1 == S-&gt;top2)    /* 栈已满，不能再push新元素了 */
        return ERROR;
    if (stackNumber == 1)            /* 栈1有元素进栈 */
        S-&gt;data[++S-&gt;top1] = e; /* 若是栈1则先top1+1后给数组元素赋值。 */
    else if (stackNumber == 2)    /* 栈2有元素进栈 */
        S-&gt;data[--S-&gt;top2] = e; /* 若是栈2则先top2-1后给数组元素赋值。 */
    return OK;
}
</code></pre>
<p>因为在开始已经判断了是否有栈满的情况，所以后面的top1+1或top2-1是不担心溢出问题的。<br>
对于两栈共享空间的pop方法，参数就只是判断栈1栈2的参数stackNumber，代码如下：</p>
<pre><code class="language-c">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */
Status Pop(SqDoubleStack *S, SElemType *e, int stackNumber)
{
    if (stackNumber == 1)
    {
        if (S-&gt;top1 == -1)
            return ERROR; /* 说明栈1已经是空栈，溢出 */
        *e = S-&gt;data[S-&gt;top1--]; /* 将栈1的栈顶元素出栈 */
    }
    else if (stackNumber == 2)
    {
        if (S-&gt;top2 == MAXSIZE)
            return ERROR; /* 说明栈2已经是空栈，溢出 */
        *e = S-&gt;data[S-&gt;top2++]; /* 将栈2的栈顶元素出栈 */
    }
    return OK;
}
</code></pre>
<p>事实上，使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。就像买卖股票一样，你买入时，一定是有一个你不知道的人在做卖出操作。有人赚钱，就一定是有人赔钱。这样使用两栈共享空间存储方法才有比较大的意义。否则两个栈都在不停地增长，那很快就会因栈满而溢出了。</p>
<h2 id="4-6-栈的链式存储结构及实现">4.6 栈的链式存储结构及实现</h2>
<h3 id="4-6-1-栈的链式存储结构">4.6.1 栈的链式存储结构</h3>
<p>栈的链式存储结构，简称为链栈。<br>
链栈的结构代码如下：</p>
<pre><code class="language-c">/* 链栈结构 */
typedef struct StackNode
{
    SElemType data;
    struct StackNode *next;
}StackNode,*LinkStackPtr;

typedef struct LinkStack
{
    LinkStackPtr top;
    int count;
}LinkStack;
</code></pre>
<h3 id="4-6-2-栈的链式存储结构-进栈操作">4.6.2 栈的链式存储结构-进栈操作</h3>
<p>对于链栈的进栈push操作，假设元素值为e的新结点是s，top为栈顶指针，示意图如图4-6-2所示代码如下。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-6-2.JPG?raw=true" srcset="/img/loading.gif" alt="4-6-2"></p>
<pre><code class="language-c">/* 插入元素e为新的栈顶元素 */
Status Push(LinkStack *S,SElemType e)
{
    LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode));
    s-&gt;data=e;
    s-&gt;next=S-&gt;top;/* 把当前的栈顶元素赋值给新结点的直接后继，见图中① */
    S-&gt;top=s;         /* 将新的结点s赋值给栈顶指针，见图中② */
    S-&gt;count++;
    return OK;
}
</code></pre>
<h3 id="4-6-3-栈的链式存储结构——出栈操作">4.6.3 栈的链式存储结构——出栈操作</h3>
<p>至于链栈的出栈pop操作，也是很简单的三句操作。假设变量p用来存储要删除的栈顶结点，将栈顶指针下移一位，最后释放p即可，如图4-6-3所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-6-3.JPG?raw=true" srcset="/img/loading.gif" alt="4-6-3"></p>
<pre><code class="language-c">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */
Status Pop(LinkStack *S,SElemType *e)
{
        LinkStackPtr p;
        if(StackEmpty(*S))
                return ERROR;
        *e=S-&gt;top-&gt;data;
        p=S-&gt;top;               /* 将栈顶结点赋值给p，见图中③ */
        S-&gt;top=S-&gt;top-&gt;next;    /* 使得栈顶指针下移一位，指向后一结点，见图中④ */
        free(p);                    /* 释放结点p */
        S-&gt;count--;
        return OK;
}
</code></pre>
<p>链栈的进栈push和出栈pop操作都很简单，时间复杂度均是O(1)。<br>
对比一下顺序栈与链栈，它们在时间复杂度上是一样的，均为O(1)。对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以它们的区别是如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。</p>
<h2 id="4-7-栈的作用">4.7 栈的作用</h2>
<p>栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。</p>
<h2 id="4-8-栈的应用——递归">4.8 栈的应用——递归</h2>
<h3 id="4-8-1-4-8-2递归定义">4.8.1-4.8.2递归定义</h3>
<p>我们<strong>把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数</strong>。<br>
当然，写递归程序最怕的就是陷入永不结束的无穷递归中，所以，<strong>每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出</strong>。</p>
<h2 id="4-9-栈的应用——四则运算表达式求值">4.9 栈的应用——四则运算表达式求值</h2>
<h3 id="4-9-1-后缀-逆波兰-表示法定义">4.9.1 后缀(逆波兰)表示法定义</h3>
<p>栈的现实应用也很多，我们再来重点讲一个比较常见的应用：数学表达式的求值。<br>
一种不需要括号的后缀表达法，我们也把它称为逆波兰(Reverse Polish Notation，RPN)表示。<br>
我们先来看看，对于“<code>9+(3-1)×3+10÷2</code>”，如果要用后缀表示法应该是：“<code>9 3 1-3*+10 2/+</code>”，这样的表达式称为后缀表达式，叫后缀的原因在于<strong>所有的符号都是在要运算数字的后面出现</strong>。</p>
<h3 id="4-9-2-后缀表达式计算结果">4.9.2 后缀表达式计算结果</h3>
<p>后缀表达式：<code>9 3 1-3*+10 2/+</code><br>
规则：<strong>从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</strong></p>
<h3 id="4-9-3-中缀表达式转后缀表达式">4.9.3 中缀表达式转后缀表达式</h3>
<p>我们把平时所用的标准四则运算表达式，即“<code>9+(3-1)×3+10÷2</code>”叫做中缀表达式。因为所有的运算符号都在两数字的中间。<br>
中缀表达式“<code>9+(3-1)×3+10÷2</code>”转化为后缀表达式“<code>9 3 1-3*+10 2/+</code>”。<br>
规则：<strong>从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号(乘除优先加减)则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</strong></p>
<h2 id="4-10-队列的定义">4.10 队列的定义</h2>
<p>队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>
队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</p>
<h2 id="4-11-队列的抽象数据类型">4.11 队列的抽象数据类型</h2>
<pre><code class="language-c">ADT 队列(Queue)
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
    InitQueue(*Q)：初始化操作，建立一个空队列Q。
    DestroyQueue(*Q)：若队列Q存在，则销毁它。
    ClearQueue(*Q)：将队列Q清空。
    QueueEmpty(Q)：若队列Q为空，返回true，否则返回false。
    GetHead(Q，*e)：若队列Q存在且非空，用e返回队列Q的队头元素。
    EnQueue(*Q，e)：若队列Q存在，插入新元素e到队列Q中并成为队尾元素。
    DeQueue(*Q，*e)：删除队列Q中队头元素，并用e返回其值。
    QueueLength(Q)：返回队列Q的元素个数
endADT
</code></pre>
<h2 id="4-12-循环队列">4.12 循环队列</h2>
<h3 id="4-12-1-队列顺序存储的不足">4.12.1 队列顺序存储的不足</h3>
<p>入队的时间复杂度为O(1)。<br>
与栈不同的是，队列元素的出列是在队头，即下标为0的位置，那也就意味着，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为0的位置不为空，此时时间复杂度为出队的时间复杂度为O(n)，效率太低。<br>
如果队列前面的位置空的，后面的位置排满了，那么新进的元素可以排到前面，这就引进了循环队列的概念。<br>
为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列是空队列。</p>
<h3 id="4-12-2-循环队列定义">4.12.2 循环队列定义</h3>
<p>队列中头尾相接的顺序存储结构称为循环队列。<br>
此时问题又出来了，空队列时，front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？</p>
<ol>
<li>办法一是设置一个标志变量flag，当<code>front==rear</code>，且flag=0时为队列空，当<code>front==rear</code>，且flag=1时为队列满。</li>
<li>办法二是当队列空时，条件就是<code>front=rear</code>，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。<br>
我们重点来讨论第二种方法，由于rear可能比front大，也可能比front小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的最大尺寸为QueueSize，那么队列满的条件是“<code>(rear+1)%QueueSize==front</code>”(取模“%”的目的就是为了整合rear与front大小为一个问题)。<br>
通用的计算队列长度公式为：<code>(rear-front+QueueSize)%QueueSize</code>。<br>
循环队列的顺序存储结构代码如下：</li>
</ol>
<pre><code class="language-c">typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */
/* 循环队列的顺序存储结构 */
typedef struct
{
    QElemType data[MAXSIZE];
    int front;      /* 头指针 */
    int rear;       /* 尾指针，若队列不空，指向队列尾元素的下一个位置 */
}SqQueue;
</code></pre>
<p>循环队列的初始化代码如下：</p>
<pre><code class="language-c">/* 初始化一个空队列Q */
Status InitQueue(SqQueue *Q)
{
    Q-&gt;front = 0;
    Q-&gt;rear = 0;
    return  OK;
}
</code></pre>
<p>循环队列求队列长度代码如下：</p>
<pre><code class="language-c">/* 返回Q的元素个数，也就是队列的当前长度 */
int QueueLength(SqQueue Q)
{
    return  (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
}
</code></pre>
<p>循环队列的入队列操作代码如下：</p>
<pre><code class="language-c">/* 若队列未满，则插入元素e为Q新的队尾元素 */
Status EnQueue(SqQueue *Q, QElemType e)
{
    if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front)    /* 队列满的判断 */
        return ERROR;
    Q-&gt;data[Q-&gt;rear] = e;               /* 将元素e赋值给队尾 */
    Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE;/* rear指针向后移一位置， */
                                      /* 若到最后则转到数组头部 */
    return  OK;
}
</code></pre>
<p>循环队列的出队列操作代码如下：</p>
<pre><code class="language-c">/* 若队列不空，则删除Q中队头元素，用e返回其值 */
Status DeQueue(SqQueue *Q, QElemType *e)
{
    if (Q-&gt;front == Q-&gt;rear)            /* 队列空的判断 */
        return ERROR;
    *e = Q-&gt;data[Q-&gt;front];                /* 将队头元素赋值给e */
    Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;    /* front指针向后移一位置 */
                                    /* 若到最后则转到数组头部 */
    return  OK;
}
</code></pre>
<h2 id="4-13-队列的链式存储结构及实现">4.13 队列的链式存储结构及实现</h2>
<p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。<br>
为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点，如图4-13-1所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-1.JPG?raw=true" srcset="/img/loading.gif" alt="4-13-1"><br>
空队列时，front和rear都指向头结点，如图4-13-2所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-2.JPG?raw=true" srcset="/img/loading.gif" alt="4-13-2"><br>
链队列的结构为：</p>
<pre><code class="language-c">typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */

typedef struct QNode    /* 结点结构 */
{
    QElemType data;
    struct QNode *next;
}QNode, *QueuePtr;

typedef struct            /* 队列的链表结构 */
{
    QueuePtr front, rear; /* 队头、队尾指针 */
}LinkQueue;
</code></pre>
<h3 id="4-13-1-队列的链式存储结构——入队操作">4.13.1 队列的链式存储结构——入队操作</h3>
<p>入队操作时，其实就是在链表尾部插入结点，如图4-13-3所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-3.JPG?raw=true" srcset="/img/loading.gif" alt="4-13-3"><br>
入队代码如下：</p>
<pre><code class="language-c">/* 插入元素e为Q的新的队尾元素 */
Status EnQueue(LinkQueue *Q, QElemType e)
{
    QueuePtr s = (QueuePtr)malloc(sizeof(QNode));
    if (!s) /* 存储分配失败 */
        exit(OVERFLOW);
    s-&gt;data = e;
    s-&gt;next = NULL;
    Q-&gt;rear-&gt;next = s;    /* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */
    Q-&gt;rear = s;        /* 把当前的s设置为队尾结点，rear指向s，见图中② */
    return OK;
}
</code></pre>
<h3 id="4-13-2-队列的链式存储结构——出队操作">4.13.2 队列的链式存储结构——出队操作</h3>
<p>出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将rear指向头结点，如图4-13-4所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-4.JPG?raw=true" srcset="/img/loading.gif" alt="4-13-4"></p>
<p>出队代码如下：</p>
<pre><code class="language-c">/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */
Status DeQueue(LinkQueue *Q, QElemType *e)
{
    QueuePtr p;
    if (Q-&gt;front == Q-&gt;rear)
        return ERROR;
    p = Q-&gt;front-&gt;next;        /* 将欲删除的队头结点暂存给p，见图中① */
    *e = p-&gt;data;                /* 将欲删除的队头结点的值赋值给e */
    Q-&gt;front-&gt;next = p-&gt;next;/* 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中② */
    if (Q-&gt;rear == p)/* 空队列的时候 */ /* 若队头就是队尾，则删除后将rear指向头结点，见图中③ */
        Q-&gt;rear = Q-&gt;front;
    free(p);
    return OK;
}
</code></pre>
<p>对于循环队列与链队列的比较，可以从两方面来考虑，从时间上，其实它们的基本操作都是常数时间，即都为O(1)的，不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。对于空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。<br>
总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。</p>
<h2 id="4-14-总结回顾">4.14 总结回顾</h2>
<p>这一章讲的是栈和队列，它们都是特殊的线性表，只不过对插入和删除操作做了限制。<br>
栈(stack)是限定仅在表尾进行插入和删除操作的线性表。<br>
队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>
它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。因此它们各自有各自的技巧来解决这个问题。<br>
对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。<br>
对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。<br>
它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同如图4-14-1所示。<br>
<img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-14-1.JPG?raw=true" srcset="/img/loading.gif" alt="4-14-1"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
</search>
