<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关系数据库MySQL入门</title>
    <url>/2020/02/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/MySQL/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93MySQL/</url>
    <content><![CDATA[<blockquote>
<p><strong>本文转载于GitHub项目<a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">Python - 100天从新手到大师</a></strong></p>
</blockquote>
<h3 id="一：-关系数据库概述"><a href="#一：-关系数据库概述" class="headerlink" title="一： 关系数据库概述"></a>一： 关系数据库概述</h3><ol>
<li><p>数据持久化 - 将数据保存到能够长久保存数据的存储介质中，在掉电的情况下数据也不会丢失。</p>
</li>
<li><p>数据库发展史 - 网状数据库、层次数据库、关系数据库、NoSQL数据库。</p>
<blockquote>
<p>1970年，IBM的研究员E.F.Codd在<em>Communication of the ACM</em>上发表了名为<em>A Relational Model of Data for Large Shared Data Banks</em>的论文，提出了关系模型的概念，奠定了关系模型的理论基础。后来Codd又陆续发表多篇文章，论述了范式理论和衡量关系系统的12条标准，用数学理论奠定了关系数据库的基础。</p>
</blockquote>
</li>
<li><p>关系数据库特点。</p>
<ul>
<li><p>理论基础：集合论和关系代数。</p>
</li>
<li><p>具体表象：用二维表（有行和列）组织数据。</p>
</li>
<li><p>编程语言：结构化查询语言（SQL）。</p>
</li>
</ul>
</li>
<li><p>ER模型（实体关系模型）和概念模型图。</p>
<p><strong>ER模型</strong>，全称为<strong>实体关系模型</strong>（Entity-Relationship Model），由美籍华裔计算机科学家陈品山先生提出，是概念数据模型的高层描述方式，如下图所示。</p>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/MySQL/er_diagram.png" srcset="/img/loading.gif" alt="er_diagram.png"></p>
<ul>
<li>实体 - 矩形框</li>
<li>属性 - 椭圆框</li>
<li>关系 - 菱形框</li>
<li>重数 - 1:1（一对一） / 1:N（一对多） / M:N（多对多）</li>
</ul>
<p>实际项目开发中，我们可以利用数据库建模工具（如：PowerDesigner）来绘制概念数据模型（其本质就是ER模型），然后再设置好目标数据库系统，将概念模型转换成物理模型，最终生成创建二维表的SQL（很多工具都可以根据我们设计的物理模型图以及设定的目标数据库来导出SQL或直接生成数据表）。</p>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/MySQL/conceptual_model.png" srcset="/img/loading.gif" alt="conceptual_model.png"></p>
</li>
<li><p>关系数据库产品。</p>
<ul>
<li><a href="https://www.oracle.com/index.html" target="_blank" rel="noopener">Oracle</a> - 目前世界上使用最为广泛的数据库管理系统，作为一个通用的数据库系统，它具有完整的数据管理功能；作为一个关系数据库，它是一个完备关系的产品；作为分布式数据库，它实现了分布式处理的功能。在Oracle最新的12c版本中，还引入了多承租方架构，使用该架构可轻松部署和管理数据库云。</li>
<li><a href="https://www.ibm.com/analytics/us/en/db2/" target="_blank" rel="noopener">DB2</a> - IBM公司开发的、主要运行于Unix（包括IBM自家的<a href="https://zh.wikipedia.org/wiki/AIX" target="_blank" rel="noopener">AIX</a>）、Linux、以及Windows服务器版等系统的关系数据库产品。DB2历史悠久且被认为是最早使用SQL的数据库产品，它拥有较为强大的商业智能功能。</li>
<li><a href="https://www.microsoft.com/en-us/sql-server/" target="_blank" rel="noopener">SQL Server</a> - 由Microsoft开发和推广的关系型数据库产品，最初适用于中小企业的数据管理，但是近年来它的应用范围有所扩展，部分大企业甚至是跨国公司也开始基于它来构建自己的数据管理系统。</li>
<li><a href="https://www.mysql.com/" target="_blank" rel="noopener">MySQL</a> - MySQL是开放源代码的，任何人都可以在GPL（General Public License）的许可下下载并根据个性化的需要对其进行修改。MySQL因为其速度、可靠性和适应性而备受关注。</li>
<li><a href="">PostgreSQL</a> - 在BSD许可证下发行的开放源代码的关系数据库产品。</li>
</ul>
</li>
</ol>
<h3 id="二：-MySQL简介"><a href="#二：-MySQL简介" class="headerlink" title="二： MySQL简介"></a>二： MySQL简介</h3><p>MySQL最早是由瑞典的MySQL AB公司开发的一个开放源码的关系数据库管理系统，该公司于2008年被昇阳微系统公司（Sun Microsystems）收购。在2009年，甲骨文公司（Oracle）收购昇阳微系统公司，因此在这之后MySQL成为了Oracle旗下产品。</p>
<p>MySQL在过去由于性能高、成本低、可靠性好，已经成为最流行的开源数据库，因此被广泛地应用于中小型网站开发。随着MySQL的不断成熟，它也逐渐被应用于更多大规模网站和应用，比如维基百科、谷歌（Google）、脸书（Facebook）、淘宝网等网站都使用了MySQL来提供数据持久化服务。</p>
<p>甲骨文公司收购后昇阳微系统公司，大幅调涨MySQL商业版的售价，且甲骨文公司不再支持另一个自由软件项目<a href="https://zh.wikipedia.org/wiki/OpenSolaris" target="_blank" rel="noopener">OpenSolaris</a>的发展，因此导致自由软件社区对于Oracle是否还会持续支持MySQL社区版（MySQL的各个发行版本中唯一免费的版本）有所担忧，MySQL的创始人麦克尔·维德纽斯以MySQL为基础，成立分支计划<a href="https://zh.wikipedia.org/wiki/MariaDB" target="_blank" rel="noopener">MariaDB</a>（以他女儿的名字命名的数据库）。有许多原来使用MySQL数据库的公司（例如：维基百科）已经陆续完成了从MySQL数据库到MariaDB数据库的迁移。</p>
<ol>
<li><p>安装和配置</p>
<blockquote>
<p><strong>说明</strong>：下面的安装和配置都是以CentOS Linux环境为例，如果需要在其他系统下安装MySQL，读者可以自行在网络上查找对应的安装教程）。</p>
</blockquote>
<ul>
<li><p>刚才说过，MySQL有一个分支版本名叫MariaDB，该数据库旨在继续保持MySQL数据库在<a href="https://zh.wikipedia.org/wiki/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81" target="_blank" rel="noopener">GNU GPL</a>下开源。如果要使用MariaDB作为MySQL的替代品，可以使用下面的命令进行安装。</p>
<pre><code class="Shell">yum install mariadb mariadb-server</code></pre>
</li>
<li><p>如果要安装官方版本的MySQL，可以在<a href="https://www.mysql.com/" target="_blank" rel="noopener">MySQL官方网站</a>下载安装文件。首先在下载页面中选择平台和版本，然后找到对应的下载链接。下面以MySQL 5.7.26版本和Red Hat Enterprise Linux为例，直接下载包含所有安装文件的归档文件，解归档之后通过包管理工具进行安装。</p>
<pre><code class="Shell">wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar
tar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar</code></pre>
<p>如果系统上有MariaDB相关的文件，需要先移除MariaDB相关的文件。</p>
<pre><code class="Shell">yum list installed | grep mariadb | awk &#39;{print $1}&#39; | xargs yum erase -y</code></pre>
<p>接下来可以按照如下所示的顺序用RPM（Redhat Package Manager）工具安装MySQL。</p>
<pre><code class="Shell">rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm
rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm
rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm
rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm</code></pre>
<p>可以使用下面的命令查看已经安装的MySQL相关的包。</p>
<pre><code class="Shell">rpm -qa | grep mysql</code></pre>
</li>
<li><p>配置MySQL。</p>
<p>MySQL的配置文件在<code>/etc</code>目录下，名为<code>my.cnf</code>，默认的配置文件内容如下所示。如果对这个文件不理解并没有关系，什么时候用到这个配置文件什么时候再了解它就行了。</p>
<pre><code class="Shell">cat /etc/my.cnf</code></pre>
<pre><code class="INI"># For advice on how to change settings please see
# http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html

[mysqld]
#
# Remove leading # and set to the amount of RAM for the most important data
# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.
# innodb_buffer_pool_size = 128M
#
# Remove leading # to turn on a very important data integrity option: logging
# changes to the binary log between backups.
# log_bin
#
# Remove leading # to set options mainly useful for reporting servers.
# The server defaults are faster for transactions and fast SELECTs.
# Adjust sizes as needed, experiment to find the optimal values.
# join_buffer_size = 128M
# sort_buffer_size = 2M
# read_rnd_buffer_size = 2M
datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock

# Disabling symbolic-links is recommended to prevent assorted security risks
symbolic-links=0

log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid</code></pre>
</li>
<li><p>启动MySQL服务。</p>
<p>可以使用下面的命令来启动MySQL。</p>
<pre><code class="Shell">service mysqld start</code></pre>
<p>在CentOS 7中，更推荐使用下面的命令来启动MySQL。</p>
<pre><code class="Shell">systemctl start mysqld</code></pre>
<p>启动MySQL成功后，可以通过下面的命令来检查网络端口使用情况，MySQL默认使用3306端口。</p>
<pre><code class="Shell">netstat -ntlp | grep mysql</code></pre>
<p>也可以使用下面的命令查找是否有名为mysqld的进程。</p>
<pre><code class="Shell">pgrep mysqld</code></pre>
</li>
<li><p>使用MySQL客户端工具连接服务器。</p>
<p>命令行工具：</p>
<pre><code class="Shell">mysql -u root -p</code></pre>
<blockquote>
<p>说明：启动客户端时，<code>-u</code>参数用来指定用户名，MySQL默认的超级管理账号为<code>root</code>；<code>-p</code>表示要输入密码（用户口令）；如果连接的是其他主机而非本机，可以用<code>-h</code>来指定连接主机的主机名或IP地址。</p>
</blockquote>
<p>如果是首次安装MySQL，可以使用下面的命令来找到默认的初始密码。</p>
<pre><code class="Shell">cat /var/log/mysqld.log | grep password</code></pre>
<p>上面的命令会查看MySQL的日志带有password的行，在显示的结果中<code>root@localhost:</code>后面的部分就是默认设置的初始密码。</p>
<p>修改超级管理员（root）的访问口令为<code>123456</code>。</p>
<pre><code class="SQL">set global validate_password_policy=0;
set global validate_password_length=6;
alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;</code></pre>
<blockquote>
<p><strong>说明</strong>：MySQL较新的版本默认不允许使用弱口令作为用户口令，所以我们通过上面的前两条命令修改了验证用户口令的策略和口令的长度。事实上我们不应该使用弱口令，因为存在用户口令被暴力破解的风险。近年来，攻击数据库窃取数据和劫持数据库勒索比特币的事件屡见不鲜，要避免这些潜在的风险，最为重要的一点是不要让数据库服务器暴露在公网上（最好的做法是将数据库置于内网，至少要做到不向公网开放数据库服务器的访问端口），另外要保管好<code>root</code>账号的口令，应用系统需要访问数据库时，通常不使用<code>root</code>账号进行访问，而是创建其他拥有适当权限的账号来访问。</p>
</blockquote>
<p>再次使用客户端工具连接MySQL服务器时，就可以使用新设置的口令了。在实际开发中，为了方便用户操作，可以选择图形化的客户端工具来连接MySQL服务器，包括：</p>
<ul>
<li>MySQL Workbench（官方提供的工具）</li>
<li>Navicat for MySQL（界面简单优雅，功能直观强大）</li>
<li>SQLyog for MySQL（强大的MySQL数据库管理员工具）</li>
</ul>
</li>
</ul>
</li>
<li><p>常用命令。</p>
<ul>
<li><p>查看服务器版本。</p>
<pre><code class="SQL">select version();</code></pre>
</li>
<li><p>查看所有数据库。</p>
<pre><code class="SQL">show databases;</code></pre>
</li>
<li><p>切换到指定数据库。</p>
<pre><code class="SQL">use mysql;</code></pre>
</li>
<li><p>查看数据库下所有表。</p>
<pre><code class="Shell">show tables;</code></pre>
</li>
<li><p>获取帮助。</p>
<pre><code class="SQL">? contents;
? functions;
? numeric functions;
? round;

? data types;
? longblob;</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="三：-SQL详解"><a href="#三：-SQL详解" class="headerlink" title="三： SQL详解"></a>三： SQL详解</h3><h4 id="3-1-基本操作"><a href="#3-1-基本操作" class="headerlink" title="3.1 基本操作"></a>3.1 基本操作</h4><p>我们通常可以将SQL分为三类：DDL（数据定义语言）、DML（数据操作语言）和DCL（数据控制语言）。DDL主要用于创建（create）、删除（drop）、修改（alter）数据库中的对象，比如创建、删除和修改二维表；DML主要负责插入数据（insert）、删除数据（delete）、更新数据（update）和查询（select）；DCL通常用于授予权限（grant）和召回权限（revoke）。</p>
<blockquote>
<p>说明：SQL是不区分大小写的语言，为了书写方便，下面的SQL都使用了小写字母来书写。</p>
</blockquote>
<ol>
<li><p>DDL（数据定义语言）</p>
<pre><code class="SQL">-- 如果存在名为school的数据库就删除它
drop database if exists school;

-- 创建名为school的数据库并设置默认的字符集和排序方式
create database school default charset utf8;

-- 切换到school数据库上下文环境
use school;

-- 创建学院表
create table tb_college
(
collid         int auto_increment comment &#39;编号&#39;,
collname     varchar(50) not null comment &#39;名称&#39;,
collintro     varchar(500) default &#39;&#39; comment &#39;介绍&#39;,
primary key (collid)
);

-- 创建学生表
create table tb_student
(
stuid         int not null comment &#39;学号&#39;,
stuname     varchar(20) not null comment &#39;姓名&#39;,
stusex         boolean default 1 comment &#39;性别&#39;,
stubirth     date not null comment &#39;出生日期&#39;,
stuaddr     varchar(255) default &#39;&#39; comment &#39;籍贯&#39;,
collid         int not null comment &#39;所属学院&#39;,
primary key (stuid),
foreign key (collid) references tb_college (collid)
);

-- 创建教师表
create table tb_teacher
(
teaid         int not null comment &#39;工号&#39;,
teaname     varchar(20) not null comment &#39;姓名&#39;,
teatitle     varchar(10) default &#39;助教&#39; comment &#39;职称&#39;,
collid         int not null comment &#39;所属学院&#39;,
primary key (teaid),
foreign key (collid) references tb_college (collid)
);

-- 创建课程表
create table tb_course
(
couid         int not null comment &#39;编号&#39;,
couname     varchar(50) not null comment &#39;名称&#39;,
coucredit     int not null comment &#39;学分&#39;,
teaid         int not null comment &#39;授课老师&#39;,
primary key (couid),
foreign key (teaid) references tb_teacher (teaid)
);

-- 创建选课记录表
create table tb_record
(
recid         int auto_increment comment &#39;选课记录编号&#39;,
sid         int not null comment &#39;选课学生&#39;,
cid         int not null comment &#39;所选课程&#39;,
seldate     datetime default now() comment &#39;选课时间日期&#39;,
score         decimal(4,1) comment &#39;考试成绩&#39;,
primary key (recid),
foreign key (sid) references tb_student (stuid),
foreign key (cid) references tb_course (couid),
unique (sid, cid)
);</code></pre>
<p>上面的DDL有几个地方需要强调一下：</p>
<ul>
<li><p>创建数据库时，我们通过<code>default charset utf8</code>指定了数据库默认使用的字符集，我们推荐使用该字符集，因为utf8能够支持国际化编码。如果将来数据库中用到的字符可能包括类似于Emoji这样的图片字符，也可以将默认字符集设定为utf8mb4（最大4字节的utf-8编码）。查看MySQL支持的字符集可以执行下面的语句。</p>
<pre><code class="SQL">show character set;</code></pre>
<pre><code>+----------+---------------------------------+---------------------+--------+
| Charset  | Description                     | Default collation   | Maxlen |
+----------+---------------------------------+---------------------+--------+
| big5     | Big5 Traditional Chinese        | big5_chinese_ci     |      2 |
| dec8     | DEC West European               | dec8_swedish_ci     |      1 |
| cp850    | DOS West European               | cp850_general_ci    |      1 |
| hp8      | HP West European                | hp8_english_ci      |      1 |
| koi8r    | KOI8-R Relcom Russian           | koi8r_general_ci    |      1 |
| latin1   | cp1252 West European            | latin1_swedish_ci   |      1 |
| latin2   | ISO 8859-2 Central European     | latin2_general_ci   |      1 |
| swe7     | 7bit Swedish                    | swe7_swedish_ci     |      1 |
| ascii    | US ASCII                        | ascii_general_ci    |      1 |
| ujis     | EUC-JP Japanese                 | ujis_japanese_ci    |      3 |
| sjis     | Shift-JIS Japanese              | sjis_japanese_ci    |      2 |
| hebrew   | ISO 8859-8 Hebrew               | hebrew_general_ci   |      1 |
| tis620   | TIS620 Thai                     | tis620_thai_ci      |      1 |
| euckr    | EUC-KR Korean                   | euckr_korean_ci     |      2 |
| koi8u    | KOI8-U Ukrainian                | koi8u_general_ci    |      1 |
| gb2312   | GB2312 Simplified Chinese       | gb2312_chinese_ci   |      2 |
| greek    | ISO 8859-7 Greek                | greek_general_ci    |      1 |
| cp1250   | Windows Central European        | cp1250_general_ci   |      1 |
| gbk      | GBK Simplified Chinese          | gbk_chinese_ci      |      2 |
| latin5   | ISO 8859-9 Turkish              | latin5_turkish_ci   |      1 |
| armscii8 | ARMSCII-8 Armenian              | armscii8_general_ci |      1 |
| utf8     | UTF-8 Unicode                   | utf8_general_ci     |      3 |
| ucs2     | UCS-2 Unicode                   | ucs2_general_ci     |      2 |
| cp866    | DOS Russian                     | cp866_general_ci    |      1 |
| keybcs2  | DOS Kamenicky Czech-Slovak      | keybcs2_general_ci  |      1 |
| macce    | Mac Central European            | macce_general_ci    |      1 |
| macroman | Mac West European               | macroman_general_ci |      1 |
| cp852    | DOS Central European            | cp852_general_ci    |      1 |
| latin7   | ISO 8859-13 Baltic              | latin7_general_ci   |      1 |
| utf8mb4  | UTF-8 Unicode                   | utf8mb4_general_ci  |      4 |
| cp1251   | Windows Cyrillic                | cp1251_general_ci   |      1 |
| utf16    | UTF-16 Unicode                  | utf16_general_ci    |      4 |
| utf16le  | UTF-16LE Unicode                | utf16le_general_ci  |      4 |
| cp1256   | Windows Arabic                  | cp1256_general_ci   |      1 |
| cp1257   | Windows Baltic                  | cp1257_general_ci   |      1 |
| utf32    | UTF-32 Unicode                  | utf32_general_ci    |      4 |
| binary   | Binary pseudo charset           | binary              |      1 |
| geostd8  | GEOSTD8 Georgian                | geostd8_general_ci  |      1 |
| cp932    | SJIS for Windows Japanese       | cp932_japanese_ci   |      2 |
| eucjpms  | UJIS for Windows Japanese       | eucjpms_japanese_ci |      3 |
| gb18030  | China National Standard GB18030 | gb18030_chinese_ci  |      4 |
+----------+---------------------------------+---------------------+--------+
41 rows in set (0.00 sec)</code></pre><p>如果要设置MySQL服务启动时默认使用的字符集，可以修改MySQL的配置并添加以下内容</p>
<pre><code class="INI">[mysqld]
character-set-server=utf8</code></pre>
</li>
<li><p>在创建表的时候，我们可以在右圆括号的后面通过<code>engine=XXX</code>来指定表的存储引擎，MySQL支持多种存储引擎，可以通过<code>show engines</code>命令进行查看。MySQL 5.5以后的版本默认使用的存储引擎是InnoDB，它正好也就是我们推荐大家使用的存储引擎（因为InnoDB更适合互联网应用对高并发、性能以及事务支持等方面的需求）。</p>
<pre><code class="SQL">show engines\G</code></pre>
<pre><code>*************************** 1. row ***************************
      Engine: InnoDB
     Support: DEFAULT
     Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
          XA: YES
  Savepoints: YES
*************************** 2. row ***************************
      Engine: MRG_MYISAM
     Support: YES
     Comment: Collection of identical MyISAM tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 3. row ***************************
      Engine: MEMORY
     Support: YES
     Comment: Hash based, stored in memory, useful for temporary tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 4. row ***************************
      Engine: BLACKHOLE
     Support: YES
     Comment: /dev/null storage engine (anything you write to it disappears)
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 5. row ***************************
      Engine: MyISAM
     Support: YES
     Comment: MyISAM storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 6. row ***************************
      Engine: CSV
     Support: YES
     Comment: CSV storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 7. row ***************************
      Engine: ARCHIVE
     Support: YES
     Comment: Archive storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 8. row ***************************
      Engine: PERFORMANCE_SCHEMA
     Support: YES
     Comment: Performance Schema
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 9. row ***************************
      Engine: FEDERATED
     Support: NO
     Comment: Federated MySQL storage engine
Transactions: NULL
          XA: NULL
  Savepoints: NULL
9 rows in set (0.00 sec)</code></pre><p>下面的表格对MySQL几种常用的数据引擎进行了简单的对比。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>InnoDB</th>
<th>MRG_MYISAM</th>
<th>MEMORY</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>有</td>
<td>没有</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>事务</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>锁机制</td>
<td>行锁</td>
<td>表锁</td>
<td>表锁</td>
<td>表锁</td>
</tr>
<tr>
<td>B树索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>哈希索引</td>
<td></td>
<td></td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>全文检索</td>
<td>支持（5.6+）</td>
<td></td>
<td></td>
<td>支持</td>
</tr>
<tr>
<td>集群索引</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据缓存</td>
<td>支持</td>
<td></td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>索引缓存</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>数据可压缩</td>
<td></td>
<td></td>
<td></td>
<td>支持</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中</td>
<td>低</td>
</tr>
<tr>
<td>存储空间使用</td>
<td>高</td>
<td>低</td>
<td></td>
<td>低</td>
</tr>
<tr>
<td>批量插入性能</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>是否支持外键</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>通过上面的比较我们可以了解到，InnoDB是唯一能够支持外键、事务以及行锁的存储引擎，所以我们之前说它更适合互联网应用，而且它也是较新的MySQL版本中默认使用的存储引擎。</p>
</li>
<li><p>在定义表结构为每个字段选择数据类型时，如果不清楚哪个数据类型更合适，可以通过MySQL的帮助系统来了解每种数据类型的特性、数据的长度和精度等相关信息。</p>
<pre><code class="SQL">? data types</code></pre>
<pre><code>You asked for help about help category: &quot;Data Types&quot;
For more information, type &#39;help &lt;item&gt;&#39;, where &lt;item&gt; is one of the following
topics:
   AUTO_INCREMENT
   BIGINT
   BINARY
   BIT
   BLOB
   BLOB DATA TYPE
   BOOLEAN
   CHAR
   CHAR BYTE
   DATE
   DATETIME
   DEC
   DECIMAL
   DOUBLE
   DOUBLE PRECISION
   ENUM
   FLOAT
   INT
   INTEGER
   LONGBLOB
   LONGTEXT
   MEDIUMBLOB
   MEDIUMINT
   MEDIUMTEXT
   SET DATA TYPE
   SMALLINT
   TEXT
   TIME
   TIMESTAMP
   TINYBLOB
   TINYINT
   TINYTEXT
   VARBINARY
   VARCHAR
   YEAR DATA TYPE</code></pre><pre><code class="SQL">? varchar</code></pre>
<pre><code>Name: &#39;VARCHAR&#39;
Description:
[NATIONAL] VARCHAR(M) [CHARACTER SET charset_name] [COLLATE
collation_name]

A variable-length string. M represents the maximum column length in
characters. The range of M is 0 to 65,535. The effective maximum length
of a VARCHAR is subject to the maximum row size (65,535 bytes, which is
shared among all columns) and the character set used. For example, utf8
characters can require up to three bytes per character, so a VARCHAR
column that uses the utf8 character set can be declared to be a maximum
of 21,844 characters. See
http://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html.

MySQL stores VARCHAR values as a 1-byte or 2-byte length prefix plus
data. The length prefix indicates the number of bytes in the value. A
VARCHAR column uses one length byte if values require no more than 255
bytes, two length bytes if values may require more than 255 bytes.

*Note*:

MySQL follows the standard SQL specification, and does not remove
trailing spaces from VARCHAR values.

VARCHAR is shorthand for CHARACTER VARYING. NATIONAL VARCHAR is the
standard SQL way to define that a VARCHAR column should use some
predefined character set. MySQL uses utf8 as this predefined character
set. http://dev.mysql.com/doc/refman/5.7/en/charset-national.html.
NVARCHAR is shorthand for NATIONAL VARCHAR.

URL: http://dev.mysql.com/doc/refman/5.7/en/string-type-overview.html</code></pre><p>在数据类型的选择上，保存字符串数据通常都使用VARCHAR和CHAR两种类型，前者通常称为变长字符串，而后者通常称为定长字符串；对于InnoDB存储引擎，行存储格式没有区分固定长度和可变长度列，因此VARCHAR类型好CHAR类型没有本质区别，后者不一定比前者性能更好。如果要保存的很大字符串，可以使用TEXT类型；如果要保存很大的字节串，可以使用BLOB（二进制大对象）类型。在MySQL中，TEXT和BLOB又分别包括TEXT、MEDIUMTEXT、LONGTEXT和BLOB、MEDIUMBLOB、LONGBLOB三种不同的类型，它们主要的区别在于存储数据的最大大小不同。保存浮点数可以用FLOAT或DOUBLE类型，而保存定点数应该使用DECIMAL类型。如果要保存时间日期，DATETIME类型优于TIMESTAMP类型，因为前者能表示的时间日期范围更大。</p>
</li>
</ul>
</li>
<li><p>DML</p>
<pre><code class="SQL">-- 插入学院数据
insert into tb_college (collname, collintro) values 
(&#39;计算机学院&#39;, &#39;创建于1956年是我国首批建立计算机专业。学院现有计算机科学与技术一级学科和网络空间安全一级学科博士学位授予权，其中计算机科学与技术一级学科具有博士后流动站。计算机科学与技术一级学科在2017年全国第四轮学科评估中评为A；2019 U.S.News全球计算机学科排名26名；ESI学科排名0.945‰，进入全球前1‰，位列第43位。&#39;),
(&#39;外国语学院&#39;, &#39;1998年浙江大学、杭州大学、浙江农业大学、浙江医科大学四校合并，成立新的浙江大学。1999年原浙江大学外语系、原杭州大学外国语学院、原杭州大学大外部、原浙江农业大学公外部、原浙江医科大学外语教学部合并，成立浙江大学外国语学院。2003年学院更名为浙江大学外国语言文化与国际交流学院。&#39;),
(&#39;经济管理学院&#39;, &#39;四川大学经济学院历史悠久、传承厚重，其前身是创办于1905年的四川大学经济科,距今已有100多年的历史。已故著名经济学家彭迪先、张与九、蒋学模、胡寄窗、陶大镛、胡代光，以及当代著名学者刘诗白等曾先后在此任教或学习。在长期的办学过程中，学院坚持以马克思主义的立场、观点、方法为指导，围绕建设世界一流经济学院的奋斗目标，做实“两个伟大”深度融合，不断提高党的建设质量与科学推进一流事业深度融合。&#39;);

-- 插入学生数据
insert into tb_student (stuid, stuname, stusex, stubirth, stuaddr, collid) values
(1001, &#39;杨逍&#39;, 1, &#39;1990-3-4&#39;, &#39;四川成都&#39;, 1),
(1002, &#39;任我行&#39;, 1, &#39;1992-2-2&#39;, &#39;湖南长沙&#39;, 1),
(1033, &#39;王语嫣&#39;, 0, &#39;1989-12-3&#39;, &#39;四川成都&#39;, 1),
(1572, &#39;岳不群&#39;, 1, &#39;1993-7-19&#39;, &#39;陕西咸阳&#39;, 1),
(1378, &#39;纪嫣然&#39;, 0, &#39;1995-8-12&#39;, &#39;四川绵阳&#39;, 1),
(1954, &#39;林平之&#39;, 1, &#39;1994-9-20&#39;, &#39;福建莆田&#39;, 1),
(2035, &#39;东方不败&#39;, 1, &#39;1988-6-30&#39;, null, 2),
(3011, &#39;林震南&#39;, 1, &#39;1985-12-12&#39;, &#39;福建莆田&#39;, 3),
(3755, &#39;项少龙&#39;, 1, &#39;1993-1-25&#39;, null, 3),
(3923, &#39;杨不悔&#39;, 0, &#39;1985-4-17&#39;, &#39;四川成都&#39;, 3),
(4040, &#39;隔壁老王&#39;, 1, &#39;1989-1-1&#39;, &#39;四川成都&#39;, 2);

-- 删除学生数据
delete from tb_student where stuid=4040;

-- 更新学生数据
update tb_student set stuname=&#39;杨过&#39;, stuaddr=&#39;湖南长沙&#39; where stuid=1001;

-- 插入老师数据
insert into tb_teacher (teaid, teaname, teatitle, collid) values 
(1122, &#39;张三丰&#39;, &#39;教授&#39;, 1),
(1133, &#39;宋远桥&#39;, &#39;副教授&#39;, 1),
(1144, &#39;杨逍&#39;, &#39;副教授&#39;, 1),
(2255, &#39;范遥&#39;, &#39;副教授&#39;, 2),
(3366, &#39;韦一笑&#39;, &#39;讲师&#39;, 3);

-- 插入课程数据
insert into tb_course (couid, couname, coucredit, teaid) values 
(1111, &#39;Python程序设计&#39;, 3, 1122),
(2222, &#39;Web前端开发&#39;, 2, 1122),
(3333, &#39;操作系统&#39;, 4, 1122),
(4444, &#39;计算机网络&#39;, 2, 1133),
(5555, &#39;编译原理&#39;, 4, 1144),
(6666, &#39;算法和数据结构&#39;, 3, 1144),
(7777, &#39;经贸法语&#39;, 3, 2255),
(8888, &#39;成本会计&#39;, 2, 3366),
(9999, &#39;审计学&#39;, 3, 3366);

-- 插入选课数据
insert into tb_record (sid, cid, seldate, score) values 
(1001, 1111, &#39;2017-09-01&#39;, 95),
(1001, 2222, &#39;2017-09-01&#39;, 87.5),
(1001, 3333, &#39;2017-09-01&#39;, 100),
(1001, 4444, &#39;2018-09-03&#39;, null),
(1001, 6666, &#39;2017-09-02&#39;, 100),
(1002, 1111, &#39;2017-09-03&#39;, 65),
(1002, 5555, &#39;2017-09-01&#39;, 42),
(1033, 1111, &#39;2017-09-03&#39;, 92.5),
(1033, 4444, &#39;2017-09-01&#39;, 78),
(1033, 5555, &#39;2017-09-01&#39;, 82.5),
(1572, 1111, &#39;2017-09-02&#39;, 78),
(1378, 1111, &#39;2017-09-05&#39;, 82),
(1378, 7777, &#39;2017-09-02&#39;, 65.5),
(2035, 7777, &#39;2018-09-03&#39;, 88),
(2035, 9999, default, null),
(3755, 1111, default, null),
(3755, 8888, default, null),
(3755, 9999, &#39;2017-09-01&#39;, 92);</code></pre>
<pre><code class="SQL">-- 查询所有学生信息
select * from tb_student;

-- 查询所有课程名称及学分(投影和别名)
select couname, coucredit from tb_course;
select couname as 课程名称, coucredit as 学分 from tb_course;

-- 查询所有学生的姓名和性别(条件运算)
select stuname as 姓名, case stusex when 1 then &#39;男&#39; else &#39;女&#39; end as 性别 from tb_student;
select stuname as 姓名, if(stusex, &#39;男&#39;, &#39;女&#39;) as 性别 from tb_student;

-- 查询所有女学生的姓名和出生日期(筛选)
select stuname, stubirth from tb_student where stusex=0;

-- 查询所有80后学生的姓名、性别和出生日期(筛选)
select stuname, stusex, stubirth from tb_student where stubirth&gt;=&#39;1980-1-1&#39; and stubirth&lt;=&#39;1989-12-31&#39;;
select stuname, stusex, stubirth from tb_student where stubirth between &#39;1980-1-1&#39; and &#39;1989-12-31&#39;;

-- 查询姓&quot;杨&quot;的学生姓名和性别(模糊)
select stuname, stusex from tb_student where stuname like &#39;杨%&#39;;

-- 查询姓&quot;杨&quot;名字两个字的学生姓名和性别(模糊)
select stuname, stusex from tb_student where stuname like &#39;杨_&#39;;

-- 查询姓&quot;杨&quot;名字三个字的学生姓名和性别(模糊)
select stuname, stusex from tb_student where stuname like &#39;杨__&#39;;

-- 查询名字中有&quot;不&quot;字或&quot;嫣&quot;字的学生的姓名(模糊)
select stuname, stusex from tb_student where stuname like &#39;%不%&#39; or stuname like &#39;%嫣%&#39;;

-- 查询没有录入家庭住址的学生姓名(空值)
select stuname from tb_student where stuaddr is null;

-- 查询录入了家庭住址的学生姓名(空值)
select stuname from tb_student where stuaddr is not null;

-- 查询学生选课的所有日期(去重)
select distinct seldate from tb_record;

-- 查询学生的家庭住址(去重)
select distinct stuaddr from tb_student where stuaddr is not null;

-- 查询男学生的姓名和生日按年龄从大到小排列(排序)
select stuname as 姓名, datediff(curdate(), stubirth) div 365 as 年龄 from tb_student where stusex=1 order by 年龄 desc;

-- 查询年龄最大的学生的出生日期(聚合函数)
select min(stubirth) from tb_student;

-- 查询年龄最小的学生的出生日期(聚合函数)
select max(stubirth) from tb_student;

-- 查询男女学生的人数(分组和聚合函数)
select stusex, count(*) from tb_student group by stusex;

-- 查询课程编号为1111的课程的平均成绩(筛选和聚合函数)
select avg(score) from tb_record where cid=1111;

-- 查询学号为1001的学生所有课程的平均分(筛选和聚合函数)
select avg(score) from tb_record where sid=1001;

-- 查询每个学生的学号和平均成绩(分组和聚合函数)
select sid as 学号, avg(score) as 平均分 from tb_record group by sid;

-- 查询平均成绩大于等于90分的学生的学号和平均成绩
-- 分组以前的筛选使用where子句 / 分组以后的筛选使用having子句
select sid as 学号, avg(score) as 平均分 from tb_record group by sid having 平均分&gt;=90;

-- 查询年龄最大的学生的姓名(子查询/嵌套的查询)
select stuname from tb_student where stubirth=( select min(stubirth) from tb_student );

-- 查询年龄最大的学生姓名和年龄(子查询+运算)
select stuname as 姓名, datediff(curdate(), stubirth) div 365 as 年龄 from tb_student where stubirth=( select min(stubirth) from tb_student );

-- 查询选了两门以上的课程的学生姓名(子查询/分组条件/集合运算)
select stuname from tb_student where stuid in ( select stuid from tb_record group by stuid having count(stuid)&gt;2 );

-- 查询学生姓名、课程名称以及成绩(连接查询)
select stuname, couname, score from tb_student t1, tb_course t2, tb_record t3 where stuid=sid and couid=cid and score is not null;

-- 查询学生姓名、课程名称以及成绩按成绩从高到低查询第11-15条记录(内连接+分页)
select stuname, couname, score from tb_student inner join tb_record on stuid=sid inner join tb_course on couid=cid where score is not null order by score desc limit 5 offset 10;

select stuname, couname, score from tb_student inner join tb_record on stuid=sid inner join tb_course on couid=cid where score is not null order by score desc limit 10, 5;

-- 查询选课学生的姓名和平均成绩(子查询和连接查询)
select stuname, avgmark from tb_student, ( select sid, avg(score) as avgmark from tb_record group by sid ) temp where stuid=sid;

select stuname, avgmark from tb_student inner join ( select sid, avg(score) as avgmark from tb_record group by sid ) temp on stuid=sid;

-- 查询每个学生的姓名和选课数量(左外连接和子查询)
select stuname, ifnull(total, 0) from tb_student left outer join ( select sid, count(sid) as total from tb_record group by sid ) temp on stuid=sid;</code></pre>
<p>上面的DML有几个地方需要加以说明：</p>
<ol>
<li><p>MySQL中支持多种类型的运算符，包括：算术运算符（+、-、*、/、%）、比较运算符（=、&lt;&gt;、&lt;=&gt;、&lt;、&lt;=、&gt;、&gt;=、BETWEEN…AND…、IN、IS NULL、IS NOT NULL、LIKE、RLIKE、REGEXP）、逻辑运算符（NOT、AND、OR、XOR）和位运算符（&amp;、|、^、~、&gt;&gt;、&lt;&lt;），我们可以在DML中使用这些运算符处理数据。</p>
</li>
<li><p>在查询数据时，可以在SELECT语句及其子句（如WHERE子句、ORDER BY子句、HAVING子句等）中使用函数，这些函数包括字符串函数、数值函数、时间日期函数、流程函数等，如下面的表格所示。</p>
<p>常用字符串函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CONCAT</td>
<td>将多个字符串连接成一个字符串</td>
</tr>
<tr>
<td>FORMAT</td>
<td>将数值格式化成字符串并指定保留几位小数</td>
</tr>
<tr>
<td>FROM_BASE64 / TO_BASE64</td>
<td>BASE64解码/编码</td>
</tr>
<tr>
<td>BIN / OCT / HEX</td>
<td>将数值转换成二进制/八进制/十六进制字符串</td>
</tr>
<tr>
<td>LOCATE</td>
<td>在字符串中查找一个子串的位置</td>
</tr>
<tr>
<td>LEFT / RIGHT</td>
<td>返回一个字符串左边/右边指定长度的字符</td>
</tr>
<tr>
<td>LENGTH / CHAR_LENGTH</td>
<td>返回字符串的长度以字节/字符为单位</td>
</tr>
<tr>
<td>LOWER / UPPER</td>
<td>返回字符串的小写/大写形式</td>
</tr>
<tr>
<td>LPAD / RPAD</td>
<td>如果字符串的长度不足，在字符串左边/右边填充指定的字符</td>
</tr>
<tr>
<td>LTRIM / RTRIM</td>
<td>去掉字符串前面/后面的空格</td>
</tr>
<tr>
<td>ORD / CHAR</td>
<td>返回字符对应的编码/返回编码对应的字符</td>
</tr>
<tr>
<td>STRCMP</td>
<td>比较字符串，返回-1、0、1分别表示小于、等于、大于</td>
</tr>
<tr>
<td>SUBSTRING</td>
<td>返回字符串指定范围的子串</td>
</tr>
</tbody></table>
<p>常用数值函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>ABS</td>
<td>返回一个数的绝度值</td>
</tr>
<tr>
<td>CEILING / FLOOR</td>
<td>返回一个数上取整/下取整的结果</td>
</tr>
<tr>
<td>CONV</td>
<td>将一个数从一种进制转换成另一种进制</td>
</tr>
<tr>
<td>CRC32</td>
<td>计算循环冗余校验码</td>
</tr>
<tr>
<td>EXP / LOG / LOG2 / LOG10</td>
<td>计算指数/对数</td>
</tr>
<tr>
<td>POW</td>
<td>求幂</td>
</tr>
<tr>
<td>RAND</td>
<td>返回[0,1)范围的随机数</td>
</tr>
<tr>
<td>ROUND</td>
<td>返回一个数四舍五入后的结果</td>
</tr>
<tr>
<td>SQRT</td>
<td>返回一个数的平方根</td>
</tr>
<tr>
<td>TRUNCATE</td>
<td>截断一个数到指定的精度</td>
</tr>
<tr>
<td>SIN / COS / TAN / COT / ASIN / ACOS / ATAN</td>
<td>三角函数</td>
</tr>
</tbody></table>
<p>常用时间日期函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CURDATE / CURTIME / NOW</td>
<td>获取当前日期/时间/日期和时间</td>
</tr>
<tr>
<td>ADDDATE / SUBDATE</td>
<td>将两个日期表达式相加/相减并返回结果</td>
</tr>
<tr>
<td>DATE / TIME</td>
<td>从字符串中获取日期/时间</td>
</tr>
<tr>
<td>YEAR / MONTH / DAY</td>
<td>从日期中获取年/月/日</td>
</tr>
<tr>
<td>HOUR / MINUTE / SECOND</td>
<td>从时间中获取时/分/秒</td>
</tr>
<tr>
<td>DATEDIFF / TIMEDIFF</td>
<td>返回两个时间日期表达式相差多少天/小时</td>
</tr>
<tr>
<td>MAKEDATE / MAKETIME</td>
<td>制造一个日期/时间</td>
</tr>
</tbody></table>
<p>常用流程函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>IF</td>
<td>根据条件是否成立返回不同的值</td>
</tr>
<tr>
<td>IFNULL</td>
<td>如果为NULL则返回指定的值否则就返回本身</td>
</tr>
<tr>
<td>NULLIF</td>
<td>两个表达式相等就返回NULL否则返回第一个表达式的值</td>
</tr>
</tbody></table>
<p>其他常用函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>MD5 / SHA1 / SHA2</td>
<td>返回字符串对应的哈希摘要</td>
</tr>
<tr>
<td>CHARSET / COLLATION</td>
<td>返回字符集/校对规则</td>
</tr>
<tr>
<td>USER / CURRENT_USER</td>
<td>返回当前用户</td>
</tr>
<tr>
<td>DATABASE</td>
<td>返回当前数据库名</td>
</tr>
<tr>
<td>VERSION</td>
<td>返回当前数据库版本</td>
</tr>
<tr>
<td>FOUND_ROWS / ROW_COUNT</td>
<td>返回查询到的行数/受影响的行数</td>
</tr>
<tr>
<td>LAST_INSERT_ID</td>
<td>返回最后一个自增主键的值</td>
</tr>
<tr>
<td>UUID / UUID_SHORT</td>
<td>返回全局唯一标识符</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>DCL</p>
<pre><code class="SQL">-- 创建可以远程登录的root账号并为其指定口令
create user &#39;root&#39;@&#39;%&#39; identified by &#39;123456&#39;;

-- 为远程登录的root账号授权操作所有数据库所有对象的所有权限并允许其将权限再次赋予其他用户
grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; with grant option;

-- 创建名为hellokitty的用户并为其指定口令
create user &#39;hellokitty&#39;@&#39;%&#39; identified by &#39;123123&#39;;

-- 将对school数据库所有对象的所有操作权限授予hellokitty
grant all privileges on school.* to &#39;hellokitty&#39;@&#39;%&#39;;

-- 召回hellokitty对school数据库所有对象的insert/delete/update权限
revoke insert, delete, update on school.* from &#39;hellokitty&#39;@&#39;%&#39;;</code></pre>
<blockquote>
<p>说明：创建一个可以允许任意主机登录并且具有超级管理员权限的用户在现实中并不是一个明智的决定，因为一旦该账号的口令泄露或者被破解，数据库将会面临灾难级的风险。</p>
</blockquote>
</li>
</ol>
<h4 id="3-2-索引"><a href="#3-2-索引" class="headerlink" title="3.2 索引"></a>3.2 索引</h4><p>索引是关系型数据库中用来提升查询性能最为重要的手段。关系型数据库中的索引就像一本书的目录，我们可以想象一下，如果要从一本书中找出某个知识点，但是这本书没有目录，这将是意见多么可怕的事情（我们估计得一篇一篇的翻下去，才能确定这个知识点到底在什么位置）。创建索引虽然会带来存储空间上的开销，就像一本书的目录会占用一部分的篇幅一样，但是在牺牲空间后换来的查询时间的减少也是非常显著的。</p>
<p>MySQL中，所有数据类型的列都可以被索引，常用的存储引擎InnoDB和MyISAM能支持每个表创建16个索引。InnoDB和MyISAM使用的索引其底层算法是B-tree（B树），B-tree是一种自平衡的树，类似于平衡二叉排序树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的操作都在对数时间内完成。</p>
<p>接下来我们通过一个简单的例子来说明索引的意义，比如我们要根据学生的姓名来查找学生，这个场景在实际开发中应该经常遇到，就跟通过商品名称查找商品道理是一样的。我们可以使用MySQL的<code>explain</code>关键字来查看SQL的执行计划。</p>
<pre><code class="SQL">explain select * from tb_student where stuname=&#39;林震南&#39;\G</code></pre>
<pre><code>*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 11
     filtered: 10.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)</code></pre><p>在上面的SQL执行计划中，有几项值得我们关注：</p>
<ol>
<li>type：MySQL在表中找到满足条件的行的方式，也称为访问类型，包括：ALL（全表扫描）、index（索引全扫描）、range（索引范围扫描）、ref（非唯一索引扫描）、eq_ref（唯一索引扫描）、const/system、NULL。在所有的访问类型中，很显然ALL是性能最差的，它代表了全表扫描是指要扫描表中的每一行才能找到匹配的行。</li>
<li>possible_keys：MySQL可以选择的索引，但是<strong>有可能不会使用</strong>。</li>
<li>key：MySQL真正使用的索引。</li>
<li>rows：执行查询需要扫描的行数，这是一个<strong>预估值</strong>。</li>
</ol>
<p>从上面的执行计划可以看出，当我们通过学生名字查询学生时实际上是进行了全表扫描，不言而喻这个查询性能肯定是非常糟糕的，尤其是在表中的行很多的时候。如果我们需要经常通过学生姓名来查询学生，那么就应该在学生姓名对应的列上创建索引，通过索引来加速查询。</p>
<pre><code class="SQL">create index idx_student_name on tb_student(stuname);</code></pre>
<p>再次查看刚才的SQL对应的执行计划。</p>
<pre><code class="SQL">explain select * from tb_student where stuname=&#39;林震南&#39;\G</code></pre>
<pre><code>*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ref
possible_keys: idx_student_name
          key: idx_student_name
      key_len: 62
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)</code></pre><p>可以注意到，在对学生姓名创建索引后，刚才的查询已经不是全表扫描而是基于索引的查询，而且扫描的行只有唯一的一行，这显然大大的提升了查询的性能。MySQL中还允许创建前缀索引，即对索引字段的前N个字符创建索引，这样的话可以减少索引占用的空间（但节省了空间很有可能会浪费时间，<strong>时间和空间是不可调和的矛盾</strong>），如下所示。</p>
<pre><code class="SQL">create index idx_student_name_1 on tb_student(stuname(1));</code></pre>
<p>上面的索引相当于是根据学生姓名的第一个字来创建的索引，我们再看看SQL执行计划。</p>
<pre><code class="SQL">explain select * from tb_student where stuname=&#39;林震南&#39;\G</code></pre>
<pre><code>*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ref
possible_keys: idx_student_name
          key: idx_student_name
      key_len: 5
          ref: const
         rows: 2
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)</code></pre><p>不知道大家是否注意到，这一次扫描的行变成了2行，因为学生表中有两个姓“林”的学生，我们只用姓名的第一个字作为索引的话，在查询时通过索引就会找到这两行。</p>
<p>如果要删除索引，可以使用下面的SQL。</p>
<pre><code class="SQL">alter table tb_student drop index idx_student_name;</code></pre>
<p>或者</p>
<pre><code class="SQL">drop index idx_student_name on tb_student;</code></pre>
<p>我们简单的为大家总结一下索引的设计原则：</p>
<ol>
<li><strong>最适合</strong>索引的列是出现在<strong>WHERE子句</strong>和连接子句中的列。</li>
<li>索引列的基数越大（取值多重复值少），索引的效果就越好。</li>
<li>使用<strong>前缀索引</strong>可以减少索引占用的空间，内存中可以缓存更多的索引。</li>
<li><strong>索引不是越多越好</strong>，虽然索引加速了读操作（查询），但是写操作（增、删、改）都会变得更慢，因为数据的变化会导致索引的更新，就如同书籍章节的增删需要更新目录一样。</li>
<li>使用InnoDB存储引擎时，表的普通索引都会保存主键的值，所以<strong>主键要尽可能选择较短的数据类型</strong>，这样可以有效的减少索引占用的空间，利用提升索引的缓存效果。</li>
</ol>
<p>最后，还有一点需要说明，InnoDB使用的B-tree索引，数值类型的列除了等值判断时索引会生效之外，使用&gt;、&lt;、&gt;=、&lt;=、BETWEEN…AND… 、&lt;&gt;时，索引仍然生效；对于字符串类型的列，如果使用不以通配符开头的模糊查询，索引也是起作用的，但是其他的情况会导致索引失效，这就意味着很有可能会做全表查询。</p>
<h4 id="3-3-视图"><a href="#3-3-视图" class="headerlink" title="3.3 视图"></a>3.3 视图</h4><p>视图是关系型数据库中将一组查询指令构成的结果集组合成可查询的数据表的对象。简单的说，视图就是虚拟的表，但与数据表不同的是，数据表是一种实体结构，而视图是一种虚拟结构，你也可以将视图理解为保存在数据库中被赋予名字的SQL语句。</p>
<p>使用视图可以获得以下好处：</p>
<ol>
<li>可以将实体数据表隐藏起来，让外部程序无法得知实际的数据结构，让访问者可以使用表的组成部分而不是整个表，降低数据库被攻击的风险。</li>
<li>在大多数的情况下视图是只读的（更新视图的操作通常都有诸多的限制），外部程序无法直接透过视图修改数据。</li>
<li>重用SQL语句，将高度复杂的查询包装在视图表中，直接访问该视图即可取出需要的数据；也可以将视图视为数据表进行连接查询。</li>
<li>视图可以返回与实体数据表不同格式的数据，</li>
</ol>
<p>创建视图。</p>
<pre><code class="SQL">create view vw_score 
as 
    select sid, round(avg(score), 1) as avgscore from tb_record group by sid;

create view vw_student_score 
as 
    select stuname, avgscore 
        from tb_student, vw_score  
        where stuid=sid;</code></pre>
<blockquote>
<p><strong>提示</strong>：因为视图不包含数据，所以每次使用视图时，都必须执行查询以获得数据，如果你使用了连接查询、嵌套查询创建了较为复杂的视图，你可能会发现查询性能下降得很厉害。因此，在使用复杂的视图前，应该进行测试以确保其性能能够满足应用的需求。</p>
</blockquote>
<p>使用视图。</p>
<pre><code class="SQL">select stuname, avgscore from vw_student_score order by avgscore desc;</code></pre>
<pre><code>+--------------+----------+
| stuname      | avgscore |
+--------------+----------+
| 杨过         |     95.6 |
| 任我行       |     53.5 |
| 王语嫣       |     84.3 |
| 纪嫣然       |     73.8 |
| 岳不群       |     78.0 |
| 东方不败     |     88.0 |
| 项少龙       |     92.0 |
+--------------+----------+</code></pre><p>既然视图是一张虚拟的表，那么视图的中的数据可以更新吗？视图的可更新性要视具体情况而定，以下类型的视图是不能更新的：</p>
<ol>
<li>使用了聚合函数（SUM、MIN、MAX、AVG、COUNT等）、DISTINCT、GROUP BY、HAVING、UNION或者UNION ALL的视图。</li>
<li>SELECT中包含了子查询的视图。</li>
<li>FROM子句中包含了一个不能更新的视图的视图。</li>
<li>WHERE子句的子查询引用了FROM子句中的表的视图。</li>
</ol>
<p>删除视图。</p>
<pre><code class="SQL">drop view vw_student_score;</code></pre>
<blockquote>
<p><strong>说明</strong>：如果希望更新视图，可以先用上面的命令删除视图，也可以通过<code>create or replace view</code>来更新视图。</p>
</blockquote>
<p>视图的规则和限制。</p>
<ol>
<li>视图可以嵌套，可以利用从其他视图中检索的数据来构造一个新的视图。视图也可以和表一起使用。</li>
<li>创建视图时可以使用<code>order by</code>子句，但如果从视图中检索数据时也使用了<code>order by</code>，那么该视图中原先的<code>order by</code>会被覆盖。</li>
<li>视图无法使用索引，也不会激发触发器（实际开发中因为性能等各方面的考虑，通常不建议使用触发器，所以我们也不对这个概念进行介绍）的执行。</li>
</ol>
<h4 id="3-4-存储过程"><a href="#3-4-存储过程" class="headerlink" title="3.4 存储过程"></a>3.4 存储过程</h4><p>存储过程是事先编译好存储在数据库中的一组SQL的集合，调用存储过程可以简化应用程序开发人员的工作，减少与数据库服务器之间的通信，对于提升数据操作的性能也是有帮助的。其实迄今为止，我们使用的SQL语句都是针对一个或多个表的单条语句，但在实际开发中经常会遇到某个操作需要多条SQL语句才能完成的情况。例如，电商网站在受理用户订单时，需要做以下一系列的处理。 </p>
<ol>
<li>通过查询来核对库存中是否有对应的物品以及库存是否充足。</li>
<li>如果库存有物品，需要锁定库存以确保这些物品不再卖给别人， 并且要减少可用的物品数量以反映正确的库存量。</li>
<li>如果库存不足，可能需要进一步与供应商进行交互或者至少产生一条系统提示消息。 </li>
<li>不管受理订单是否成功，都需要产生流水记录，而且需要给对应的用户产生一条通知信息。 </li>
</ol>
<p>我们可以通过存储过程将复杂的操作封装起来，这样不仅有助于保证数据的一致性，而且将来如果业务发生了变动，只需要调整和修改存储过程即可。对于调用存储过程的用户来说，存储过程并没有暴露数据表的细节，而且执行存储过程比一条条的执行一组SQL要快得多。</p>
<p>下面的存储过程实现了查询某门课程的最高分、最低分和平均分。</p>
<pre><code class="SQL">drop procedure if exists sp_score_by_cid;

delimiter $$

create procedure sp_score_by_cid(
    courseId int, 
    out maxScore decimal(4,1), 
    out minScore decimal(4,1),
    out avgScore decimal(4,1)
)
begin
    select max(score) into maxScore from tb_record 
        where cid=courseId;
    select min(score) into minScore from tb_record 
        where cid=courseId;
    select avg(score) into avgScore from tb_record 
        where cid=courseId;
end $$

delimiter ;

call sp_score_by_cid(1111, @a, @b, @c);
select @a, @b, @c;</code></pre>
<blockquote>
<p>说明：在定义存储过程时，因为可能需要书写多条SQL，而分隔这些SQL需要使用分号作为分隔符，如果这个时候，仍然用分号表示整段代码结束，那么定义存储过程的SQL就会出现错误，所以上面我们用<code>delimiter $$</code>将整段代码结束的标记定义为<code>$$</code>，那么代码中的分号将不再表示整段代码的结束，需要马上执行，整段代码在遇到<code>end $$</code>时才输入完成并执行。在定义完存储过程后，通过<code>delimiter ;</code>将结束符重新改回成分号。</p>
</blockquote>
<p>上面定义的存储过程有四个参数，其中第一个参数是输入参数，代表课程的编号，后面的参数都是输出参数，因为存储过程不能定义返回值，只能通过输出参数将执行结果带出，定义输出参数的关键字是<code>out</code>，默认情况下参数都是输入参数。</p>
<p>调用存储过程。</p>
<pre><code class="SQL">call sp_score_by_cid(1111, @a, @b, @c);</code></pre>
<p>获取输出参数的值。</p>
<pre><code class="SQL">select @a as 最高分, @b as 最低分, @c as 平均分;</code></pre>
<p>删除存储过程。</p>
<pre><code class="SQL">drop procedure sp_score_by_cid;</code></pre>
<p>在存储过程中，我们可以定义变量、条件，可以使用分支和循环语句，可以通过游标操作查询结果，还可以使用事件调度器，这些内容我们暂时不在此处进行介绍。虽然我们说了很多存储过程的好处，但是在实际开发中，如果过度的使用存储过程，将大量复杂的运算放到存储过程中，也会导致占用数据库服务器的CPU资源，造成数据库服务器承受巨大的压力。为此，我们一般会将复杂的运算和处理交给应用服务器，因为很容易部署多台应用服务器来分摊这些压力。</p>
<h3 id="四：-几个重要的概念"><a href="#四：-几个重要的概念" class="headerlink" title="四： 几个重要的概念"></a>四： 几个重要的概念</h3><h4 id="4-1-范式理论-设计二维表的指导思想"><a href="#4-1-范式理论-设计二维表的指导思想" class="headerlink" title="4.1 范式理论 - 设计二维表的指导思想"></a>4.1 范式理论 - 设计二维表的指导思想</h4><ol>
<li>第一范式：数据表的每个列的值域都是由原子值组成的，不能够再分割。</li>
<li>第二范式：数据表里的所有数据都要和该数据表的键（主键与候选键）有完全依赖关系。</li>
<li>第三范式：所有非键属性都只和候选键有相关性，也就是说非键属性之间应该是独立无关的。</li>
</ol>
<h4 id="4-2-数据完整性"><a href="#4-2-数据完整性" class="headerlink" title="4.2 数据完整性"></a>4.2 数据完整性</h4><ol>
<li><p>实体完整性 - 每个实体都是独一无二的</p>
<ul>
<li>主键（primary key） / 唯一约束 / 唯一索引（unique）</li>
</ul>
</li>
<li><p>引用完整性（参照完整性）- 关系中不允许引用不存在的实体</p>
<ul>
<li>外键（foreign key）</li>
</ul>
</li>
<li><p>域完整性 - 数据是有效的</p>
<ul>
<li><p>数据类型及长度</p>
</li>
<li><p>非空约束（not null）</p>
</li>
<li><p>默认值约束（default）</p>
</li>
<li><p>检查约束（check）</p>
<blockquote>
<p>说明：在MySQL数据库中，检查约束并不起作用。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="4-3-数据一致性"><a href="#4-3-数据一致性" class="headerlink" title="4.3 数据一致性"></a>4.3 数据一致性</h4><ol>
<li><p>事务：一系列对数据库进行读/写的操作，这些操作要么全都成功，要么全都失败。</p>
</li>
<li><p>事务的ACID特性</p>
<ul>
<li>原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行</li>
<li>一致性：事务应确保数据库的状态从一个一致状态转变为另一个一致状态</li>
<li>隔离性：多个事务并发执行时，一个事务的执行不应影响其他事务的执行</li>
<li>持久性：已被提交的事务对数据库的修改应该永久保存在数据库中</li>
</ul>
</li>
<li><p>MySQL中的事务操作</p>
<ul>
<li><p>开启事务环境</p>
<pre><code class="SQL">start transaction</code></pre>
<p>或</p>
<pre><code class="SQL">begin</code></pre>
</li>
<li><p>提交事务</p>
<pre><code class="SQL">commit</code></pre>
</li>
<li><p>回滚事务</p>
<pre><code class="SQL">rollback</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="五：-其他内容"><a href="#五：-其他内容" class="headerlink" title="五： 其他内容"></a>五： 其他内容</h3><p>大家应该能够想到，关于MySQL的知识肯定远远不止上面列出的这些，比如MySQL的性能优化、管理和维护MySQL的相关工具、MySQL数据的备份和恢复、监控MySQL、部署高可用架构等问题我们在这里都没有进行讨论。当然，这些内容也都是跟项目开发密切相关的，我们就留到后续的章节中再续点进行讲解。</p>
<h3 id="六：-Python数据库编程"><a href="#六：-Python数据库编程" class="headerlink" title="六： Python数据库编程"></a>六： Python数据库编程</h3><p>我们用如下所示的数据库来演示在Python中如何访问MySQL数据库。</p>
<pre><code class="SQL">drop database if exists hrs;
create database hrs default charset utf8;

use hrs;

drop table if exists tb_emp;
drop table if exists tb_dept;

create table tb_dept
(
dno   int not null comment &#39;编号&#39;,
dname varchar(10) not null comment &#39;名称&#39;,
dloc  varchar(20) not null comment &#39;所在地&#39;,
primary key (dno)
);

insert into tb_dept values 
    (10, &#39;会计部&#39;, &#39;北京&#39;),
    (20, &#39;研发部&#39;, &#39;成都&#39;),
    (30, &#39;销售部&#39;, &#39;重庆&#39;),
    (40, &#39;运维部&#39;, &#39;深圳&#39;);

create table tb_emp
(
eno   int not null comment &#39;员工编号&#39;,
ename varchar(20) not null comment &#39;员工姓名&#39;,
job   varchar(20) not null comment &#39;员工职位&#39;,
mgr   int comment &#39;主管编号&#39;,
sal   int not null comment &#39;员工月薪&#39;,
comm  int comment &#39;每月补贴&#39;,
dno   int comment &#39;所在部门编号&#39;,
primary key (eno)
);

alter table tb_emp add constraint fk_emp_dno foreign key (dno) references tb_dept (dno);

insert into tb_emp values 
    (7800, &#39;张三丰&#39;, &#39;总裁&#39;, null, 9000, 1200, 20),
    (2056, &#39;乔峰&#39;, &#39;分析师&#39;, 7800, 5000, 1500, 20),
    (3088, &#39;李莫愁&#39;, &#39;设计师&#39;, 2056, 3500, 800, 20),
    (3211, &#39;张无忌&#39;, &#39;程序员&#39;, 2056, 3200, null, 20),
    (3233, &#39;丘处机&#39;, &#39;程序员&#39;, 2056, 3400, null, 20),
    (3251, &#39;张翠山&#39;, &#39;程序员&#39;, 2056, 4000, null, 20),
    (5566, &#39;宋远桥&#39;, &#39;会计师&#39;, 7800, 4000, 1000, 10),
    (5234, &#39;郭靖&#39;, &#39;出纳&#39;, 5566, 2000, null, 10),
    (3344, &#39;黄蓉&#39;, &#39;销售主管&#39;, 7800, 3000, 800, 30),
    (1359, &#39;胡一刀&#39;, &#39;销售员&#39;, 3344, 1800, 200, 30),
    (4466, &#39;苗人凤&#39;, &#39;销售员&#39;, 3344, 2500, null, 30),
    (3244, &#39;欧阳锋&#39;, &#39;程序员&#39;, 3088, 3200, null, 20),
    (3577, &#39;杨过&#39;, &#39;会计&#39;, 5566, 2200, null, 10),
    (3588, &#39;朱九真&#39;, &#39;会计&#39;, 5566, 2500, null, 10);</code></pre>
<p>在Python 3中，我们通常使用纯Python的三方库PyMySQL来访问MySQL数据库，它应该是目前Python操作MySQL数据库最好的选择。</p>
<ol>
<li><p>安装PyMySQL。</p>
<pre><code class="Shell">pip install pymysql</code></pre>
</li>
<li><p>添加一个部门。</p>
<pre><code class="Python">import pymysql

</code></pre>
</li>
</ol>
<p>   def main():<br>       no = int(input(‘编号: ‘))<br>       name = input(‘名字: ‘)<br>       loc = input(‘所在地: ‘)<br>       # 1. 创建数据库连接对象<br>       con = pymysql.connect(host=’localhost’, port=3306,<br>                             database=’hrs’, charset=’utf8’,<br>                             user=’yourname’, password=’yourpass’)<br>       try:<br>           # 2. 通过连接对象获取游标<br>           with con.cursor() as cursor:<br>               # 3. 通过游标执行SQL并获得执行结果<br>               result = cursor.execute(<br>                   ‘insert into tb_dept values (%s, %s, %s)’,<br>                   (no, name, loc)<br>               )<br>           if result == 1:<br>               print(‘添加成功!’)<br>           # 4. 操作成功提交事务<br>           con.commit()<br>       finally:<br>           # 5. 关闭连接释放资源<br>           con.close()</p>
<p>   if <strong>name</strong> == ‘<strong>main</strong>‘:<br>       main()</p>
<pre><code>
3. 删除一个部门。

   ```Python
   import pymysql


   def main():
       no = int(input(&#39;编号: &#39;))
       con = pymysql.connect(host=&#39;localhost&#39;, port=3306,
                             database=&#39;hrs&#39;, charset=&#39;utf8&#39;,
                             user=&#39;yourname&#39;, password=&#39;yourpass&#39;,
                             autocommit=True)
       try:
           with con.cursor() as cursor:
               result = cursor.execute(
                   &#39;delete from tb_dept where dno=%s&#39;,
                   (no, )
               )
           if result == 1:
               print(&#39;删除成功!&#39;)
       finally:
           con.close()


   if __name__ == &#39;__main__&#39;:
       main()</code></pre><blockquote>
<p>说明：如果不希望每次SQL操作之后手动提交或回滚事务，可以像上面的代码那样，在创建连接的时候多加一个名为<code>autocommit</code>的参数并将它的值设置为<code>True</code>，表示每次执行SQL之后自动提交。如果程序中不需要使用事务环境也不希望手动的提交或回滚就可以这么做。</p>
</blockquote>
<ol start="4">
<li><p>更新一个部门。</p>
<pre><code class="Python">import pymysql

</code></pre>
</li>
</ol>
<p>   def main():<br>       no = int(input(‘编号: ‘))<br>       name = input(‘名字: ‘)<br>       loc = input(‘所在地: ‘)<br>       con = pymysql.connect(host=’localhost’, port=3306,<br>                             database=’hrs’, charset=’utf8’,<br>                             user=’yourname’, password=’yourpass’,<br>                             autocommit=True)<br>       try:<br>           with con.cursor() as cursor:<br>               result = cursor.execute(<br>                   ‘update tb_dept set dname=%s, dloc=%s where dno=%s’,<br>                   (name, loc, no)<br>               )<br>           if result == 1:<br>               print(‘更新成功!’)<br>       finally:<br>           con.close()</p>
<p>   if <strong>name</strong> == ‘<strong>main</strong>‘:<br>       main()</p>
<pre><code>
5. 查询所有部门。

   ```Python
   import pymysql
   from pymysql.cursors import DictCursor


   def main():
       con = pymysql.connect(host=&#39;localhost&#39;, port=3306,
                             database=&#39;hrs&#39;, charset=&#39;utf8&#39;,
                             user=&#39;yourname&#39;, password=&#39;yourpass&#39;)
       try:
           with con.cursor(cursor=DictCursor) as cursor:
               cursor.execute(&#39;select dno as no, dname as name, dloc as loc from tb_dept&#39;)
               results = cursor.fetchall()
               print(results)
               print(&#39;编号\t名称\t\t所在地&#39;)
               for dept in results:
                   print(dept[&#39;no&#39;], end=&#39;\t&#39;)
                   print(dept[&#39;name&#39;], end=&#39;\t&#39;)
                   print(dept[&#39;loc&#39;])
       finally:
           con.close()


   if __name__ == &#39;__main__&#39;:
       main()</code></pre><ol start="6">
<li><p>分页查询员工信息。</p>
<pre><code class="Python">import pymysql
from pymysql.cursors import DictCursor

</code></pre>
</li>
</ol>
<p>   class Emp(object):</p>
<pre><code>   def __init__(self, no, name, job, sal):
       self.no = no
       self.name = name
       self.job = job
       self.sal = sal

   def __str__(self):
       return f&#39;\n编号：{self.no}\n姓名：{self.name}\n职位：{self.job}\n月薪：{self.sal}\n&#39;</code></pre><p>   def main():<br>       page = int(input(‘页码: ‘))<br>       size = int(input(‘大小: ‘))<br>       con = pymysql.connect(host=’localhost’, port=3306,<br>                             database=’hrs’, charset=’utf8’,<br>                             user=’yourname’, password=’yourpass’)<br>       try:<br>           with con.cursor() as cursor:<br>               cursor.execute(<br>                   ‘select eno as no, ename as name, job, sal from tb_emp limit %s,%s’,<br>                   ((page - 1) * size, size)<br>               )<br>               for emp_tuple in cursor.fetchall():<br>                   emp = Emp(*emp_tuple)<br>                   print(emp)<br>       finally:<br>           con.close()</p>
<p>   if <strong>name</strong> == ‘<strong>main</strong>‘:<br>       main()</p>
<pre><code></code></pre>]]></content>
      <categories>
        <category>读书笔记</category>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转Linux操作系统</title>
    <url>/2020/02/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/%E7%8E%A9%E8%BD%ACLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<blockquote>
<p><strong>本文转载于GitHub项目<a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">Python - 100天从新手到大师</a></strong></p>
</blockquote>
<blockquote>
<p>说明：本文中对Linux命令的讲解都是基于名为CentOS的Linux发行版本，我自己使用的是阿里云服务器，系统版本为CentOS Linux release 7.6.1810。不同的Linux发行版本在Shell命令和工具程序上会有一些差别，但是这些差别是很小的。</p>
</blockquote>
<h3 id="一：-操作系统发展史"><a href="#一：-操作系统发展史" class="headerlink" title="一： 操作系统发展史"></a>一： 操作系统发展史</h3><p>只有硬件没有软件的计算机系统被称之为“裸机”，我们很难用“裸机”来完成计算机日常的工作（如存储和运算），所以必须用特定的软件来控制硬件的工作。最靠近计算机硬件的软件是系统软件，其中最为重要的就是“操作系统”。“操作系统”是控制和管理整个计算机硬件和软件资源、实现资源分配和任务调配、为系统用户以及其他软件提供接口和环境的程序的集合。</p>
<h4 id="1-1-没有操作系统（手工操作）"><a href="#1-1-没有操作系统（手工操作）" class="headerlink" title="1.1 没有操作系统（手工操作）"></a>1.1 没有操作系统（手工操作）</h4><p>在计算机诞生之初没有操作系统的年代，人们先把程序纸带（或卡片）装上计算机，然后启动输入机把程序送入计算机，接着通过控制台开关启动程序运行。当程序执行完毕，打印机输出计算的结果，用户卸下并取走纸带（或卡片）。第二个用户上机，重复同样的步骤。在整个过程中用户独占机器，CPU等待手工操作，资源利用率极低。</p>
<h4 id="1-2-批处理系统"><a href="#1-2-批处理系统" class="headerlink" title="1.2 批处理系统"></a>1.2 批处理系统</h4><p>首先启动计算机上的一个监督程序，在监督程序的控制下，计算机能够自动的、成批的处理一个或多个用户的作业。完成一批作业后，监督程度又从输入机读取作业存入磁带机。按照上面的步骤重复处理任务。监督程序不停的处理各个作业，实现了作业的自动转接，减少了作业的建立时间和手工操作时间，提高了计算机资源的利用率。 批处理系统又可以分为单道批处理系统、多道批处理系统、联机批处理系统、脱机批处理系统。</p>
<h4 id="1-3-分时系统和实时系统"><a href="#1-3-分时系统和实时系统" class="headerlink" title="1.3 分时系统和实时系统"></a>1.3 分时系统和实时系统</h4><p>分时系统是把处理器的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。 若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时中断，把处理机让给另一作业使用，等待下一轮调度时再继续其运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的感觉是他独占了一台计算机。而每个用户可以通过自己的终端向系统发出各种操作控制命令，在充分的人机交互情况下，完成作业的运行。为了解决分时系统不能及时响应用户指令的情况，又出现了能够在在严格的时间范围内完成事件处理，及时响应随机外部事件的实时系统。</p>
<h4 id="1-4-通用操作系统"><a href="#1-4-通用操作系统" class="headerlink" title="1.4 通用操作系统"></a>1.4 通用操作系统</h4><ol>
<li><p>1960s：IBM的System/360系列的机器有了统一的操作系统OS/360。</p>
</li>
<li><p>1965年：AT&amp;T的贝尔实验室加入GE和MIT的合作计划开始开发MULTICS。</p>
</li>
<li><p>1969年：MULTICS项目失败，Ken Tompson赋闲在家，为了玩“Space Travel”游戏用汇编语言在当时已经被淘汰的PDP-7上开发了Unics。</p>
<blockquote>
<p>注：很难想象，Unix这么伟大的系统，居然是一个赋闲在家的程序员（关键是老婆回娘家还带上了孩子）在一台被淘汰的设备上为了玩游戏开发出来的。</p>
</blockquote>
</li>
<li><p>1970年~1971年：Ken Tompson和Dennis Ritchie用B语言在PDP-11上重写了Unics，并在Brian Kernighan的建议下将其更名为Unix。</p>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/ken-and-dennis-pdp-11.png" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p>1972年~1973年：Dennis Ritchie发明了C语言来取代可移植性较差的B语言，并开启了用C语言重写Unix的工作。</p>
</li>
<li><p>1974年：Unix推出了里程碑意义的第5版，几乎完全用C语言来实现。</p>
</li>
<li><p>1979年：从Unix第7版开始，AT&amp;T发布新的使用条款，将Unix私有化。</p>
</li>
<li><p>1987年：Andrew S. Tanenbaum教授为了能在课堂上为学生讲解操作系统运作的细节，决定在不使用任何AT&amp;T的源代码前提下，自行开发与Unix兼容的操作系统以避免版权上的争议，该系统被命名为Minix。</p>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/andrew.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p>1991年：Linus Torvalds就读于芬兰赫尔辛基大学期间，尝试在Minix上做一些开发工作，但因为Minix只是作为教学用途的操作系统，功能并不强大，为了方便在学校的新闻组和邮件系统中读写和下载文件，Linus编写了磁盘驱动程序和文件系统，这些东西形成了Linux系统内核的雏形。</p>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/linus.png" srcset="/img/loading.gif" alt=""></p>
</li>
</ol>
<p>下图是Unix操作系统家族的图谱。</p>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/history-of-unix.png" srcset="/img/loading.gif" alt=""></p>
<h3 id="二：-Linux概述"><a href="#二：-Linux概述" class="headerlink" title="二： Linux概述"></a>二： Linux概述</h3><p>Linux是一个通用操作系统。一个操作系统要负责任务调度、内存分配、处理外围设备I/O等操作。操作系统通常由内核（运行其他程序，管理像磁盘、打印机等硬件设备的核心程序）和系统程序（设备驱动、底层库、shell、服务程序等）两部分组成。</p>
<p>Linux内核是芬兰人Linus Torvalds开发的，于1991年9月发布。而Linux操作系统作为Internet时代的产物，它是由全世界许多开发者共同合作开发的，是一个自由的操作系统（注意自由和免费并不是同一个概念，想了解二者的差别可以<a href="https://www.debian.org/intro/free" target="_blank" rel="noopener">点击这里</a>）。</p>
<h3 id="三：-Linux系统优点"><a href="#三：-Linux系统优点" class="headerlink" title="三： Linux系统优点"></a>三： Linux系统优点</h3><ol>
<li>通用操作系统，不跟特定的硬件绑定。</li>
<li>用C语言编写，可移植性强，有内核编程接口。</li>
<li>支持多用户和多任务，支持安全的分层文件系统。</li>
<li>大量的实用程序，完善的网络功能以及强大的支持文档。</li>
<li>可靠的安全性和良好的稳定性，对开发者更友好。</li>
</ol>
<h3 id="四：-Linux系统发行版本"><a href="#四：-Linux系统发行版本" class="headerlink" title="四： Linux系统发行版本"></a>四： Linux系统发行版本</h3><ol>
<li><a href="https://www.redhat.com/en" target="_blank" rel="noopener">Redhat</a></li>
<li><a href="https://www.ubuntu.com/" target="_blank" rel="noopener">Ubuntu</a></li>
<li><a href="https://www.centos.org/" target="_blank" rel="noopener">CentOS</a></li>
<li><a href="https://getfedora.org/" target="_blank" rel="noopener">Fedora</a></li>
<li><a href="https://www.debian.org/" target="_blank" rel="noopener">Debian</a></li>
<li><a href="https://www.opensuse.org/" target="_blank" rel="noopener">openSUSE</a></li>
</ol>
<h3 id="五：-基础命令"><a href="#五：-基础命令" class="headerlink" title="五： 基础命令"></a>五： 基础命令</h3><p>Linux系统的命令通常都是如下所示的格式：</p>
<pre><code class="Shell">命令名称 [命名参数] [命令对象]</code></pre>
<ol>
<li><p>获取登录信息 - <strong>w</strong> / <strong>who</strong> / <strong>last</strong>/ <strong>lastb</strong>。</p>
<pre><code class="Shell">[root ~]# w
 23:31:16 up 12:16,  2 users,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    182.139.66.250   23:03    4.00s  0.02s  0.00s w
jackfrue pts/1    182.139.66.250   23:26    3:56   0.00s  0.00s -bash
[root ~]# who
root     pts/0        2018-04-12 23:03 (182.139.66.250)
jackfrued pts/1        2018-04-12 23:26 (182.139.66.250)
[root ~]# who am i
root     pts/0        2018-04-12 23:03 (182.139.66.250)
[root ~]# who mom likes
root     pts/0        2018-04-12 23:03 (182.139.66.250)
[root ~]# last
root     pts/0        117.136.63.184   Sun May 26 18:57   still logged in   
reboot   system boot  3.10.0-957.10.1. Mon May 27 02:52 - 19:10  (-7:-42)   
root     pts/4        117.136.63.184   Sun May 26 18:51 - crash  (08:01)    
root     pts/4        117.136.63.184   Sun May 26 18:49 - 18:49  (00:00)    
root     pts/3        117.136.63.183   Sun May 26 18:35 - crash  (08:17)    
root     pts/2        117.136.63.183   Sun May 26 18:34 - crash  (08:17)    
root     pts/0        117.136.63.183   Sun May 26 18:10 - crash  (08:42)    </code></pre>
</li>
<li><p>查看自己使用的Shell - <strong>ps</strong>。</p>
<p>Shell也被称为“壳”或“壳程序”，它是用户与操作系统内核交流的翻译官，简单的说就是人与计算机交互的界面和接口。目前很多Linux系统默认的Shell都是bash（<u>B</u>ourne <u>A</u>gain <u>SH</u>ell），因为它可以使用tab键进行命令和路径补全、可以保存历史命令、可以方便的配置环境变量以及执行批处理操作。</p>
<pre><code class="Shell">[root ~]# ps
  PID TTY          TIME CMD
 3531 pts/0    00:00:00 bash
 3553 pts/0    00:00:00 ps</code></pre>
</li>
<li><p>查看命令的说明和位置 - <strong>whatis</strong> / <strong>which</strong> / <strong>whereis</strong>。</p>
<pre><code class="Shell">[root ~]# whatis ps
ps (1)        - report a snapshot of the current processes.
[root ~]# whatis python
python (1)    - an interpreted, interactive, object-oriented programming language
[root ~]# whereis ps
ps: /usr/bin/ps /usr/share/man/man1/ps.1.gz
[root ~]# whereis python
python: /usr/bin/python /usr/bin/python2.7 /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz
[root ~]# which ps
/usr/bin/ps
[root ~]# which python
/usr/bin/python</code></pre>
</li>
<li><p>清除屏幕上显示的内容 - <strong>clear</strong>。</p>
</li>
<li><p>查看帮助文档 - <strong>man</strong> / <strong>info</strong> / <strong>help</strong> / <strong>apropos</strong>。</p>
<pre><code class="Shell">[root@izwz97tbgo9lkabnat2lo8z ~]# ps --help
Usage:
 ps [options]
 Try &#39;ps --help &lt;simple|list|output|threads|misc|all&gt;&#39;
  or &#39;ps --help &lt;s|l|o|t|m|a&gt;&#39;
 for additional help text.
For more details see ps(1).
[root@izwz97tbgo9lkabnat2lo8z ~]# man ps
PS(1)                                User Commands                                PS(1)
NAME
       ps - report a snapshot of the current processes.
SYNOPSIS
       ps [options]
DESCRIPTION
...</code></pre>
</li>
<li><p>查看系统和主机名 - <strong>uname</strong> / <strong>hostname</strong>。</p>
<pre><code class="Shell">[root@izwz97tbgo9lkabnat2lo8z ~]# uname
Linux
[root@izwz97tbgo9lkabnat2lo8z ~]# hostname
izwz97tbgo9lkabnat2lo8z
[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat /etc/centos-release
CentOS Linux release 7.6.1810 (Core)</code></pre>
<blockquote>
<p>说明：<code>cat</code>是连接文件内容并打印到标准输出的命令，后面会讲到该命令；<code>/etc</code>是Linux系统上的一个非常重要的目录，它保存了很多的配置文件；<code>centos-release</code>是该目录下的一个文件，因为我自己使用的Linux发行版本是CentOS 7.6，因此这里会有一个这样的文件。</p>
</blockquote>
</li>
<li><p>时间和日期 - <strong>date</strong> / <strong>cal</strong>。</p>
<pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# date
Wed Jun 20 12:53:19 CST 2018
[root@iZwz97tbgo9lkabnat2lo8Z ~]# cal
      June 2018
Su Mo Tu We Th Fr Sa
                1  2
 3  4  5  6  7  8  9
10 11 12 13 14 15 16
17 18 19 20 21 22 23
24 25 26 27 28 29 30
[root@iZwz97tbgo9lkabnat2lo8Z ~]# cal 5 2017
      May 2017
Su Mo Tu We Th Fr Sa
    1  2  3  4  5  6
 7  8  9 10 11 12 13
14 15 16 17 18 19 20
21 22 23 24 25 26 27
28 29 30 31</code></pre>
</li>
<li><p>重启和关机 - <strong>reboot</strong> / <strong>shutdown</strong>。</p>
<pre><code class="Shell">[root ~]# shutdown -h +5
Shutdown scheduled for Sun 2019-05-26 19:34:27 CST, use &#39;shutdown -c&#39; to cancel.
[root ~]# 
Broadcast message from root (Sun 2019-05-26 19:29:27 CST):

The system is going down for power-off at Sun 2019-05-26 19:34:27 CST!
[root ~]# shutdown -c

Broadcast message from root (Sun 2019-05-26 19:30:22 CST):

The system shutdown has been cancelled at Sun 2019-05-26 19:31:22 CST!
[root ~]# shutdown -r 23:58
Shutdown scheduled for Sun 2019-05-26 23:58:00 CST, use &#39;shutdown -c&#39; to cancel.
[root ~]# shutdown -c

Broadcast message from root (Sun 2019-05-26 19:31:06 CST):

The system shutdown has been cancelled at Sun 2019-05-26 19:32:06 CST!</code></pre>
<blockquote>
<p>说明：在执行<code>shutdown</code>命令时会向登录系统的用户发出警告，可以在命令后面跟上警告消息来替换默认的警告消息，也可以在<code>-h</code>参数后通过<code>now</code>来表示立刻关机。</p>
</blockquote>
</li>
<li><p>退出登录 -  <strong>exit</strong> / <strong>logout</strong>。</p>
</li>
<li><p>查看历史命令 - <strong>history</strong>。</p>
<pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# history
...
452  ls
453  cd Python-3.6.5/
454  clear
455  history
[root@iZwz97tbgo9lkabnat2lo8Z ~]# !454</code></pre>
<blockquote>
<p>说明：查看到历史命令之后，可以用<code>!历史命令编号</code>来重新执行该命令；通过<code>history -c</code>可以清除历史命令。</p>
</blockquote>
</li>
</ol>
<h3 id="六：-实用程序"><a href="#六：-实用程序" class="headerlink" title="六： 实用程序"></a>六： 实用程序</h3><h4 id="6-1-文件和文件夹操作"><a href="#6-1-文件和文件夹操作" class="headerlink" title="6.1 文件和文件夹操作"></a>6.1 文件和文件夹操作</h4><ol>
<li><p>创建/删除空目录 - <strong>mkdir</strong> / <strong>rmdir</strong>。</p>
<pre><code class="Shell">[root ~]# mkdir abc
[root ~]# mkdir -p xyz/abc
[root ~]# rmdir abc</code></pre>
</li>
<li><p>创建/删除文件 - <strong>touch</strong> / <strong>rm</strong>。</p>
<pre><code class="Shell">[root ~]# touch readme.txt
[root ~]# touch error.txt
[root ~]# rm error.txt
rm: remove regular empty file ‘error.txt’? y
[root ~]# rm -rf xyz</code></pre>
<ul>
<li><code>touch</code>命令用于创建空白文件或修改文件时间。在Linux系统中一个文件有三种时间：<ul>
<li>更改内容的时间 - mtime。</li>
<li>更改权限的时间 - ctime。</li>
<li>最后访问时间 - atime。</li>
</ul>
</li>
<li><code>rm</code>的几个重要参数：<ul>
<li><code>-i</code>：交互式删除，每个删除项都会进行询问。</li>
<li><code>-r</code>：删除目录并递归的删除目录中的文件和目录。</li>
<li><code>-f</code>：强制删除，忽略不存在的文件，没有任何提示。</li>
</ul>
</li>
</ul>
</li>
<li><p>切换和查看当前工作目录 - <strong>cd</strong> / <strong>pwd</strong>。</p>
<blockquote>
<p>说明：<code>cd</code>命令后面可以跟相对路径（以当前路径作为参照）或绝对路径（以<code>/</code>开头）来切换到指定的目录，也可以用<code>cd ..</code>来返回上一级目录。请大家想一想，如果要返回到上上一级目录应该给<code>cd</code>命令加上什么样的参数呢？</p>
</blockquote>
</li>
<li><p>查看目录内容 - <strong>ls</strong>。</p>
<ul>
<li><code>-l</code>：以长格式查看文件和目录。</li>
<li><code>-a</code>：显示以点开头的文件和目录（隐藏文件）。</li>
<li><code>-R</code>：遇到目录要进行递归展开（继续列出目录下面的文件和目录）。</li>
<li><code>-d</code>：只列出目录，不列出其他内容。</li>
<li><code>-S</code> / <code>-t</code>：按大小/时间排序。</li>
</ul>
</li>
<li><p>查看文件内容 - <strong>cat</strong> / <strong>tac</strong> / <strong>head</strong> / <strong>tail</strong> / <strong>more</strong> / <strong>less</strong> / <strong>rev</strong> / <strong>od</strong>。</p>
<pre><code class="Shell">[root ~]# wget http://www.sohu.com/ -O sohu.html
--2018-06-20 18:42:34--  http://www.sohu.com/
Resolving www.sohu.com (www.sohu.com)... 14.18.240.6
Connecting to www.sohu.com (www.sohu.com)|14.18.240.6|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 212527 (208K) [text/html]
Saving to: ‘sohu.html’
100%[==================================================&gt;] 212,527     --.-K/s   in 0.03s
2018-06-20 18:42:34 (7.48 MB/s) - ‘sohu.html’ saved [212527/212527]
[root ~]# cat sohu.html
...
[root ~]# head -10 sohu.html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;搜狐&lt;/title&gt;
&lt;meta name=&quot;Keywords&quot; content=&quot;搜狐,门户网站,新媒体,网络媒体,新闻,财经,体育,娱乐,时尚,汽车,房产,科技,图片,论坛,微博,博客,视频,电影,电视剧&quot;/&gt;
&lt;meta name=&quot;Description&quot; content=&quot;搜狐网为用户提供24小时不间断的最新资讯，及搜索、邮件等网络服务。内容包括全球热点事件、突发新闻、时事评论、热播影视剧、体育赛事、行业动态、生活服务信息，以及论坛、博客、微博、我的搜狐等互动空间。&quot; /&gt;
&lt;meta name=&quot;shenma-site-verification&quot; content=&quot;1237e4d02a3d8d73e96cbd97b699e9c3_1504254750&quot;&gt;
&lt;meta charset=&quot;utf-8&quot;/&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;/&gt;
[root ~]# tail -2 sohu.html
&lt;/body&gt;
&lt;/html&gt;
[root ~]# less sohu.html
...
[root ~]# cat -n sohu.html | more
...</code></pre>
<blockquote>
<p>说明：上面用到了一个名为<code>wget</code>的命令，它是一个网络下载器程序，可以从指定的URL下载资源。</p>
</blockquote>
</li>
<li><p>拷贝/移动文件 - <strong>cp</strong> / <strong>mv</strong>。</p>
<pre><code class="Shell">[root ~]# mkdir backup
[root ~]# cp sohu.html backup/
[root ~]# cd backup
[root backup]# ls
sohu.html
[root backup]# mv sohu.html sohu_index.html
[root backup]# ls
sohu_index.html</code></pre>
</li>
<li><p>文件重命名 - <strong>rename</strong>。</p>
<pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# rename .htm .html *.htm</code></pre>
</li>
<li><p>查找文件和查找内容 - <strong>find</strong> / <strong>grep</strong>。</p>
<pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# find / -name &quot;*.html&quot;
/root/sohu.html
/root/backup/sohu_index.html
[root@izwz97tbgo9lkabnat2lo8z ~]# find . -atime 7 -type f -print
[root@izwz97tbgo9lkabnat2lo8z ~]# find . -type f -size +2k
[root@izwz97tbgo9lkabnat2lo8z ~]# find . -type f -name &quot;*.swp&quot; -delete
[root@iZwz97tbgo9lkabnat2lo8Z ~]# grep &quot;&lt;script&gt;&quot; sohu.html -n
20:&lt;script&gt;
[root@iZwz97tbgo9lkabnat2lo8Z ~]# grep -E \&lt;\/?script.*\&gt; sohu.html -n
20:&lt;script&gt;
22:&lt;/script&gt;
24:&lt;script src=&quot;//statics.itc.cn/web/v3/static/js/es5-shim-08e41cfc3e.min.js&quot;&gt;&lt;/script&gt;
25:&lt;script src=&quot;//statics.itc.cn/web/v3/static/js/es5-sham-1d5fa1124b.min.js&quot;&gt;&lt;/script&gt;
26:&lt;script src=&quot;//statics.itc.cn/web/v3/static/js/html5shiv-21fc8c2ba6.js&quot;&gt;&lt;/script&gt;
29:&lt;script type=&quot;text/javascript&quot;&gt;
52:&lt;/script&gt;
...</code></pre>
<blockquote>
<p>说明：<code>grep</code>在搜索字符串时可以使用正则表达式，如果需要使用正则表达式可以用<code>grep -E</code>或者直接使用<code>egrep</code>。</p>
</blockquote>
</li>
<li><p>创建链接和查看链接 - <strong>ln</strong> / <strong>readlink</strong>。</p>
<pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html
-rw-r--r-- 1 root root 212131 Jun 20 19:15 sohu.html
[root@iZwz97tbgo9lkabnat2lo8Z ~]# ln /root/sohu.html /root/backup/sohu_backup
[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html
-rw-r--r-- 2 root root 212131 Jun 20 19:15 sohu.html
[root@iZwz97tbgo9lkabnat2lo8Z ~]# ln /root/sohu.html /root/backup/sohu_backup2
[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html
-rw-r--r-- 3 root root 212131 Jun 20 19:15 sohu.html
[root@iZwz97tbgo9lkabnat2lo8Z ~]# ln -s /etc/centos-release sysinfo
[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sysinfo
lrwxrwxrwx 1 root root 19 Jun 20 19:21 sysinfo -&gt; /etc/centos-release
[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat sysinfo
CentOS Linux release 7.4.1708 (Core)
[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat /etc/centos-release
CentOS Linux release 7.4.1708 (Core)</code></pre>
<blockquote>
<p>说明：链接可以分为硬链接和软链接（符号链接）。硬链接可以认为是一个指向文件数据的指针，就像Python中对象的引用计数，每添加一个硬链接，文件的对应链接数就增加1，只有当文件的链接数为0时，文件所对应的存储空间才有可能被其他文件覆盖。我们平常删除文件时其实并没有删除硬盘上的数据，我们删除的只是一个指针，或者说是数据的一条使用记录，所以类似于“文件粉碎机”之类的软件在“粉碎”文件时除了删除文件指针，还会在文件对应的存储区域填入数据来保证文件无法再恢复。软链接类似于Windows系统下的快捷方式，当软链接链接的文件被删除时，软链接也就失效了。</p>
</blockquote>
</li>
<li><p>压缩/解压缩和归档/解归档 - <strong>gzip</strong> / <strong>gunzip</strong> / <strong>xz</strong>。</p>
<pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# wget http://download.redis.io/releases/redis-4.0.10.tar.gz
--2018-06-20 19:29:59--  http://download.redis.io/releases/redis-4.0.10.tar.gz
Resolving download.redis.io (download.redis.io)... 109.74.203.151
Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 1738465 (1.7M) [application/x-gzip]
Saving to: ‘redis-4.0.10.tar.gz’
100%[==================================================&gt;] 1,738,465   70.1KB/s   in 74s
2018-06-20 19:31:14 (22.9 KB/s) - ‘redis-4.0.10.tar.gz’ saved [1738465/1738465]
[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls redis*
redis-4.0.10.tar.gz
[root@iZwz97tbgo9lkabnat2lo8Z ~]# gunzip redis-4.0.10.tar.gz
[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls redis*
redis-4.0.10.tar</code></pre>
</li>
<li><p>归档和解归档 - <strong>tar</strong>。</p>
<pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# tar -xvf redis-4.0.10.tar
redis-4.0.10/
redis-4.0.10/.gitignore
redis-4.0.10/00-RELEASENOTES
redis-4.0.10/BUGS
redis-4.0.10/CONTRIBUTING
redis-4.0.10/COPYING
redis-4.0.10/INSTALL
redis-4.0.10/MANIFESTO
redis-4.0.10/Makefile
redis-4.0.10/README.md
redis-4.0.10/deps/
redis-4.0.10/deps/Makefile
redis-4.0.10/deps/README.md
...</code></pre>
<blockquote>
<p>说明：归档（也称为创建归档）和解归档都使用<code>tar</code>命令，通常创建归档需要<code>-cvf</code>三个参数，其中<code>c</code>表示创建（create），<code>v</code>表示显示创建归档详情（verbose），<code>f</code>表示指定归档的文件（file）；解归档需要加上<code>-xvf</code>参数，其中<code>x</code>表示抽取（extract），其他两个参数跟创建归档相同。</p>
</blockquote>
</li>
<li><p>将标准输入转成命令行参数 - <strong>xargs</strong>。</p>
<p>下面的命令会将查找当前路径下的html文件，然后通过<code>xargs</code>将这些文件作为参数传给<code>rm</code>命令，实现查找并删除文件的操作。</p>
<pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# find . -type f -name &quot;*.html&quot; | xargs rm -f</code></pre>
<p>下面的命令将a.txt文件中的多行内容变成一行输出到b.txt文件中，其中<code>&lt;</code>表示从a.txt中读取输入，<code>&gt;</code>表示将命令的执行结果输出到b.txt中。</p>
<pre><code class="Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# xargs &lt; a.txt &gt; b.txt</code></pre>
<blockquote>
<p>说明：这个命令就像上面演示的那样常在管道（实现进程间通信的一种方式）和重定向（重新指定输入输出的位置）操作中用到，后面的内容中会讲到管道操作和输入输出重定向操作。</p>
</blockquote>
</li>
<li><p>显示文件或目录 - <strong>basename</strong> / <strong>dirname</strong>。</p>
</li>
<li><p>其他相关工具。 </p>
<ul>
<li><strong>sort</strong> - 对内容排序</li>
<li><strong>uniq</strong> - 去掉相邻重复内容</li>
<li><strong>tr</strong> - 替换指定内容为新内容</li>
<li><strong>cut</strong> / <strong>paste</strong> - 剪切/黏贴内容</li>
<li><strong>split</strong> - 拆分文件</li>
<li><strong>file</strong> - 判断文件类型</li>
<li><strong>wc</strong> - 统计文件行数、单词数、字节数</li>
<li><strong>iconv</strong> - 编码转换</li>
</ul>
<pre><code class="Shell">[root ~]# cat foo.txt
grape
apple
pitaya
[root ~]# cat bar.txt
100
200
300
400
[root ~]# paste foo.txt bar.txt
grape   100
apple   200
pitaya  300
       400
[root ~]# paste foo.txt bar.txt &gt; hello.txt
[root ~]# cut -b 4-8 hello.txt
pe      10
le      20
aya     3
0
[root ~]# cat hello.txt | tr &#39;\t&#39; &#39;,&#39;
grape,100
apple,200
pitaya,300
,400
[root ~]# split -l 100 sohu.html hello
[root ~]# wget https://www.baidu.com/img/bd_logo1.png
[root ~]# file bd_logo1.png
bd_logo1.png: PNG image data, 540 x 258, 8-bit colormap, non-interlaced
[root ~]# wc sohu.html
 2979   6355 212527 sohu.html
[root ~]# wc -l sohu.html
2979 sohu.html
[root ~]# wget http://www.qq.com -O qq.html
[root ~]# iconv -f gb2312 -t utf-8 qq.html</code></pre>
</li>
</ol>
<h4 id="6-2-管道和重定向"><a href="#6-2-管道和重定向" class="headerlink" title="6.2 管道和重定向"></a>6.2 管道和重定向</h4><ol>
<li><p>管道的使用 - <strong>|</strong>。</p>
<p>例子：查找当前目录下文件个数。</p>
<pre><code class="Shell">[root ~]# find ./ | wc -l
6152</code></pre>
<p>例子：列出当前路径下的文件和文件夹，给每一项加一个编号。</p>
<pre><code class="Shell">[root ~]# ls | cat -n
     1  dump.rdb
     2  mongodb-3.6.5
     3  Python-3.6.5
     4  redis-3.2.11
     5  redis.conf</code></pre>
<p>例子：查找record.log中包含AAA，但不包含BBB的记录的总数</p>
<pre><code class="Shell">[root ~]# cat record.log | grep AAA | grep -v BBB | wc -l</code></pre>
</li>
<li><p>输出重定向和错误重定向 - <strong>&gt;</strong> / <strong>&gt;&gt;</strong> / <strong>2&gt;</strong>。</p>
<pre><code class="Shell">[root ~]# cat readme.txt
banana
apple
grape
apple
grape
watermelon
pear
pitaya
[root ~]# cat readme.txt | sort | uniq &gt; result.txt
[root ~]# cat result.txt
apple
banana
grape
pear
pitaya
watermelon</code></pre>
</li>
<li><p>输入重定向 - <strong>&lt;</strong>。</p>
<pre><code class="Shell">[root ~]# echo &#39;hello, world!&#39; &gt; hello.txt
[root ~]# wall &lt; hello.txt
[root ~]#
Broadcast message from root (Wed Jun 20 19:43:05 2018):
hello, world!
[root ~]# echo &#39;I will show you some code.&#39; &gt;&gt; hello.txt
[root ~]# wall &lt; hello.txt
[root ~]#
Broadcast message from root (Wed Jun 20 19:43:55 2018):
hello, world!
I will show you some code.</code></pre>
</li>
<li><p>多重定向 - <strong>tee</strong>。</p>
<p>下面的命令除了在终端显示命令<code>ls</code>的结果之外，还会追加输出到<code>ls.txt</code>文件中。</p>
<pre><code class="Shell">[root ~]# ls | tee -a ls.txt</code></pre>
</li>
</ol>
<h4 id="6-3-别名"><a href="#6-3-别名" class="headerlink" title="6.3 别名"></a>6.3 别名</h4><ol>
<li><p><strong>alias</strong></p>
<pre><code class="Shell">[root ~]# alias ll=&#39;ls -l&#39;
[root ~]# alias frm=&#39;rm -rf&#39;
[root ~]# ll
...
drwxr-xr-x  2 root       root   4096 Jun 20 12:52 abc
...
[root ~]# frm abc</code></pre>
</li>
<li><p><strong>unalias</strong></p>
<pre><code class="Shell">[root ~]# unalias frm
[root ~]# frm sohu.html
-bash: frm: command not found</code></pre>
</li>
</ol>
<h4 id="6-4-文本处理"><a href="#6-4-文本处理" class="headerlink" title="6.4 文本处理"></a>6.4 文本处理</h4><ol>
<li><p>字符流编辑器 - <strong>sed</strong>。</p>
<p>sed是操作、过滤和转换文本内容的工具。假设有一个名为fruit.txt的文件，内容如下所示。</p>
<pre><code class="Shell">[root ~]# cat -n fruit.txt 
     1  banana
     2  grape
     3  apple
     4  watermelon
     5  orange</code></pre>
<p>接下来，我们在第2行后面添加一个pitaya。</p>
<pre><code class="Shell">[root ~]# sed &#39;2a pitaya&#39; fruit.txt 
banana
grape
pitaya
apple
watermelon
orange</code></pre>
<blockquote>
<p>注意：刚才的命令和之前我们讲过的很多命令一样并没有改变fruit.txt文件，而是将添加了新行的内容输出到终端中，如果想保存到fruit.txt中，可以使用输出重定向操作。</p>
</blockquote>
<p>在第2行前面插入一个waxberry。</p>
<pre><code class="Shell">[root ~]# sed &#39;2i waxberry&#39; fruit.txt
banana
waxberry
grape
apple
watermelon
orange</code></pre>
<p>删除第3行。</p>
<pre><code class="Shell">[root ~]# sed &#39;3d&#39; fruit.txt
banana
grape
watermelon
orange</code></pre>
<p>删除第2行到第4行。</p>
<pre><code class="Shell">[root ~]# sed &#39;2,4d&#39; fruit.txt
banana
orange</code></pre>
<p>将文本中的字符a替换为@。</p>
<pre><code class="Shell">[root ~]# sed &#39;s#a#@#&#39; fruit.txt 
b@nana
gr@pe
@pple
w@termelon
or@nge</code></pre>
<p>将文本中的字符a替换为@，使用全局模式。</p>
<pre><code class="Shell">[root ~]# sed &#39;s#a#@#g&#39; fruit.txt 
b@n@n@
gr@pe
@pple
w@termelon
or@nge</code></pre>
</li>
<li><p>模式匹配和处理语言 - <strong>awk</strong>。</p>
<p>awk是一种编程语言，也是Linux系统中处理文本最为强大的工具，它的作者之一和现在的维护者就是之前提到过的Brian Kernighan（ken和dmr最亲密的伙伴）。通过该命令可以从文本中提取出指定的列、用正则表达式从文本中取出我们想要的内容、显示指定的行以及进行统计和运算，总之它非常强大。</p>
<p>假设有一个名为fruit2.txt的文件，内容如下所示。</p>
<pre><code class="Shell">[root ~]# cat fruit2.txt 
1       banana      120
2       grape       500
3       apple       1230
4       watermelon  80
5       orange      400</code></pre>
<p>显示文件的第3行。</p>
<pre><code class="Shell">[root ~]# awk &#39;NR==3&#39; fruit2.txt 
3       apple       1230</code></pre>
<p>显示文件的第2列。</p>
<pre><code class="Shell">[root ~]# awk &#39;{print $2}&#39; fruit2.txt 
banana
grape
apple
watermelon
orange</code></pre>
<p>显示文件的最后一列。</p>
<pre><code class="Shell">[root ~]# awk &#39;{print $NF}&#39; fruit2.txt 
120
500
1230
80
400</code></pre>
<p>输出末尾数字大于等于300的行。</p>
<pre><code class="Shell">[root ~]# awk &#39;{if($3 &gt;= 300) {print $0}}&#39; fruit2.txt 
2       grape       500
3       apple       1230
5       orange      400</code></pre>
<p>上面展示的只是awk命令的冰山一角，更多的内容留给读者自己在实践中去探索。</p>
</li>
</ol>
<h3 id="七：-用户管理"><a href="#七：-用户管理" class="headerlink" title="七： 用户管理"></a>七： 用户管理</h3><ol>
<li><p>创建和删除用户 - <strong>useradd</strong> / <strong>userdel</strong>。</p>
<pre><code class="Shell">[root home]# useradd hellokitty
[root home]# userdel hellokitty</code></pre>
<ul>
<li><code>-d</code> - 创建用户时为用户指定用户主目录</li>
<li><code>-g</code> - 创建用户时指定用户所属的用户组</li>
</ul>
</li>
<li><p>创建和删除用户组 - <strong>groupadd</strong> / <strong>groupdel</strong>。</p>
<blockquote>
<p>说明：用户组主要是为了方便对一个组里面所有用户的管理。</p>
</blockquote>
</li>
<li><p>修改密码 - <strong>passwd</strong>。</p>
<pre><code class="Shell">[root ~]# passwd hellokitty
New password: 
Retype new password: 
passwd: all authentication tokens updated successfully.</code></pre>
<blockquote>
<p>说明：输入密码和确认密码没有回显且必须一气呵成的输入完成（不能使用退格键），密码和确认密码需要一致。如果使用<code>passwd</code>命令时没有指定命令作用的对象，则表示要修改当前用户的密码。如果想批量修改用户密码，可以使用<code>chpasswd</code>命令。</p>
</blockquote>
<ul>
<li><code>-l</code> / <code>-u</code> - 锁定/解锁用户。</li>
<li><code>-d</code> - 清除用户密码。</li>
<li><code>-e</code> - 设置密码立即过期，用户登录时会强制要求修改密码。</li>
<li><code>-i</code> - 设置密码过期多少天以后禁用该用户。</li>
</ul>
</li>
<li><p>查看和修改密码有效期 - <strong>chage</strong>。</p>
<p>设置hellokitty用户100天后必须修改密码，过期前15天通知该用户，过期后15天禁用该用户。</p>
<pre><code class="Shell">chage -M 100 -W 15 -I 15 hellokitty</code></pre>
</li>
<li><p>切换用户 - <strong>su</strong>。</p>
<pre><code class="Shell">[root ~]# su hellokitty
[hellokitty root]$</code></pre>
</li>
<li><p>以管理员身份执行命令 - <strong>sudo</strong>。</p>
<pre><code class="Shell">[hellokitty ~]$ ls /root
ls: cannot open directory /root: Permission denied
[hellokitty ~]$ sudo ls /root
[sudo] password for hellokitty:</code></pre>
<blockquote>
<p><strong>说明</strong>：如果希望用户能够以管理员身份执行命令，用户必须要出现在sudoers名单中，sudoers文件在 <code>/etc</code>目录下，如果希望直接编辑该文件也可以使用下面的命令。</p>
</blockquote>
</li>
<li><p>编辑sudoers文件 - <strong>visudo</strong>。</p>
<p>这里使用的编辑器是vi，关于vi的知识在后面有讲解。该文件的部分内容如下所示：</p>
<pre><code>## Allow root to run any commands anywhere 
root    ALL=(ALL)   ALL

## Allows members of the &#39;sys&#39; group to run networking, software, 
## service management apps and more.
# %sys ALL = NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS
## Allows people in group wheel to run all commands
%wheel  ALL=(ALL)   ALL

## Same thing without a password
# %wheel    ALL=(ALL)   NOPASSWD: ALL

## Allows members of the users group to mount and unmount the
## cdrom as root
# %users  ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom

## Allows members of the users group to shutdown this system
# %users  localhost=/sbin/shutdown -h now</code></pre></li>
<li><p>显示用户与用户组的信息 - <strong>id</strong>。</p>
</li>
<li><p>给其他用户发消息 -<strong>write</strong> / <strong>wall</strong>。</p>
<p>发送方：</p>
<pre><code class="Shell">[root ~]# write hellokitty
Dinner is on me.
Call me at 6pm.</code></pre>
<p>接收方：</p>
<pre><code class="Shell">[hellokitty ~]$ 
Message from root on pts/0 at 17:41 ...
Dinner is on me.
Call me at 6pm.
EOF</code></pre>
</li>
<li><p>查看/设置是否接收其他用户发送的消息 - <strong>mesg</strong>。</p>
<pre><code class="Shell">[hellokitty ~]$ mesg
is y
[hellokitty ~]$ mesg n
[hellokitty ~]$ mesg
is n</code></pre>
</li>
</ol>
<h3 id="八：-文件系统"><a href="#八：-文件系统" class="headerlink" title="八： 文件系统"></a>八： 文件系统</h3><h4 id="8-1-文件和路径"><a href="#8-1-文件和路径" class="headerlink" title="8.1 文件和路径"></a>8.1 文件和路径</h4><ol>
<li>命名规则：文件名的最大长度与文件系统类型有关，一般情况下，文件名不应该超过255个字符，虽然绝大多数的字符都可以用于文件名，但是最好使用英文大小写字母、数字、下划线、点这样的符号。文件名中虽然可以使用空格，但应该尽可能避免使用空格，否则在输入文件名时需要用将文件名放在双引号中或者通过<code>\</code>对空格进行转义。</li>
<li>扩展名：在Linux系统下文件的扩展名是可选的，但是使用扩展名有助于对文件内容的理解。有些应用程序要通过扩展名来识别文件，但是更多的应用程序并不依赖文件的扩展名，就像<code>file</code>命令在识别文件时并不是依据扩展名来判定文件的类型。</li>
<li>隐藏文件：以点开头的文件在Linux系统中是隐藏文件（不可见文件）。</li>
</ol>
<h4 id="8-2-目录结构"><a href="#8-2-目录结构" class="headerlink" title="8.2 目录结构"></a>8.2 目录结构</h4><ol>
<li>/bin - 基本命令的二进制文件。</li>
<li>/boot - 引导加载程序的静态文件。</li>
<li>/dev - 设备文件。</li>
<li><strong>/etc</strong> - 配置文件。</li>
<li>/home - 普通用户主目录的父目录。</li>
<li>/lib - 共享库文件。</li>
<li>/lib64 - 共享64位库文件。</li>
<li>/lost+found - 存放未链接文件。</li>
<li>/media - 自动识别设备的挂载目录。</li>
<li>/mnt - 临时挂载文件系统的挂载点。</li>
<li>/opt - 可选插件软件包安装位置。</li>
<li>/proc -  内核和进程信息。</li>
<li><strong>/root</strong> - 超级管理员用户主目录。</li>
<li>/run - 存放系统运行时需要的东西。</li>
<li>/sbin - 超级用户的二进制文件。</li>
<li>/sys - 设备的伪文件系统。</li>
<li>/tmp - 临时文件夹。</li>
<li><strong>/usr</strong> - 用户应用目录。</li>
<li>/var - 变量数据目录。</li>
</ol>
<h4 id="8-3-访问权限"><a href="#8-3-访问权限" class="headerlink" title="8.3 访问权限"></a>8.3 访问权限</h4><ol>
<li><p><strong>chmod</strong> - 改变文件模式比特。</p>
<pre><code class="Shell">[root ~]# ls -l
...
-rw-r--r--  1 root       root 211878 Jun 19 16:06 sohu.html
...
[root ~]# chmod g+w,o+w sohu.html
[root ~]# ls -l
...
-rw-rw-rw-  1 root       root 211878 Jun 19 16:06 sohu.html
...
[root ~]# chmod 644 sohu.html
[root ~]# ls -l
...
-rw-r--r--  1 root       root 211878 Jun 19 16:06 sohu.html
...</code></pre>
<blockquote>
<p>说明：通过上面的例子可以看出，用<code>chmod</code>改变文件模式比特有两种方式：一种是字符设定法，另一种是数字设定法。除了<code>chmod</code>之外，可以通过<code>umask</code>来设定哪些权限将在新文件的默认权限中被删除。</p>
</blockquote>
<p>长格式查看目录或文件时显示结果及其对应权限的数值如下表所示。</p>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/file-mode.png" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>chown</strong> - 改变文件所有者。</p>
<pre><code class="Shell"> [root ~]# ls -l
 ...
 -rw-r--r--  1 root root     54 Jun 20 10:06 readme.txt
 ...
 [root ~]# chown hellokitty readme.txt
 [root ~]# ls -l
 ...
 -rw-r--r--  1 hellokitty root     54 Jun 20 10:06 readme.txt
 ...</code></pre>
</li>
<li><p><strong>chgrp</strong> - 改变用户组。</p>
</li>
</ol>
<h4 id="8-4-磁盘管理"><a href="#8-4-磁盘管理" class="headerlink" title="8.4 磁盘管理"></a>8.4 磁盘管理</h4><ol>
<li><p>列出文件系统的磁盘使用状况 - <strong>df</strong>。</p>
<pre><code class="Shell">[root ~]# df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/vda1        40G  5.0G   33G  14% /
devtmpfs        486M     0  486M   0% /dev
tmpfs           497M     0  497M   0% /dev/shm
tmpfs           497M  356K  496M   1% /run
tmpfs           497M     0  497M   0% /sys/fs/cgroup
tmpfs           100M     0  100M   0% /run/user/0</code></pre>
</li>
<li><p>磁盘分区表操作 - <strong>fdisk</strong>。</p>
<pre><code class="Shell">[root ~]# fdisk -l
Disk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x000a42f4
   Device Boot      Start         End      Blocks   Id  System
/dev/vda1   *        2048    83884031    41940992   83  Linux
Disk /dev/vdb: 21.5 GB, 21474836480 bytes, 41943040 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes</code></pre>
</li>
<li><p>磁盘分区工具 - <strong>parted</strong>。</p>
</li>
<li><p>格式化文件系统 - <strong>mkfs</strong>。</p>
<pre><code class="Shell">[root ~]# mkfs -t ext4 -v /dev/sdb</code></pre>
<ul>
<li><code>-t</code> - 指定文件系统的类型。</li>
<li><code>-c</code> - 创建文件系统时检查磁盘损坏情况。</li>
<li><code>-v</code> - 显示详细信息。</li>
</ul>
</li>
<li><p>文件系统检查 - <strong>fsck</strong>。</p>
</li>
<li><p>转换或拷贝文件 - <strong>dd</strong>。</p>
</li>
<li><p>挂载/卸载 - <strong>mount</strong> / <strong>umount</strong>。</p>
</li>
<li><p>创建/激活/关闭交换分区 - <strong>mkswap</strong> / <strong>swapon</strong> / <strong>swapoff</strong>。</p>
</li>
</ol>
<blockquote>
<p>说明：执行上面这些命令会带有一定的风险，如果不清楚这些命令的用法，最好不用随意使用，在使用的过程中，最好对照参考资料进行操作，并在操作前确认是否要这么做。</p>
</blockquote>
<h3 id="九：-编辑器-vim"><a href="#九：-编辑器-vim" class="headerlink" title="九： 编辑器 - vim"></a>九： 编辑器 - vim</h3><ol>
<li><p>启动vim。可以通过<code>vi</code>或<code>vim</code>命令来启动vim，启动时可以指定文件名来打开一个文件，如果没有指定文件名，也可以在保存的时候指定文件名。</p>
<pre><code class="Shell">[root ~]# vim guess.py</code></pre>
</li>
<li><p>命令模式、编辑模式和末行模式：启动vim进入的是命令模式（也称为Normal模式），在命令模式下输入英文字母<code>i</code>会进入编辑模式（Insert模式），屏幕下方出现<code>-- INSERT --</code>提示；在编辑模式下按下<code>Esc</code>会回到命令模式，此时如果输入英文<code>:</code>会进入末行模式，在末行模式下输入<code>q!</code>可以在不保存当前工作的情况下强行退出vim；在命令模式下输入<code>v</code>会进入可视模式（Visual模式），可以用光标选择一个区域再完成对应的操作。</p>
</li>
<li><p>保存和退出vim：在命令模式下输入<code>:</code> 进入末行模式，输入<code>wq</code>可以实现保存退出；如果想放弃编辑的内容输入<code>q!</code>强行退出，这一点刚才已经提到过了；在命令模式下也可以直接输入<code>ZZ</code>实现保存退出。如果只想保存文件不退出，那么可以在末行模式下输入<code>w</code>；可以在<code>w</code>后面输入空格再指定要保存的文件名。</p>
</li>
<li><p>光标操作。</p>
<ul>
<li>在命令模式下可以通过<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>来控制光标向左、下、上、右的方向移动，可以在字母前输入数字来表示移动的距离，例如：<code>10h</code>表示向左移动10个字符。</li>
<li>在命令模式下可以通过<code>Ctrl+y</code>和<code>Ctrl+e</code>来实现向上、向下滚动一行文本的操作，可以通过<code>Ctrl+f</code>和<code>Ctrl+b</code>来实现向前和向后翻页的操作。</li>
<li>在命令模式下可以通过输入英文字母<code>G</code>将光标移到文件的末尾，可以通过<code>gg</code>将光标移到文件的开始，也可以通过在<code>G</code>前输入数字来将光标移动到指定的行。</li>
</ul>
</li>
<li><p>文本操作。</p>
<ul>
<li>删除：在命令模式下可以用<code>dd</code>来删除整行；可以在<code>dd</code>前加数字来指定删除的行数；可以用<code>d$</code>来实现删除从光标处删到行尾的操作，也可以通过<code>d0</code>来实现从光标处删到行首的操作；如果想删除一个单词，可以使用<code>dw</code>；如果要删除全文，可以在输入<code>:%d</code>（其中<code>:</code>用来从命令模式进入末行模式）。</li>
<li>复制和粘贴：在命令模式下可以用<code>yy</code>来复制整行；可以在<code>yy</code>前加数字来指定复制的行数；可以通过<code>p</code>将复制的内容粘贴到光标所在的地方。</li>
<li>撤销和恢复：在命令模式下输入<code>u</code>可以撤销之前的操作；通过<code>Ctrl+r</code>可以恢复被撤销的操作。</li>
<li>对内容进行排序：在命令模式下输入<code>%!sort</code>。</li>
</ul>
</li>
<li><p>查找和替换。</p>
<ul>
<li>查找操作需要输入<code>/</code>进入末行模式并提供正则表达式来匹配与之对应的内容，例如：<code>/doc.*\.</code>，输入<code>n</code>来向前搜索，也可以输入<code>N</code>来向后搜索。</li>
<li>替换操作需要输入<code>:</code>进入末行模式并指定搜索的范围、正则表达式以及替换后的内容和匹配选项，例如：<code>:1,$s/doc.*/hello/gice</code>，其中：<ul>
<li><code>g</code> - global：全局匹配。</li>
<li><code>i</code> - ignore case：忽略大小写匹配。</li>
<li><code>c</code> - confirm：替换时需要确认。</li>
<li><code>e</code> - error：忽略错误。</li>
</ul>
</li>
</ul>
</li>
<li><p>参数设定：在输入<code>:</code>进入末行模式后可以对vim进行设定。</p>
<ul>
<li><p>设置Tab键的空格数：<code>set ts=4</code></p>
</li>
<li><p>设置显示/不显示行号：<code>set nu</code> / <code>set nonu</code></p>
</li>
<li><p>设置启用/关闭高亮语法：<code>syntax on</code> / <code>syntax off</code></p>
</li>
<li><p>设置显示标尺（光标所在的行和列）： <code>set ruler</code></p>
</li>
<li><p>设置启用/关闭搜索结果高亮：<code>set hls</code> / <code>set nohls</code></p>
<blockquote>
<p>说明：如果希望上面的这些设定在每次启动vim时都能自动生效，需要将这些设定写到用户主目录下的.vimrc文件中。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>高级技巧</p>
<ul>
<li><p>比较多个文件。</p>
<pre><code class="Shell">[root ~]# vim -d foo.txt bar.txt</code></pre>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/vim-diff.png" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p>打开多个文件。</p>
<pre><code class="Shell">[root ~]# vim foo.txt bar.txt hello.txt</code></pre>
<p>启动vim后只有一个窗口显示的是foo.txt，可以在末行模式中输入<code>ls</code>查看到打开的三个文件，也可以在末行模式中输入<code>b &lt;num&gt;</code>来显示另一个文件，例如可以用<code>:b 2</code>将bar.txt显示出来，可以用<code>:b 3</code>将hello.txt显示出来。</p>
</li>
<li><p>拆分和切换窗口。</p>
<p>可以在末行模式中输入<code>sp</code>或<code>vs</code>来实现对窗口的水平或垂直拆分，这样我们就可以同时打开多个编辑窗口，通过按两次<code>Ctrl+w</code>就可以实现编辑窗口的切换，在一个窗口中执行退出操作只会关闭对应的窗口，其他的窗口继续保留。</p>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/vim-multi-window.png" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p>映射快捷键：在vim下可以将一些常用操作映射为快捷键来提升工作效率。</p>
<ul>
<li><p>例子1：在命令模式下输入<code>F4</code>执行从第一行开始删除10000行代码的操作。</p>
<p><code>:map &lt;F4&gt; gg10000dd</code>。</p>
<p>例子2：在编辑模式下输入<code>__main</code>直接补全为<code>if __name__ == &#39;__main__&#39;:</code>。</p>
<p><code>:inoremap __main if __name__ == &#39;__main__&#39;:</code></p>
</li>
</ul>
<blockquote>
<p>说明：上面例子2的<code>inoremap</code>中的<code>i</code>表示映射的键在编辑模式使用， <code>nore</code>表示不要递归，这一点非常重要，否则如果键对应的内容中又出现键本身，就会引发递归（相当于进入了死循环）。如果希望映射的快捷键每次启动vim时都能生效，需要将映射写到用户主目录下的.vimrc文件中。</p>
</blockquote>
</li>
<li><p>录制宏。</p>
<ul>
<li><p>在命令模式下输入<code>qa</code>开始录制宏（其中<code>a</code>是寄存器的名字，也可以是其他英文字母或0-9的数字）。</p>
</li>
<li><p>执行你的操作（光标操作、编辑操作等），这些操作都会被录制下来。</p>
</li>
<li><p>如果录制的操作已经完成了，按<code>q</code>结束录制。</p>
</li>
<li><p>通过<code>@a</code>（<code>a</code>是刚才使用的寄存器的名字）播放宏，如果要多次执行宏可以在前面加数字，例如<code>100@a</code>表示将宏播放100次。</p>
</li>
<li><p>可以试一试下面的例子来体验录制宏的操作，该例子来源于<a href="https://harttle.land/tags.html#Vim" target="_blank" rel="noopener">Harttle Land网站</a>，该网站上提供了很多关于vim的使用技巧，有兴趣的可以了解一下。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/vim-macro.png" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="十：-软件安装和配置"><a href="#十：-软件安装和配置" class="headerlink" title="十： 软件安装和配置"></a>十： 软件安装和配置</h3><h4 id="10-1-使用包管理工具"><a href="#10-1-使用包管理工具" class="headerlink" title="10.1 使用包管理工具"></a>10.1 使用包管理工具</h4><ol>
<li><strong>yum</strong> - Yellowdog Updater Modified。<ul>
<li><code>yum search</code>：搜索软件包，例如<code>yum search nginx</code>。</li>
<li><code>yum list installed</code>：列出已经安装的软件包，例如<code>yum list installed | grep zlib</code>。</li>
<li><code>yum install</code>：安装软件包，例如<code>yum install nginx</code>。</li>
<li><code>yum remove</code>：删除软件包，例如<code>yum remove nginx</code>。</li>
<li><code>yum update</code>：更新软件包，例如<code>yum update</code>可以更新所有软件包，而<code>yum update tar</code>只会更新tar。</li>
<li><code>yum check-update</code>：检查有哪些可以更新的软件包。</li>
<li><code>yum info</code>：显示软件包的相关信息，例如<code>yum info nginx</code>。</li>
</ul>
</li>
<li><strong>rpm</strong> - Redhat Package Manager。<ul>
<li>安装软件包：<code>rpm -ivh &lt;packagename&gt;.rpm</code>。</li>
<li>移除软件包：<code>rpm -e &lt;packagename&gt;</code>。</li>
<li>查询软件包：<code>rpm -qa</code>，例如可以用<code>rpm -qa | grep mysql</code>来检查是否安装了MySQL相关的软件包。</li>
</ul>
</li>
</ol>
<p>下面以Nginx为例，演示如何使用yum安装软件。</p>
<pre><code class="Shell">[root ~]# yum -y install nginx
...
Installed:
  nginx.x86_64 1:1.12.2-2.el7
Dependency Installed:
  nginx-all-modules.noarch 1:1.12.2-2.el7
  nginx-mod-http-geoip.x86_64 1:1.12.2-2.el7
  nginx-mod-http-image-filter.x86_64 1:1.12.2-2.el7
  nginx-mod-http-perl.x86_64 1:1.12.2-2.el7
  nginx-mod-http-xslt-filter.x86_64 1:1.12.2-2.el7
  nginx-mod-mail.x86_64 1:1.12.2-2.el7
  nginx-mod-stream.x86_64 1:1.12.2-2.el7
Complete!
[root ~]# yum info nginx
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
Installed Packages
Name        : nginx
Arch        : x86_64
Epoch       : 1
Version     : 1.12.2
Release     : 2.el7
Size        : 1.5 M
Repo        : installed
From repo   : epel
Summary     : A high performance web server and reverse proxy server
URL         : http://nginx.org/
License     : BSD
Description : Nginx is a web server and a reverse proxy server for HTTP, SMTP, POP3 and
            : IMAP protocols, with a strong focus on high concurrency, performance and low
            : memory usage.
[root ~]# nginx -v
nginx version: nginx/1.12.2</code></pre>
<p>移除Nginx。</p>
<pre><code class="Shell">[root ~]# yum -y remove nginx</code></pre>
<p>下面以MySQL为例，演示如何使用rpm安装软件。要安装MySQL需要先到<a href="https://www.mysql.com/" target="_blank" rel="noopener">MySQL官方网站</a>下载对应的<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">RPM文件</a>，当然要选择和你使用的Linux系统对应的版本。MySQL现在是Oracle公司旗下的产品，在MySQL被收购后，MySQL的作者重新制作了一个MySQL的分支MariaDB，可以通过yum进行安装。</p>
<pre><code class="Shell">[root mysql]# ls
mysql-community-client-5.7.22-1.el7.x86_64.rpm
mysql-community-common-5.7.22-1.el7.x86_64.rpm
mysql-community-libs-5.7.22-1.el7.x86_64.rpm
mysql-community-server-5.7.22-1.el7.x86_64.rpm
[root mysql]# yum -y remove mariadb-libs
[root mysql]# yum -y install libaio
[root mysql]#rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm
...
[root mysql]#rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm
...
[root mysql]#rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm
...
[root mysql]#rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm
...</code></pre>
<blockquote>
<p>说明：由于MySQL和<a href="https://mariadb.org/" target="_blank" rel="noopener">MariaDB</a>的底层依赖库是有冲突的，所以上面我们首先用<code>yum</code>移除了名为mariadb-libs的依赖库并安装了名为libaio支持异步I/O操作的依赖库。关于MySQL和MariaDB之间的关系，可以阅读<a href="https://zh.wikipedia.org/wiki/MariaDB" target="_blank" rel="noopener">维基百科</a>上关于MariaDB的介绍。</p>
</blockquote>
<p>移除安装的MySQL。</p>
<pre><code class="Shell">[root ~]# rpm -qa | grep mysql | xargs rpm -e</code></pre>
<h4 id="10-2-下载解压配置环境变量"><a href="#10-2-下载解压配置环境变量" class="headerlink" title="10.2 下载解压配置环境变量"></a>10.2 下载解压配置环境变量</h4><p>下面以安装MongoDB为例，演示这类软件应该如何安装。</p>
<pre><code class="Shell">[root ~]# wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.5.tgz
--2018-06-21 18:32:53--  https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.5.tgz
Resolving fastdl.mongodb.org (fastdl.mongodb.org)... 52.85.83.16, 52.85.83.228, 52.85.83.186, ...
Connecting to fastdl.mongodb.org (fastdl.mongodb.org)|52.85.83.16|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 100564462 (96M) [application/x-gzip]
Saving to: ‘mongodb-linux-x86_64-rhel70-3.6.5.tgz’
100%[==================================================&gt;] 100,564,462  630KB/s   in 2m 9s
2018-06-21 18:35:04 (760 KB/s) - ‘mongodb-linux-x86_64-rhel70-3.6.5.tgz’ saved [100564462/100564462]
[root ~]# gunzip mongodb-linux-x86_64-rhel70-3.6.5.tgz
[root ~]# tar -xvf mongodb-linux-x86_64-rhel70-3.6.5.tar
mongodb-linux-x86_64-rhel70-3.6.5/README
mongodb-linux-x86_64-rhel70-3.6.5/THIRD-PARTY-NOTICES
mongodb-linux-x86_64-rhel70-3.6.5/MPL-2
mongodb-linux-x86_64-rhel70-3.6.5/GNU-AGPL-3.0
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongodump
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongorestore
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongoexport
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongoimport
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongostat
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongotop
mongodb-linux-x86_64-rhel70-3.6.5/bin/bsondump
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongofiles
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongoreplay
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongoperf
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongod
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongos
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongo
mongodb-linux-x86_64-rhel70-3.6.5/bin/install_compass
[root ~]# vim .bash_profile
...
PATH=$PATH:$HOME/bin:$HOME/mongodb-linux-x86_64-rhel70-3.6.5/bin
export PATH
...
[root ~]# source .bash_profile
[root ~]# mongod --version
db version v3.6.5
git version: a20ecd3e3a174162052ff99913bc2ca9a839d618
OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013
allocator: tcmalloc
modules: none
build environment:
    distmod: rhel70
    distarch: x86_64
    target_arch: x86_64
[root ~]# mongo --version
MongoDB shell version v3.6.5
git version: a20ecd3e3a174162052ff99913bc2ca9a839d618
OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013
allocator: tcmalloc
modules: none
build environment:
    distmod: rhel70
    distarch: x86_64
    target_arch: x86_64</code></pre>
<blockquote>
<p>说明：当然也可以通过yum来安装MongoDB，具体可以参照<a href="https://docs.mongodb.com/master/administration/install-on-linux/" target="_blank" rel="noopener">官方网站</a>上给出的说明。</p>
</blockquote>
<h4 id="10-3-源代码构建安装"><a href="#10-3-源代码构建安装" class="headerlink" title="10.3 源代码构建安装"></a>10.3 源代码构建安装</h4><ol>
<li><p>安装Python 3.6。</p>
<pre><code class="Shell">[root ~]# yum install gcc
[root ~]# wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz
[root ~]# gunzip Python-3.6.5.tgz
[root ~]# tar -xvf Python-3.6.5.tar
[root ~]# cd Python-3.6.5
[root ~]# ./configure --prefix=/usr/local/python36 --enable-optimizations
[root ~]# yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel
[root ~]# make &amp;&amp; make install
...
[root ~]# ln -s /usr/local/python36/bin/python3.6 /usr/bin/python3
[root ~]# python3 --version
Python 3.6.5
[root ~]# python3 -m pip install -U pip
[root ~]# pip3 --version</code></pre>
<blockquote>
<p>说明：上面在安装好Python之后还需要注册PATH环境变量，将Python安装路径下bin文件夹的绝对路径注册到PATH环境变量中。注册环境变量可以修改用户主目录下的.bash_profile或者/etc目录下的profile文件，二者的区别在于前者相当于是用户环境变量，而后者相当于是系统环境变量。</p>
</blockquote>
</li>
<li><p>安装Redis-3.2.12。</p>
<pre><code class="Shell">[root ~]# wget http://download.redis.io/releases/redis-3.2.12.tar.gz
[root ~]# gunzip redis-3.2.12.tar.gz
[root ~]# tar -xvf redis-3.2.12.tar
[root ~]# cd redis-3.2.12
[root ~]# make &amp;&amp; make install
[root ~]# redis-server --version
Redis server v=3.2.12 sha=00000000:0 malloc=jemalloc-4.0.3 bits=64 build=5bc5cd3c03d6ceb6
[root ~]# redis-cli --version
redis-cli 3.2.12</code></pre>
</li>
</ol>
<h3 id="十一：-配置服务"><a href="#十一：-配置服务" class="headerlink" title="十一： 配置服务"></a>十一： 配置服务</h3><p>我们可以Linux系统下安装和配置各种服务，也就是说我们可以把Linux系统打造成数据库服务器、Web服务器、缓存服务器、文件服务器、消息队列服务器等等。Linux下的大多数服务都被设置为守护进程（驻留在系统后台运行，但不会因为服务还在运行而导致Linux无法停止运行），所以我们安装的服务通常名字后面都有一个字母<code>d</code>，它是英文单词<code>daemon</code>的缩写，例如：防火墙服务叫firewalld，我们之前安装的MySQL服务叫mysqld，Apache服务器叫httpd等。在安装好服务之后，可以使用<code>systemctl</code>命令或<code>service</code>命令来完成对服务的启动、停止等操作，具体操作如下所示。</p>
<ol>
<li><p>启动防火墙服务。</p>
<pre><code class="Shell">[root ~]# systemctl start firewalld</code></pre>
</li>
<li><p>终止防火墙服务。</p>
<pre><code class="Shell">[root ~]# systemctl stop firewalld</code></pre>
</li>
<li><p>重启防火墙服务。</p>
<pre><code class="Shell">[root ~]# systemctl restart firewalld</code></pre>
</li>
<li><p>查看防火墙服务状态。</p>
<pre><code class="Shell"> [root ~]# systemctl status firewalld</code></pre>
</li>
<li><p>设置/禁用防火墙服务开机自启。</p>
<pre><code class="Shell">[root ~]# systemctl enable firewalld
Created symlink from /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service to /usr/lib/systemd/system/firewalld.service.
Created symlink from /etc/systemd/system/multi-user.target.wants/firewalld.service to /usr/lib/systemd/system/firewalld.service.
[root ~]# systemctl disable firewalld
Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.
Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.</code></pre>
</li>
</ol>
<h3 id="十二：-计划任务"><a href="#十二：-计划任务" class="headerlink" title="十二： 计划任务"></a>十二： 计划任务</h3><ol>
<li><p>在指定的时间执行命令</p>
<ul>
<li><strong>at</strong> - 将任务排队，在指定的时间执行。</li>
<li><strong>atq</strong> - 查看待执行的任务队列。</li>
<li><strong>atrm</strong> - 从队列中删除待执行的任务。</li>
</ul>
<p>指定3天以后下午5点要执行的任务。</p>
<pre><code class="Shell">[root ~]# at 5pm+3days
at&gt; rm -f /root/*.html
at&gt; &lt;EOT&gt;
job 9 at Wed Jun  5 17:00:00 2019</code></pre>
<p>查看待执行的任务队列。</p>
<pre><code class="Shell">[root ~]# atq
9       Wed Jun  5 17:00:00 2019 a root</code></pre>
<p>从队列中删除指定的任务。</p>
<pre><code class="Shell">[root ~]$ atrm 9</code></pre>
</li>
<li><p>计划任务表 - <strong>crontab</strong>。</p>
<pre><code class="Shell">[root ~]# crontab -e
* * * * * echo &quot;hello, world!&quot; &gt;&gt; /root/hello.txt
59 23 * * * rm -f /root/*.log</code></pre>
<blockquote>
<p>说明：输入<code>crontab -e</code>命令会打开vim来编辑Cron表达式并指定触发的任务，上面我们定制了两个计划任务，一个是每分钟向/root目录下的hello.txt中追加输出<code>hello, world!</code>；另一个是每天23时59分执行删除/root目录下以log为后缀名的文件。如果不知道Cron表达式如何书写，可以参照/etc/crontab文件中的提示（下面会讲到）或者用搜索引擎找一下“Cron表达式在线生成器”来生成Cron表达式。</p>
</blockquote>
<p>和crontab相关的文件在<code>/etc</code>目录下，通过修改<code>/etc</code>目录下的crontab文件也能够定制计划任务。</p>
<pre><code class="Shell">[root ~]# cd /etc
[root etc]# ls -l | grep cron
-rw-------.  1 root root      541 Aug  3  2017 anacrontab
drwxr-xr-x.  2 root root     4096 Mar 27 11:56 cron.d
drwxr-xr-x.  2 root root     4096 Mar 27 11:51 cron.daily
-rw-------.  1 root root        0 Aug  3  2017 cron.deny
drwxr-xr-x.  2 root root     4096 Mar 27 11:50 cron.hourly
drwxr-xr-x.  2 root root     4096 Jun 10  2014 cron.monthly
-rw-r--r--   1 root root      493 Jun 23 15:09 crontab
drwxr-xr-x.  2 root root     4096 Jun 10  2014 cron.weekly
[root etc]# vim crontab
  1 SHELL=/bin/bash
  2 PATH=/sbin:/bin:/usr/sbin:/usr/bin
  3 MAILTO=root
  4
  5 # For details see man 4 crontabs
  6
  7 # Example of job definition:
  8 # .---------------- minute (0 - 59)
  9 # |  .------------- hour (0 - 23)
 10 # |  |  .---------- day of month (1 - 31)
 11 # |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
 12 # |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
 13 # |  |  |  |  |
 14 # *  *  *  *  * user-name  command to be executed</code></pre>
</li>
</ol>
<h3 id="十三：-网络访问和管理"><a href="#十三：-网络访问和管理" class="headerlink" title="十三： 网络访问和管理"></a>十三： 网络访问和管理</h3><ol>
<li><p>安全远程连接 - <strong>ssh</strong>。</p>
<pre><code class="Shell"> [root ~]$ ssh root@120.77.222.217
 The authenticity of host &#39;120.77.222.217 (120.77.222.217)&#39; can&#39;t be established.
 ECDSA key fingerprint is SHA256:BhUhykv+FvnIL03I9cLRpWpaCxI91m9n7zBWrcXRa8w.
 ECDSA key fingerprint is MD5:cc:85:e9:f0:d7:07:1a:26:41:92:77:6b:7f:a0:92:65.
 Are you sure you want to continue connecting (yes/no)? yes
 Warning: Permanently added &#39;120.77.222.217&#39; (ECDSA) to the list of known hosts.
 root@120.77.222.217&#39;s password: </code></pre>
</li>
<li><p>通过网络获取资源 - <strong>wget</strong>。</p>
<ul>
<li>-b 后台下载模式</li>
<li>-O 下载到指定的目录</li>
<li>-r 递归下载</li>
</ul>
</li>
<li><p>发送和接收邮件 - <strong>mail</strong>。</p>
</li>
<li><p>网络配置工具（旧） - <strong>ifconfig</strong>。</p>
<pre><code class="Shell">[root ~]# ifconfig eth0
eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 172.18.61.250  netmask 255.255.240.0  broadcast 172.18.63.255
        ether 00:16:3e:02:b6:46  txqueuelen 1000  (Ethernet)
        RX packets 1067841  bytes 1296732947 (1.2 GiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 409912  bytes 43569163 (41.5 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions </code></pre>
</li>
<li><p>网络配置工具（新） - <strong>ip</strong>。</p>
<pre><code class="Shell">[root ~]# ip address
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:16:3e:02:b6:46 brd ff:ff:ff:ff:ff:ff
    inet 172.18.61.250/20 brd 172.18.63.255 scope global eth0
       valid_lft forever preferred_lft forever</code></pre>
</li>
<li><p>网络可达性检查 - <strong>ping</strong>。</p>
<pre><code class="Shell">[root ~]# ping www.baidu.com -c 3
PING www.a.shifen.com (220.181.111.188) 56(84) bytes of data.
64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=1 ttl=51 time=36.3 ms
64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=2 ttl=51 time=36.4 ms
64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=3 ttl=51 time=36.4 ms
--- www.a.shifen.com ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2002ms
rtt min/avg/max/mdev = 36.392/36.406/36.427/0.156 ms</code></pre>
</li>
<li><p>显示或管理路由表 - <strong>route</strong>。</p>
</li>
<li><p>查看网络服务和端口 - <strong>netstat</strong> / <strong>ss</strong>。</p>
<pre><code class="Shell">[root ~]# netstat -nap | grep nginx</code></pre>
</li>
<li><p>网络监听抓包 - <strong>tcpdump</strong>。</p>
</li>
<li><p>安全文件拷贝 - <strong>scp</strong>。</p>
<pre><code class="Shell">[root ~]# scp root@1.2.3.4:/root/guido.jpg hellokitty@4.3.2.1:/home/hellokitty/pic.jpg</code></pre>
</li>
<li><p>文件同步工具 - <strong>rsync</strong>。</p>
<blockquote>
<p>说明：使用<code>rsync</code>可以实现文件的自动同步，这个对于文件服务器来说相当重要。关于这个命令的用法，我们在后面讲项目部署的时候为大家详细说明。</p>
</blockquote>
</li>
<li><p>安全文件传输 - <strong>sftp</strong>。</p>
<pre><code class="Shell">[root ~]# sftp root@1.2.3.4
root@1.2.3.4&#39;s password:
Connected to 1.2.3.4.
sftp&gt;</code></pre>
<ul>
<li><p><code>help</code>：显示帮助信息。</p>
</li>
<li><p><code>ls</code>/<code>lls</code>：显示远端/本地目录列表。</p>
</li>
<li><p><code>cd</code>/<code>lcd</code>：切换远端/本地路径。</p>
</li>
<li><p><code>mkdir</code>/<code>lmkdir</code>：创建远端/本地目录。</p>
</li>
<li><p><code>pwd</code>/<code>lpwd</code>：显示远端/本地当前工作目录。</p>
</li>
<li><p><code>get</code>：下载文件。</p>
</li>
<li><p><code>put</code>：上传文件。</p>
</li>
<li><p><code>rm</code>：删除远端文件。</p>
</li>
<li><p><code>bye</code>/<code>exit</code>/<code>quit</code>：退出sftp。</p>
</li>
</ul>
</li>
</ol>
<h3 id="十四：-进程管理"><a href="#十四：-进程管理" class="headerlink" title="十四： 进程管理"></a>十四： 进程管理</h3><ol>
<li><p>查看进程 - <strong>ps</strong>。</p>
<pre><code class="Shell">[root ~]# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Jun23 ?        00:00:05 /usr/lib/systemd/systemd --switched-root --system --deserialize 21
root         2     0  0 Jun23 ?        00:00:00 [kthreadd]
...
[root ~]# ps -ef | grep mysqld
root      4943  4581  0 22:45 pts/0    00:00:00 grep --color=auto mysqld
mysql    25257     1  0 Jun25 ?        00:00:39 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid</code></pre>
</li>
<li><p>显示进程状态树 - <strong>pstree</strong>。</p>
<pre><code class="Shell"> [root ~]# pstree
 systemd─┬─AliYunDun───18*[{AliYunDun}]
         ├─AliYunDunUpdate───3*[{AliYunDunUpdate}]
         ├─2*[agetty]
         ├─aliyun-service───2*[{aliyun-service}]
         ├─atd
         ├─auditd───{auditd}
         ├─dbus-daemon
         ├─dhclient
         ├─irqbalance
         ├─lvmetad
         ├─mysqld───28*[{mysqld}]
         ├─nginx───2*[nginx]
         ├─ntpd
         ├─polkitd───6*[{polkitd}]
         ├─rsyslogd───2*[{rsyslogd}]
         ├─sshd───sshd───bash───pstree
         ├─systemd-journal
         ├─systemd-logind
         ├─systemd-udevd
         └─tuned───4*[{tuned}]</code></pre>
</li>
<li><p>查找与指定条件匹配的进程 - <strong>pgrep</strong>。</p>
<pre><code class="Shell">[root ~]$ pgrep mysqld
3584</code></pre>
</li>
<li><p>通过进程号终止进程 - <strong>kill</strong>。</p>
<pre><code class="Shell">[root ~]$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
[root ~]# kill 1234
[root ~]# kill -9 1234</code></pre>
<p>例子：用一条命令强制终止正在运行的Redis进程。</p>
<pre><code class="Shell">ps -ef | grep redis | grep -v grep | awk &#39;{print $2}&#39; | xargs kill</code></pre>
</li>
<li><p>通过进程名终止进程 - <strong>killall</strong> / <strong>pkill</strong>。</p>
<p> 结束名为mysqld的进程。</p>
<pre><code class="Shell"> [root ~]# pkill mysqld</code></pre>
<p> 结束hellokitty用户的所有进程。</p>
<pre><code class="Shell"> [root ~]# pkill -u hellokitty</code></pre>
<blockquote>
<p>说明：这样的操作会让hellokitty用户和服务器断开连接。</p>
</blockquote>
</li>
<li><p>将进程置于后台运行。</p>
<ul>
<li><code>Ctrl+Z</code> - 快捷键，用于停止进程并置于后台。</li>
<li><code>&amp;</code> - 将进程置于后台运行。</li>
</ul>
<pre><code class="Shell">[root ~]# mongod &amp;
[root ~]# redis-server
...
^Z
[4]+  Stopped                 redis-server</code></pre>
</li>
<li><p>查询后台进程 - <strong>jobs</strong>。</p>
<pre><code class="Shell">[root ~]# jobs
[2]   Running                 mongod &amp;
[3]-  Stopped                 cat
[4]+  Stopped                 redis-server</code></pre>
</li>
<li><p>让进程在后台继续运行 - <strong>bg</strong>。</p>
<pre><code class="Shell">[root ~]# bg %4
[4]+ redis-server &amp;
[root ~]# jobs
[2]   Running                 mongod &amp;
[3]+  Stopped                 cat
[4]-  Running                 redis-server &amp;</code></pre>
</li>
<li><p>将后台进程置于前台 - <strong>fg</strong>。</p>
<pre><code class="Shell"> [root ~]# fg %4
 redis-server</code></pre>
<blockquote>
<p>说明：置于前台的进程可以使用<code>Ctrl+C</code>来终止它。</p>
</blockquote>
</li>
<li><p>调整程序/进程运行时优先级 - <strong>nice</strong> / <strong>renice</strong>。</p>
</li>
<li><p>用户登出后进程继续工作 - <strong>nohup</strong>。</p>
<pre><code class="Shell"> [root ~]# nohup ping www.baidu.com &gt; result.txt &amp;</code></pre>
</li>
<li><p>跟踪进程系统调用情况 - <strong>strace</strong>。</p>
<pre><code class="Shell"> [root ~]# pgrep mysqld
 8803
 [root ~]# strace -c -p 8803
 strace: Process 8803 attached
 ^Cstrace: Process 8803 detached
 % time     seconds  usecs/call     calls    errors syscall
 ------ ----------- ----------- --------- --------- ----------------
  99.18    0.005719        5719         1           restart_syscall
   0.49    0.000028          28         1           mprotect
   0.24    0.000014          14         1           clone
   0.05    0.000003           3         1           mmap
   0.03    0.000002           2         1           accept
 ------ ----------- ----------- --------- --------- ----------------
 100.00    0.005766                     5           total</code></pre>
<blockquote>
<p>说明：这个命令的用法和参数都比较复杂，建议大家在真正用到这个命令的时候再根据实际需要进行了解。</p>
</blockquote>
</li>
<li><p>查看当前运行级别 - <strong>runlevel</strong>。</p>
<pre><code class="Shell"> [root ~]# runlevel
 N 3</code></pre>
</li>
<li><p>实时监控进程占用资源状况 - <strong>top</strong>。</p>
<pre><code class="Shell"> [root ~]# top
 top - 23:04:23 up 3 days, 14:10,  1 user,  load average: 0.00, 0.01, 0.05
 Tasks:  65 total,   1 running,  64 sleeping,   0 stopped,   0 zombie
 %Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
 KiB Mem :  1016168 total,   191060 free,   324700 used,   500408 buff/cache
 KiB Swap:        0 total,        0 free,        0 used.   530944 avail Mem
 ...</code></pre>
<ul>
<li><code>-c</code> - 显示进程的整个路径。</li>
<li><code>-d</code> - 指定两次刷屏之间的间隔时间（秒为单位）。</li>
<li><code>-i</code> - 不显示闲置进程或僵尸进程。</li>
<li><code>-p</code> - 显示指定进程的信息。</li>
</ul>
</li>
</ol>
<h3 id="十五：-系统诊断"><a href="#十五：-系统诊断" class="headerlink" title="十五： 系统诊断"></a>十五： 系统诊断</h3><ol>
<li><p>系统启动异常诊断 - <strong>dmesg</strong>。</p>
</li>
<li><p>查看系统活动信息 - <strong>sar</strong>。</p>
<pre><code class="Shell">[root ~]# sar -u -r 5 10
Linux 3.10.0-957.10.1.el7.x86_64 (izwz97tbgo9lkabnat2lo8z)      06/02/2019      _x86_64_        (2 CPU)

06:48:30 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle
06:48:35 PM     all      0.10      0.00      0.10      0.00      0.00     99.80

06:48:30 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty
06:48:35 PM   1772012   2108392     54.33    102816   1634528    784940     20.23    793328   1164704         0</code></pre>
<ul>
<li><code>-A</code> - 显示所有设备（CPU、内存、磁盘）的运行状况。</li>
<li><code>-u</code> - 显示所有CPU的负载情况。</li>
<li><code>-d</code> - 显示所有磁盘的使用情况。</li>
<li><code>-r</code> - 显示内存的使用情况。</li>
<li><code>-n</code> - 显示网络运行状态。</li>
</ul>
</li>
<li><p>查看内存使用情况 - <strong>free</strong>。</p>
<pre><code class="Shell">[root ~]# free
              total        used        free      shared  buff/cache   available
Mem:        1016168      323924      190452         356      501792      531800
Swap:             0           0           0</code></pre>
</li>
<li><p>虚拟内存统计 - <strong>vmstat</strong>。</p>
<pre><code class="Shell">[root ~]# vmstat
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 2  0      0 204020  79036 667532    0    0     5    18  101   58  1  0 99  0  0</code></pre>
</li>
<li><p>CPU信息统计 - <strong>mpstat</strong>。</p>
<pre><code class="Shell">[root ~]# mpstat
Linux 3.10.0-957.5.1.el7.x86_64 (iZ8vba0s66jjlfmo601w4xZ)       05/30/2019      _x86_64_        (1 CPU)

01:51:54 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
01:51:54 AM  all    0.71    0.00    0.17    0.04    0.00    0.00    0.00    0.00    0.00   99.07</code></pre>
</li>
<li><p>查看进程使用内存状况 - <strong>pmap</strong>。</p>
<pre><code class="Shell">[root ~]# ps
  PID TTY          TIME CMD
 4581 pts/0    00:00:00 bash
 5664 pts/0    00:00:00 ps
[root ~]# pmap 4581
4581:   -bash
0000000000400000    884K r-x-- bash
00000000006dc000      4K r---- bash
00000000006dd000     36K rw--- bash
00000000006e6000     24K rw---   [ anon ]
0000000001de0000    400K rw---   [ anon ]
00007f82fe805000     48K r-x-- libnss_files-2.17.so
00007f82fe811000   2044K ----- libnss_files-2.17.so
...</code></pre>
</li>
<li><p>报告设备CPU和I/O统计信息 - <strong>iostat</strong>。</p>
<pre><code class="Shell">[root ~]# iostat
Linux 3.10.0-693.11.1.el7.x86_64 (iZwz97tbgo9lkabnat2lo8Z)      06/26/2018      _x86_64_       (1 CPU)
avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.79    0.00    0.20    0.04    0.00   98.97
Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda               0.85         6.78        21.32    2106565    6623024
vdb               0.00         0.01         0.00       2088          0</code></pre>
</li>
<li><p>显示所有PCI设备 - <strong>lspci</strong>。</p>
<pre><code class="Shell">[root ~]# lspci
00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)
00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]
00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]
00:01.2 USB controller: Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II] (rev 01)
00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)
00:02.0 VGA compatible controller: Cirrus Logic GD 5446
00:03.0 Ethernet controller: Red Hat, Inc. Virtio network device
00:04.0 Communication controller: Red Hat, Inc. Virtio console
00:05.0 SCSI storage controller: Red Hat, Inc. Virtio block device
00:06.0 SCSI storage controller: Red Hat, Inc. Virtio block device
00:07.0 Unclassified device [00ff]: Red Hat, Inc. Virtio memory balloon</code></pre>
</li>
<li><p>显示进程间通信设施的状态 - <strong>ipcs</strong>。</p>
<pre><code class="Shell">[root ~]# ipcs

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status      

------ Semaphore Arrays --------
key        semid      owner      perms      nsems</code></pre>
</li>
</ol>
<h3 id="十六：-Shell编程"><a href="#十六：-Shell编程" class="headerlink" title="十六： Shell编程"></a>十六： Shell编程</h3><p>之前我们提到过，Shell是一个连接用户和操作系统的应用程序，它提供了人机交互的界面（接口），用户通过这个界面访问操作系统内核的服务。Shell脚本是一种为Shell编写的脚本程序，我们可以通过Shell脚本来进行系统管理，同时也可以通过它进行文件操作。总之，编写Shell脚本对于使用Linux系统的人来说，应该是一项标配技能。</p>
<p>互联网上有大量关于Shell脚本的相关知识，我不打算再此对Shell脚本做一个全面系统的讲解，我们通过下面的代码来感性的认识下Shell脚本就行了。</p>
<p>例子1：输入两个整数m和n，计算从m到n的整数求和的结果。</p>
<pre><code class="Shell">#!/usr/bin/bash
printf &#39;m = &#39;
read m
printf &#39;n = &#39;
read n
a=$m
sum=0
while [ $a -le $n ]
do
    sum=$[ sum + a ]
    a=$[ a + 1 ]
done
echo &#39;结果: &#39;$sum</code></pre>
<p>例子2：自动创建文件夹和指定数量的文件。</p>
<pre><code class="Shell">#!/usr/bin/bash
printf &#39;输入文件名: &#39;
read file
printf &#39;输入文件数量(&lt;1000): &#39;
read num
if [ $num -ge 1000 ]
then
    echo &#39;文件数量不能超过1000&#39;
else
    if [ -e $dir -a -d $dir ]
    then
        rm -rf $dir
    else
        if [ -e $dir -a -f $dir ]
        then
            rm -f $dir
        fi
    fi
    mkdir -p $dir
    index=1
    while [ $index -le $num ]
    do
        if [ $index -lt 10 ]
        then
            pre=&#39;00&#39;
        elif [ $index -lt 100 ]
        then
            pre=&#39;0&#39;
        else
            pre=&#39;&#39;
        fi
        touch $dir&#39;/&#39;$file&#39;_&#39;$pre$index
        index=$[ index + 1 ]
    done
fi</code></pre>
<p>例子3：自动安装指定版本的Redis。</p>
<pre><code class="Shell">#!/usr/bin/bash
install_redis() {
    if ! which redis-server &gt; /dev/null
    then
        cd /root
        wget $1$2&#39;.tar.gz&#39; &gt;&gt; install.log
        gunzip /root/$2&#39;.tar.gz&#39;
        tar -xf /root/$2&#39;.tar&#39;
        cd /root/$2
        make &gt;&gt; install.log
        make install &gt;&gt; install.log
        echo &#39;安装完成&#39;
    else
        echo &#39;已经安装过Redis&#39;
    fi
}

install_redis &#39;http://download.redis.io/releases/&#39; $1</code></pre>
<h3 id="十七：-相关资源"><a href="#十七：-相关资源" class="headerlink" title="十七： 相关资源"></a>十七： 相关资源</h3><ol>
<li><p>Linux命令行常用快捷键</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>tab</td>
<td>自动补全命令或路径</td>
</tr>
<tr>
<td>Ctrl+a</td>
<td>将光标移动到命令行行首</td>
</tr>
<tr>
<td>Ctrl+e</td>
<td>将光标移动到命令行行尾</td>
</tr>
<tr>
<td>Ctrl+f</td>
<td>将光标向右移动一个字符</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>将光标向左移动一个字符</td>
</tr>
<tr>
<td>Ctrl+k</td>
<td>剪切从光标到行尾的字符</td>
</tr>
<tr>
<td>Ctrl+u</td>
<td>剪切从光标到行首的字符</td>
</tr>
<tr>
<td>Ctrl+w</td>
<td>剪切光标前面的一个单词</td>
</tr>
<tr>
<td>Ctrl+y</td>
<td>复制剪切命名剪切的内容</td>
</tr>
<tr>
<td>Ctrl+c</td>
<td>中断正在执行的任务</td>
</tr>
<tr>
<td>Ctrl+h</td>
<td>删除光标前面的一个字符</td>
</tr>
<tr>
<td>Ctrl+d</td>
<td>退出当前命令行</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>搜索历史命令</td>
</tr>
<tr>
<td>Ctrl+g</td>
<td>退出历史命令搜索</td>
</tr>
<tr>
<td>Ctrl+l</td>
<td>清除屏幕上所有内容在屏幕的最上方开启一个新行</td>
</tr>
<tr>
<td>Ctrl+s</td>
<td>锁定终端使之暂时无法输入内容</td>
</tr>
<tr>
<td>Ctrl+q</td>
<td>退出终端锁定</td>
</tr>
<tr>
<td>Ctrl+z</td>
<td>将正在终端执行的任务停下来放到后台</td>
</tr>
<tr>
<td>!!</td>
<td>执行上一条命令</td>
</tr>
<tr>
<td>!数字</td>
<td>执行数字对应的历史命令</td>
</tr>
<tr>
<td>!字母</td>
<td>执行最近的以字母打头的命令</td>
</tr>
<tr>
<td>!$ / Esc+.</td>
<td>获得上一条命令最后一个参数</td>
</tr>
<tr>
<td>Esc+b</td>
<td>移动到当前单词的开头</td>
</tr>
<tr>
<td>Esc+f</td>
<td>移动到当前单词的结尾</td>
</tr>
</tbody></table>
</li>
<li><p>man查阅命令手册的内容说明</p>
<table>
<thead>
<tr>
<th>手册中的标题</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>NAME</td>
<td>命令的说明和介绍</td>
</tr>
<tr>
<td>SYNOPSIS</td>
<td>使用该命令的基本语法</td>
</tr>
<tr>
<td>DESCRIPTION</td>
<td>使用该命令的详细描述，各个参数的作用，有时候这些信息会出现在OPTIONS中</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>命令相关参数选项的说明</td>
</tr>
<tr>
<td>EXAMPLES</td>
<td>使用该命令的参考例子</td>
</tr>
<tr>
<td>EXIT STATUS</td>
<td>命令结束的退出状态码，通常0表示成功执行</td>
</tr>
<tr>
<td>SEE ALSO</td>
<td>和命令相关的其他命令或信息</td>
</tr>
<tr>
<td>BUGS</td>
<td>和命令相关的缺陷的描述</td>
</tr>
<tr>
<td>AUTHOR</td>
<td>该命令的作者介绍</td>
</tr>
</tbody></table>
</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>使用正则表达式</title>
    <url>/2020/02/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p><strong>本文转载于GitHub项目<a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">Python - 100天从新手到大师</a></strong></p>
</blockquote>
<h3 id="一：-正则表达式相关知识"><a href="#一：-正则表达式相关知识" class="headerlink" title="一： 正则表达式相关知识"></a>一： 正则表达式相关知识</h3><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。</p>
<p>我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。</p>
<p>关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫<a href="https://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">《正则表达式30分钟入门教程》</a>，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配任意字符</td>
<td>b.t</td>
<td>可以匹配bat / but / b#t / b1t等</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母/数字/下划线</td>
<td>b\wt</td>
<td>可以匹配bat / b1t / b_t等<br>但不能匹配b#t</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空白字符（包括\r、\n、\t等）</td>
<td>love\syou</td>
<td>可以匹配love you</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
<td>\d\d</td>
<td>可以匹配01 / 23 / 99等</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的边界</td>
<td>\bThe\b</td>
<td></td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
<td>^The</td>
<td>可以匹配The开头的字符串</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结束</td>
<td>.exe$</td>
<td>可以匹配.exe结尾的字符串</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非字母/数字/下划线</td>
<td>b\Wt</td>
<td>可以匹配b#t / b@t等<br>但不能匹配but / b1t / b_t等</td>
</tr>
<tr>
<td>\S</td>
<td>匹配非空白字符</td>
<td>love\Syou</td>
<td>可以匹配love#you等<br>但不能匹配love you</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字</td>
<td>\d\D</td>
<td>可以匹配9a / 3# / 0F等</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界</td>
<td>\Bio\B</td>
<td></td>
</tr>
<tr>
<td>[]</td>
<td>匹配来自字符集的任意单一字符</td>
<td>[aeiou]</td>
<td>可以匹配任一元音字母字符</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配不在字符集中的任意单一字符</td>
<td>[^aeiou]</td>
<td>可以匹配任一非元音字母字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配0次或多次</td>
<td>\w*</td>
<td></td>
</tr>
<tr>
<td>+</td>
<td>匹配1次或多次</td>
<td>\w+</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>匹配0次或1次</td>
<td>\w?</td>
<td></td>
</tr>
<tr>
<td>{N}</td>
<td>匹配N次</td>
<td>\w{3}</td>
<td></td>
</tr>
<tr>
<td>{M,}</td>
<td>匹配至少M次</td>
<td>\w{3,}</td>
<td></td>
</tr>
<tr>
<td>{M,N}</td>
<td>匹配至少M次至多N次</td>
<td>\w{3,6}</td>
<td></td>
</tr>
<tr>
<td>|</td>
<td>分支</td>
<td>foo|bar</td>
<td>可以匹配foo或者bar</td>
</tr>
<tr>
<td>(?#)</td>
<td>注释</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(exp)</td>
<td>匹配exp并捕获到自动命名的组中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?&nbsp;&lt;name&gt;exp)</td>
<td>匹配exp并捕获到名为name的组中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?:exp)</td>
<td>匹配exp但是不捕获匹配的文本</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?=exp)</td>
<td>匹配exp前面的位置</td>
<td>\b\w+(?=ing)</td>
<td>可以匹配I’m dancing中的danc</td>
</tr>
<tr>
<td>(?&lt;=exp)</td>
<td>匹配exp后面的位置</td>
<td>(?&lt;=\bdanc)\w+\b</td>
<td>可以匹配I love dancing and reading中的第一个ing</td>
</tr>
<tr>
<td>(?!exp)</td>
<td>匹配后面不是exp的位置</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?&lt;!exp)</td>
<td>匹配前面不是exp的位置</td>
<td></td>
<td></td>
</tr>
<tr>
<td>*?</td>
<td>重复任意次，但尽可能少重复</td>
<td>a.*b<br>a.*?b</td>
<td>将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串</td>
</tr>
<tr>
<td>+?</td>
<td>重复1次或多次，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
<tr>
<td>??</td>
<td>重复0次或1次，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
<tr>
<td>{M,N}?</td>
<td>重复M到N次，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
<tr>
<td>{M,}?</td>
<td>重复M次以上，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>说明：</strong> 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\进行转义处理，例如想匹配小数点可以写成\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\(和\)，否则圆括号被视为正则表达式中的分组。</p>
</blockquote>
<h3 id="二：-Python对正则表达式的支持"><a href="#二：-Python对正则表达式的支持" class="headerlink" title="二： Python对正则表达式的支持"></a>二： Python对正则表达式的支持</h3><p>Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>compile(pattern, flags=0)</td>
<td>编译正则表达式返回正则表达式对象</td>
</tr>
<tr>
<td>match(pattern, string, flags=0)</td>
<td>用正则表达式匹配字符串 成功返回匹配对象 否则返回None</td>
</tr>
<tr>
<td>search(pattern, string, flags=0)</td>
<td>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None</td>
</tr>
<tr>
<td>split(pattern, string, maxsplit=0, flags=0)</td>
<td>用正则表达式指定的模式分隔符拆分字符串 返回列表</td>
</tr>
<tr>
<td>sub(pattern, repl, string, count=0, flags=0)</td>
<td>用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数</td>
</tr>
<tr>
<td>fullmatch(pattern, string, flags=0)</td>
<td>match函数的完全匹配（从字符串开头到结尾）版本</td>
</tr>
<tr>
<td>findall(pattern, string, flags=0)</td>
<td>查找字符串所有与正则表达式匹配的模式 返回字符串的列表</td>
</tr>
<tr>
<td>finditer(pattern, string, flags=0)</td>
<td>查找字符串所有与正则表达式匹配的模式 返回一个迭代器</td>
</tr>
<tr>
<td>purge()</td>
<td>清除隐式编译的正则表达式的缓存</td>
</tr>
<tr>
<td>re.I / re.IGNORECASE</td>
<td>忽略大小写匹配标记</td>
</tr>
<tr>
<td>re.M / re.MULTILINE</td>
<td>多行匹配标记</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>说明：</strong> 上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。</p>
</blockquote>
<p>下面我们通过一系列的例子来告诉大家在Python中如何使用正则表达式。</p>
<h4 id="例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。"><a href="#例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。" class="headerlink" title="例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。"></a>例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。</h4><pre><code class="Python">&quot;&quot;&quot;
验证输入用户名和QQ号是否有效并给出对应的提示信息

要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0
&quot;&quot;&quot;
import re


def main():
    username = input(&#39;请输入用户名: &#39;)
    qq = input(&#39;请输入QQ号: &#39;)
    # match函数的第一个参数是正则表达式字符串或正则表达式对象
    # 第二个参数是要跟正则表达式做匹配的字符串对象
    m1 = re.match(r&#39;^[0-9a-zA-Z_]{6,20}$&#39;, username)
    if not m1:
        print(&#39;请输入有效的用户名.&#39;)
    m2 = re.match(r&#39;^[1-9]\d{4,11}$&#39;, qq)
    if not m2:
        print(&#39;请输入有效的QQ号.&#39;)
    if m1 and m2:
        print(&#39;你输入的信息是有效的!&#39;)


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
<blockquote>
<p><strong>提示：</strong> 上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\，例如表示数字的\d得书写成\\d，这样不仅写起来不方便，阅读的时候也会很吃力。</p>
</blockquote>
<h4 id="例子2：从一段文字中提取出国内手机号码。"><a href="#例子2：从一段文字中提取出国内手机号码。" class="headerlink" title="例子2：从一段文字中提取出国内手机号码。"></a>例子2：从一段文字中提取出国内手机号码。</h4><p>下面这张图是截止到2017年底，国内三家运营商推出的手机号段。</p>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/tel-start-number.png" srcset="/img/loading.gif" alt="tel-start-number.png"></p>
<pre><code class="Python">import re


def main():
    # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字
    pattern = re.compile(r&#39;(?&lt;=\D)1[34578]\d{9}(?=\D)&#39;)
    sentence = &#39;&#39;&#39;
    重要的事情说8130123456789遍，我的手机号是13512346789这个靓号，
    不是15600998765，也是110或119，王大锤的手机号才是15600998765。
    &#39;&#39;&#39;
    # 查找所有匹配并保存到一个列表中
    mylist = re.findall(pattern, sentence)
    print(mylist)
    print(&#39;--------华丽的分隔线--------&#39;)
    # 通过迭代器取出匹配对象并获得匹配的内容
    for temp in pattern.finditer(sentence):
        print(temp.group())
    print(&#39;--------华丽的分隔线--------&#39;)
    # 通过search函数指定搜索位置找出所有匹配
    m = pattern.search(sentence)
    while m:
        print(m.group())
        m = pattern.search(sentence, m.end())


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
<blockquote>
<p><strong>说明：</strong> 上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：<code>(?&lt;=\D)(1[38]\d{9}|14[57]\d{8}|15[0-35-9]\d{8}|17[678]\d{8})(?=\D)</code>，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。</p>
</blockquote>
<h4 id="例子3：替换字符串中的不良内容"><a href="#例子3：替换字符串中的不良内容" class="headerlink" title="例子3：替换字符串中的不良内容"></a>例子3：替换字符串中的不良内容</h4><pre><code class="Python">import re


def main():
    sentence = &#39;你丫是傻叉吗? 我操你大爷的. Fuck you.&#39;
    purified = re.sub(&#39;[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔&#39;,
                      &#39;*&#39;, sentence, flags=re.IGNORECASE)
    print(purified)  # 你丫是*吗? 我*你大爷的. * you.


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
<blockquote>
<p><strong>说明：</strong> re模块的正则表达式相关函数中都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用<a href="http://www.runoob.com/python/python-operators.html#ysf5" target="_blank" rel="noopener">按位或运算符</a>进行叠加，如<code>flags=re.I | re.M</code>。</p>
</blockquote>
<h4 id="例子4：拆分长字符串"><a href="#例子4：拆分长字符串" class="headerlink" title="例子4：拆分长字符串"></a>例子4：拆分长字符串</h4><pre><code class="Python">import re


def main():
    poem = &#39;窗前明月光，疑是地上霜。举头望明月，低头思故乡。&#39;
    sentence_list = re.split(r&#39;[，。, .]&#39;, poem)
    while &#39;&#39; in sentence_list:
        sentence_list.remove(&#39;&#39;)
    print(sentence_list)  # [&#39;窗前明月光&#39;, &#39;疑是地上霜&#39;, &#39;举头望明月&#39;, &#39;低头思故乡&#39;]


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
<h3 id="三：-后话"><a href="#三：-后话" class="headerlink" title="三： 后话"></a>三： 后话</h3><p>如果要从事爬虫类应用的开发，那么正则表达式一定是一个非常好的助手，因为它可以帮助我们迅速的从网页代码中发现某种我们指定的模式并提取出我们需要的信息，当然对于初学者来收，要编写一个正确的适当的正则表达式可能并不是一件容易的事情（当然有些常用的正则表达式可以直接在网上找找），所以实际开发爬虫应用的时候，有很多人会选择<a href="https://www.crummy.com/software/BeautifulSoup/" target="_blank" rel="noopener">Beautiful Soup</a>或<a href="http://lxml.de/" target="_blank" rel="noopener">Lxml</a>来进行匹配和信息的提取，前者简单方便但是性能较差，后者既好用性能也好，但是安装稍嫌麻烦。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>python处理excle实例之字符串减法</title>
    <url>/2020/02/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/python%E5%A4%84%E7%90%86excle%E5%AE%9E%E4%BE%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%8F%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/python%2Bexcel.jpg" srcset="/img/loading.gif" alt="python+excel"></p>
<a id="more"></a>

<pre><code class="py">#!/usr/bin/python
# -*- coding: utf-8 -*-
from openpyxl import load_workbook


# 求字符串A-B
def str_A_cut_B(a, b):
    if b:
        for x in a:
            if x in b:
                a = a.replace(x, &quot;&quot;)
    return a


# 写入模式打开0.txt
# f = open(&quot;0.txt&quot;, &quot;w&quot;)

# 打开excel名为test
wb = load_workbook(filename=&#39;test.xlsx&#39;)

# 打开工作表Sheet1
sheet = wb[&#39;Sheet1&#39;]

for i in range(2, 36):
    temp = &#39;C&#39; + str(i)

    # 将temp单元格的内容存入str1
    str1 = sheet[temp].value
    str0 = &quot;张 朱 颜 赵 杨 施 胡 何 秦 刘 夏 鹏 李 唐 许 王 邓 顾&quot;
    z = str_A_cut_B(str0, str1)

    # 若单元格为空，换行输出
    if str1:
        # 输出格式
        for j in range(len(z)):
            print(z[j], end=&#39; &#39;)  # 不换行输出
            # print(z[j], end=&#39; &#39;, file=f)
        print(&#39; &#39;)
        # print(&#39; &#39;, file=f)
    else:
        print(&#39; &#39;)
        # print(&#39; &#39;, file=f)
# f.close()</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>excel</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在GitHub搜索开源项目</title>
    <url>/2020/02/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Github/%E5%A6%82%E4%BD%95%E5%9C%A8GitHub%E4%B8%8A%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="一：-如何使用搜索栏"><a href="#一：-如何使用搜索栏" class="headerlink" title="一： 如何使用搜索栏"></a>一： 如何使用搜索栏</h2><p>所有搜索需求用空格隔开。</p>
<p>搜索栏输入：</p>
<ol>
<li><p>搜索项目名里面包含python、项目readme里面包含python、描述里面包含python<br><code>in:name python</code>、<code>in:readme python</code>、<code>in:description 爬虫</code>/<code>in:des 爬虫</code><br>PS：description描述里面包含比较准确</p>
</li>
<li><p>stars数大于1000、forks数大于xxx<br><code>stars:&gt;1000</code>、<code>forks:&gt;xxx</code></p>
</li>
<li><p>指定编程语言<br><code>language:python</code></p>
</li>
<li><p>最后更新时间限定<br><code>pushed:&gt;2020-01-01</code></p>
</li>
<li><p>限定国内开发者<br><code>location:China</code></p>
</li>
</ol>
<h2 id="二：-chrome插件推荐"><a href="#二：-chrome插件推荐" class="headerlink" title="二： chrome插件推荐"></a>二： chrome插件推荐</h2><ul>
<li>Octotree</li>
<li>GitZip for github<br>双击你想下载的文件后面空白的地方，文件前方会出现√，右下角出现<code>Download checked items</code>即可下载。</li>
<li>英文不好的小伙伴推荐沙拉查词</li>
</ul>
<h2 id="三：-git-clone速度慢的解决方案"><a href="#三：-git-clone速度慢的解决方案" class="headerlink" title="三： git clone速度慢的解决方案"></a>三： git clone速度慢的解决方案</h2><p>登录<a href="https://gitee.com/" target="_blank" rel="noopener">Gitee</a> -&gt; 新建仓库 -&gt; 拉到最下的创建上面，点击导入已有仓库 -&gt; 填入你想git clone的GitHub仓库地址 -&gt; 本地，git clone。</p>
<h2 id="四：-参考视频"><a href="#四：-参考视频" class="headerlink" title="四： 参考视频"></a>四： 参考视频</h2><p><a href="https://www.bilibili.com/video/av75587104" target="_blank" rel="noopener">https://www.bilibili.com/video/av75587104</a></p>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu安装完以后的基础配置</title>
    <url>/2020/02/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/ubuntu%E5%AE%89%E8%A3%85%E5%AE%8C%E4%BB%A5%E5%90%8E%E7%9A%84%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="一：-安装类型"><a href="#一：-安装类型" class="headerlink" title="一： 安装类型"></a>一： 安装类型</h2><ol>
<li>/boot分区（引导）-&gt;512MB-&gt;主分区-&gt;空间起始位置-&gt;Ext4日志文件系统-&gt;/boot。</li>
<li>/ 根分区（相当于windows的c盘）-&gt;102400MB-&gt;主分区-&gt;空间起始位置-&gt;XFS日志文件系统-&gt;/。</li>
<li>swap分区（桌面系统不分，服务器必分）-&gt;2048MB-&gt;逻辑分区-&gt;空间起始位置-&gt;交换空间。</li>
<li>/home分区（存储空间，剩余都给它）-&gt;max MB-&gt;主分区-&gt;空间起始位置-&gt;XFS日志文件系统-&gt;/home。</li>
<li>现在安装。</li>
</ol>
<h2 id="二：-基础配置"><a href="#二：-基础配置" class="headerlink" title="二： 基础配置"></a>二： 基础配置</h2><h3 id="2-1-设置root用户密码"><a href="#2-1-设置root用户密码" class="headerlink" title="2.1 设置root用户密码"></a>2.1 设置root用户密码</h3><p><code>sudo passwd root</code><br><code>su</code></p>
<a id="more"></a>

<h3 id="2-2-修改镜像源"><a href="#2-2-修改镜像源" class="headerlink" title="2.2 修改镜像源"></a>2.2 修改镜像源</h3><ol>
<li><code>sudo nano /etc/apt/sources.list</code></li>
<li>将原文件所有内容注释掉；</li>
<li>复制<a href="https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.2f191b11mRGGjV" target="_blank" rel="noopener">阿里巴巴镜像源</a></li>
<li>黏贴到终端，<code>ctrl</code>+<code>o</code>保存，回车确定,<code>ctrl</code>+<code>x</code>。</li>
</ol>
<h3 id="2-3-更新源和系统"><a href="#2-3-更新源和系统" class="headerlink" title="2.3 更新源和系统"></a>2.3 更新源和系统</h3><p><code>sudo apt update</code><br><code>sudo apt upgrade</code><br><code>sudo apt dist-upgrade</code><br><code>sudo apt autoremove</code>  # 清理不需要的旧组件<br><code>reboot</code>  # 重启</p>
<h3 id="2-4-安装输入法"><a href="#2-4-安装输入法" class="headerlink" title="2.4 安装输入法"></a>2.4 安装输入法</h3><ol>
<li>卸载自带ibus<br><code>sudo apt remove ibus</code></li>
<li>安装fcitx<br><code>sudo apt install fcitx-bin fcitx-table</code></li>
<li>安装Google拼音<br><code>sudo apt install fcitx-googlepinyin</code></li>
<li><code>sudo im-config</code>-&gt;确定-&gt;yes-&gt;选择fcitx,确定-&gt;reboot重启。</li>
</ol>
<h3 id="2-5-安装Google浏览器"><a href="#2-5-安装Google浏览器" class="headerlink" title="2.5 安装Google浏览器"></a>2.5 安装Google浏览器</h3><ol>
<li>打开 <a href="https://www.google.cn/intl/zh-CN/chrome/" target="_blank" rel="noopener">https://www.google.cn/intl/zh-CN/chrome/</a></li>
<li>下载-&gt;64位.deb-&gt;接受并安装。</li>
<li>在下载文件夹内打开终端。</li>
<li><code>sudo dpkg -i google-chrome-stable_current_amd64.deb</code></li>
</ol>
<h3 id="2-6-设置语言"><a href="#2-6-设置语言" class="headerlink" title="2.6 设置语言"></a>2.6 设置语言</h3><p>设置-&gt;区域和语言-&gt;管理已安装的语言-&gt;安装。</p>
<h3 id="2-7-安装vlc"><a href="#2-7-安装vlc" class="headerlink" title="2.7 安装vlc"></a>2.7 安装vlc</h3><p><code>sudo apt install vlc</code></p>
<h3 id="2-8-关闭ubuntu内部错误"><a href="#2-8-关闭ubuntu内部错误" class="headerlink" title="2.8 关闭ubuntu内部错误"></a>2.8 关闭ubuntu内部错误</h3><ol>
<li><code>sudo nano /etc/default/apport</code></li>
<li>enable=1改为0</li>
<li><code>ctrl</code>+<code>o</code>保存，回车确定,<code>ctrl</code>+<code>x</code>。</li>
</ol>
<h3 id="2-9-安装新立得软件包"><a href="#2-9-安装新立得软件包" class="headerlink" title="2.9 安装新立得软件包"></a>2.9 安装新立得软件包</h3><p><code>sudo apt install synaptic</code></p>
<h2 id="三：-参考视频"><a href="#三：-参考视频" class="headerlink" title="三： 参考视频"></a>三： 参考视频</h2><p><strong><a href="https://www.bilibili.com/video/av48233413" target="_blank" rel="noopener">https://www.bilibili.com/video/av48233413</a></strong></p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>利用python实现Gitee Pages定时自动部署/自动签到</title>
    <url>/2020/02/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/%E5%88%A9%E7%94%A8python%E5%AE%9E%E7%8E%B0Gitee-Pages%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E3%80%81%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0/</url>
    <content><![CDATA[<h2 id="一：-前期准备"><a href="#一：-前期准备" class="headerlink" title="一： 前期准备"></a>一： 前期准备</h2><h3 id="1-1-基础环境"><a href="#1-1-基础环境" class="headerlink" title="1.1 基础环境"></a>1.1 基础环境</h3><ol>
<li>python3 + selenium + chrome浏览器。<br>如果有不懂的可以查阅<a href="https://python-selenium-zh.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">selenium-python中文文档</a></li>
<li>chrome-&gt;设置-&gt;关于chrome-&gt;查看版本（我的版本是 80.0.3987.106（正式版本） （64 位））。  </li>
<li>需要下载跟你的chrome版本一致的<a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">ChromeDriver可执行驱动</a><br>下载完解压放在python根目录(即跟python.exe放在一起)。</li>
<li>最好有一台云主机，没有的话需要自己的电脑设定定时开机，定时任务，定时关机。  <a id="more"></a></li>
</ol>
<h3 id="1-2-安装环境"><a href="#1-2-安装环境" class="headerlink" title="1.2 安装环境"></a>1.2 安装环境</h3><ol>
<li>安装python3,不懂的请查阅我的相关blog文。</li>
<li>打开windows命令行，安装selenium<br><code>pip install selenium -i https://pypi.tuna.tsinghua.edu.cn/simple</code></li>
</ol>
<h2 id="二：-代码"><a href="#二：-代码" class="headerlink" title="二： 代码"></a>二： 代码</h2><h3 id="2-1-源码"><a href="#2-1-源码" class="headerlink" title="2.1 源码"></a>2.1 源码</h3><pre><code class="py">#!/usr/bin/python
# -*- coding: utf-8 -*-
import time
from selenium import webdriver
from selenium.webdriver.common.alert import Alert

# 模拟浏览器打开到gitee登录界面
driver = webdriver.Chrome()
driver.get(&#39;https://gitee.com/login&#39;)
# 将窗口最大化
driver.maximize_window()
time.sleep(2)

# 输入账号--通过html的id属性定位输入位置--改为你的账号
user_login = driver.find_element_by_id(&#39;user_login&#39;)
user_login.send_keys(&quot;此处改为你的账号&quot;)
# 输入密码--通过html的id属性定位输入位置--改为你的密码
driver.find_element_by_id(&#39;user_password&#39;).send_keys(&quot;此处改为你的密码&quot;)
# 点击登录按钮--通过xpath确定点击位置
driver.find_element_by_xpath(
    &#39;/html/body/div[2]/div[2]/div[1]/div/div[2]/div/form[1]/div[2]/div/div/div[4]/input&#39;).click()

time.sleep(2)

# 切换到gitee pages界面--改为you_gitee_id
driver.get(&#39;https://gitee.com/此处改为you_gitee_id/此处改为you_gitee_id/pages&#39;)
# 点击更新按钮--通过xpath确定点击位置
driver.find_element_by_xpath(&#39;/html/body/div[3]/div[2]/div/div[2]/div[1]/form/div[7]&#39;).click()
# 确认更新提示框--这个函数的作用是确认提示框
Alert(driver).accept()

# 等待5秒更新
time.sleep(5)

# 这个print其实没事什么用,如果真的要测试脚本是否运行成功，可以用try来抛出异常
print(&quot;成功&quot;)

# 脚本运行成功,退出浏览器
driver.quit()

# 写上更新日志
# 我这里是写在D盘，可以改为自己喜欢的目录
fp = open(&quot;D:\log.txt&quot;, &quot;a+&quot;)
now_time = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())
fp.write(&quot;auto update time:{0}\n&quot;.format(now_time))
fp.close()</code></pre>
<p>把源码黏贴到<code>gitee.py</code>文件内，备用。</p>
<h3 id="2-2-注意事项"><a href="#2-2-注意事项" class="headerlink" title="2.2 注意事项"></a>2.2 注意事项</h3><ul>
<li><p>html的id属性、xpath可以通过在chrome的网页里面按F12 -&gt; 选择一个元素进行检查(快捷键Ctrl + Shift + C)查看，如图就是<code>百度一下</code>的div块元素属性。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/CopyFullXPath.png" srcset="/img/loading.gif" alt="CopyXPath"></p>
</li>
<li><p>python selenium模块的具体函数使用方法请参考官方文档。  </p>
</li>
<li><p>编写自动签到脚本也差不多同样的道理。</p>
</li>
</ul>
<h2 id="三：-添加定时任务自动部署"><a href="#三：-添加定时任务自动部署" class="headerlink" title="三： 添加定时任务自动部署"></a>三： 添加定时任务自动部署</h2><pre><code class="bat">@echo off

d:

python gitee.py

echo &quot;等待更新完成再关闭窗口... ...&quot;

timeout /t 300
rem 上面的代码是等待5分钟。
</code></pre>
<ol>
<li>编写windows批处理脚本，代码如上。注意编码要是windows特有的GBK编码，否则会有乱码，保存为<code>gitee.bat</code>。</li>
<li>登录云主机，复制<code>gitee.py</code>、<code>gitee.bat</code>到D盘根目录。</li>
<li>云主机内-&gt;右键我的电脑-&gt;管理-&gt;工具-&gt;任务计划程序-&gt;创建基本任务…添加任务每天执行一次，实在不会的请<a href="https://jingyan.baidu.com/article/154b463130041128ca8f41c7.html" target="_blank" rel="noopener">百度</a></li>
<li>在自己电脑上的话也可以把上述部署代码添加到<a href="https://8hn9w5.coding-pages.com/2020/02/15/hexo/hexo%E4%B8%80%E9%94%AE%E4%B8%8A%E4%BC%A0%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC%E7%9A%84%E6%9E%84%E5%BB%BA/" target="_blank" rel="noopener">hexo一键上传部署脚本</a>的后面，每次git push后自动在gitee的pages界面部署。</li>
</ol>
<h2 id="四：-参考文献"><a href="#四：-参考文献" class="headerlink" title="四： 参考文献"></a>四： 参考文献</h2><ul>
<li><a href="https://python-selenium-zh.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://python-selenium-zh.readthedocs.io/zh_CN/latest/</a></li>
<li><a href="https://blog.csdn.net/ydydyd00/article/details/80882183" target="_blank" rel="noopener">https://blog.csdn.net/ydydyd00/article/details/80882183</a></li>
<li><a href="https://jingyan.baidu.com/article/154b463130041128ca8f41c7.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/154b463130041128ca8f41c7.html</a></li>
</ul>
<p><strong>enjoy!</strong></p>
]]></content>
      <categories>
        <category>python</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>python</tag>
        <tag>自动签到</tag>
      </tags>
  </entry>
  <entry>
    <title>you-get下载视频</title>
    <url>/2020/02/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/you-get%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<h2 id="一：-简介"><a href="#一：-简介" class="headerlink" title="一： 简介"></a>一： 简介</h2><p>You-Get 乃一小小哒命令行程序，提供便利的方式来下载网络上的媒体信息，通过python来安装。<br>支持主流视频网站如：YouTube、Google+、bilibili哔哩哔哩、163/网易视频/网易云音乐、斗鱼、爱奇艺、Youku、AcFun等等</p>
<h2 id="二：-安装及其使用"><a href="#二：-安装及其使用" class="headerlink" title="二： 安装及其使用"></a>二： 安装及其使用</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p>1） 安装python3  <a id="more"></a><br>  安装教程这里推荐：<a href="http://www.runoob.com/python3/python3-install.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-install.html</a><br>  win下载地址：<a href="https://www.python.org/downloads/windows" target="_blank" rel="noopener">https://www.python.org/downloads/windows</a><br>  Linux下载地址：<a href="https://www.python.org/downloads/source" target="_blank" rel="noopener">https://www.python.org/downloads/source</a>  </p>
<p>2） 安装you-get<br>  然后打开win的cmd命令行、Linux为终端，输入以下命令：  </p>
<ul>
<li>升级pip<br><code>python -m pip install --upgrade pip -i https://pypi.tuna.tsinghua.edu.cn/simple</code></li>
<li>安装you-get<br><code>pip install you-get -i https://pypi.tuna.tsinghua.edu.cn/simple</code></li>
<li>升级you-get<br><code>pip install --upgrade you-get -i https://pypi.tuna.tsinghua.edu.cn/simple</code></li>
</ul>
<p>3） 安装<a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a><br>  FFmpeg用于转换视频格式、播放视频等，下载下来的视频有可能播放格式不支持，不需要也可不装。<br>  FFmpeg下载地址：<a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">https://www.ffmpeg.org/</a><br>  windows下载地址：<a href="https://ffmpeg.zeranoe.com/builds/" target="_blank" rel="noopener">https://ffmpeg.zeranoe.com/builds/</a><br>  ps：windows下载，选择默认选项即可</p>
<h3 id="2-2-下载"><a href="#2-2-下载" class="headerlink" title="2.2 下载"></a>2.2 下载</h3><h4 id="2-2-1-下载默认画质和格式"><a href="#2-2-1-下载默认画质和格式" class="headerlink" title="2.2.1 下载默认画质和格式"></a>2.2.1 下载默认画质和格式</h4><p><code>you-get https://www.bilibili.com/video/av77151622/</code>  </p>
<p>下载路径默认为文件所在当前路径。<br>所以要下载在指定路径需要先cd到指定路径。  </p>
<h4 id="2-2-2-下载指定画质和格式"><a href="#2-2-2-下载指定画质和格式" class="headerlink" title="2.2.2 下载指定画质和格式"></a>2.2.2 下载指定画质和格式</h4><p>1） 先用<code>-i</code>以查看所有可用画质与格式。<br>  <code>you-get -i https://www.bilibili.com/video/av77151622/</code><br>  最上面的标有<code>[ DASH(也可能是 DEFAULT ） ]</code>为默认画质。如认同，可下载。  </p>
<p>2） 或，您希望下载其他播放格式或者其他清晰度，请追加屏幕上面提示的参数，如本视频是:<br>  <code>you-get --format=flv720 https://www.bilibili.com/video/av77151622/</code>  </p>
<ul>
<li>目前，格式选择没有大规模铺开；默认选项为最高画质.  </li>
<li>如不希望you-get合并视频，使用<code>-n</code>。  </li>
<li>如YouTube视频带有字幕，将被一同下载，以SubRip格式保存.</li>
</ul>
<h4 id="2-2-3-下载其他内容"><a href="#2-2-3-下载其他内容" class="headerlink" title="2.2.3 下载其他内容"></a>2.2.3 下载其他内容</h4><p>1） 如你有URL，可以直接使用，如下载you-get:<br>  <code>you-get https://github.com/soimort/you-get/archive/master.zip</code>  </p>
<p>2） 或者, you-get将自动检查网页，下载一切有可能感兴趣的内容:<br>  <code>you-get http://kopasas.tumblr.com/post/69361932517</code></p>
<ul>
<li>此功能为测试性，远未完成。对于类似Tumblr和Blogger的大图有效，但是没有办法为所有网站建立通用格式.</li>
</ul>
<p>3） 在Google Videos搜索并下载<br>  you-get可以下载任何东西. 如果不是合法的URL, you-get将在Google查找并下载最相关视频. (可能不是最心仪的，但是很有可能)<br>  <code>you-get &quot;Richard Stallman eats&quot;</code>  </p>
<h4 id="2-2-4-暂停与恢复下载"><a href="#2-2-4-暂停与恢复下载" class="headerlink" title="2.2.4 暂停与恢复下载"></a>2.2.4 暂停与恢复下载</h4><p>可以使用<code>Ctrl</code>+<code>C</code> 暂停下载.<br>临时的<code>.download</code>文件将保存于输出目录。下次使用you-get传入相同参数时，下载将从上次继续开始. 如果下载已经完成 (临时的<code>.download</code> 扩展名消失), you-get将忽略下载.<br>用<code>-f</code>强行重下载. (注意: 将覆盖同名文件或临时文件!)  </p>
<h4 id="2-2-5-设置输出文件名或路径"><a href="#2-2-5-设置输出文件名或路径" class="headerlink" title="2.2.5 设置输出文件名或路径"></a>2.2.5 设置输出文件名或路径</h4><p>使用<code>-o</code> 设定路径为d:, <code>-O</code> 设定输出文件名为out:<br><code>you-get -o d:\ -O out https://www.bilibili.com/video/av77151622/</code><br>提示:</p>
<ul>
<li>如果原视频标题含有与系统不兼容字符，十分有效.</li>
<li>也可以帮助使用脚本批量下载于指定目录和文件名.</li>
</ul>
<h4 id="2-2-6-批量下载"><a href="#2-2-6-批量下载" class="headerlink" title="2.2.6 批量下载"></a>2.2.6 批量下载</h4><p>两种方法：</p>
<ol>
<li>把视频URL用空格隔开<br><code>you-get 视频A网址 视频B网址</code></li>
<li>用<code>--playlist</code><br><code>you-get --playlist https://www.bilibili.com/video/av5123229</code></li>
<li>下载视频的同时会下载xml格式弹幕，需要将其转换为ass格式，有一个工具可以帮你：<a href="https://github.com/ikde/danmu2ass/releases/download/v1.1/Danmu2Ass1.1.zip" target="_blank" rel="noopener">Danmu2Ass</a>。</li>
</ol>
<h3 id="2-3-观看视频"><a href="#2-3-观看视频" class="headerlink" title="2.3 观看视频"></a>2.3 观看视频</h3><p>使用 <code>-p</code> 将视频喂进播放器, 例如 mPlayer 或者 vlc,而不是下载:<br><code>you-get -p vlc &#39;https://www.youtube.com/watch?v=jNQXAC9IVRw&#39;</code><br>或者你想在浏览器中观看而不希望看广告或评论区:<br><code>you-get -p chromium &#39;https://www.youtube.com/watch?v=jNQXAC9IVRw&#39;</code>  </p>
<h2 id="三：-官方文档"><a href="#三：-官方文档" class="headerlink" title="三： 官方文档"></a>三： 官方文档</h2><p><a href="https://github.com/soimort/you-get/wiki/%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">官方中文文档</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>you-get</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬图攻略</title>
    <url>/2020/02/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/python%E7%88%AC%E5%9B%BE%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<h2 id="一：-软件工具"><a href="#一：-软件工具" class="headerlink" title="一： 软件工具"></a>一： 软件工具</h2><h3 id="1-1-Python3"><a href="#1-1-Python3" class="headerlink" title="1.1 Python3"></a>1.1 Python3</h3><p>这里选择的是最新版 Python3<br>安装教程这里推荐：<a href="http://www.runoob.com/python3/python3-install.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-install.html</a><br>win下载地址：<a href="https://www.python.org/downloads/windows" target="_blank" rel="noopener">https://www.python.org/downloads/windows</a><br>Linux下载地址：<a href="https://www.python.org/downloads/source" target="_blank" rel="noopener">https://www.python.org/downloads/source</a>  <a id="more"></a></p>
<h3 id="1-2-PyCharm"><a href="#1-2-PyCharm" class="headerlink" title="1.2 PyCharm"></a>1.2 PyCharm</h3><p>可视化开发工具IDE：<a href="https://www.jetbrains.com/pycharm/download/" target="_blank" rel="noopener">https://www.jetbrains.com/pycharm/download/</a></p>
<h2 id="二：原理"><a href="#二：原理" class="headerlink" title="二：原理"></a>二：原理</h2><h3 id="2-1-实现步骤"><a href="#2-1-实现步骤" class="headerlink" title="2.1 实现步骤"></a>2.1 实现步骤</h3><p>以图片为例，其实很简单，分以下四步：</p>
<ul>
<li>获取首页的页码数，并创建与页码对应的文件夹</li>
<li>获取页面的栏目地址</li>
<li>进入栏目，获取栏目页码数(每个栏目下有多张图片，分页显示)</li>
<li>获取到栏目下对用标签容器中的图片并下载</li>
</ul>
<h3 id="2-2-注意事项"><a href="#2-2-注意事项" class="headerlink" title="2.2 注意事项"></a>2.2 注意事项</h3><p>这里以爬取某个网站的套路为例，详细见代码，这里主要说以下几点注意事项：  </p>
<p>1）导库，其实就类似于Java中框架或者是工具类，底层都被封装好了</p>
<p>安装第三方库：</p>
<pre><code class="py"># Win下直接装的 python3
pip install BeautifulSoup4 -i https://pypi.tuna.tsinghua.edu.cn/simple
pip install requests -i https://pypi.tuna.tsinghua.edu.cn/simple
# Linux python2 python3 共存
pip3 install BeautifulSoup4 -i https://pypi.tuna.tsinghua.edu.cn/simple
pip3 install requests -i https://pypi.tuna.tsinghua.edu.cn/simple</code></pre>
<p>导入第三方库：</p>
<pre><code class="py"># 导入requests库
import requests
# 导入文件操作库
import os
# bs4全名BeautifulSoup4，是编写python爬虫常用库之一，主要用来解析html标签。
import bs4
from bs4 import BeautifulSoup
# 基础类库
import sys
# Python 3.x 解决中文编码问题
import importlib
importlib.reload(sys)</code></pre>
<p>2）定义方法函数，一个爬虫可能会几百行，所以尽量不要写成一坨</p>
<pre><code class="py">def download(page_no, file_path):
    # 这里写代码逻辑</code></pre>
<p>3）定义全局变量</p>
<pre><code class="py"># 给请求指定一个请求头来模拟chrome浏览器
global headers # 告诉编译器这是全局变量 headers 
headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&#39;}

# 函数内使用之前需要
# 告诉编译器我在这个方法中使用的a是刚才定义的全局变量 headers ，而不是方法内部的局部变量。
global headers</code></pre>
<p>4）防盗链</p>
<p>有些网站加入了防盗链，无所不能的 python  解决方案：</p>
<pre><code class="py">headers = {&#39;Referer&#39;: href}
img = requests.get(url, headers=headers)</code></pre>
<p>5）切换版本</p>
<p>Linux服务器使用的是阿里云服务器（centos7.4），默认版本 python2，python3 自行安装</p>
<pre><code class="py">[root@AY140216131049Z mzitu]# python2 -V
Python 2.7.5
[root@AY140216131049Z mzitu]# python3 -V
Python 3.7.1
# 默认版本
[root@AY140216131049Z mzitu]# python -V
Python 2.7.5
# 临时切换版本 &lt;whereis python&gt;
[root@AY140216131049Z mzitu]# alias python=&#39;/usr/local/bin/python3.7&#39;
[root@AY140216131049Z mzitu]# python -V
Python 3.7.1
</code></pre>
<p>6）异常捕获</p>
<p>在爬取的过程中可能存在异常页面，这里我们进行捕获，不影响后续操作：</p>
<pre><code class="py">try:
    # 业务逻辑
except Exception as e:
   print(e)</code></pre>
<h3 id="2-3-执行脚本"><a href="#2-3-执行脚本" class="headerlink" title="2.3 执行脚本"></a>2.3 执行脚本</h3><pre><code class="py">python3 mzitu.py

# 或者后台执行

nohup python3 -u mzitu.py &gt; mzitu.log 2&gt;&amp;1 &amp;</code></pre>
<h2 id="三：-源码"><a href="#三：-源码" class="headerlink" title="三： 源码"></a>三： 源码</h2><h3 id="3-1-win下代码"><a href="#3-1-win下代码" class="headerlink" title="3.1 win下代码"></a>3.1 win下代码</h3><pre><code class="py">#coding=utf-8
#!/usr/bin/python
# 导入requests库
import requests
# 导入文件操作库
import os
import bs4
from bs4 import BeautifulSoup
import sys
import importlib
import random
import time
importlib.reload(sys)


# 越多越好
meizi_headers = [
    &quot;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36&quot;,
    &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36&quot;,
    &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0&quot;,
    &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/537.75.14&quot;,
    &quot;Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Win64; x64; Trident/6.0)&quot;,
    &#39;Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11&#39;,
    &#39;Opera/9.25 (Windows NT 5.1; U; en)&#39;,
    &#39;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&#39;,
    &#39;Mozilla/5.0 (compatible; Konqueror/3.5; Linux) KHTML/3.5.5 (like Gecko) (Kubuntu)&#39;,
    &#39;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.0.12) Gecko/20070731 Ubuntu/dapper-security Firefox/1.5.0.12&#39;,
    &#39;Lynx/2.8.5rel.1 libwww-FM/2.14 SSL-MM/1.4.1 GNUTLS/1.2.9&#39;,
    &quot;Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.7 (KHTML, like Gecko) Ubuntu/11.04 Chromium/16.0.912.77 Chrome/16.0.912.77 Safari/535.7&quot;,
    &quot;Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:10.0) Gecko/20100101 Firefox/10.0&quot;,
    &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&#39;
]
# 给请求指定一个请求头来模拟chrome浏览器
global headers
headers = {&#39;User-Agent&#39;: random.choice(meizi_headers)}
# 爬图网址
mziTu = &#39;http://www.mzitu.com/&#39;
# 定义图片存储位置
global save_path
save_path = &#39;D:\BeautifulPictures&#39;

# 创建文件夹
def createFile(file_path):
    if os.path.exists(file_path) is False:
        os.makedirs(file_path)
    # 切换路径至上面创建的文件夹
    os.chdir(file_path)

# 下载文件
def download(page_no, file_path):
    global headers
    res_sub = requests.get(page_no, headers=headers)
    # 解析html
    soup_sub = BeautifulSoup(res_sub.text, &#39;html.parser&#39;)
    # 获取页面的栏目地址
    all_a = soup_sub.find(&#39;div&#39;,class_=&#39;postlist&#39;).find_all(&#39;a&#39;,target=&#39;_blank&#39;)
    count = 0
    for a in all_a:
        count = count + 1
        if (count % 2) == 0:
            headers = {&#39;User-Agent&#39;: random.choice(meizi_headers)}
            print(&quot;内页第几页：&quot; + str(count))
            # 提取href
            href = a.attrs[&#39;href&#39;]
            print(&quot;套图地址：&quot; + href)
            res_sub_1 = requests.get(href, headers=headers)
            soup_sub_1 = BeautifulSoup(res_sub_1.text, &#39;html.parser&#39;)
            # ------ 这里最好使用异常处理 ------
            try:
                # 获取套图的最大数量
                pic_max = soup_sub_1.find(&#39;div&#39;, class_=&#39;pagenavi&#39;).find_all(&#39;span&#39;)[6].text
                print(&quot;套图数量：&quot; + pic_max)
                for j in range(1, int(pic_max) + 1):
                    # 单位为秒，1-3 随机数
                    time.sleep(random.randint(1, 3))
                    headers = {&#39;User-Agent&#39;: random.choice(meizi_headers)}
                    # print(&quot;子内页第几页：&quot; + str(j))
                    # j int类型需要转字符串
                    href_sub = href + &quot;/&quot; + str(j)
                    print(&quot;图片地址：&quot;+href_sub)
                    res_sub_2 = requests.get(href_sub, headers=headers)
                    soup_sub_2 = BeautifulSoup(res_sub_2.text, &quot;html.parser&quot;)
                    img = soup_sub_2.find(&#39;div&#39;, class_=&#39;main-image&#39;).find(&#39;img&#39;)
                    if isinstance(img, bs4.element.Tag):
                        # 提取src
                        url = img.attrs[&#39;src&#39;]
                        array = url.split(&#39;/&#39;)
                        file_name = array[len(array)-1]
                        # 防盗链加入Referer
                        headers = {&#39;User-Agent&#39;: random.choice(meizi_headers), &#39;Referer&#39;: url}
                        img = requests.get(url, headers=headers)
                        print(&#39;开始保存图片&#39;, img)
                        f = open(file_name, &#39;ab&#39;)
                        f.write(img.content)
                        print(file_name, &#39;图片保存成功！&#39;)
                        f.close()
            except Exception as e:
                print(e)


# 主方法
def main():
    res = requests.get(mziTu, headers=headers)
    # 使用自带的html.parser解析
    soup = BeautifulSoup(res.text, &#39;html.parser&#39;)
    # 创建文件夹
    createFile(save_path)
    # 获取首页总页数
    img_max = soup.find(&#39;div&#39;, class_=&#39;nav-links&#39;).find_all(&#39;a&#39;)[3].text
    # print(&quot;总页数:&quot;+img_max)
    for i in range(1, int(img_max) + 1):
        # 获取每页的URL地址
        if i == 1:
            page = mziTu
        else:
            page = mziTu + &#39;page/&#39; + str(i)
        file = save_path + &#39;\\&#39; + str(i)
        createFile(file)
        # 下载每页的图片
        print(&quot;套图页码：&quot; + page)
        download(page, file)


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
<h3 id="3-2-linux下代码"><a href="#3-2-linux下代码" class="headerlink" title="3.2 linux下代码"></a>3.2 linux下代码</h3><pre><code class="py">#coding=utf-8
#!/usr/bin/python
# 导入requests库
import requests
# 导入文件操作库
import os
import bs4
from bs4 import BeautifulSoup
import sys
import importlib
importlib.reload(sys)

# 给请求指定一个请求头来模拟chrome浏览器
global headers
headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&#39;}
# 爬图地址
mziTu = &#39;http://www.mzitu.com/&#39;
# 定义存储位置
global save_path
save_path = ​&#39;/mnt/data/mzitu&#39;

# 创建文件夹
def createFile(file_path):
    if os.path.exists(file_path) is False:
        os.makedirs(file_path)
    # 切换路径至上面创建的文件夹
    os.chdir(file_path)

# 下载文件
def download(page_no, file_path):
    global headers
    res_sub = requests.get(page_no, headers=headers)
    # 解析html
    soup_sub = BeautifulSoup(res_sub.text, &#39;html.parser&#39;)
    # 获取页面的栏目地址
    all_a = soup_sub.find(&#39;div&#39;,class_=&#39;postlist&#39;).find_all(&#39;a&#39;,target=&#39;_blank&#39;)
    count = 0
    for a in all_a:
        count = count + 1
        if (count % 2) == 0:
            print(&quot;内页第几页：&quot; + str(count))
            # 提取href
            href = a.attrs[&#39;href&#39;]
            print(&quot;套图地址：&quot; + href)
            res_sub_1 = requests.get(href, headers=headers)
            soup_sub_1 = BeautifulSoup(res_sub_1.text, &#39;html.parser&#39;)
            # ------ 这里最好使用异常处理 ------
            try:
                # 获取套图的最大数量
                pic_max = soup_sub_1.find(&#39;div&#39;,class_=&#39;pagenavi&#39;).find_all(&#39;span&#39;)[6].text
                print(&quot;套图数量：&quot; + pic_max)
                for j in range(1, int(pic_max) + 1):
                    # print(&quot;子内页第几页：&quot; + str(j))
                    # j int类型需要转字符串
                    href_sub = href + &quot;/&quot; + str(j)
                    print(href_sub)
                    res_sub_2 = requests.get(href_sub, headers=headers)
                    soup_sub_2 = BeautifulSoup(res_sub_2.text, &quot;html.parser&quot;)
                    img = soup_sub_2.find(&#39;div&#39;, class_=&#39;main-image&#39;).find(&#39;img&#39;)
                    if isinstance(img, bs4.element.Tag):
                        # 提取src
                        url = img.attrs[&#39;src&#39;]
                        array = url.split(&#39;/&#39;)
                        file_name = array[len(array)-1]
                        # print(file_name)
                        # 防盗链加入Referer
                        headers = {&#39;Referer&#39;: href}
                        img = requests.get(url, headers=headers)
                        # print(&#39;开始保存图片&#39;)
                        f = open(file_name, &#39;ab&#39;)
                        f.write(img.content)
                        # print(file_name, &#39;图片保存成功！&#39;)
                        f.close()
            except Exception as e:
                print(e)


# 主方法
def main():
    res = requests.get(mziTu, headers=headers)
    # 使用自带的html.parser解析
    soup = BeautifulSoup(res.text, &#39;html.parser&#39;)
    # 创建文件夹
    createFile(save_path)
    # 获取首页总页数
    img_max = soup.find(&#39;div&#39;, class_=&#39;nav-links&#39;).find_all(&#39;a&#39;)[3].text
    # print(&quot;总页数:&quot;+img_max)
    for i in range(1, int(img_max) + 1):
        # 获取每页的URL地址
        if i == 1:
            page = mziTu
        else:
            page = mziTu + &#39;page/&#39; + str(i)
        file = save_path + &#39;/&#39; + str(i)
        createFile(file)
        # 下载每页的图片
        print(&quot;套图页码：&quot; + page)
        download(page, file)


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
<h2 id="四：-参考文献"><a href="#四：-参考文献" class="headerlink" title="四： 参考文献"></a>四： 参考文献</h2><p><a href="https://gitee.com/52itstyle/Python" target="_blank" rel="noopener">小柒2012 / 从零学Python / Day01</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬图</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo一键上传部署脚本的构建</title>
    <url>/2020/02/15/hexo/hexo%E4%B8%80%E9%94%AE%E4%B8%8A%E4%BC%A0%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<ol>
<li>windows先右键新建一个文本文档，后缀改为<code>git push hexo.bat</code>；Linux新建一个<code>git push hexo.sh</code>文档;</li>
<li>注意：编码要是windows默认编码GBK；Linux上是UTF-8；</li>
<li>然后复制黏贴，话不多说，直接上代码。  <a id="more"></a></li>
</ol>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><pre><code class="bat">@echo off

cd G:\code\hexo
REM 改为hexo根目录
echo &quot;当前目录是： G:\code\hexo&quot;
REM 改为hexo根目录
echo &quot;正在add... ...&quot;
git add source/ 
REM 只添加了blog文件目录，需要的可自行添加...
echo;
echo &quot;add complete.&quot;
echo;
echo;

echo &quot;正在commit... ...&quot;
set now=%date% %time%
echo %now%
git commit -m &quot;blog update at %now%&quot;
echo;
echo &quot;commit complete.&quot;
echo;
echo;

echo &quot;正在将更改提交到远程git服务器... ...&quot;
git push githuborigin hexo &amp;&amp; git push giteeorigin hexo &amp;&amp; git push codingorigin hexo
echo;
echo &quot;git push complete.&quot;
echo;
echo;

echo &quot;正在部署blog... ...&quot;
hexo clean &amp;&amp; hexo g &amp;&amp; hexo d
echo;
echo &quot;部署 complete.&quot;
echo;
echo;

pause</code></pre>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>先提升权限，<code>chmod +x ./git\ push\ hexo.sh</code>。</p>
<pre><code class="sh">cd /home/zs/文档/hexo/closer_laps
# 改为hexo根目录
echo &quot;当前目录是： /home/zs/文档/hexo/closer_laps&quot;

# 改为hexo根目录
echo &quot;正在add... ...&quot;
git add source/ 
echo;
echo &quot;add complete.&quot;
echo;
echo;

echo &quot;正在commit... ...&quot;
now=`date &#39;+%Y-%m-%d %H:%M:%S&#39;`
echo &quot;$now&quot;
git commit -m &quot;blog update at $now&quot;
echo;
echo &quot;commit complete.&quot;
echo;
echo;

echo &quot;正在push... ...&quot;
git push githuborigin hexo &amp;&amp; git push giteeorigin hexo &amp;&amp; git push codingorigin hexo
echo;
echo &quot;git push complete.&quot;
echo;
echo;

echo &quot;正在部署blog... ...&quot;
hexo clean &amp;&amp; hexo g &amp;&amp; hexo d
echo;
echo &quot;部署 complete.&quot;
echo;
echo;</code></pre>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>一键部署</tag>
      </tags>
  </entry>
  <entry>
    <title>同时在Github、Gitee、Coding上部署Hexo</title>
    <url>/2020/02/14/hexo/%E5%90%8C%E6%97%B6%E5%9C%A8Github%E3%80%81Gitee%E3%80%81Coding%E4%B8%8A%E9%83%A8%E7%BD%B2Hexo/</url>
    <content><![CDATA[<h2 id="一、创建托管仓库"><a href="#一、创建托管仓库" class="headerlink" title="一、创建托管仓库"></a>一、创建托管仓库</h2><ul>
<li><p>GitHub <a href="https://github.com" target="_blank" rel="noopener">https://github.com</a><br>与用户名相同，格式为YouID.github.io</p>
</li>
<li><p>Gitee <a href="https://gitee.com" target="_blank" rel="noopener">https://gitee.com</a><br>与用户名相同，格式为YouID</p>
</li>
<li><p>Coding <a href="https://coding.net" target="_blank" rel="noopener">https://coding.net</a><br>与用户名相同，格式为YouID.coding.me</p>
<a id="more"></a>

</li>
</ul>
<h2 id="二、在Github、Gitee、Coding上添加SSH，并push"><a href="#二、在Github、Gitee、Coding上添加SSH，并push" class="headerlink" title="二、在Github、Gitee、Coding上添加SSH，并push"></a>二、在Github、Gitee、Coding上添加SSH，并push</h2><ol>
<li>获取id_rsa.pub文件内的公匙;具体如何获取请百度<code>id_rsa.pub</code></li>
<li>在 Github、Gitee、Coding平台 - 设置 - 添加SSH Keys。</li>
<li>将博客分支master和分支hexo里的内容push到仓库，并设定hexo为主分支（hexo分支的好处请参考<a href="https://closer_laps.gitee.io/2019/12/09/hexo/hexo%20%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/"> hexo 多客户端上更新博客</a>）。</li>
</ol>
<h2 id="三、开启Pages服务并绑定域名"><a href="#三、开启Pages服务并绑定域名" class="headerlink" title="三、开启Pages服务并绑定域名"></a>三、开启Pages服务并绑定域名</h2><ul>
<li>GitHub 进入托管的仓库 -&gt; Settings -&gt; Options 往下拉-&gt;GitHub Pages</li>
<li>Gitee 进入托管的仓库 -&gt; 服务-&gt; Gitee Pages (绑定域名需要升级Gitee Pro，普通版每次部署更新需要手动点更新！！！)</li>
<li>Coding 进入托管的仓库 -&gt; Pages服务 -&gt; 设置</li>
</ul>
<h2 id="四、Hexo推送设置"><a href="#四、Hexo推送设置" class="headerlink" title="四、Hexo推送设置"></a>四、Hexo推送设置</h2><p>在博客根目录下，打开<code>_config.yml</code>,deploy设置如下所示</p>
<pre><code class="yml">deploy:
  type: git
  repo:
        github: git@github.com:YouID/YouID.github.io.git
        gitee: git@gitee.com:YouID/YouID.git
        coding: git@e.coding.net:YouID/YouID.coding.me.git
  branch: master</code></pre>
<h2 id="五：将本地仓库和远程仓库连接"><a href="#五：将本地仓库和远程仓库连接" class="headerlink" title="五：将本地仓库和远程仓库连接"></a>五：将本地仓库和远程仓库连接</h2><ul>
<li><p>GitHub<br><code>git remote add githuborigin git@github.com:YouID/YouID.github.io.git</code></p>
</li>
<li><p>Gitee<br><code>git remote add giteeorigin git@gitee.com:YouID/YouID.git</code>  </p>
</li>
<li><p>Coding<br><code>git remote add codingorigin git@e.coding.net:YouID/YouID.coding.me.git</code></p>
</li>
</ul>
<p>输入<code>git remote -v</code>，成功的话会显示3个你关联的远程库：<code>codingorigin</code>、<code>githuborigin</code>、<code>giteeorigin</code>。如下：</p>
<pre><code>codingorigin    git@e.coding.net:YouID/YouID.coding.me.git (fetch)
codingorigin    git@e.coding.net:YouID/YouID.coding.me.git (push)
giteeorigin     git@gitee.com:YouID/YouID.git (fetch)
giteeorigin     git@gitee.com:YouID/YouID.git (push)
githuborigin  git@github.com:YouID/YouID.github.io.git (fetch)
githuborigin  git@github.com:YouID/YouID.github.io.git (push)</code></pre><h2 id="六、一键部署必杀命令"><a href="#六、一键部署必杀命令" class="headerlink" title="六、一键部署必杀命令"></a>六、一键部署必杀命令</h2><p><code>git add source/ &amp;&amp; git commit -m &quot;blog update&quot; &amp;&amp; git push githuborigin hexo &amp;&amp; git push giteeorigin hexo &amp;&amp; git push codingorigin hexo &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; exit</code><br>把所有命令用<code>&amp;&amp;</code>串起来，有一个失败就会停止；成功，最后一条命令就会退出终端。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>多平台部署</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在markdown中优雅的编辑数学公式</title>
    <url>/2020/02/12/hexo/%E5%A6%82%E4%BD%95%E5%9C%A8markdown%E4%B8%AD%E4%BC%98%E9%9B%85%E7%9A%84%E7%BC%96%E8%BE%91%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>下载IDE软件vscode，安装插件<code>Markdown Preview Enhanced</code>(简称MPE)。</p>
<p><a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/" target="_blank" rel="noopener">MPE官方使用文档</a>。  </p>
<h2 id="hexo博客中使用-KaTeX-来渲染数学表达式"><a href="#hexo博客中使用-KaTeX-来渲染数学表达式" class="headerlink" title="hexo博客中使用 KaTeX 来渲染数学表达式"></a>hexo博客中使用 KaTeX 来渲染数学表达式</h2><ol>
<li>在Next主题配置下面开启mathjax。（不知道怎么开启的小伙伴请查询官方文档或者github）</li>
<li>在博客需要用到公式的md文件的头文件中添加一句：<code>mathjax: true</code>。</li>
</ol>
<h2 id="上下标及标记"><a href="#上下标及标记" class="headerlink" title="上下标及标记"></a>上下标及标记</h2><a id="more"></a>

<ol>
<li>默认下的分隔符：<br><code>$...$</code> 或者<code>\(...\)</code>中的数学表达式将会在行内显示。<br><code>$$...$$</code> 或者 <code>\[...\]</code> 或者 <code>```math</code> 中的数学表达式将会在块内显示。  </li>
<li>公式两边用<code>$</code>符号标记为公式，如:<br><code>$a^2$</code>显示为$a^2$<br><code>$H_2O$</code>显示为$H_2O$<br><code>==marked==</code>显示为==marked==  </li>
</ol>
<h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p>Markdown Preview Enhanced 使用 KaTeX 来渲染数学表达式。  </p>
<p>如这个公式：$f(x)=\int_{-\infty}^\infty\widehat f\xi,e^{2\pi i\xi x},d\xi$  </p>
<p>想要正确地写出它的文本形式可不容易：<br><code>f(x)=\int_{-\infty}^\infty\widehat f\xi\,e^{2\pi i\xi x}\,d\xi</code>  </p>
<p>如果仅仅为了写个公式，就去学LaTeX语法，那没有十天半月的肯定不行。这个时候，你需要一个<a href="http://www.wiris.com/editor/demo/en/developers#output-formats" target="_blank" rel="noopener">可视化公式编辑器</a>的神器，它可以让我们可视化地编辑公式，然后自动得到它的LaTeX文本：<br><img src="https://www.liaoxuefeng.com/files/attachments/1280023417847873/l" srcset="/img/loading.gif" alt="使用说明">  </p>
<p>在线转换地址1：<a href="http://www.wiris.com/editor/demo/en/developers#output-formats" target="_blank" rel="noopener">http://www.wiris.com/editor/demo/en/developers#output-formats</a></p>
<p>在线转换地址2：<a href="https://latex.91maths.com/" target="_blank" rel="noopener">https://latex.91maths.com/</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>数学公式</tag>
        <tag>markdown语法</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习之路 一：基础知识</title>
    <url>/2020/02/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Python/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%20%E4%B8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>本文适合有基础c、c++语言知识的人学习，同时也可当作python工具书查阅。  </p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol>
<li><p>这里选择的是最新版 Python3<br>安装教程这里推荐：<a href="http://www.runoob.com/python3/python3-install.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-install.html</a><br>win下载地址：<a href="https://www.python.org/downloads/windows" target="_blank" rel="noopener">https://www.python.org/downloads/windows</a><br>Linux下载地址：<a href="https://www.python.org/downloads/source" target="_blank" rel="noopener">https://www.python.org/downloads/source</a>  </p>
</li>
<li><p>可视化开发工具IDE：<a href="https://www.jetbrains.com/pycharm/download/" target="_blank" rel="noopener">https://www.jetbrains.com/pycharm/download/</a></p>
</li>
<li><p><strong>因国内pip速度较慢，安装完python后建议改为国内清华大学镜像源，以下：</strong>  </p>
<ul>
<li><p>临时使用<br><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 模块名字</code><a id="more"></a></p>
</li>
<li><p>设为默认<br>升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置：<br><code>pip install -U pip</code> 假如这个命令出了问题，使用以下命令 <code>easy_install --upgrade pip</code><br><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
</li>
</ul>
</li>
<li><p>指定目录 pip下载及离线安装包</p>
<ul>
<li>将pip安装的包导出至requirements文件列表<br>cd进入想要下载的目录。<br><code>pip freeze &gt; requirements.txt</code></li>
<li>批量下载pip包<br><code>pip download -d d:\0\package -r requirements.txt</code></li>
<li>pip批量安装包及通过列表文件安装（先cd进入requirements所在目录）<br><code>pip install -r requirements.txt</code></li>
</ul>
</li>
</ol>
<h2 id="1-1基础语法"><a href="#1-1基础语法" class="headerlink" title="1.1基础语法"></a>1.1基础语法</h2><h3 id="1-1-1-输出"><a href="#1-1-1-输出" class="headerlink" title="1.1.1 输出"></a>1.1.1 输出</h3><p>打印 <code>print (&quot;Hello, Python!&quot;)</code><br>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号<code>,</code>。<br>不换行输出 <code>print(&#39;*&#39;, end=&#39; &#39;)</code>。  </p>
<h3 id="1-1-2-字符串转义"><a href="#1-1-2-字符串转义" class="headerlink" title="1.1.2 字符串转义"></a>1.1.2 字符串转义</h3><p>特殊字符会使用反斜杠<code>\</code>来转义。比如<code>\n</code>表示换行，<code>\t</code>表示制表符，字符<code>\</code>本身也要转义，所以\表示的字符就是\<br><code>print(&#39;Isn\&#39;t, they said.&#39;)</code><br>如果不希望前置了 \ 的字符转义成特殊字符，而是使用<em>原始字符串</em>方式，在引号前添加 r 即可。<br><code>print(r&#39;C:\软件\python&#39;)</code><br>用三重引号可以跨行连续输入。<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>或<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code><br>字符串可以用 + 进行连接（粘到一起），也可以用 * 进行重复:<code>3 * &#39;io&#39; + &#39; so easy&#39;</code>  </p>
<h3 id="1-1-3-脚本式编程"><a href="#1-1-3-脚本式编程" class="headerlink" title="1.1.3 脚本式编程"></a>1.1.3 脚本式编程</h3><p>Python 文件将以 <code>.py</code> 为扩展名。<br>在linux和mac上面编程时，已经设置了PATH变量，头文件加入<code>#!/usr/bin/python</code>，可以直接执行。</p>
<pre><code class="python">#!/usr/bin/python
# -*- coding: utf-8 -*-
print (&quot;Hello, Python!&quot;)</code></pre>
<p>这里，假定您的Python解释器在/usr/bin目录中，使用以下命令执行脚本：</p>
<pre><code class="py">chmod +x test.py     # 脚本文件添加可执行权限
./test.py</code></pre>
<h3 id="1-1-4-行和缩进"><a href="#1-1-4-行和缩进" class="headerlink" title="1.1.4 行和缩进"></a>1.1.4 行和缩进</h3><p>Python与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。<br>缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量(一般是四个空格)，这个必须严格执行。  </p>
<h3 id="1-1-5-注释"><a href="#1-1-5-注释" class="headerlink" title="1.1.5 注释"></a>1.1.5 注释</h3><p>python中单行注释采用 # 开头。<br>python 中多行注释使用三个单引号(‘’’)或三个双引号(“””)。  </p>
<h3 id="1-1-6-同一行显示多条语句"><a href="#1-1-6-同一行显示多条语句" class="headerlink" title="1.1.6 同一行显示多条语句"></a>1.1.6 同一行显示多条语句</h3><p>Python可以在同一行中使用多条语句，语句之间使用分号(;)分割。  </p>
<h3 id="1-1-7-多个语句构成代码组"><a href="#1-1-7-多个语句构成代码组" class="headerlink" title="1.1.7 多个语句构成代码组"></a>1.1.7 多个语句构成代码组</h3><p>缩进相同的一组语句构成一个代码块，我们称之代码组。<br>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。<br>我们将首行及后面的代码组称为一个子句(clause)。<br>如下实例：</p>
<pre><code class="py">if expression :
   suite
elif expression :  
   suite  
else :  
   suite</code></pre>
<h2 id="1-2-变量类型"><a href="#1-2-变量类型" class="headerlink" title="1.2 变量类型"></a>1.2 变量类型</h2><h3 id="1-2-1-变量赋值"><a href="#1-2-1-变量赋值" class="headerlink" title="1.2.1 变量赋值"></a>1.2.1 变量赋值</h3><p>Python 中的变量赋值不需要类型声明。<br>Python允许你同时为多个变量赋值。例如：<br><code>a, b, c = 1, 2, &quot;john&quot;</code>  </p>
<h3 id="1-2-2-标准数据类型"><a href="#1-2-2-标准数据类型" class="headerlink" title="1.2.2 标准数据类型"></a>1.2.2 标准数据类型</h3><p>Python 定义了一些标准类型，用于存储各种类型的数据。<br>Python有五个标准的数据类型：  </p>
<ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Dictionary（字典）</li>
</ul>
<p>bool类型有True和False和None（等于NULL）。</p>
<h3 id="1-2-2-1-Python数字"><a href="#1-2-2-1-Python数字" class="headerlink" title="1.2.2.1 Python数字"></a>1.2.2.1 Python数字</h3><p>数字数据类型用于存储数值。他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。<br>当你指定一个值时，Number对象就会被创建：<br><code>var1 = 1</code><br>您也可以使用del语句删除一些对象的引用。del语句的语法是：<br><code>del var1[,var2[,var3[....,varN]]]]</code><br>您可以通过使用del语句删除单个或多个对象的引用。例如：<br><code>del var_a, var_b</code><br>Python支持四种不同的数字类型：</p>
<ul>
<li>int（有符号整型,如<code>0112L</code>,<code>0xDEFL</code>,<code>0x69</code>）# long 类型只在Python2.X版本中。在Python3.X版本中 long 类被 int 替代。</li>
<li>float（浮点型,<code>-32.54e100</code>）</li>
<li>complex（复数,<code>4.53e-7j</code>）</li>
</ul>
<h3 id="1-2-2-2-Python字符串"><a href="#1-2-2-2-Python字符串" class="headerlink" title="1.2.2.2 Python字符串"></a>1.2.2.2 Python字符串</h3><p>字符串或串(String)是由数字、字母、下划线组成的一串字符。<br>python的字串列表有2种取值顺序:  </p>
<ul>
<li>从左到右索引默认0开始的，最大范围是字符串长度少1</li>
<li>从右到左索引默认-1开始的，最大范围是字符串开头</li>
</ul>
<p>如果你要实现从字符串中获取一段子字符串的话，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。<br>[头下标:尾下标] 获取的子字符串包含头下标的字符，但不包含尾下标的字符。  </p>
<pre><code class="py">&gt;&gt;&gt; s = &#39;abcdef&#39;
&gt;&gt;&gt; print(&#39;s[1:5]  &#39;,s[1:5])
&gt;&gt;&gt; print(&#39;s[-6:-4]  &#39;,s[-6:-4])
s[1:5]   bcde
s[-6:-4]   ab</code></pre>
<p>字符串格式化<br>在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。  </p>
<pre><code class="py">&gt;&gt;&gt; print(&quot;My name is %s and weight is %d kg!&quot; % (&#39;Zara&#39;, 21))
My name is Zara and weight is 21 kg!</code></pre>
<h3 id="1-2-2-3-Python列表"><a href="#1-2-2-3-Python列表" class="headerlink" title="1.2.2.3 Python列表"></a>1.2.2.3 Python列表</h3><p>List（列表）相当于c语言中的数组。 是 Python 中使用最频繁的数据类型。<br>列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。<br>列表用 <code>[ ]</code> 标识，是 python 最通用的复合数据类型。<br>列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。<br>加号 + 是列表连接运算符，星号 * 是重复操作。如下实例：</p>
<pre><code class="py">&gt;&gt;&gt; list = [ &#39;runoob&#39;, 786 , 2.23, &#39;john&#39;, 70.2 ]
&gt;&gt;&gt; tinylist = [123, &#39;john&#39;]
&gt;&gt;&gt; print (&#39;输出第1个至第三个元素  &#39;, list[1:3]) 
&gt;&gt;&gt; print (&#39;输出从第2个开始至列表末尾的所有元素   &#39;, list[2:])
&gt;&gt;&gt; print (&#39;输出列表两次    &#39;, tinylist * 2)
&gt;&gt;&gt; print (&#39;打印组合的列表    &#39;, list + tinylist)
输出第1个至第三个元素   [786, 2.23]
输出从第2个开始至列表末尾的所有元素    [2.23, &#39;john&#39;, 70.2]
输出列表两次     [123, &#39;john&#39;, 123, &#39;john&#39;]
打印组合的列表     [&#39;runoob&#39;, 786, 2.23, &#39;john&#39;, 70.2, 123, &#39;john&#39;]</code></pre>
<p>每当需要访问最后一个列表元素时，都可使用索引-1，来获取最后一个元素。如<code>list[-1]</code>。<br><code>squares = [value**2 for value in range(1,11)]</code>此列表解析生成1-10的平方数存入数组。<br><code>list[1]=list[:]</code>可以复制列表。  </p>
<h3 id="1-2-2-4-Python-元组"><a href="#1-2-2-4-Python-元组" class="headerlink" title="1.2.2.4 Python 元组"></a>1.2.2.4 Python 元组</h3><p>元组是另一个数据类型，类似于 List（列表）。<br>元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。<br><strong>元组是不允许更新的。而列表是允许更新的。</strong>  </p>
<h3 id="1-2-2-5-Python-字典"><a href="#1-2-2-5-Python-字典" class="headerlink" title="1.2.2.5 Python 字典"></a>1.2.2.5 Python 字典</h3><p>字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。<br>两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。<br>字典用”{ }”标识。字典由索引(key)和它对应的值value组成。  </p>
<pre><code class="py">&gt;&gt;&gt; dict = {}
&gt;&gt;&gt; dict[&#39;one&#39;] = &quot;This is one&quot;
&gt;&gt;&gt; dict[2] = &quot;This is two&quot;
&gt;&gt;&gt; tinydict = {&#39;name&#39;: &#39;john&#39;,&#39;code&#39;:6734, &#39;dept&#39;: &#39;sales&#39;}
&gt;&gt;&gt; print (dict[&#39;one&#39;])          # 输出键为&#39;one&#39; 的值
&gt;&gt;&gt; print (dict[2])              # 输出键为 2 的值
&gt;&gt;&gt; print (tinydict)             # 输出完整的字典
&gt;&gt;&gt; print (tinydict.keys())      # 输出所有键
&gt;&gt;&gt; print (tinydict.values())    # 输出所有值
This is one
This is two
{&#39;name&#39;: &#39;john&#39;, &#39;code&#39;: 6734, &#39;dept&#39;: &#39;sales&#39;}
dict_keys([&#39;name&#39;, &#39;code&#39;, &#39;dept&#39;])
dict_values([&#39;john&#39;, 6734, &#39;sales&#39;])</code></pre>
<ol>
<li><p>修改字典中的值<br><code>dict[&#39;color&#39;] = &#39;yellow&#39;</code></p>
</li>
<li><p>删除键-值对<br><code>del dict[&#39;color&#39;]</code> # 删除键’color’<br><code>dict.clear()</code> # 清空字典<br><code>del dict</code> # 删除字典  </p>
</li>
<li><p>遍历字典</p>
<pre><code class="py"> for key, value in dict.items():
   print(&quot;\nKey: &quot; + key)
   print(&quot;Value: &quot; + value)</code></pre>
</li>
</ol>
<h3 id="1-2-3-Python数据类型转换"><a href="#1-2-3-Python数据类型转换" class="headerlink" title="1.2.3 Python数据类型转换"></a>1.2.3 Python数据类型转换</h3><p>和c语言一样。当我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。<br><code>float(2)</code>  </p>
<h3 id="1-2-4-如何查看模块及其方法的使用和它们的源码"><a href="#1-2-4-如何查看模块及其方法的使用和它们的源码" class="headerlink" title="1.2.4 如何查看模块及其方法的使用和它们的源码"></a>1.2.4 如何查看模块及其方法的使用和它们的源码</h3><ol>
<li>进入cmd或者终端，python交互模式。</li>
<li><code>import 模块名</code>  # 导入模块</li>
<li><code>dir(模块名)</code> # 查看模块拥有的方法</li>
<li><code>help(模块名)</code> # 查看模块介绍及其所含方法、拉到最后file后面查看源码路径</li>
<li><code>help(方法名)</code> # 查看方法的内置帮助、用法</li>
</ol>
<h2 id="1-3-运算符"><a href="#1-3-运算符" class="headerlink" title="1.3 运算符"></a>1.3 运算符</h2><p><code>+、-、*、/、%</code>和c语言一样<br><code>**</code>是幂，<code>2**3=8</code><br><code>//</code>是取整除,<code>9//2=4</code><br>比较运算符和c语言一样<br>赋值运算符和c语言一样，多了<code>**=</code>,<code>//=</code><br>位运算符和c语言一样<br>逻辑运算符:<code>and</code>等同于c语言中的<code>&amp;&amp;</code>，<code>or</code>等于c语言中的<code>||</code>，<code>not</code>等于c语言中的<code>!</code>  </p>
<h3 id="1-3-1-成员运算符"><a href="#1-3-1-成员运算符" class="headerlink" title="1.3.1 成员运算符"></a>1.3.1 成员运算符</h3><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。  </p>
<ul>
<li>in<br>如果在指定的序列中找到值返回 True，否则返回 False。例子：x in y , 如果 x 在 y 序列中返回 True。</li>
<li>not in<br>如果在指定的序列中没有找到值返回 True，否则返回 False。例子：x not in y , 如果 x 不在 y 序列中返回 True。</li>
</ul>
<h3 id="1-3-2-身份运算符"><a href="#1-3-2-身份运算符" class="headerlink" title="1.3.2 身份运算符"></a>1.3.2 身份运算符</h3><p>身份运算符用于比较两个对象的存储单元.</p>
<ul>
<li>is<br>is 是判断两个标识符是不是引用自一个对象。例子：x is y, 类似 id(x) == id(y)</li>
<li>is not<br>is not 是判断两个标识符是不是引用自不同对象。例子：x is not y ， 类似 id(a) != id(b)</li>
</ul>
<h2 id="1-4-条件语句"><a href="#1-4-条件语句" class="headerlink" title="1.4 条件语句"></a>1.4 条件语句</h2><p><code>if</code>等用于c语言中<code>if</code>，<code>else</code>等同于c语言中<code>else</code>，<code>elif</code>等同于c语言中<code>else if</code><br>Python程序语言指定任何非0和非空（null）值为True，0 或者 null为False。<br>Python 编程中 if 语句用于控制程序的执行，基本形式为：</p>
<pre><code class="py">if 判断条件1:
    执行语句1……
elif 判断条件2:
    执行语句2……
elif 判断条件3:
    执行语句3……
else:
    执行语句4……</code></pre>
<h2 id="1-5-循环语句"><a href="#1-5-循环语句" class="headerlink" title="1.5 循环语句"></a>1.5 循环语句</h2><p>有while，for循环，循环控制语句有break，continue，pass。  </p>
<h3 id="1-5-1-while"><a href="#1-5-1-while" class="headerlink" title="1.5.1 while"></a>1.5.1 while</h3><p>while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。其基本形式为：  </p>
<pre><code class="py">while 判断条件(condition)：
    执行语句(statements)……</code></pre>
<p>例子：</p>
<pre><code class="py">pets = [&#39;dog&#39;, &#39;cat&#39;, &#39;dog&#39;, &#39;goldfish&#39;, &#39;cat&#39;, &#39;rabbit&#39;, &#39;cat&#39;]
while &#39;cat&#39; in pets:
    pets.remove(&#39;cat&#39;)
print(pets)</code></pre>
<h3 id="1-5-2-for"><a href="#1-5-2-for" class="headerlink" title="1.5.2 for"></a>1.5.2 for</h3><p>for循环的语法格式如下：</p>
<pre><code class="py">for 迭代变量(iterating_var) in 数列、序列(sequence):
   执行语句(statements)</code></pre>
<pre><code class="py">sum = 0
for x in range(101):
    sum = sum + x
print(sum) #1-100的和，等于5050</code></pre>
<pre><code class="py">L = [&#39;Bart&#39;, &#39;Lisa&#39;, &#39;Adam&#39;]
for i in L:
    print(i)</code></pre>
<h3 id="1-5-3-循环控制语句"><a href="#1-5-3-循环控制语句" class="headerlink" title="1.5.3 循环控制语句"></a>1.5.3 循环控制语句</h3><p>break,continue和c语言相同。pass就是一个空语句,不做任何事情，一般用做占位语句。。</p>
<h2 id="1-6-函数"><a href="#1-6-函数" class="headerlink" title="1.6 函数"></a>1.6 函数</h2><p>Python内置了很多有用的函数，我们可以直接调用。可以直接从Python的官方网站查看文档：<br><a href="https://docs.python.org/zh-cn/3/library/functions.html#abs" target="_blank" rel="noopener">Python的官方网站查看内置函数</a><br>比如求绝对值的函数abs，只有一个参数。<br>也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。  </p>
<h3 id="1-6-1-定义函数"><a href="#1-6-1-定义函数" class="headerlink" title="1.6.1 定义函数"></a>1.6.1 定义函数</h3><p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p>
<ol>
<li>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。</li>
<li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li>
<li>函数内容以冒号起始，并且缩进。</li>
<li>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li>
</ol>
<p>一般格式如下：</p>
<pre><code class="py">def 函数名（参数列表）:
    函数体</code></pre>
<p>python函数的使用方法基本上和c语言相同，不用指定返回类型，可以返回列表，字典等。  </p>
<p>一、python可以给函数指定默认值。<br><code>def student(name=&#39;Li Ming&#39;, age=18):</code><br>如果函数有一个实参默认值为空，则必须确保为空的实参在最后一个。如：<br><code>def get_name(first_name, last_name, middle_name=&#39;&#39;):</code>  </p>
<p>二、将列表传递给函数后，函数就可对其进行修改。在函数中对这个列表所做的任何修改都是永久性的，这让你能够高效地处理大量的数据。<br>有时候，需要禁止函数修改列表。这时候，可向函数传递列表的副本而不是原件。<br><code>def stu(name[:], age[:])</code>  </p>
<p>三、Python允许函数从调用语句中收集任意数量的实参。<br><code>def make_pizza(*toppings):</code><br>形参名 *toppings 中的星号让Python创建一个名为 toppings 的空元组，并将收到的所有值都封装到这个元组中。<br>如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。<br><code>def make_pizza(size, *toppings):</code>  </p>
<p>四、使用任意数量的关键字实参<br><code>def build_profile(first, last, **user_info):</code>  </p>
<h3 id="1-6-2-将函数存储在模块中"><a href="#1-6-2-将函数存储在模块中" class="headerlink" title="1.6.2 将函数存储在模块中"></a>1.6.2 将函数存储在模块中</h3><p>可以将函数存储在被称为模块的独立文件中，再将模块导入到主程序中。跟c语言差不多，c语言中用头文件，函数文件。  </p>
<ol>
<li>导入整个模块<br>假设<code>xxx.py</code>所在目录内有另外一个<code>pizza.py</code>，添加<code>import pizza</code>语句<br>导入名为模块 module_name.py 的的整个模块通用语法：<code>import module_name</code><br>可使用下面的语法来使用其中任何一个函数：<code>module_name.function_name ()</code></li>
<li>导入特定的函数<br><code>from module_name import function_0 , function_1 , function_2</code><br>通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数。<br>若使用这种语法，调用函数时就无需使用句点。<code>make_pizza(16, &#39;pepperoni&#39;)</code></li>
<li>使用 as 给函数指定别名<br>指定别名的通用语法如下：<code>from module_name import function_name as fn</code></li>
<li>使用 as 给模块指定别名<br>给模块指定别名的通用语法如下：<code>import module_name as mn</code></li>
<li>导入模块中的所有函数<br>最好只导入你需要用的函数，或者导入整个模块并使用句点表示法。<br>导入模块 module_name 中的所有函数通用语法如下：<code>from module_name import *</code></li>
</ol>
<p>所有的 import 语句都应放在文件开头，唯一例外的情形是，在文件开头使用了注释来描述整个程序。</p>
<h2 id="1-7-类"><a href="#1-7-类" class="headerlink" title="1.7 类"></a>1.7 类</h2><h3 id="1-7-1-创建类"><a href="#1-7-1-创建类" class="headerlink" title="1.7.1 创建类"></a>1.7.1 创建类</h3><p>根据约定，在Python中，首字母大写的名称指的是类。  </p>
<pre><code class="py">class Dog():
    &quot;&quot;&quot;一次模拟小狗的简单尝试&quot;&quot;&quot;
    def __init__(self, name, age):
        &quot;&quot;&quot;初始化属性name和age&quot;&quot;&quot;
        self.name = name
        self.age = age
        self.son = &#39;zero&#39;
    def sit(self):
        &quot;&quot;&quot;模拟小狗被命令时蹲下&quot;&quot;&quot;
        print(self.name.title() + &quot; is now sitting.&quot;)
    def roll_over(self):
        &quot;&quot;&quot;模拟小狗被命令时打滚&quot;&quot;&quot;
        print(self.name.title() + &quot; rolled over!&quot;)
my_dog = Dog(&#39;willie&#39;, 6)
print(&quot;My dog&#39;s name is &quot; + my_dog.name.title() + &quot;.&quot;)
print(&quot;My dog is &quot; + str(my_dog.age) + &quot; years old.&quot;)
my_dog.sit()
print(my_dog.son)</code></pre>
<p>一 方法 <strong>init</strong>()<br>可参考c++中的构造函数。  </p>
<ol>
<li>我们将方法 <strong>init</strong>() 定义成了包含三个形参： self 、 name 和 age 。在这个方法的定义中，形参 self 必不可少，还必须位于其他形参的前面，相当于c++中的This指针。  </li>
<li>因为Python调用这个 <strong>init</strong>() 方法来创建 Dog 实例时，将自动传入实参 self 。每个与类相关联的方法调用都自动传递实参 self ，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。  </li>
<li>我们将通过实参向 Dog() 传递名字和年龄； self 会自动传递，因此我们不需要传递它。每当我们根据 Dog 类创建实例时，都只需给最后两个形参（ name 和 age ）提供值。  </li>
<li>Dog 类还定义了另外两个方法： sit() 和 roll_over() 。由于这些方法不需要额外的信息，如名字，因此它们只有一个形参 self 。  </li>
</ol>
<p>二 根据类创建实例</p>
<ol>
<li>访问属性<br>要访问实例的属性，可使用句点表示法。<code>my_dog.name</code></li>
<li>调用方法<br>用句点表示法来调用 Dog 类中定义的任何方法。<code>my_dog.roll_over()</code></li>
<li>给属性指定默认值<br>可以在方法 <strong>init</strong>()中添加默认值<br>如果你对某个属性这样做了，就无需包含为它提供初始值的形参。</li>
</ol>
<p>三 修改属性的值</p>
<ol>
<li>直接修改属性的值<br><code>my_dog.son=&#39;kuku&#39;</code></li>
<li>通过方法修改属性的值<br>等于在类里面新建一个方法，来修改类里面属性的值<br><code>def update_name(self, mile):</code><br>   <code>self.name = mile</code></li>
<li>通过方法对属性的值进行递增<br>跟2差不多，用方法里面的实参来修改。</li>
</ol>
<h3 id="1-7-2-继承"><a href="#1-7-2-继承" class="headerlink" title="1.7.2 继承"></a>1.7.2 继承</h3><pre><code class="py">class ElectricCar(Car):
    &quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;
   def __init__(self, make, model, year):
      &quot;&quot;&quot;初始化父类的属性&quot;&quot;&quot;
      super().__init__(make, model, year)
      self.battery_size = 70</code></pre>
<p>一 给子类定义属性和方法<br><strong>super() 是一个特殊函数，帮助Python将父类和子类关联起来。这行代码让Python调用ElectricCar 的父类的方法 <strong>init</strong>() ，让 ElectricCar 实例包含父类的所有属性。父类也称为超类（superclass），名称super因此而得名。</strong>  </p>
<p>二 重写父类的方法  </p>
<p>可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。  </p>
<h3 id="1-7-3-导入类"><a href="#1-7-3-导入类" class="headerlink" title="1.7.3 导入类"></a>1.7.3 导入类</h3><p>Python允许你将类存储在模块中，然后在主程序中导入所需的模块。  </p>
<ol>
<li>导入类<br><code>from car import Car</code></li>
<li>从一个模块中导入多个类<br><code>from car import Car, ElectricCar</code></li>
<li>导入整个模块<br>你还可以导入整个模块，再使用句点表示法访问需要的类。<code>import car</code></li>
<li>导入模块中的所有类<br><code>from module_name import *</code> #不推荐这种方式</li>
<li>在一个模块中导入另一个模块</li>
</ol>
<h3 id="1-7-4-类编码风格"><a href="#1-7-4-类编码风格" class="headerlink" title="1.7.4 类编码风格"></a>1.7.4 类编码风格</h3><p>类名应采用驼峰命名法，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。</p>
<h2 id="1-8-文件和异常"><a href="#1-8-文件和异常" class="headerlink" title="1.8 文件和异常"></a>1.8 文件和异常</h2><h3 id="1-8-1-从文件中读取数据"><a href="#1-8-1-从文件中读取数据" class="headerlink" title="1.8.1 从文件中读取数据"></a>1.8.1 从文件中读取数据</h3><h4 id="1-8-1-1-读取整个文件"><a href="#1-8-1-1-读取整个文件" class="headerlink" title="1.8.1.1 读取整个文件"></a>1.8.1.1 读取整个文件</h4><p>open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。<br><code>open(file, mode=&#39;r&#39;)</code><br>完整的语法格式为：<br><code>open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code><br>参数说明:</p>
<ul>
<li>file: 必需，文件路径（相对或者绝对路径）。</li>
<li>mode: 可选，文件打开模式</li>
<li>buffering: 设置缓冲</li>
<li>encoding: 一般使用utf8</li>
<li>errors: 报错级别</li>
<li>newline: 区分换行符</li>
<li>closefd: 传入的file参数类型</li>
<li>opener:</li>
</ul>
<pre><code class="py">with open(&#39;pi_digits.txt&#39;) as file_object:
   contents = file_object.read()
   print(contents)</code></pre>
<p>函数 open() 接受一个参数：要打开的文件的名称。 函数 open()返回一个表示文件的对象。Python将这个对象存储在我们将在后面使用的变量中。<br>关键字 ==with== 在不再需要访问文件后将其关闭。在这个程序中，我们没有调用 close() ；你只管打开文件，并在需要时使用它，Python自会在合适的时候自动将其关闭。<br>有了表示 pi_digits.txt 的文件对象后，我们使用方法 read() （前述程序的第2行）读取这个文件的全部内容，并将其作为一个长长的字符串存储在变量 contents 中。这样，通过打印 contents 的值，就可将这个文本文件的全部内容显示出来。<br>相比于原始文件，该输出唯一不同的地方是末尾多了一个空行。为何会多出这个空行呢？因为 read() 到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除多出来的空行，可在 print 语句中使用 rstrip() ：<code>print(contents.rstrip())</code>  </p>
<h4 id="1-8-1-2-文件路径"><a href="#1-8-1-2-文件路径" class="headerlink" title="1.8.1.2 文件路径"></a>1.8.1.2 文件路径</h4><p>在Linux和OS X中，你可以这样编写代码：<br><code>file_path = &#39;/home/ehmatthes/other_files/text_files/filename.txt&#39;</code><br><code>with open(file_path) as file_object:</code><br>Windows系统中，在文件路径中使用反斜杠（ \ ）而不是斜杠（ / ）：<br><code>file_path = &#39;C:\Users\ehmatthes\other_files\text_files\filename.txt&#39;</code><br><code>with open(file_path) as file_object:</code>  </p>
<h4 id="1-8-1-3-逐行读取"><a href="#1-8-1-3-逐行读取" class="headerlink" title="1.8.1.3 逐行读取"></a>1.8.1.3 逐行读取</h4><pre><code class="py">filename = &#39;pi_digits.txt&#39;
with open(filename) as file_object:
   for a in file_object:
      print(a.rstrip())</code></pre>
<h4 id="1-8-1-4-创建一个包含文件各行内容的列表"><a href="#1-8-1-4-创建一个包含文件各行内容的列表" class="headerlink" title="1.8.1.4 创建一个包含文件各行内容的列表"></a>1.8.1.4 创建一个包含文件各行内容的列表</h4><pre><code class="py">filename = &#39;pi_digits.txt&#39;
with open(filename) as file_object:
   lines = file_object.readlines()
for line in lines:
   print(line.rstrip())</code></pre>
<h4 id="1-8-1-5-使用文件的内容"><a href="#1-8-1-5-使用文件的内容" class="headerlink" title="1.8.1.5 使用文件的内容"></a>1.8.1.5 使用文件的内容</h4><pre><code class="py">filename = &#39;pi_digits.txt&#39;
with open(filename) as file_object:
   lines = file_object.readlines()
pi_string = &#39;&#39;
for line in lines:
   pi_string += line.strip()
print(pi_string)</code></pre>
<p>输出3.141592653589793238462643383279<br>在变量 pi_string 存储的字符串中，包含原来位于每行左边的空格，为删除这些空格，可使用 strip() 函数消除空格。<br><code>print str.strip( &#39;0&#39; );  # 去除首尾字符 0</code></p>
<h3 id="1-8-2-写入文件"><a href="#1-8-2-写入文件" class="headerlink" title="1.8.2 写入文件"></a>1.8.2 写入文件</h3><h4 id="1-8-2-1-写入空文件"><a href="#1-8-2-1-写入空文件" class="headerlink" title="1.8.2.1 写入空文件"></a>1.8.2.1 写入空文件</h4><pre><code class="py">filename = &#39;a.txt&#39;
with open(filename, &#39;w&#39;) as file_object:
   file_object.write(&quot;I love programming.\n&quot;)</code></pre>
<p>打开文件时，可指定<strong>读取模式（ ‘r’ ）、写入模式（ ‘w’ ）、附加模式（ ‘a’ ）或让你能够读取和写入文件的模式（ ‘r+’ ）</strong>。如果<br>你省略了模式实参，Python将以默认的只读模式打开文件。<br><strong>Python只能将字符串写入文本文件。要将数值数据存储到文本文件中，必须先使用函数str() 将其转换为字符串格式。</strong></p>
<h4 id="1-8-2-2-写入多行"><a href="#1-8-2-2-写入多行" class="headerlink" title="1.8.2.2 写入多行"></a>1.8.2.2 写入多行</h4><p>每句后面加上换行符。</p>
<h3 id="1-8-3-异常"><a href="#1-8-3-异常" class="headerlink" title="1.8.3 异常"></a>1.8.3 异常</h3><p>Python使用被称为异常的特殊对象来管理程序执行期间发生的错误。每当发生错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继续运行；如果你未对异常进行处理，程序将停止，并显示一个traceback，其中包含有关异常的报告。<br>异常是使用 try-except 代码块处理的。 try-except 代码块让Python执行指定的操作，同时告诉Python发生异常时怎么办。使用了 try-except 代码块时，即便出现异常，程序也将继续运行：显示你编写的友好的错误消息，而不是令用户迷惑的traceback。  </p>
<h4 id="1-8-3-1-使用-try-except-else-代码块"><a href="#1-8-3-1-使用-try-except-else-代码块" class="headerlink" title="1.8.3.1 使用 try-except-else 代码块"></a>1.8.3.1 使用 try-except-else 代码块</h4><pre><code class="py">print(&quot;Give me two numbers, and I&#39;ll divide them.&quot;)
print(&quot;Enter &#39;q&#39; to quit.&quot;)
while True:
   first_number = input(&quot;\nFirst number: &quot;)
   if first_number == &#39;q&#39;:
     break
   second_number = input(&quot;Second number: &quot;)
   try:
      answer = int(first_number) / int(second_number)
   except ZeroDivisionError:
      print(&quot;You can&#39;t divide by 0!&quot;)
   else:
      print(answer)</code></pre>
<p>当你认为可能发生了错误时，可编写一个 try-except 代码块来处理可能引发的异常。<br>通过将可能引发错误的代码放在 try-except 代码块中，可提高这个程序抵御错误的能力。这个示例还包含一个 else 代码块；依赖于 try 代码块成功执行的代码都应放到 else 代码块中。<br>try-except-else 代码块的工作原理大致如下：<strong>Python尝试执行 try 代码块中的代码；只有可能引发异常的代码才需要放在 try 语句中。有时候，有一些仅在 try 代码块成功执行时才需要运行的代码；这些代码应放在 else 代码块中。 except 代码块告诉Python，如果它尝试运行 try 代码块中的代码时引发了指定的异常，该怎么办。</strong>  </p>
<h4 id="1-8-3-2-分析多个文本"><a href="#1-8-3-2-分析多个文本" class="headerlink" title="1.8.3.2 分析多个文本"></a>1.8.3.2 分析多个文本</h4><pre><code class="py">def count_words(filename):
   &quot;&quot;&quot;计算一个文件大致包含多少个单词&quot;&quot;&quot;
   try:
      with open(filename) as f_obj:
         contents = f_obj.read()
   except FileNotFoundError:
      print(&quot;Sorry, the file &quot; + filename + &quot; does not exist.&quot;)
   else:
      # 计算文件大致包含多少个单词
      words = contents.split()
      num_words = len(words)
      print(&quot;The file &quot; + filename + &quot; has about &quot; + str(num_words) + &quot; words.&quot;)

filenames = [&#39;0.txt&#39;, &#39;1.txt&#39;, &#39;2.txt&#39;, &#39;3.txt&#39;]
for filename in filenames:
   count_words(filename)</code></pre>
<p>如果你希望失败的时候不提示用户，可以在 except xxxError 后面添加一句pass。  </p>
<h3 id="1-8-4-存储数据"><a href="#1-8-4-存储数据" class="headerlink" title="1.8.4 存储数据"></a>1.8.4 存储数据</h3><p>模块 json 让你能够将简单的Python数据结构转储到文件中，并在程序再次运行时加载该文件中的数据。还可以使用 json 在Python程序之间分享数据。更重要的是，JSON数据格式并非Python专用的，这让你能够将以JSON格式存储的数据与使用其他编程语言的人分享。  </p>
<h4 id="1-8-4-1-使用-json-dump-和-json-load-保存和读取用户生成的数据"><a href="#1-8-4-1-使用-json-dump-和-json-load-保存和读取用户生成的数据" class="headerlink" title="1.8.4.1 使用 json.dump() 和 json.load() 保存和读取用户生成的数据"></a>1.8.4.1 使用 json.dump() 和 json.load() 保存和读取用户生成的数据</h4><pre><code class="py">import json
# 如果以前存储了用户名，就加载它
# 否则，就提示用户输入用户名并存储它
filename = &#39;username.json&#39;
try:
   with open(filename) as f_obj:
      username = json.load(f_obj)
except FileNotFoundError:
   username = input(&quot;What is your name? &quot;)
   with open(filename, &#39;w&#39;) as f_obj:
      json.dump(username, f_obj)
      print(&quot;We&#39;ll remember you when you come back, &quot; + username + &quot;!&quot;)
else:
   print(&quot;Welcome back, &quot; + username + &quot;!&quot;)</code></pre>
<p>先导入模块json，通过方法json.dump() 和 json.load()来保存用户名。<br>上面的程序，如果第一次执行，保存用户名到username，第二次执行则显示欢迎回来。  </p>
<h4 id="1-8-4-2-重构"><a href="#1-8-4-2-重构" class="headerlink" title="1.8.4.2 重构"></a>1.8.4.2 重构</h4><p>有时候，我们要保证高内聚，低耦合，需要将各个模块代码分为一系列完成具体工作的函数，这样的过程称为重构。<br>下面我们来重构上一节的代码：  </p>
<pre><code class="py">import json
def get_stored_username():
   &quot;&quot;&quot;如果存储了用户名，就获取它&quot;&quot;&quot;
   filename = &#39;username.json&#39;
   try:
      with open(filename) as f_obj:
         username = json.load(f_obj)
   except FileNotFoundError:
      return None
   else:
      return username

def get_new_username():
   &quot;&quot;&quot;提示用户输入用户名&quot;&quot;&quot;
   username = input(&quot;What is your name? &quot;)
   filename = &#39;username.json&#39;
   with open(filename, &#39;w&#39;) as f_obj:
      json.dump(username, f_obj)
   return username

def greet_user():
   &quot;&quot;&quot;问候用户，并指出其名字&quot;&quot;&quot;
   username = get_stored_username()
   if username:
      print(&quot;Welcome back, &quot; + username + &quot;!&quot;)
   else:
      username = get_new_username()
      print(&quot;We&#39;ll remember you when you come back, &quot; + username + &quot;!&quot;)

greet_user()</code></pre>
<p>在这个最终版本中，每个函数都执行单一而清晰的任务。要编写出清晰而易于维护和扩展的代码，划分工作必不可少。  </p>
<h2 id="1-9-测试代码"><a href="#1-9-测试代码" class="headerlink" title="1.9 测试代码"></a>1.9 测试代码</h2><p>这章中我们学习如何使用Python模块 unittest 中的工具来测试代码。</p>
<h3 id="1-9-1-测试函数"><a href="#1-9-1-测试函数" class="headerlink" title="1.9.1 测试函数"></a>1.9.1 测试函数</h3><h4 id="1-9-1-1-单元测试和测试用例"><a href="#1-9-1-1-单元测试和测试用例" class="headerlink" title="1.9.1.1 单元测试和测试用例"></a>1.9.1.1 单元测试和测试用例</h4><p>Python标准库中的模块 unittest 提供了代码测试工具。单元测试用于核实函数的某个方面没有问题；测试用例是一组单元测试，这些单元测试一起核实函数在各种情形下的行为都符合要求。良好的测试用例考虑到了函数可能收到的各种输入，包含针对所有这些情形的测试。全覆盖式测试用例包含一整套单元测试，涵盖了各种可能的函数使用方式。对于大型项目，要实现全覆盖可能很难。通常，最初只要针对代码的重要行为编写测试即可，等项目被广泛使用时再考虑全覆盖。  </p>
<h4 id="1-9-1-2-如何测试"><a href="#1-9-1-2-如何测试" class="headerlink" title="1.9.1.2 如何测试"></a>1.9.1.2 如何测试</h4><p>要为函数编写测试用例，可先导入模块 unittest 以及要测试的函数，再创建一个继承 unittest.TestCase 的类，并编写一系列方法对函数行为的不同方面进行测试。<br>下面是一个只包含一个方法的测试用例，它检查函数 get_formatted_name() 在给定名和姓时能否正确地工作：  </p>
<pre><code class="py">#文件名name_function.py
def get_formatted_name(first, last, middle=&#39;&#39;):
    &quot;&quot;&quot;生成整洁的姓名&quot;&quot;&quot;
    if middle:
        full_name = first + &#39; &#39; + middle + &#39; &#39; + last
    else:
        full_name = first + &#39; &#39; + last
    return full_name.title()</code></pre>
<pre><code class="py">import unittest
from name_function import get_formatted_name
#文件名test_name_ function.py
class NamesTestCase(unittest.TestCase):
    &quot;&quot;&quot;测试name_function.py&quot;&quot;&quot;
    def test_first_last_name(self):
        &quot;&quot;&quot;能够正确地处理像Janis Joplin这样的姓名吗？&quot;&quot;&quot;
        formatted_name = get_formatted_name(&#39;janis&#39;, &#39;joplin&#39;)
        self.assertEqual(formatted_name, &#39;Janis Joplin&#39;)

    def test_first_last_middle_name(self):
        &quot;&quot;&quot;能够正确地处理像Wolfgang Amadeus Mozart这样的姓名吗？&quot;&quot;&quot;
        formatted_name = get_formatted_name(&#39;wolfgang&#39;, &#39;mozart&#39;, &#39;amadeus&#39;)
        self.assertEqual(formatted_name, &#39;Wolfgang Amadeus Mozart&#39;)

unittest.main()</code></pre>
<p>首先，我们导入了模块 unittest 和要测试的函数 get_formatted_ name() 。我们创建了一个名为 NamesTestCase（名字随便） 的类，用于包含一系列针对 get_formatted_name() 的单元测试。这个类必须继承unittest.TestCase 类，这样Python才知道如何运行你编写的测试。<br>我们运行 test_name_function.py 时，所有以 test_ 打头的方法都将自动运行。<br>在这个方法中，我们调用了要测试的函数，并存储了要测试的返回值。<br>最后我们使用了 unittest 类最有用的功能之一：一个断言方法。断言方法用来核实得到的结果是否与期望的结果一致。<br>我们调用 <strong>unittest 的方法 assertEqual()</strong> ，并向它传递 formatted_name 和 ‘Janis Joplin’ 。代码行 <code>self.assertEqual(formatted_name, &#39;Janis Joplin&#39;)</code> 的意思是说：“将 formatted_name 的值同字符串 ‘Janis Joplin’ 进行比较，如果它们相等，就万事大吉，如果它们不相等，跟我说一声！”  </p>
<h3 id="1-9-2-测试类"><a href="#1-9-2-测试类" class="headerlink" title="1.9.2 测试类"></a>1.9.2 测试类</h3><h4 id="1-9-2-1-各种断言方法"><a href="#1-9-2-1-各种断言方法" class="headerlink" title="1.9.2.1 各种断言方法"></a>1.9.2.1 各种断言方法</h4><p>Python在 unittest.TestCase 类中提供了很多断言方法。如下：  </p>
<table>
<thead>
<tr>
<th>方 法</th>
<th>用 途</th>
</tr>
</thead>
<tbody><tr>
<td>assertEqual(a, b)</td>
<td>核实 a == b</td>
</tr>
<tr>
<td>assertNotEqual(a, b)</td>
<td>核实 a != b</td>
</tr>
<tr>
<td>assertTrue(x)</td>
<td>核实 x 为 True</td>
</tr>
<tr>
<td>assertFalse(x)</td>
<td>核实 x 为 False</td>
</tr>
<tr>
<td>assertIn( item , list )</td>
<td>核实 item 在 list 中</td>
</tr>
<tr>
<td>assertNotIn( item , list )</td>
<td>核实 item 不在 list 中</td>
</tr>
</tbody></table>
<h4 id="1-9-2-2-方法-setUp"><a href="#1-9-2-2-方法-setUp" class="headerlink" title="1.9.2.2 方法 setUp()"></a>1.9.2.2 方法 setUp()</h4><pre><code class="py">class AnonymousSurvey():
    &quot;&quot;&quot;收集匿名调查问卷的答案&quot;&quot;&quot;
    def __init__(self, question):
        &quot;&quot;&quot;存储一个问题，并为存储答案做准备&quot;&quot;&quot;
        self.question = question
        self.responses = []

    def show_question(self):
        &quot;&quot;&quot;显示调查问卷&quot;&quot;&quot;
        print(question)

    def store_response(self, new_response):
        &quot;&quot;&quot;存储单份调查答卷&quot;&quot;&quot;
        self.responses.append(new_response)

    def show_results(self):
        &quot;&quot;&quot;显示收集到的所有答卷&quot;&quot;&quot;
        print(&quot;Survey results:&quot;)
        for response in responses:
            print(&#39;- &#39; + response)</code></pre>
<pre><code class="py">import unittest
from survey import AnonymousSurvey
class TestAnonymousSurvey(unittest.TestCase):
    &quot;&quot;&quot;针对AnonymousSurvey类的测试&quot;&quot;&quot;
    def setUp(self):
    # 创建一个调查对象和一组答案，供使用的测试方法使用
        question = &quot;What language did you first learn to speak?&quot;
        self.my_survey = AnonymousSurvey(question)
        self.responses = [&#39;English&#39;, &#39;Spanish&#39;, &#39;Mandarin&#39;]

    def test_store_single_response(self):
        &quot;&quot;&quot;测试单个答案会被妥善地存储&quot;&quot;&quot;
        self.my_survey.store_response(self.responses[0])
        self.assertIn(self.responses[0], self.my_survey.responses)

    def test_store_three_responses(self):
        &quot;&quot;&quot;测试三个答案会被妥善地存储&quot;&quot;&quot;
        for response in self.responses:
            self.my_survey.store_response(response)
        for response in self.responses:
            self.assertIn(response, self.my_survey.responses)

unittest.main()</code></pre>
<p>使用 setUp() 来创建一个调查对象和一组答案，供方法 <code>test_store_single_response()</code> 和 <code>test_store_three_responses()</code> 使用。<br>方法 setUp() 做了两件事情：创建一个调查对象（见方法setUp()第4行）；创建一个答案列表（见方法setUp()第5行）。<br>这让两个测试方法都更简单，因为它们都不用创建调查对象和答案。方法 <code>test_store_three_response()</code> 核实 self.responses 中的第一个答案—— self.responses[0] ——被妥善地存储，而方法 <code>test_store_three_response()</code> 核实 self.responses 中的全部三个答案都被妥善地存储。  </p>
]]></content>
      <categories>
        <category>python</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构第九章 排序</title>
    <url>/2020/02/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC9%E7%AB%A0%20%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>排序的定义：</strong><br><strong>假设含有n个记录的序列为{$r_1$，$r_2$，…，$r_n$}，其相应的关键字分别为{$k_1$，$k_2$，…，$k_n$}，需确定1，2，……，n的一种排列$p_1$，$p_2$，……，$p_n$，使其相应的关键字满足$k_{p1}$≤$k_{p2}$≤······≤$k_{pn}$（非递减或非递增）关系，即使得序列成为一个按关键字有序的序列{$r_{p1}$，$r_{p2}$，······，$r_{pn}$}，这样的操作就称为排序。</strong></p>
<a id="more"></a>

<h2 id="9-1-9-2-排序的基本概念与分类"><a href="#9-1-9-2-排序的基本概念与分类" class="headerlink" title="9.1-9.2 排序的基本概念与分类"></a>9.1-9.2 排序的基本概念与分类</h2><p>我们在排序问题中，通常将数据元素称为记录。显然我们输入的是一个记录集合，输出的也是一个记录集合，所以说，可以将排序看成是线性表的一种操作。</p>
<p>排序的依据是关键字之间的大小关系，那么，对同一个记录集合，针对不同的关键字进行排序，可以得到不同序列。</p>
<p>这里关键字k可以是记录r的主关键字，也可以是次关键字，甚至是若干数据项的组合。  </p>
<h3 id="9-2-1-排序的稳定性"><a href="#9-2-1-排序的稳定性" class="headerlink" title="9.2.1 排序的稳定性"></a>9.2.1 排序的稳定性</h3><p>假设$k_i=k_y(1≤i≤n，1≤j≤n，i≠j)$，且在排序前的序列中$r_i$领先于$r_j$（即$i&lt;j$）。如果排序后$r_i$仍领先于$r_j$，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中$r_j$领先$r_i$，则称所用的排序方法是不稳定的。</p>
<h3 id="9-2-2-内排序与外排序"><a href="#9-2-2-内排序与外排序" class="headerlink" title="9.2.2 内排序与外排序"></a>9.2.2 内排序与外排序</h3><p>根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为：内排序和外排序。</p>
<p><strong>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。</strong>我们这里主要就介绍内排序的多种方法。</p>
<p>对于内排序来说，排序算法的性能主要是受3个方面影响：</p>
<ol>
<li><strong>时间性能</strong><br>排序是数据处理中经常执行的一种操作，往往属于系统的核心部分，因此排序算法的时间开销是衡量其好坏的最重要的标志。在内排序中，主要进行两种操作：比较和移动。比较指关键字之间的比较，这是要做排序最起码的操作。移动指记录从一个位置移动到另一个位置，事实上，移动可以通过改变记录的存储方式来予以避免（这个我们在讲解具体的算法时再谈）。总之，高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。</li>
<li><strong>辅助空间</strong><br>评价排序算法的另一个主要标准是执行算法所需要的辅助存储空间。辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。</li>
<li><strong>算法的复杂性</strong><br>注意这里指的是算法本身的复杂度，而不是指算法的时间复杂度。显然算法过于复杂也会影响排序的性能。</li>
</ol>
<p>根据排序过程中借助的主要操作，我们把<strong>内排序分为：插入排序、交换排序、选择排序和归并排序。</strong></p>
<p>本章一共要讲解七种排序的算法，按照算法的复杂度分为两大类，冒泡排序、简单选择排序和直接插入排序属于简单算法，而希尔排序、堆排序、归并排序、快速排序属于改进算法。</p>
<h3 id="9-2-3-排序用到的结构与函数"><a href="#9-2-3-排序用到的结构与函数" class="headerlink" title="9.2.3 排序用到的结构与函数"></a>9.2.3 排序用到的结构与函数</h3><p>为了讲清楚排序算法的代码，我先提供一个用于排序用的顺序表结构，此结构也将用于之后我们要讲的所有排序算法。</p>
<pre><code class="c">#define MAXSIZE 10  /* 用于要排序数组个数最大值，可根据需要修改 */
typedef struct
{
    int r[MAXSIZE + 1];    /* 用于存储要排序数组，r[0]用作哨兵或临时变量 */
    int length;            /* 用于记录顺序表的长度 */
}SqList;</code></pre>
<p>另外，由于排序最最常用到的操作是数组两元素的交换，我们将它写成函数，在之后的讲解中会大量的用到。</p>
<pre><code class="c">/* 交换L中数组r的下标为i和j的值 */
void swap(SqList *L, int i, int j)
{
    int temp = L-&gt;r[i];
    L-&gt;r[i] = L-&gt;r[j];
    L-&gt;r[j] = temp;
}</code></pre>
<h2 id="9-3-冒泡排序"><a href="#9-3-冒泡排序" class="headerlink" title="9.3 冒泡排序"></a>9.3 冒泡排序</h2><h3 id="9-3-1-最简单排序实现"><a href="#9-3-1-最简单排序实现" class="headerlink" title="9.3.1 最简单排序实现"></a>9.3.1 最简单排序实现</h3><p><strong>冒泡排序（Bubble Sort）一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</strong>冒泡的实现在细节上可以有很多种变化，我们将分别就3种不同的冒泡实现代码，来讲解冒泡排序的思想。</p>
<pre><code class="c">/* 对顺序表L作交换排序（冒泡排序初级版） */
void BubbleSort0(SqList *L)
{
    int i, j;
    for (i = 1; i &lt; L-&gt;length; i++)
    {
        for (j = i + 1; j &lt;= L-&gt;length; j++)
        {
            if (L-&gt;r[i] &gt; L-&gt;r[j])
            {
                swap(L, i, j);/* 交换L-&gt;r[i]与L-&gt;r[j]的值 */
            }
        }
    }
}</code></pre>
<h3 id="9-3-2-冒泡排序算法"><a href="#9-3-2-冒泡排序算法" class="headerlink" title="9.3.2 冒泡排序算法"></a>9.3.2 冒泡排序算法</h3><p>我们来看看正宗的冒泡算法。</p>
<pre><code class="c">/* 对顺序表L作冒泡排序 */
void BubbleSort(SqList *L)
{
    int i, j;
    for (i = 1; i &lt; L-&gt;length; i++)
    {
        for (j = L-&gt;length - 1; j &gt;= i; j--)  /* 注意j是从后往前循环 */
        {
            if (L-&gt;r[j] &gt; L-&gt;r[j + 1]) /* 若前者大于后者（注意这里与上一算法的差异）*/
            {
                swap(L, j, j + 1);/* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */
            }
        }
    }
}</code></pre>
<h3 id="9-3-3-冒泡排序优化"><a href="#9-3-3-冒泡排序优化" class="headerlink" title="9.3.3 冒泡排序优化"></a>9.3.3 冒泡排序优化</h3><pre><code class="c">/* 对顺序表L作改进冒泡算法 */
void BubbleSort2(SqList *L)
{
    int i, j;
    Status flag = TRUE;            /* flag用来作为标记 */
    for (i = 1; i &lt; L-&gt;length &amp;&amp; flag; i++) /* 若flag为true说明有过数据交换，否则停止循环 */
    {
        flag = FALSE;                /* 初始为False */
        for (j = L-&gt;length - 1; j &gt;= i; j--)
        {
            if (L-&gt;r[j] &gt; L-&gt;r[j + 1])
            {
                swap(L, j, j + 1);    /* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */
                flag = TRUE;        /* 如果有数据交换，则flag为true */
            }
        }
    }
}</code></pre>
<p>代码改动的关键就是在i变量的for循环中，增加了对flag是否为true的判断。</p>
<p>经过这样的改进，冒泡排序在性能上就有了一些提升，可以避免因已经有序的情况下的无意义循环判断。</p>
<h3 id="9-3-4-冒泡排序复杂度分析"><a href="#9-3-4-冒泡排序复杂度分析" class="headerlink" title="9.3.4 冒泡排序复杂度分析"></a>9.3.4 冒泡排序复杂度分析</h3><p>分析一下它的时间复杂度。当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以推断出就是n-1次的比较，没有数据交换，时间复杂度为 O（n）。当最坏的情况，即待排序表是逆序的情况，此时需要比较$\sum_{i=2}^n(i-1)=1+2+3+…+（n-1）=\frac{n(n-1)}2$次，并作等数量级的记录移动。因此，时间复杂度为O（n²）。</p>
<h2 id="9-4-简单选择排序"><a href="#9-4-简单选择排序" class="headerlink" title="9.4 简单选择排序"></a>9.4 简单选择排序</h2><p>冒泡排序的思想就是不断地在交换，通过交换完成最终的排序，这和做股票短线频繁操作的人是类似的。我们可不可以像只有在时机非常明确到来时才出手的股票高手一样，也就是在排序时找到合适的关键字再做交换，并且只移动一次就完成相应关键字的排序定位工作呢？这就是选择排序法的初步思想。</p>
<p>选择排序的基本思想是每一趟在<code>n-i+1（i=1,2,…,n-1）</code>个记录中选取关键字最小的记录作为有序序列的第i个记录。我们这里先介绍的是简单选择排序法。</p>
<h3 id="9-4-1-简单选择排序算法"><a href="#9-4-1-简单选择排序算法" class="headerlink" title="9.4.1 简单选择排序算法"></a>9.4.1 简单选择排序算法</h3><p><strong>简单选择排序法（Simple Selection Sort）就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i（1≤i≤n）个记录交换之。</strong></p>
<pre><code class="c">/* 对顺序表L作简单选择排序 */
void SelectSort(SqList *L)
{
    int i, j, min;
    for (i = 1; i &lt; L-&gt;length; i++)
    {
        min = i;                        /* 将当前下标定义为最小值下标 */
        for (j = i + 1; j &lt;= L-&gt;length; j++)/* 循环之后的数据 */
        {
            if (L-&gt;r[min] &gt; L-&gt;r[j])    /* 如果有小于当前最小值的关键字 */
                min = j;                /* 将此关键字的下标赋值给min */
        }
        if (i != min)                        /* 若min不等于i，说明找到最小值，交换 */
            swap(L, i, min);                /* 交换L-&gt;r[i]与L-&gt;r[min]的值 */
    }
}</code></pre>
<p>简单选择排序会先找到最小值的下标，然后交换。接着迭代循环。</p>
<h3 id="9-4-2-简单选择排序复杂度分析"><a href="#9-4-2-简单选择排序复杂度分析" class="headerlink" title="9.4.2 简单选择排序复杂度分析"></a>9.4.2 简单选择排序复杂度分析</h3><p>从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第i趟排序需要进行n-i次关键字的比较，此时需要比较$\sum_{i=1}^{n-1}(n-i)=n-1+n-2+…+1=\frac{n(n-1)}{2}$次。而对于交换次数而言，当最好的时候，交换为0次，最差的时候，也就初始降序时，交换次数为n-1次，基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为O（n²）。</p>
<p>应该说，尽管与冒泡排序同为O（n²），但简单选择排序的性能上还是要略优于冒泡排序。</p>
<h2 id="9-5-直接插入排序"><a href="#9-5-直接插入排序" class="headerlink" title="9.5 直接插入排序"></a>9.5 直接插入排序</h2><h3 id="9-5-1-直接插入排序算法"><a href="#9-5-1-直接插入排序算法" class="headerlink" title="9.5.1 直接插入排序算法"></a>9.5.1 直接插入排序算法</h3><p><strong>直接插入排序（Straight Insertion Sort）的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。</strong></p>
<pre><code class="c">/* 对顺序表L作直接插入排序 */
void InsertSort(SqList *L)
{
    int i, j;
    for (i = 2; i &lt;= L-&gt;length; i++)
    {
        if (L-&gt;r[i] &lt; L-&gt;r[i - 1]) /* 需将L-&gt;r[i]插入有序子表 */
        {
            L-&gt;r[0] = L-&gt;r[i]; /* L-&gt;r[0]一开始无数值，以待设置哨兵 */
            for (j = i - 1; L-&gt;r[j] &gt; L-&gt;r[0]; j--)
                L-&gt;r[j + 1] = L-&gt;r[j]; /* 记录后移 */
            L-&gt;r[j + 1] = L-&gt;r[0]; /* 插入到正确位置 */
        }
    }
}</code></pre>
<h3 id="9-5-2-直接插入排序复杂度分析"><a href="#9-5-2-直接插入排序复杂度分析" class="headerlink" title="9.5.2 直接插入排序复杂度分析"></a>9.5.2 直接插入排序复杂度分析</h3><p>我们来分析一下这个算法，从空间上来看，它只需要一个记录的辅助空间，因此关键是看它的时间复杂度。</p>
<p>当最好的情况，也就是要排序的表本身就是有序的，比如数列是{2，3，4，5，6}，那么我们比较次数，其实就是代码第7行每个L.r[i]与L.r[i-1]的比较，共比较了$n-1(\sum_{i=2}^{n}1)$次，由于每次都是L.r[i]&gt;L.r[i-1]，因此没有移动的记录，时间复杂度为O(n)。</p>
<p>当最坏的情况，即待排序表是逆序的情况，比如{6，5，4，3，2}，此时需要比较$\sum_{i=2}^{n}(i)=2+3+…+n=\frac{(n+2)(n-1)}{2}$次，而记录的移动次数也达到最大值$\sum_{i=2}^{n}(i+1)=\frac{(n+4)(n-1)}{2}$次。</p>
<p>如果排序记录是随机的，那么根据概率相同的原则，平均比较和移动次数约为$\frac{n^{2}}{4}$次。因此，我们得出直接插入排序法的时间复杂度为O(n²)。从这里也看出，同样的O(n²)时间复杂度，直接插入排序法比冒泡和简单选择排序的性能要好一些。</p>
<h2 id="9-6-希尔排序"><a href="#9-6-希尔排序" class="headerlink" title="9.6 希尔排序"></a>9.6 希尔排序</h2><h3 id="9-6-1-希尔排序原理"><a href="#9-6-1-希尔排序原理" class="headerlink" title="9.6.1 希尔排序原理"></a>9.6.1 希尔排序原理</h3><p>因为直接插入排序在排序表本身有序的情况下，时间复杂度为O(n)。</p>
<p>如果让待排序的记录个数较少呢，我们就可以用直接插入排序很快完成排序工作。很容易想到的就是将原本有大量记录数的记录进行分组。分割成若干个子序列，此时每个子序列待排序的记录个数就比较少了，然后在这些子序列内分别进行直接插入排序，当整个序列都基本有序时，注意只是基本有序时，再对全体记录进行一次直接插入排序。</p>
<p><strong>所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，像{2，1，3，6，4，7，5，8，9}这样可以称为基本有序了。</strong>但像{1，5，9，3，7.8，2，4，6}这样的9在第三位，2在倒数第三位就谈不上基本有序。</p>
<p>因此，我们需要采取跳跃分割的策略：<strong>将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。</strong></p>
<h3 id="9-6-2-希尔排序算法"><a href="#9-6-2-希尔排序算法" class="headerlink" title="9.6.2 希尔排序算法"></a>9.6.2 希尔排序算法</h3><p>希尔排序算法代码如下。</p>
<pre><code class="c">/* 对顺序表L作希尔排序 */
void ShellSort(SqList *L)
{
    int i, j, k = 0;
    int increment = L-&gt;length;
    do
    {
        increment = increment / 3 + 1;/* 增量序列 */
        for (i = increment + 1; i &lt;= L-&gt;length; i++)
        {
            if (L-&gt;r[i] &lt; L-&gt;r[i - increment])
            {/*  需将L-&gt;r[i]插入有序增量子表 */
                L-&gt;r[0] = L-&gt;r[i]; /*  暂存在L-&gt;r[0] */
                for (j = i - increment; j &gt; 0 &amp;&amp; L-&gt;r[0] &lt; L-&gt;r[j]; j -= increment)
                    L-&gt;r[j + increment] = L-&gt;r[j]; /*  记录后移，查找插入位置 */
                L-&gt;r[j + increment] = L-&gt;r[0]; /*  插入 */
            }
        }
    }
    while (increment &gt; 1);
}</code></pre>
<h3 id="9-6-3-希尔排序复杂度分析"><a href="#9-6-3-希尔排序复杂度分析" class="headerlink" title="9.6.3 希尔排序复杂度分析"></a>9.6.3 希尔排序复杂度分析</h3><p>通过这段代码的剖析，相信大家有些明白，希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个子序列，实现跳跃式的移动，使得排序的效率提高。</p>
<p>这里“增量”的选取就非常关键了。我们在代码中第7行，是用increment=increment/3+1；的方式选取增量的，可究竟应该选取什么样的增量才是最好，目前还是一个数学难题，迄今为止还没有人找到一种最好的增量序列。不过大量的研究表明，当增量序列为$dlta[k]=2^{t-k+1}-1(0\leq k\leq t\leq [\log_{2}(n+1)] )$时，可以获得不错的效率，其时间复杂度为$O(n^{3/2})$，要好于直接排序的O(n²)。需要注意的是，增量序列的最后一个增量值必须等于1才行。另外由于记录是跳跃式的移动，希尔排序并不是一种稳定的排序算法。</p>
<p>不管怎么说，希尔排序算法的发明，使得我们终于突破了慢速排序的时代（超越了时间复杂度为O(n²)），之后，相应的更为高效的排序算法也就相继出现了。</p>
<h2 id="9-7-堆排序"><a href="#9-7-堆排序" class="headerlink" title="9.7 堆排序"></a>9.7 堆排序</h2><p><strong>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆（例如图9-7-2左图所示）；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</strong>（例如图9-7-2右图所示）。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B9%9D%E7%AB%A0/9-7-2.JPG" srcset="/img/loading.gif" alt="9-7-2"></p>
<p>这里需要注意从堆的定义可知，根结点一定是堆中所有结点最大（小）者。较大（小）的结点靠近根结点（但也不绝对，比如右图小顶堆中60、40均小于70，但它们并没有70靠近根结点）。</p>
<p>如果按照层序遍历的方式给结点从1开始编号，则结点之间满足如下关系：<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B9%9D%E7%AB%A0/9-7-2.5.JPG" srcset="/img/loading.gif" alt="9-7-2.5"></p>
<p>这里为什么i要小于等于[n/2]呢？相信大家可能都忘记了二叉树的性质5，其实忘记也不奇怪，这个性质在我们讲完之后，就再也没有提到过它。可以说，这个性质仿佛就是在为堆准备的。性质5的第一条就说一棵完全二叉树，如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点[i/2]。那么对于有n个结点的二叉树而言，它的i值自然就是小于等于[n/2]了。性质5的第二、三条，也是在说明下标i与2i和2i+1的双亲子女关系。如果完全忘记的同学不妨去复习一下。</p>
<p>如果将图9-7-2的大顶堆和小顶堆用层序遍历存入数组，则一定满足上面的关系表达，如图9-7-3所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B9%9D%E7%AB%A0/9-7-3.JPG" srcset="/img/loading.gif" alt="9-7-3"></p>
<h3 id="9-7-1-堆排序算法"><a href="#9-7-1-堆排序算法" class="headerlink" title="9.7.1 堆排序算法"></a>9.7.1 堆排序算法</h3><p><strong>堆排序（Heap Sort）</strong>就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是，<strong>将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。</strong></p>
<p>相信大家有些明白堆排序的基本思想了，不过要实现它还需要解决两个问题：</p>
<ol>
<li>如何由一个无序序列构建成一个堆？</li>
<li>如果在输出堆顶元素后，调整剩余元素成为一个新的堆？</li>
</ol>
<p>要解释清楚它们，让我们来看代码。</p>
<pre><code class="c">/*  对顺序表L进行堆排序 */
void HeapSort(SqList *L)
{
    int i;
    for (i = L-&gt;length / 2; i &gt; 0; i--) /*  把L中的r构建成一个大根堆 */
        HeapAdjust(L, i, L-&gt;length);

    for (i = L-&gt;length; i &gt; 1; i--)
    {
        swap(L, 1, i); /* 将堆顶记录和当前未经排序子序列的最后一个记录交换 */
        HeapAdjust(L, 1, i - 1); /*  将L-&gt;r[1..i-1]重新调整为大根堆 */
    }
}</code></pre>
<p>从代码中也可以看出，整个排序过程分为两个for循环。第一个循环要完成的就是将现在的待排序序列构建成一个大顶堆。第二个循环要完成的就是逐步将每个最大值的根结点与末尾元素交换，并且再调整其成为大顶堆。</p>
<p>现在我们来看关键的 HeapAdjust（堆调整）函数是如何实现的。</p>
<pre><code class="c">/* 已知L-&gt;r[s..m]中记录的关键字除L-&gt;r[s]之外均满足堆的定义， */
/* 本函数调整L-&gt;r[s]的关键字,使L-&gt;r[s..m]成为一个大顶堆 */
void HeapAdjust(SqList *L, int s, int m)
{
    int temp, j;
    temp = L-&gt;r[s];
    for (j = 2 * s; j &lt;= m; j *= 2) /* 沿关键字较大的孩子结点向下筛选 */
    {
        if (j &lt; m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j + 1])
            ++j; /* j为关键字中较大的记录的下标 */
        if (temp &gt;= L-&gt;r[j])
            break; /* rc应插入在位置s上 */
        L-&gt;r[s] = L-&gt;r[j];
        s = j;
    }
    L-&gt;r[s] = temp; /* 插入 */
}</code></pre>
<p>HeapAdjust函数的作用其实就是构建初始堆。初始堆的构建如下：假设有n个结点，依次检查（n/2）到1的所有结点。假如序号为n/2的结点不是堆，则调整位置，将较大的元素调整到根结点（保证根结点比左右孩子都大）；假如n/2的结点已经是堆，则考虑下面序号为n/2-1的结点…直到最后序号为1的结点。此时，序号为1的结点就是最大的数了。</p>
<h3 id="9-7-2-堆排序复杂度分析"><a href="#9-7-2-堆排序复杂度分析" class="headerlink" title="9.7.2 堆排序复杂度分析"></a>9.7.2 堆排序复杂度分析</h3><p>堆排序的效率到底有多高呢？我们来分析一下。</p>
<p>它的运行时间主要是消耗在初始构建堆和在重建堆时的反复筛选上。</p>
<p>在构建堆的过程中，因为我们是完全二叉树从最下层最右边的非终端结点开始构建，将它与其孩子进行比较和若有必要的互换，对于每个非终端结点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为O（n）。</p>
<p>在正式排序时，第i次取堆顶记录重建堆需要用O(㏒i)的时间（完全二叉树的某个结点到根结点的距离为$[\log_{2}i]+1$，并且需要取n-1次堆顶记录，因此，重建堆的时间复杂度为O(n㏒n)。</p>
<p>所以总体来说，堆排序的时间复杂度为O(n㏒n)。由于堆排序对原始记录的排序状态并不敏感，因此它无论是最好、最坏和平均时间复杂度均为O(n㏒n)。这在性能上显然要远远好过于冒泡、简单选择、直接插入的O（n²）的时间复杂度了。</p>
<p>空间复杂度上，它只有一个用来交换的暂存单元，也非常的不错。不过由于记录的比较与交换是跳跃式进行，因此堆排序也是一种不稳定的排序方法。</p>
<p>另外，由于初始构建堆所需的比较次数较多，因此，它并不适合待排序序列个数较少的情况。</p>
<h2 id="9-8-归并排序"><a href="#9-8-归并排序" class="headerlink" title="9.8 归并排序"></a>9.8 归并排序</h2><h3 id="9-8-1-归并排序算法"><a href="#9-8-1-归并排序算法" class="headerlink" title="9.8.1 归并排序算法"></a>9.8.1 归并排序算法</h3><p>归并”一词的中文含义就是合并、并入的意思，而在数据结构中的定义是将两个或两个以上的有序表组合成一个新的有序表。</p>
<p><strong>归并排序（Merging Sort）</strong>就是利用归并的思想实现的排序方法。它的原理是<strong>假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[n/2]（[x]表示不小于x的最小整数）个长度为2或1的有序子序列；再两两归并，……，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2路归并排序。</strong></p>
<p>好了，有了对归并排序的初步认识后，我们来看代码。</p>
<pre><code class="c">/* 对顺序表L作归并排序 */
void MergeSort(SqList *L)
{
    MSort(L-&gt;r, L-&gt;r, 1, L-&gt;length);
}</code></pre>
<p>一句代码，别奇怪，它只是调用了另一个函数而已。为了与前面的排序算法统一，我们用了同样的参数定义SqList*L，由于我们要讲解的归并排序实现需要用到递归调用，因此我们外封装了一个函数。假设现在要对数组{50，10，90，30，70，40，80，60，20}进行排序，L.length=9，我现来看看MSort的实现。</p>
<pre><code class="c">/* 递归法 */
/* 将SR[s..t]归并排序为TR1[s..t] */
void MSort(int SR[], int TR1[], int s, int t)
{
    int m;
    int TR2[MAXSIZE + 1];
    if (s == t)
        TR1[s] = SR[s];
    else
    {
        m = (s + t) / 2;                /* 将SR[s..t]平分为SR[s..m]和SR[m+1..t] */
        MSort(SR, TR2, s, m);        /* 递归地将SR[s..m]归并为有序的TR2[s..m] */
        MSort(SR, TR2, m + 1, t);    /* 递归地将SR[m+1..t]归并为有序的TR2[m+1..t] */
        Merge(TR2, TR1, s, m, t);    /* 将TR2[s..m]和TR2[m+1..t]归并到TR1[s..t] */
    }
}</code></pre>
<p>可以说，如果对递归函数的运行方式理解比较透的话，MSort 函数还是很好理解的。我们来看看整个数据变换示意图，如图9-8-6所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B9%9D%E7%AB%A0/9-8-6.JPG" srcset="/img/loading.gif" alt="9-8-6"></p>
<p>现在我们来看看Merge函数的代码是如何实现的。</p>
<pre><code class="c">/* 将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n] */
void Merge(int SR[], int TR[], int i, int m, int n)
{
    int j, k, l;
    for (j = m + 1, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++)    /* 将SR中记录由小到大地并入TR */
    {
        if (SR[i] &lt; SR[j])
            TR[k] = SR[i++];
        else
            TR[k] = SR[j++];
    }
    if (i &lt;= m)
    {
        for (l = 0; l &lt;= m - i; l++)
            TR[k + l] = SR[i + l];        /* 将剩余的SR[i..m]复制到TR */
    }
    if (j &lt;= n)
    {
        for (l = 0; l &lt;= n - j; l++)
            TR[k + l] = SR[j + l];        /* 将剩余的SR[j..n]复制到TR */
    }
}</code></pre>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B9%9D%E7%AB%A0/9-8-7.JPG" srcset="/img/loading.gif" alt="9-8-7"><br>如图9-8-7，函数Merge的作用其实就是将SR数组的下标1和6比较，较小的归并到TR数组；然后SR的6和2比较，较小的归并到TR；然后SR的2和7比较，较小的归并到TR；…；最后SR的5和9比较，归并到TR，大功告成。</p>
<p>就这样，我们的归并排序就算是完成了一次排序工作，怎么样，和堆排序比，是不是要简单一些呢？</p>
<h3 id="9-8-2-归并排序复杂度分析"><a href="#9-8-2-归并排序复杂度分析" class="headerlink" title="9.8.2 归并排序复杂度分析"></a>9.8.2 归并排序复杂度分析</h3><p>我们来分析一下归并排序的时间复杂度，一趟归并需要将SR[1]~SR[n]中相邻的长度为h的有序序列进行两两归并。并将结果放到TR1[1]~TR1[n]中，这需要将待排序序列中的所有记录扫描一遍，因此耗费O（n）时间，而由完全二叉树的深度可知，整个归并排序需要进行$[\log_{2}n]$次，因此，总的时间复杂度为$O（n㏒n）$，而且这是归并排序算法中最好、最坏、平均的时间性能。</p>
<p>由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为$\log_{2}n$的栈空间，因此空间复杂度为$O（n+㏒n）$。</p>
<p>另外，对代码进行仔细研究，发现Merge函数中有<code>if(SR[i]&lt;SR[j])</code>语句，这就说明它需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。也就是说，归并排序是一种比较占用内存，但却效率高且稳定的算法。</p>
<h3 id="9-8-3-非递归实现归并排序"><a href="#9-8-3-非递归实现归并排序" class="headerlink" title="9.8.3 非递归实现归并排序"></a>9.8.3 非递归实现归并排序</h3><p>我们常说，“没有最好，只有更好。”归并排序大量引用了递归，尽管在代码上比较清晰，容易理解，但这会造成时间和空间上的性能损耗。我们排序追求的就是效率，有没有可能将递归转化成迭代呢？结论当然是可以的，而且改动之后，性能上进一步提高了，来看代码。</p>
<pre><code class="c">/* 对顺序表L作归并非递归排序 */
void MergeSort2(SqList *L)
{
    int* TR = (int*)malloc(L-&gt;length * sizeof(int));/* 申请额外空间 */
    int k = 1;
    while (k &lt; L-&gt;length)
    {
        MergePass(L-&gt;r, TR, k, L-&gt;length);
        k = 2 * k;/* 子序列长度加倍 */
        MergePass(TR, L-&gt;r, k, L-&gt;length);
        k = 2 * k;/* 子序列长度加倍 */
    }
}</code></pre>
<p>从代码中，我们能够感受到，非递归的迭代做法更加直截了当，从最小的序列开始归并直至完成。不需要像归并的递归算法一样，需要先拆分递归，再归并退出递归。</p>
<p>现在我们来看MergePass代码是如何实现的。</p>
<pre><code class="c">/* 非递归法 */
/* 将SR[]中相邻长度为s的子序列两两归并到TR[] */
void MergePass(int SR[], int TR[], int s, int n)
{
    int i = 1;
    int j;
    while (i &lt;= n - 2 * s + 1)
    {/* 两两归并 */
        Merge(SR, TR, i, i + s - 1, i + 2 * s - 1);
        i = i + 2 * s;
    }
    if (i &lt; n - s + 1) /* 归并最后两个序列 */
        Merge(SR, TR, i, i + s - 1, n);
    else /* 若最后只剩下单个子序列 */
        for (j = i; j &lt;= n; j++)
            TR[j] = SR[j];
}</code></pre>
<p>非递归的迭代方法，避免了递归时深度为$\log_{2}n$的栈空间，空间只是用到申请归并临时用的TR数组，因此空间复杂度为O（n），并且避免递归也在时间性能上有一定的提升，<strong>应该说，使用归并排序时，尽量考虑用非递归方法。</strong></p>
<h2 id="9-9-快速排序"><a href="#9-9-快速排序" class="headerlink" title="9.9 快速排序"></a>9.9 快速排序</h2><p>快速排序算法最早由图灵奖获得者Tony Hoare设计出来的，他在形式化方法理论以及ALGOL60编程语言的发明中都有卓越的贡献，是上世纪最伟大的计算机科学家之一。而这快速排序算法只是他众多贡献中的一个小发明而已。</p>
<p>更牛的是，我们现在要学习的这个快速排序算法，被列为20世纪十大算法之一。</p>
<p>希尔排序相当于直接插入排序的升级，它们同属于插入排序类，堆排序相当于简单选择排序的升级，它们同属于选择排序类。而快速排序其实就是我们前面认为最慢的冒泡排序的升级，它们都属于交换排序类。即它也是通过不断比较和移动交换来实现排序的，只不过它的实现，增大了记录的比较和移动的距离，将关键字较大的记录从前面直接移动到后面，关键字较小的记录从后面直接移动到前面，从而减少了总的比较次数和移动交换次数。</p>
<h3 id="9-9-1-快速排序算法"><a href="#9-9-1-快速排序算法" class="headerlink" title="9.9.1 快速排序算法"></a>9.9.1 快速排序算法</h3><p><strong>快速排序（Quick Sort）的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</strong></p>
<p>从字面上感觉不出它的好处来。假设现在要对数组{50，10，90，30，70，40，80，60，20}进行排序。我们通过代码的讲解来学习快速排序的精妙。我们来看代码。</p>
<pre><code class="c">/* 对顺序表L作快速排序 */
void QuickSort(SqList *L)
{
    QSort(L, 1, L-&gt;length);
}</code></pre>
<p>又是一句代码，和归并排序一样，由于需要递归调用，因此我们外封装了一个函数。现在我们来看QSort的实现。</p>
<pre><code class="c">/* 对顺序表L中的子序列L-&gt;r[low..high]作快速排序 */
void QSort(SqList *L, int low, int high)
{
    int pivot;
    if (low &lt; high)
    {
        pivot = Partition(L, low, high); /*  将L-&gt;r[low..high]一分为二，算出枢轴值pivot */
        QSort(L, low, pivot - 1);        /*  对低子表递归排序 */
        QSort(L, pivot + 1, high);        /*  对高子表递归排序 */
    }
}</code></pre>
<p>从这里，你应该能理解前面代码<code>“QSort（L，1，L-&gt;length）；”</code>中1和L-&gt;length代码的意思了，它就是当前待排序的序列最小下标值low和最大下标值high。</p>
<p>这一段代码的核心是<code>“pivot=Partition（L，low,high）；”</code>在执行它之前，L.r的数组值为{50，10，90，30，70，40，80，60，20}。<strong>Partition函数要做的，就是先选取当中的一个关键字</strong>，比如选择第一个关键字50，然后<strong>想尽办法将它放到一个位置，使得它左边的值都比它小，右边的值比它大，我们将这样的关键字称为枢轴（pivot）。</strong></p>
<p>在经过Partition（L，1，9）的执行之后，数组变成{20，10，40，30，50,70，80，60，90}，并返回值5给pivot，数字5表明50放置在数组下标为5的位置。此时，计算机把原来的数组变成了两个位于50左和右小数组{20，10，40，30}和{70，80，60，90}，而后的递归调用<code>“QSort（L，1，5-1）；&quot;</code>和<code>“QSort（L，5+1，9）；&quot;</code>语句，其实就是在对{20，10，40，30}和{70，80，60，90}分别进行同样的Partition操作，直到顺序全部正确为止。</p>
<p>到了这里，应该说理解起来还不算困难。下面我们就来看看快速排序最关键的Partition 函数实现。</p>
<pre><code class="c">/* 交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置 */
/* 此时在它之前(后)的记录均不大(小)于它。 */
int Partition(SqList *L, int low, int high)
{
    int pivotkey;

    pivotkey = L-&gt;r[low]; /* 用子表的第一个记录作枢轴记录 */
    while (low &lt; high) /*  从表的两端交替地向中间扫描 */
    {
        while (low &lt; high&amp;&amp;L-&gt;r[high] &gt;= pivotkey)
            high--;
        swap(L, low, high);/* 将比枢轴记录小的记录交换到低端 */
        while (low &lt; high&amp;&amp;L-&gt;r[low] &lt;= pivotkey)
            low++;
        swap(L, low, high);/* 将比枢轴记录大的记录交换到高端 */
    }
    return low; /* 返回枢轴所在位置 */
}</code></pre>
<p>Partition函数，其实就是将选取的pivotkey不断交换，将比它小的换到它的左边，比它大的换到它的右边，它也在交换中不断更改自己的位置，直到完全满足这个要求为止。</p>
<h3 id="9-9-2-快速排序复杂度分析"><a href="#9-9-2-快速排序复杂度分析" class="headerlink" title="9.9.2 快速排序复杂度分析"></a>9.9.2 快速排序复杂度分析</h3><p>我们来分析一下快速排序法的性能。快速排序的时间性能取决于快速排序递归的深度，可以用递归树来描述递归算法的执行情况。如果是{50，10，90，30，70，40，80，60，20}在快速排序过程中的递归过程。由于我们的第一个关键字是50，正好是待排序的序列的中间值，因此递归树是平衡的，此时性能也比较好。</p>
<p>在最优情况下，Partition每次都划分得很均匀，如果排序n个关键字，其递归树的深度就为$[\log_{2}n]+1$（[x]表示不大于x的最大整数），即仅需递归$\log_{2}n$次，需要时间为T（n）的话，第一次Partiation应该是需要对整个数组扫描一遍，做n次比较。然后，获得的枢轴将数组一分为二，那么各自还需要T（n/2）的时间（注意是最好情况，所以平分两半）。于是不断地划分下去，我们就有了下面的不等式推断。<br>$T(n)\leq 2T(n/2)+n , T(1)=0$<br>$T(n)\leq 2(2T(n/4)+n/2) +n=4T(n/4)+2n$<br>$T(n)\leq 4(2T(n/8)+n/4) +2n=8T(n/8)+3n$<br>$……$<br>$T(n)\leq nT(1)+(\log_{2}n)×n=O(n\log n)$</p>
<p>也就是说，在最优的情况下，快速排序算法的时间复杂度为$O(n\log n)$。</p>
<p>在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，它就是一棵斜树。此时需要执行n-1次递归调用，且第i次划分需要经过n-i次关键字的比较才能找到第i个记录，也就是枢轴的位置，因此比较次数为$\sum_{i=1}^{n-1}(n-i)=n-1+n-2+…+1=\frac{n(n-1)}{2}$，最终其时间复杂度为O(n²)。</p>
<p>平均的情况，设枢轴的关键字应该在第k的位置（1≤k≤n），那么：<br>$$T(n)=\frac{1}{n}\sum_{k=1}^{n}（T(k-1)+T(n-k)）+n=\frac{2}{n}\sum_{k=1}^{n}T(k)+n$$</p>
<p>由数学归纳法可证明，其数量级为$O(n\log n)$。</p>
<p>就空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归树的深度为$\log_{2}n$，其空间复杂度也就为$O(\log n)$，最坏情况，需要进行n-1递归调用，其空间复杂度为$O(n)$，平均情况，空间复杂度也为$O(\log n)$。</p>
<p>可惜的是，由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。</p>
<h3 id="9-9-3-快速排序优化"><a href="#9-9-3-快速排序优化" class="headerlink" title="9.9.3 快速排序优化"></a>9.9.3 快速排序优化</h3><p>刚才讲的快速排序还是有不少可以改进的地方，我们来看一些优化的方案。</p>
<ol>
<li>优化选取枢轴<br><strong>三数取中（median-of-three）法。即取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数</strong>，也可以随机选取。</li>
<li>优化不必要的交换<br>采用替换而不是交换的方式进行操作</li>
<li>优化小数组时的排序方案<br>我们增加了一个判断，当high-low不大于某个常数时（有资料认为7比较合适，也有认为50更合理，实际应用可适当调整），就用直接插入排序，这样就能保证最大化地利用两种排序的优势来完成排序工作。</li>
<li>优化递归操作<br>对QSort实施尾递归优化。</li>
</ol>
<pre><code class="c">/* 改进后快速排序******************************** */

/* 快速排序优化算法 */
int Partition1(SqList *L, int low, int high)
{
    int pivotkey;

    int m = low + (high - low) / 2; /* 计算数组中间的元素的下标 */
    if (L-&gt;r[low] &gt; L-&gt;r[high])
        swap(L, low, high);    /* 交换左端与右端数据，保证左端较小 */
    if (L-&gt;r[m] &gt; L-&gt;r[high])
        swap(L, high, m);        /* 交换中间与右端数据，保证中间较小 */
    if (L-&gt;r[m] &gt; L-&gt;r[low])
        swap(L, m, low);        /* 交换中间与左端数据，保证左端较小 */

    pivotkey = L-&gt;r[low]; /* 用子表的第一个记录作枢轴记录 */
    L-&gt;r[0] = pivotkey;  /* 将枢轴关键字备份到L-&gt;r[0] */
    while (low &lt; high) /*  从表的两端交替地向中间扫描 */
    {
        while (low &lt; high&amp;&amp;L-&gt;r[high] &gt;= pivotkey)
            high--;
        L-&gt;r[low] = L-&gt;r[high];
        while (low &lt; high&amp;&amp;L-&gt;r[low] &lt;= pivotkey)
            low++;
        L-&gt;r[high] = L-&gt;r[low];
    }
    L-&gt;r[low] = L-&gt;r[0];
    return low; /* 返回枢轴所在位置 */
}

void QSort1(SqList *L, int low, int high)
{
    int pivot;
    if ((high - low) &gt; MAX_LENGTH_INSERT_SORT)
    {
        while (low &lt; high)
        {
            pivot = Partition1(L, low, high); /*  将L-&gt;r[low..high]一分为二，算出枢轴值pivot */
            QSort1(L, low, pivot - 1);        /*  对低子表递归排序 */
            /* QSort(L,pivot+1,high);        /*  对高子表递归排序 */
            low = pivot + 1;    /* 尾递归 */
        }
    }
    else
        InsertSort(L);
}

/* 对顺序表L作快速排序 */
void QuickSort1(SqList *L)
{
    QSort1(L, 1, L-&gt;length);
}</code></pre>
<h2 id="9-10-总结回顾"><a href="#9-10-总结回顾" class="headerlink" title="9.10 总结回顾"></a>9.10 总结回顾</h2><p>本章内容只是在讲排序，我们需要对已经提到的各个排序算法进行对比来总结回顾。</p>
<p>首先我们讲了排序的定义，并提到了排序的稳定性，排序稳定对于某些特殊需求来说是至关重要的，因此在排序算法中，我们需要关注此算法的稳定性如何。</p>
<p>我们根据将排序记录是否全部被放置在内存中，将排序分为内排序与外排序两种，外排序需要在内外存之间多次交换数据才能进行。我们本章主要讲的是内排序的算法。</p>
<p>根据排序过程中借助的主要操作，我们将内排序分为：插入排序、交换排序、选择排序和归并排序四类。之后介绍的7种排序法，就分别是各种分类的代表算法。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B9%9D%E7%AB%A0/9-10-1.JPG" srcset="/img/loading.gif" alt="9-10-1"></p>
<p>事实上，目前还没有十全十美的排序算法，有优点就会有缺点，即使是快速排序法，也只是在整体性能上优越，它也存在排序不稳定、需要大量辅助空间、对少量数据排序无优势等不足。因此我们就来从多个角度来剖析一下提到的各种排序的长与短。</p>
<p>我们将7种算法的各种指标进行对比，如表9-10-1所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B9%9D%E7%AB%A0/9-10-2.JPG" srcset="/img/loading.gif" alt="9-10-2"></p>
<p>从算法的简单性来看，我们将7种算法分为两类：</p>
<ul>
<li>简单算法：冒泡、简单选择、直接插入。</li>
<li>改进算法：希尔、堆、归并、快速。</li>
</ul>
<p>从平均情况来看，显然最后3种改进算法要胜过希尔排序，并远远胜过前3种简单算法。</p>
<p>从最好情况看，反而冒泡和直接插入排序要更胜一筹，也就是说，如果你的待排序序列总是基本有序，反而不应该考虑4种复杂的改进算法。</p>
<p>从最坏情况看，堆排序与归并排序又强过快速排序以及其他简单排序。</p>
<p>从这三组时间复杂度的数据对比中，我们可以得出这样一个认识。堆排序和归并排序就像两个参加奥数考试的优等生，心理素质强，发挥稳定。而快速排序像是很情绪化的天才，心情好时表现极佳，碰到较糟糕环境会变得差强人意。但是他们如果都来比赛计算个位数的加减法，它们反而算不过成绩极普通的冒泡和直接插入。</p>
<p>从空间复杂度来说，归并排序强调要马跑得快，就得给马吃个饱。快速排序也有相应的空间要求，反而堆排序等却都是少量索取，大量付出，对空间要求是O(1)。如果执行算法的软件所处的环境非常在乎内存使用量的多少时，选择归并排序和快速排序就不是一个较好的决策了。</p>
<p>从稳定性来看，归并排序独占鳌头，我们前面也说过，对于非常在乎排序稳定性的应用中，归并排序是个好算法。</p>
<p>从待排序记录的个数上来说，待排序的个数n越小，采用简单排序方法越合适。反之，n越大，采用改进排序方法越合适。这也就是我们为什么对快速排序优化时，增加了一个阀值，低于阀值时换作直接插入排序的原因。</p>
<p>从表9-10-1的数据中，似乎简单选择排序在3种简单排序中性能最差，其实也不完全是，比如，如果记录的关键字本身信息量比较大（例如，关键字都是数十位的数字），此时表明其占用存储空间很大，这样移动记录所花费的时间也就越多，我们给出3种简单排序算法的移动次数比较，如表9-10-2所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B9%9D%E7%AB%A0/9-10-3.JPG" srcset="/img/loading.gif" alt="9-10-3"></p>
<p>你会发现，此时简单选择排序就变得非常有优势，原因也就在于，它是通过大量比较后选择明确记录进行移动，有的放矢。因此对于数据量不是很大而记录的关键字信息量较大的排序要求，简单排序算法是占优的。另外，记录的关键字信息量大小对那四个改进算法影响不大。</p>
<p>总之，从综合各项指标来说，经过优化的快速排序是性能最好的排序算法，但是不同的场合我们也应该考虑使用不同的算法来应对它。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构第八章 查找</title>
    <url>/2020/01/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC8%E7%AB%A0%20%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><strong>查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</strong></p>
<h2 id="8-1-8-2-查找概论"><a href="#8-1-8-2-查找概论" class="headerlink" title="8.1-8.2 查找概论"></a>8.1-8.2 查找概论</h2><p>查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合。例如图8-2-1就是一个查找表。  </p>
<a id="more"></a>

<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-2-1.JPG?raw=true" srcset="/img/loading.gif" alt="8-2-1"><br>关键字（Key）是数据元素中某个数据项的值，又称为键值，用它可以标识一个数据元素。也可以标识一个记录的某个数据项（字段），我们称为关键码，如图8-2-1中①和②所示。<br>若此关键字可以唯一地标识一个记录，则称此关键字为主关键字（Primary Key）。注意这也就意味着，对不同的记录，其主关键字均不相同。主关键字所在的数据项称为主关键码，如图8-2-1中③和④所示。<br>那么对于那些可以识别多个数据元素（或记录）的关键字，我们称为次关键字（Secondary Key），如图8-2-1中⑤所示。次关键字也可以理解为是不以唯一标识一个数据元素（或记录）的关键字，它对应的数据项就是次关键码。<br>查找表按照操作方式来分有两大种：<strong>静态查找表和动态查找表</strong>。<br>静态查找表（Static Search Table）：只作查找操作的查找表。它的主要操作有：</p>
<ol>
<li>查询某个“特定的”数据元素是否在查找表中。</li>
<li>检索某个“特定的”数据元素和各种属性。</li>
</ol>
<p>动态查找表（Dynamic Search Table）：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。显然动态查找表的操作就是两个：</p>
<ol>
<li>查找时插入数据元素。</li>
<li>查找时删除数据元素。</li>
</ol>
<p>为了提高查找的效率，我们需要专门为查找操作设置数据结构，这种<strong>面向查找操作的数据结构称为查找结构</strong>。<br>从逻辑上来说，查找所基于的数据结构是集合，集合中的记录之间没有本质关系。可是要想获得较高的查找性能，我们就不能不改变数据元素之间的关系，在存储时可以将查找集合组织成表、树等结构。<br>例如，对于静态查找表来说，我们不妨应用线性表结构来组织数据，这样可以使用顺序查找算法，如果再对主关键字排序，则可以应用折半查找等技术进行高效的查找。<br>如果是需要动态查找，则会复杂一些，可以考虑二叉排序树的查找技术。  </p>
<h2 id="8-3-顺序表查找"><a href="#8-3-顺序表查找" class="headerlink" title="8.3 顺序表查找"></a>8.3 顺序表查找</h2><p><strong>顺序查找（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。</strong></p>
<h3 id="8-3-1-顺序表查找算法"><a href="#8-3-1-顺序表查找算法" class="headerlink" title="8.3.1 顺序表查找算法"></a>8.3.1 顺序表查找算法</h3><p>顺序查找的算法实现如下：</p>
<pre><code class="c">/* 无哨兵顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字 */
int Sequential_Search(int *a,int n,int key)
{
    int i;
    for(i=1;i&lt;=n;i++){
        if (a[i]==key)
            return i;
    }
    return 0;
}</code></pre>
<h3 id="8-3-2-顺序表查找优化"><a href="#8-3-2-顺序表查找优化" class="headerlink" title="8.3.2 顺序表查找优化"></a>8.3.2 顺序表查找优化</h3><p>到这里并非足够完美，因为每次循环时都需要对i是否小于等于n作判断。事实上，设置一个哨兵，就不需要每次让i与n作比较。看下面的改进后的顺序查找算法代码。  </p>
<pre><code class="c">/* 有哨兵顺序查找 */
int Sequential_Search2(int *a,int n,int key)
{
    int i;
    a[0]=key;
    i=n;
    while(a[i]!=key){
        i--;
    }
    return i;
}</code></pre>
<p>这种在查找方向的尽头放置“哨兵”免去了在查找过程中每一次比较后都要判断查找位置是否越界的小技巧，看似与原先差别不大，但在总数据较多时，效率提高很大，是非常好的编码技巧。当然，“哨兵”也不一定就一定要在数组开始，也可以在末端。<br>对于这种顺序查找算法来说，平均查找次数为（n+1）/2，所以最终时间复杂度还是O（n）。<br>很显然，顺序查找技术是有很大缺点的，n很大时，查找效率极为低下，不过优点也是有的，算法非常简单，对静态查找表的记录没有任何要求，在一些小型数据的查找时，是可以适用的。<br>另外，也正由于查找概率的不同，我们完全可以将容易查找到的记录放在前面，而不常用的记录放置在后面，效率就可以有大幅提高。  </p>
<h2 id="8-4-有序表查找"><a href="#8-4-有序表查找" class="headerlink" title="8.4 有序表查找"></a>8.4 有序表查找</h2><h3 id="8-4-1-折半查找"><a href="#8-4-1-折半查找" class="headerlink" title="8.4.1 折半查找"></a>8.4.1 折半查找</h3><p><strong>折半查找（Binary Search）技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。</strong><br>折半查找代码如下：</p>
<pre><code class="c">/* 折半查找 */
int Binary_Search(int *a,int n,int key){
    int low,high,mid;
    low=1;    /* 定义最低下标为记录首位 */
    high=n;    /* 定义最高下标为记录末位 */
    while(low&lt;=high){
        mid=(low+high)/2;    /* 折半 */
        if (key&lt;a[mid])        /* 若查找值比中值小 */
            high=mid-1;        /* 最高下标调整到中位下标小一位 */
        else if (key&gt;a[mid])/* 若查找值比中值大 */
            low=mid+1;        /* 最低下标调整到中位下标大一位 */
        else
            return mid;        /* 若相等则说明mid即为查找到的位置 */
    }
    return 0;
}</code></pre>
<p>折半算法的时间复杂度为O（㏒n），它显然远远好于顺序查找的O（n）时间复杂度。<br>不过由于折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，这样的算法已经比较好了。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。  </p>
<h3 id="8-4-2-插值查找"><a href="#8-4-2-插值查找" class="headerlink" title="8.4.2 插值查找"></a>8.4.2 插值查找</h3><p>折半查找代码的第6句，我们略微等式变换后得到：<br><code>mid=(low+high)/2=low+1/2(high-low);</code><br>我们将在折半查找算法的代码中更改一下，第6行代码如下：<br><code>mid=low+ (high-low)*(key-a[low])/(a[high]-a[low]); /* 插值 */</code><br><strong>插值查找（Interpolation Search）是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式<code>(key-a[low])/(a[high]-a[low])</code>。</strong><br>应该说，从时间复杂度来看，它也是O（㏒n），但对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多。反之，数组中如果分布类似{0，1，2，2000，2001……，999998，999999}这种极端不均匀的数据，用插值查找未必是很合适的选择。  </p>
<h3 id="8-4-3-斐波那契查找"><a href="#8-4-3-斐波那契查找" class="headerlink" title="8.4.3 斐波那契查找"></a>8.4.3 斐波那契查找</h3><p>斐波那契查找（Fibonacci Search），它是利用了黄金分割原理来实现的。<br>下面我们根据代码来看程序是如何运行的。  </p>
<pre><code class="c">/* 斐波那契查找 */
int Fibonacci_Search(int *a,int n,int key)
{
    int low,high,mid,i,k=0;
    low=1;    /* 定义最低下标为记录首位 */
    high=n;    /* 定义最高下标为记录末位 */
    while(n&gt;F[k]-1) /* 计算n位于斐波那契数列的位置 */
        k++;
    for (i=n;i&lt;F[k]-1;i++) /* 将不满的数值补全 */
        a[i]=a[n];
    while(low&lt;=high){
        mid=low+F[k-1]-1;
        if (key&lt;a[mid]){
            high=mid-1;
            k=k-1;
        }
        else if (key&gt;a[mid]){
            low=mid+1;
            k=k-2;
        }
        else{
            if (mid&lt;=n)
                return mid;        /* 若相等则说明mid即为查找到的位置 */
            else
                return n;
        }
    }
    return 0;
}</code></pre>
<p>斐波那契查找算法的核心在于：</p>
<ol>
<li>当<code>key=a[mid]</code>时，查找就成功；</li>
<li>当<code>key&lt;a[mid]</code>时，新范围是第low个到第mid-1个，此时范围个数为F[k-1]-1个；</li>
<li>当<code>key&gt;a[mid]</code>时，新范围是第m+1个到第high个，此时范围个数为F[k-2]-1个。</li>
</ol>
<p>也就是说，如果要查找的记录在右侧，则左侧的数据都不用再判断了，不断反复进行下去，对处于当中的大部分数据，其工作效率要高一些。所以尽管斐波那契查找的时间复杂也为O（㏒n），但就平均性能来说，斐波那契查找要优于折半查找。可惜如果是最坏情况，比如这里key=1，那么始终都处于左侧长半区在查找，则查找效率要低于折半查找。<br>还有比较关键的一点，折半查找是进行加法与除法运算<code>（mid=（low+high）/2）</code>，插值查找进行复杂的四则运算<code>mid=low+ (high-low)*(key-a[low])/(a[high]-a[low])</code>，而斐波那契查找只是最简单加减法运算<code>（mid=low+F[k-1]-1）</code>，在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率。<br>应该说，三种有序表的查找本质上是分隔点的选择不同，各有优劣，实际开发时可根据数据的特点综合考虑再做出选择。  </p>
<h2 id="8-5-线性索引查找"><a href="#8-5-线性索引查找" class="headerlink" title="8.5 线性索引查找"></a>8.5 线性索引查找</h2><p>数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构。<strong>索引就是把一个关键字与它对应的记录相关联的过程</strong>，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。<br>索引按照结构可以分为线性索引、树形索引和多级索引。我们这里就只介绍线性索引技术。<strong>所谓线性索引就是将索引项集合组织为线性结构，也称为索引表</strong>。我们重点介绍三种线性索引：稠密索引、分块索引和倒排索引。  </p>
<h3 id="8-5-1-稠密索引"><a href="#8-5-1-稠密索引" class="headerlink" title="8.5.1 稠密索引"></a>8.5.1 稠密索引</h3><p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项。，如图8-5-2所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-5-2.JPG?raw=true" srcset="/img/loading.gif" alt="8-5-2"><br>对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。  </p>
<h3 id="8-5-2-分块索引"><a href="#8-5-2-分块索引" class="headerlink" title="8.5.2 分块索引"></a>8.5.2 分块索引</h3><p>稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大。为了减少索引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。  </p>
<p><strong>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：</strong></p>
<ul>
<li><strong>块内无序</strong>，即每一块内的记录不要求有序。当然，你如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间的代价，因此通常我们不要求块内有序。</li>
<li><strong>块间有序</strong>，例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字……因为只有块间有序，才有可能在查找时带来效率。  </li>
</ul>
<p>对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。  </p>
<p>如图8-5-4所示，我们定义的分块索引的索引项结构分三个数据项：</p>
<ul>
<li>最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大；</li>
<li>存储了块中的记录个数，以便于循环时使用；</li>
<li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</li>
</ul>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-5-4.JPG?raw=true" srcset="/img/loading.gif" alt="8-5-4">  </p>
<p>在分块索引表中查找，就是分两步进行：</p>
<ol>
<li>在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的，因此很容易利用折半、插值等算法得到结果。例如，在图8-5-4的数据集中查找62，我们可以很快可以从左上角的索引表中由<code>57&lt;62&lt;96</code>得到62在第三个块中。</li>
<li>根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查找。</li>
</ol>
<p>分块索引查找的平均查找长度为：（√n）+1。<br>可见，分块索引的效率比之顺序查找的O（n）是高了不少，不过显然它与折半查找的O（㏒n）相比还有不小的差距。因此在确定所在块的过程中，由于块间有序，所以可以应用折半、插值等手段来提高效率。<br>总的来说，分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于<strong>数据库表查找</strong>等技术的应用当中。  </p>
<h3 id="8-5-3-倒排索引"><a href="#8-5-3-倒排索引" class="headerlink" title="8.5.3 倒排索引"></a>8.5.3 倒排索引</h3><p>搜索引擎常用的最简单的，也算是最基础的搜索技术——倒排索引。<br>比如不同的文章，将所有单词整理出一张单词表，并排序，出现该单词的则标记为后面的文章编号。</p>
<p>索引项的通用结构是：</p>
<ul>
<li>次关键码，例如“英文单词”；</li>
<li>记录号表，例如“文章编号”。</li>
</ul>
<p><strong>其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。这样的索引方法就是倒排索引（inverted index）。</strong>倒排索引源于实际应用中需要根据属性（或字段、次关键码）的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引。<br>倒排索引的优点显然就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果。但它的缺点是这个记录号不定长，比如上例有7个单词的文章编号只有一个，而“book”、“friend”、“good”有两个文章编号，若是对多篇文章所有单词建立倒排索引，那每个单词都将对应相当多的文章编号，维护比较困难，插入和删除操作都需要作相应的处理。  </p>
<h2 id="8-6-二叉排序树"><a href="#8-6-二叉排序树" class="headerlink" title="8.6 二叉排序树"></a>8.6 二叉排序树</h2><p>二叉排序树（Binary Sort Tree），又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树。</li>
</ul>
<p>这样我们就得到了一棵二叉树，并且当我们对它进行中序遍历时，就可以得到一个有序的序列，所以我们通常称它为二叉排序树。  </p>
<h3 id="8-6-1-二叉排序树查找操作"><a href="#8-6-1-二叉排序树查找操作" class="headerlink" title="8.6.1 二叉排序树查找操作"></a>8.6.1 二叉排序树查找操作</h3><p>首先我们提供一个二叉树的结构。  </p>
<pre><code class="c">/* 二叉树的二叉链表结点结构定义 */
typedef  struct BiTNode    /* 结点结构 */
{
    int data;    /* 结点数据 */
    struct BiTNode *lchild, *rchild;    /* 左右孩子指针 */
} BiTNode, *BiTree;</code></pre>
<p>然后我们来看看二叉排序树的查找是如何实现的。  </p>
<pre><code class="c">/* 递归查找二叉排序树T中是否存在key, */
/* 指针f指向T的双亲，其初始调用值为NULL */
/* 若查找成功，则指针p指向该数据元素结点，并返回TRUE */
/* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE */
Status SearchBST(BiTree T, int key, BiTree f, BiTree *p)
{
    if (!T)    /*  查找不成功 */
    {
        *p = f;
        return FALSE;
    }
    else if (key == T-&gt;data) /*  查找成功 */
    {
        *p = T;
        return TRUE;
    }
    else if (key &lt; T-&gt;data)
        return SearchBST(T-&gt;lchild, key, T, p);  /*  在左子树中继续查找 */
    else
        return SearchBST(T-&gt;rchild, key, T, p);  /*  在右子树中继续查找 */
}</code></pre>
<h3 id="8-6-2-二叉排序树插入操作"><a href="#8-6-2-二叉排序树插入操作" class="headerlink" title="8.6.2 二叉排序树插入操作"></a>8.6.2 二叉排序树插入操作</h3><p>有了二叉排序树的查找函数，那么所谓的二叉排序树的插入，其实也就是将关键字放到树中的合适位置而已，来看代码。  </p>
<pre><code class="c">/*  当二叉排序树T中不存在关键字等于key的数据元素时， */
/*  插入key并返回TRUE，否则返回FALSE */
Status InsertBST(BiTree *T, int key)
{
    BiTree p, s;
    if (!SearchBST(*T, key, NULL, &amp;p)) /* 查找不成功 */
    {
        s = (BiTree)malloc(sizeof(BiTNode));
        s-&gt;data = key;
        s-&gt;lchild = s-&gt;rchild = NULL;
        if (!p) /* 此时因为已经查找过了，所有p指向最后查找的根结点 */
            *T = s;            /*  插入s为新的根结点 */
        else if (key &lt; p-&gt;data)
            p-&gt;lchild = s;    /*  插入s为左孩子 */
        else
            p-&gt;rchild = s;  /*  插入s为右孩子 */
        return TRUE;
    }
    else
        return FALSE;  /*  树中已有关键字相同的结点，不再插入 */
}</code></pre>
<p>有了二叉排序树的插入代码，我们要实现二叉排序树的构建就非常容易了。  </p>
<pre><code class="c">int i;
    int a[10] = { 62,88,58,47,35,73,51,99,37,93 };
    BiTree T = NULL;
    for (i = 0; i &lt; 10; i++)
        InsertBST(&amp;T, a[i]);</code></pre>
<h3 id="8-6-3-二叉排序树删除操作"><a href="#8-6-3-二叉排序树删除操作" class="headerlink" title="8.6.3 二叉排序树删除操作"></a>8.6.3 二叉排序树删除操作</h3><p>对于要删除的结点只有左子树或只有右子树的情况，相对也比较好解决。那就是结点删除后，将它的左子树或右子树整个移动到删除结点的位置即可，可以理解为独子继承父业。最终，整个结构还是一个二叉排序树。<br>但是对于要删除的结点既有左子树又有右子树的情况怎么办呢？<br>比较好的办法就是，找到需要删除的结点p的直接前驱（或直接后继）s，用s来替换结点p，然后再删除此结点s。  </p>
<p>根据我们对删除结点三种情况的分析：</p>
<ul>
<li>叶子结点；</li>
<li>仅有左或右子树的结点；</li>
<li>左右子树都有的结点。</li>
</ul>
<p>我们来看代码，下面这个算法是递归方式对二叉排序树T查找key，查找到时删除。  </p>
<pre><code class="c">/* 若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点, */
/* 并返回TRUE；否则返回FALSE。 */
Status DeleteBST(BiTree *T, int key)
{
    if (!*T) /* 不存在关键字等于key的数据元素 */
        return FALSE;
    else
    {
        if (key == (*T)-&gt;data) /* 找到关键字等于key的数据元素 */
            return Delete(T);
        else if (key &lt; (*T)-&gt;data)
            return DeleteBST(&amp;(*T)-&gt;lchild, key);
        else
            return DeleteBST(&amp;(*T)-&gt;rchild, key);
    }
}</code></pre>
<p>这段代码和前面的二叉排序树查找几乎完全相同，唯一的区别就在于第8行，此时执行的是Delete方法，对当前结点进行删除操作。我们来看Delete的代码。  </p>
<pre><code class="c">/* 从二叉排序树中删除结点p，并重接它的左或右子树。 */
Status Delete(BiTree *p)
{
    BiTree q, s;//q、s为临时结点
    if ((*p)-&gt;rchild == NULL) /* 右子树空则只需重接它的左子树(待删结点是叶子也走此分支) */
    {
        q = *p; *p = (*p)-&gt;lchild; free(q);
    }
    else if ((*p)-&gt;lchild == NULL) /* 只需重接它的右子树 */
    {
        q = *p; *p = (*p)-&gt;rchild; free(q);
    }
    else /* 左右子树均不空 */
    {
        q = *p; s = (*p)-&gt;lchild;
        while (s-&gt;rchild) /* 转左，然后向右到尽头（找待删结点NULL的前驱） */
        {//根结点*p的左子树中最右的叶结点为直接前驱
            q = s;
            s = s-&gt;rchild;
        }
        (*p)-&gt;data = s-&gt;data; /*  s指向被删结点的直接前驱（将被删结点前驱的值取代被删结点的值） */
        if (q != *p)
            q-&gt;rchild = s-&gt;lchild; /*  重接q的右子树 */
        else
            q-&gt;lchild = s-&gt;lchild; /*  重接q的左子树 */
        free(s);
    }
    return TRUE;
}</code></pre>
<p>从这段代码也可以看出，我们其实是在找删除结点的前驱结点替换的方法，对于用后继结点来替换，方法上是一样的。  </p>
<h3 id="8-6-4-二叉排序树总结"><a href="#8-6-4-二叉排序树总结" class="headerlink" title="8.6.4 二叉排序树总结"></a>8.6.4 二叉排序树总结</h3><p>总之，二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可。插入删除的时间性能比较好。而对于二叉排序树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。极端情况，最少为1次，即根结点就是要找的结点，最多也不会超过树的深度。也就是说，二叉排序树的查找性能取决于二叉排序树的形状。可问题就在于，二叉排序树的形状是不确定的。<br>如果，数组元素的次序是从小到大有序，则二叉排序树就成了极端的右斜树，查找时间复杂度为O（n），等同于顺序查找。<br>因此，如果我们希望对一个集合按二叉排序树查找，最好是把它构建成一棵平衡的二叉排序树。即其深度与完全二叉树相同，那么查找的时间复杂就为O（㏒n），近似于折半查找。  </p>
<h2 id="8-7-平衡二叉树（AVL树）"><a href="#8-7-平衡二叉树（AVL树）" class="headerlink" title="8.7 平衡二叉树（AVL树）"></a>8.7 平衡二叉树（AVL树）</h2><p><strong>平衡二叉树（Self-Balancing Binary Search Tree 或Height-Balanced Binary Search Tree），是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1</strong>。<br>从平衡二叉树的英文名字，你也可以体会到，它是<strong>一种高度平衡的二叉排序树。</strong>那什么叫做高度平衡呢？意思是说，要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。我们<strong>将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF（Balance Factor）</strong>，那么平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。<br><strong>距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为最小不平衡子树。</strong>  </p>
<h3 id="8-7-1-平衡二叉树实现原理"><a href="#8-7-1-平衡二叉树实现原理" class="headerlink" title="8.7.1 平衡二叉树实现原理"></a>8.7.1 平衡二叉树实现原理</h3><p>平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。<br>所谓的平衡二叉树，其实就是在二叉排序树创建过程中保证它的平衡性，一旦发现有不平衡的情况，马上处理，这样就不会造成不可收拾的情况出现。通过刚才这个例子，你会发现，<strong>当最小不平衡子树根结点的平衡因子BF是大于1时，就右旋，小于-1时就左旋。当插入结点后，最小不平衡子树的BF与它的子树的BF符号相反时，就需要对结点先进行一次旋转以使得符号相同后，再反向旋转一次才能够完成平衡操作。</strong>  </p>
<h3 id="8-7-2-平衡二叉树实现算法"><a href="#8-7-2-平衡二叉树实现算法" class="headerlink" title="8.7.2 平衡二叉树实现算法"></a>8.7.2 平衡二叉树实现算法</h3><p>首先是需要改进二叉排序树的结点结构，增加一个bf，用来存储平衡因子。  </p>
<pre><code class="c">/* 二叉树的二叉链表结点结构定义 */
typedef  struct BiTNode    /* 结点结构 */
{
    int data;    /* 结点数据 */
    int bf; /*  结点的平衡因子 */
    struct BiTNode *lchild, *rchild;    /* 左右孩子指针 */
} BiTNode, *BiTree;</code></pre>
<p>然后，对于右旋操作，我们的代码如下。  </p>
<pre><code class="c">/* 对以p为根的二叉排序树作右旋处理， */
/* 处理之后p指向新的树根结点，即旋转处理之前的左子树的根结点 */
void R_Rotate(BiTree *P)
{
    BiTree L;
    L = (*P)-&gt;lchild; /*  L指向P的左子树根结点 */
    (*P)-&gt;lchild = L-&gt;rchild; /*  L的右子树挂接为P的左子树 */
    L-&gt;rchild = (*P);
    *P = L; /*  P指向新的根结点 */
}</code></pre>
<p>此函数代码的意思是说，当传入一个二叉排序树P，将它的左孩子结点定义为L，将L的右子树变成P的左子树，再将P改成L的右子树，最后将L替换P成为根结点。这样就完成了一次右旋操作，如图8-7-9所示。图中三角形代表子树，N代表新增结点。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-7-9.JPG?raw=true" srcset="/img/loading.gif" alt="8-7-9">  </p>
<p>左旋操作代码如下。  </p>
<pre><code class="c">/* 对以P为根的二叉排序树作左旋处理， */
/* 处理之后P指向新的树根结点，即旋转处理之前的右子树的根结点0  */
void L_Rotate(BiTree *P)
{
    BiTree R;
    R = (*P)-&gt;rchild; /*  R指向P的右子树根结点 */
    (*P)-&gt;rchild = R-&gt;lchild; /* R的左子树挂接为P的右子树 */
    R-&gt;lchild = (*P);
    *P = R; /*  P指向新的根结点 */
}</code></pre>
<p>这段代码与右旋代码是对称的，在此不做解释了。<br>现在我们来看左平衡旋转处理的函数代码。  </p>
<pre><code class="c">#define LH +1 /*  左高 */
#define EH 0  /*  等高 */
#define RH -1 /*  右高 */

/*  对以指针T所指结点为根的二叉树作左平衡旋转处理 */
/*  本算法结束时，指针T指向新的根结点 */
void LeftBalance(BiTree *T)
{
    BiTree L, Lr;
    L = (*T)-&gt;lchild; /*  L指向T的左子树根结点 */
    switch (L-&gt;bf)
    { /*  检查T的左子树的平衡度，并作相应平衡处理 */
    case LH: /*  新结点插入在T的左孩子的左子树上，要作单右旋处理 */
        (*T)-&gt;bf = L-&gt;bf = EH;
        R_Rotate(T);
        break;
    case RH: /*  新结点插入在T的左孩子的右子树上，要作双旋处理 */
        Lr = L-&gt;rchild; /*  Lr指向T的左孩子的右子树根 */
        switch (Lr-&gt;bf)
        { /*  修改T及其左孩子的平衡因子 */
        case LH: (*T)-&gt;bf = RH;
            L-&gt;bf = EH;
            break;
        case EH: (*T)-&gt;bf = L-&gt;bf = EH;
            break;
        case RH:
            (*T)-&gt;bf = EH;
            L-&gt;bf = LH;
            break;
        }
        Lr-&gt;bf = EH;
        L_Rotate(&amp;(*T)-&gt;lchild); /*  对T的左子树作左旋平衡处理 */
        R_Rotate(T); /*  对T作右旋平衡处理 */
    }
}</code></pre>
<p>首先，我们定义了三个常数变量，分别代表1、0、-1。</p>
<ol>
<li>函数被调用，传入一个需调整平衡性的子树T。由于LeftBalance 函数被调用时，其实是已经确认当前子树是不平衡状态，且左子树的高度大于右子树的高度。换句话说，此时T的根结点应该是平衡因子BF的值大于1的数。</li>
<li>第4行，我们将T的左孩子赋值给L。</li>
<li>第5~27行是分支判断。</li>
<li>当L的平衡因子为LH，即为1时，表明它与根结点的BF值符号相同，因此，第8行，将它们的BF值都改为0，并且第9行，进行右旋操作。操作的方式如图8-7-9所示。</li>
<li>当L的平衡因子为RH，即为-1时，表明它与根结点的BF值符号相反，此时需要做双旋处理。第13~22行，针对L的右孩子Lr的BF作判断，修改根结点T和L的BF值。第24行将当前Lr的BF改为0。</li>
<li>第25行，对根结点的左子树进行左旋，如图8-7-10第二图所示。</li>
<li>第26行，对根结点进行右旋，如图8-7-10的第三图所示，完成平衡操作。</li>
</ol>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-7-10.JPG?raw=true" srcset="/img/loading.gif" alt="8-7-10">  </p>
<p>同样的，右平衡旋转处理的函数代码非常类似。  </p>
<pre><code class="c">/*  对以指针T所指结点为根的二叉树作右平衡旋转处理， */
/*  本算法结束时，指针T指向新的根结点 */
void RightBalance(BiTree *T)
{
    BiTree R, Rl;
    R = (*T)-&gt;rchild; /*  R指向T的右子树根结点 */
    switch (R-&gt;bf)
    { /*  检查T的右子树的平衡度，并作相应平衡处理 */
    case RH: /*  新结点插入在T的右孩子的右子树上，要作单左旋处理 */
        (*T)-&gt;bf = R-&gt;bf = EH;
        L_Rotate(T);
        break;
    case LH: /*  新结点插入在T的右孩子的左子树上，要作双旋处理 */
        Rl = R-&gt;lchild; /*  Rl指向T的右孩子的左子树根 */
        switch (Rl-&gt;bf)
        { /*  修改T及其右孩子的平衡因子 */
        case RH:
            (*T)-&gt;bf = LH; R-&gt;bf = EH; break;
        case EH:
            (*T)-&gt;bf = R-&gt;bf = EH; break;
        case LH:
            (*T)-&gt;bf = EH; R-&gt;bf = RH; break;
        }
        Rl-&gt;bf = EH;
        R_Rotate(&amp;(*T)-&gt;rchild); /*  对T的右子树作右旋平衡处理 */
        L_Rotate(T); /*  对T作左旋平衡处理 */
    }
}</code></pre>
<p>有了这些准备，我们的主函数才算是正式登场了。  </p>
<pre><code class="c">/*  若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个 */
/*  数据元素为e的新结点，并返回1，否则返回0。若因插入而使二叉排序树 */
/*  失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否。 */
Status InsertAVL(BiTree *T, int e, Status *taller)
{
    if (!*T)
    { /*  插入新结点，树“长高”，置taller为TRUE */
        *T = (BiTree)malloc(sizeof(BiTNode));
        (*T)-&gt;data = e; (*T)-&gt;lchild = (*T)-&gt;rchild = NULL; (*T)-&gt;bf = EH;
        *taller = TRUE;
    }
    else
    {
        if (e == (*T)-&gt;data)
        { /*  树中已存在和e有相同关键字的结点则不再插入 */
            *taller = FALSE; return FALSE;
        }
        if (e &lt; (*T)-&gt;data)
        { /*  应继续在T的左子树中进行搜索 */
            if (!InsertAVL(&amp;(*T)-&gt;lchild, e, taller)) /*  未插入 */
                return FALSE;
            if (*taller) /*   已插入到T的左子树中且左子树“长高” */
                switch ((*T)-&gt;bf) /*  检查T的平衡度 */
                {
                case LH: /*  原本左子树比右子树高，需要作左平衡处理 */
                    LeftBalance(T);    *taller = FALSE; break;
                case EH: /*  原本左、右子树等高，现因左子树增高而使树增高 */
                    (*T)-&gt;bf = LH; *taller = TRUE; break;
                case RH: /*  原本右子树比左子树高，现左、右子树等高 */
                    (*T)-&gt;bf = EH; *taller = FALSE; break;
                }
        }
        else
        { /*  应继续在T的右子树中进行搜索 */
            if (!InsertAVL(&amp;(*T)-&gt;rchild, e, taller)) /*  未插入 */
                return FALSE;
            if (*taller) /*  已插入到T的右子树且右子树“长高” */
                switch ((*T)-&gt;bf) /*  检查T的平衡度 */
                {
                case LH: /*  原本左子树比右子树高，现左、右子树等高 */
                    (*T)-&gt;bf = EH; *taller = FALSE;    break;
                case EH: /*  原本左、右子树等高，现因右子树增高而使树增高  */
                    (*T)-&gt;bf = RH; *taller = TRUE; break;
                case RH: /*  原本右子树比左子树高，需要作右平衡处理 */
                    RightBalance(T); *taller = FALSE; break;
                }
        }
    }
    return TRUE;
}</code></pre>
<p>不容易，终于讲完了，本算法代码很长，是有些复杂，编程中容易在很多细节上出错，要想真正掌握它，需要同学们自己多练习。不过其思想还是不难理解的，总之就是把不平衡消灭在最早时刻。<br>如果我们需要查找的集合本身没有顺序，在频繁查找的同时也需要经常的插入和删除操作，显然我们需要构建一棵二叉排序树，但是不平衡的二叉排序树，查找效率是非常低的，因此我们需要在构建时，就让这棵二叉排序树是平衡二叉树，此时我们的查找时间复杂度就为O（㏒n），而插入和删除也为O（㏒n）。这显然是比较理想的一种动态查找表算法。  </p>
<h2 id="8-8-多路查找树（B树）"><a href="#8-8-多路查找树（B树）" class="headerlink" title="8.8 多路查找树（B树）"></a>8.8 多路查找树（B树）</h2><p><strong>多路查找树（muitl-way search tree），其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素</strong>。<br>在这里，每一个结点可以存储多少个元素，以及它的孩子数的多少是非常关键的。为此，我们讲解它的4种特殊形式：2-3树、2-3-4树、B树和B+树。  </p>
<h3 id="8-8-1-2-3树"><a href="#8-8-1-2-3树" class="headerlink" title="8.8.1 2-3树"></a>8.8.1 2-3树</h3><p><strong>2-3树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为3结点）。</strong><br><strong>一个2结点包含一个元素和两个孩子（或没有孩子）</strong>，且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。不过，与二叉排序树不同的是，这个2结点要么没有孩子，要有就有两个，不能只有一个孩子。<br><strong>一个3结点包含一小一大两个元素和三个孩子（或没有孩子）</strong>，一个3结点要么没有孩子，要么具有3个孩子。如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。<br>并且2-3树中所有的叶子都在同一层次上。如图8-8-2所示，就是一棵有效的2-3树。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-8-2.JPG?raw=true" srcset="/img/loading.gif" alt="8-8-2">  </p>
<p>一 2-3树的插入实现<br>对于2-3树的插入来说，与二叉排序树相同，插入操作一定是发生在叶子结点上。可与二叉排序树不同的是，2-3树插入一个元素的过程有可能会对该树的其余结构产生连锁反应。<br>2-3树插入可分为三种情况。  </p>
<ol>
<li>对于空树，插入一个2结点即可，这很容易理解。</li>
<li>插入结点到一个2结点的叶子上。应该说，由于其本身就只有一个元素，所以只需要将其升级为3结点即可。如图8-8-3所示。我们希望从左图的2-3树中插入元素3，根据遍历可知，3比8小、比4小，于是就只能考虑插入到叶子结点1所在的位置，因此很自然的想法就是将此结点变成一个3结点，即右图这样完成插入操作。当然，要视插入的元素与当前叶子结点的元素比较大小后，决定谁在左谁在右。例如，若插入的是0，则此结点就是“0”在左“1”在右了。</li>
<li>要往3结点中插入一个新元素。因为3结点本身已经是2-3树的结点最大容量（已经有两个元素），因此就需要将其拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-8-3.JPG?raw=true" srcset="/img/loading.gif" alt="8-8-3">  </li>
</ol>
<p>二 2-3树的删除实现<br>删除情况较多，具体请见大话数据结构P348。  </p>
<p>当然，如果对2-3树的插入和删除等所有的情况进行讲解，既占篇幅，又没必要，总的来说它是有规律的，需要你们在上面的这些例子中多去体会后掌握。  </p>
<h3 id="8-8-2-2-3-4树"><a href="#8-8-2-2-3-4树" class="headerlink" title="8.8.2 2-3-4树"></a>8.8.2 2-3-4树</h3><p>有了2-3树的讲解，2-3-4树就很好理解了，它其实就是2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素。<br>由于2-3-4树和2-3树是类似的，我们这里就简单介绍一下，如果我们构建一个数组为{7，1，2，5，6，9，8，4，3}的2-3-4树的过程，如图8-8-15所示。图1是在分别插入7、1、2时的结果图，因为3个元素满足2-3-4树的单个4结点定义，因此此时不需要拆分，接着插入元素5，因为已经超过了4结点的定义，因此拆分为图2的形状。之后的图其实就是在元素不断插入时最后形成了图7的2-3-4树。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-8-15.JPG?raw=true" srcset="/img/loading.gif" alt="8-8-15"><br>图8-8-16是对一个2-3-4树的删除结点的演变过程，删除顺序是1、6、3、4、5、2、9。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-8-16.JPG?raw=true" srcset="/img/loading.gif" alt="8-8-16">  </p>
<h3 id="8-8-3-B树"><a href="#8-8-3-B树" class="headerlink" title="8.8.3 B树"></a>8.8.3 B树</h3><p><strong>B树（B-tree）是一种平衡的多路查找树</strong>，2-3树和2-3-4树都是B树的特例。<strong>结点最大的孩子数目称为B树的阶（order）</strong>，因此，2-3树是3阶B树，2-3-4树是4阶B树。<br>一个m阶的B树具有如下属性：<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-8-16.5.JPG?raw=true" srcset="/img/loading.gif" alt="8-8-16.5"><br>在B树上查找的过程是一个顺指针查找结点和在结点中查找关键字的交叉过程。<br>比方说，我们要查找数字7，首先从外存（比如硬盘中）读取得到根结点3、5、8三个元素，发现7不在当中，但在5和8之间，因此就通过Az再读取外存的6、7结点，查找到所要的元素。<br>至于B树的插入和删除，方式是与2-3树和2-3-4树相类似的，只不过阶数可能会很大而已。<br>我们在本节的开头提到，如果内存与外存交换数据次数频繁，会造成了时间效率上的瓶颈，那么B树结构怎么就可以做到减少次数呢？<br>我们的外存，比如硬盘，是将所有的信息分割成相等大小的页面，每次硬盘读写的都是一个或多个完整的页面，对于一个硬盘来说，一页的长度可能是211到214个字节。<br>在一个典型的B树应用中，要处理的硬盘数据量很大，因此无法一次全部装入内存。因此我们会对B树进行调整，使得B树的阶数（或结点的元素）与硬盘存储的页面大小相匹配。比如说一棵B树的阶为1001（即1个结点包含1000个关键字），高度为2，它可以储存超过10亿个关键字，我们只要让根结点持久地保留在内存中，那么在这棵树上，寻找某一个关键字至多需要两次硬盘的读取即可。<br>通过这种方式，在有限内存的情况下，每一次磁盘的访问我们都可以获得最大数量的数据。由于B树每结点可以具有比二叉树多得多的元素，所以与二叉树的操作不同，它们减少了必须访问结点和数据块的数量，从而提高了性能。可以说，B树的数据结构就是为内外存的数据交互准备的。<br>那么对于n个关键字的m阶B树，最坏情况是要查找几次呢？我们来作一分析。<br>也就是说，在含有n个关键字的B树上查找时，从根结点到关键字结点的路径上涉及的结点数不超过$\log_\frac m2\left(\frac{n+1}2\right)+1$。  </p>
<h3 id="8-8-4-B-树"><a href="#8-8-4-B-树" class="headerlink" title="8.8.4 B+树"></a>8.8.4 B+树</h3><p>B+树是应文件系统所需而出的一种B树的变形树，注意严格意义上讲，它其实已经不是第六章定义的树了。在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。<br>例如图8-8-19所示，就是一棵B+树的示意，灰色关键字即是根结点中的关键字在叶子结点再次列出，并且所有叶子结点都链接在一起。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-8-19.JPG?raw=true" srcset="/img/loading.gif" alt="8-8-19"><br>一棵m阶的B+树和m阶的B树的差异在于：</p>
<ul>
<li>有n棵子树的结点中包含有n个关键字；</li>
<li>所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接；</li>
<li>所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字。</li>
</ul>
<p>这样的数据结构最大的好处就在于，如果是要随机查找，我们就从根结点出发，与B树的查找方式相同，只不过即使在分支结点找到了待查找的关键字，它也只是用来索引的，不能提供实际记录的访问，还是需要到达包含此关键字的终端结点。如果我们是需要从最小关键字进行从小到大的顺序查找，我们就可以从最左侧的叶子结点出发，不经过分支结点，而是延着指向下一叶子的指针就可遍历所有的关键字。<br>B+树的结构特别适合带有范围的查找。比如查找我们学校18~22岁的学生人数，我们可以通过从根结点出发找到第一个18岁的学生，然后再在叶子结点按顺序查找到符合范围的所有记录。<br>B+树的插入、删除过程也都与B树类似，只不过插入和删除的元素都是在叶子结点上进行而已。  </p>
<h2 id="8-9-散列表查找（哈希表）概述"><a href="#8-9-散列表查找（哈希表）概述" class="headerlink" title="8.9 散列表查找（哈希表）概述"></a>8.9 散列表查找（哈希表）概述</h2><p>能否直接通过关键字key得到要查找的记录内存存储位置呢,而不是挨个查找下标，再通过顺序存储的存储位置计算内存地址？  </p>
<h3 id="8-9-1-散列表查找定义"><a href="#8-9-1-散列表查找定义" class="headerlink" title="8.9.1 散列表查找定义"></a>8.9.1 散列表查找定义</h3><p>我们只要通过某个函数f，使得<br><code>存储位置=f（关键字）</code><br>那样我们可以通过查找关键字不需要比较就可获得需要的记录的存储位置。这就是一种新的存储技术——散列技术。<br><strong>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f（key）</strong>。查找时，根据这个确定的对应关系找到给定值key的映射f（key），若查找集合中存在这个记录，则必定在f（key）的位置上。<br>这里我们把这种对应<strong>关系f称为散列函数，又称为哈希（Hash）函数</strong>。按这个思想，<strong>采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）</strong>。那么关键字对应的记录存储位置我们称为散列地址。  </p>
<h3 id="8-9-2-散列表查找步骤"><a href="#8-9-2-散列表查找步骤" class="headerlink" title="8.9.2 散列表查找步骤"></a>8.9.2 散列表查找步骤</h3><p>整个散列过程其实就是两步:</p>
<ol>
<li>在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。不管什么记录，我们都需要用同一个散列函数计算出地址再存储。</li>
<li>当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。说起来很简单，在哪存的，上哪去找，由于存取用的是同一个散列函数，因此结果当然也是相同的。  </li>
</ol>
<p><strong>散列技术既是一种存储方法，也是一种查找方法。</strong>然而它与线性表、树、图等结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，可以用连线图示表示出来，而散列技术的记录之间不存在什么逻辑关系，它只与关键字有关联。因此，散列主要是面向查找的存储结构。<br><strong>散列技术最适合的求解问题是查找与给定值相等的记录。</strong>对于查找来说，简化了比较过程，效率就会大大提高。但万事有利就有弊，散列技术不具备很多常规数据结构的能力。<br>比如那种同样的关键字，它能对应很多记录的情况，却不适合用散列技术；散列表也不适合范围查找，无法排序，无法计算最大值、最小值等结果。<br>设计一个简单、均匀、存储利用率高的散列函数是散列技术中最关键的问题。<br>另一个问题是冲突。在理想的情况下，每一个关键字，通过散列函数计算出来的地址都是不一样的，可现实中，这只是一个理想。我们时常会碰到两个关键字key1≠key2，但是却有f（key1）=f（key2），这种现象我们称为冲突（collsion），并把key1和key2称为这个散列函数的同义词（synonym）。出现了冲突当然非常糟糕，那将造成数据查找错误。尽管我们可以通过精心设计的散列函数让冲突尽可能的少，但是不能完全避免。于是如何处理冲突就成了一个很重要的课题，这在我们后面也需要详细讲解。  </p>
<h2 id="8-10-散列函数的构造方法"><a href="#8-10-散列函数的构造方法" class="headerlink" title="8.10 散列函数的构造方法"></a>8.10 散列函数的构造方法</h2><p>那么什么才算是好的散列函数呢？<br>1.计算简单。  2.散列地址分布均匀  </p>
<h3 id="8-10-1-直接定址法"><a href="#8-10-1-直接定址法" class="headerlink" title="8.10.1 直接定址法"></a>8.10.1 直接定址法</h3><p>可以取关键字的某个线性函数值为散列地址，即<br><code>f（key）=a x key+b（a、b为常数）</code><br>这样的散列函数优点就是简单、均匀，也不会产生冲突，但问题是这需要事先知道关键字的分布情况，适合查找表较小且连续的情况。由于这样的限制，在现实应用中，此方法虽然简单，但却并不常用。  </p>
<h3 id="8-10-2-数字分析法"><a href="#8-10-2-数字分析法" class="headerlink" title="8.10.2 数字分析法"></a>8.10.2 数字分析法</h3><p>比如手机号码作为关键字，那么我们抽取手机号码后面的四位成为散列地址。<br>这里我们提到了一个关键词——抽取。抽取方法是使用关键字的一部分来计算散列存储位置的方法，这在散列函数中是常常用到的手段。<br>数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布较均匀，就可以考虑用这个方法。  </p>
<h3 id="8-10-3-平方取中法"><a href="#8-10-3-平方取中法" class="headerlink" title="8.10.3 平方取中法"></a>8.10.3 平方取中法</h3><p>这个方法计算很简单，假设关键字是1234，那么它的平方就是1522756，再抽取中间的3位就是227，用做散列地址。再比如关键字是4321，那么它的平方就是18671041，抽取中间的3位就可以是671，也可以是710，用做散列地址。平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况。  </p>
<h3 id="8-10-4-折叠法"><a href="#8-10-4-折叠法" class="headerlink" title="8.10.4 折叠法"></a>8.10.4 折叠法</h3><p>折叠法是将关键字从左到右分割成位数相等的几部分（注意最后一部分位数不够时可以短些），然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。<br>比如我们的关键字是9876543210，散列表表长为三位，我们将它分为四组，987|654|321|0，然后将它们叠加求和987+654+321+0=1962，再取后3位得到散列地址为962。<br>折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。  </p>
<h3 id="8-10-5-除留余数法"><a href="#8-10-5-除留余数法" class="headerlink" title="8.10.5 除留余数法"></a>8.10.5 除留余数法</h3><p>此方法为最常用的构造散列函数方法。对于散列表长为m的散列函数公式为：<br><code>f（key）=key mod p（p ≤ m）</code><br>mod是取模（求余数）的意思。事实上，这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。<br>很显然，本方法的关键就在于选择合适的p，p如果选得不好，就可能会容易产生同义词。<br>根据前辈们的经验，若散列表表长为m，通常p为小于或等于表长（最好接近m）的最小质数或不包含小于20质因子的合数。  </p>
<h3 id="8-10-6-随机数法"><a href="#8-10-6-随机数法" class="headerlink" title="8.10.6 随机数法"></a>8.10.6 随机数法</h3><p>选择一个随机数，取关键字的随机函数值为它的散列地址。也就是<code>f（key）=random（key）</code>。这里random是随机函数。当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。<br>总之，现实中，应该视不同的情况采用不同的散列函数。我们只能给出一些考虑的因素来提供参考：</p>
<ol>
<li>计算散列地址所需的时间。</li>
<li>关键字的长度。</li>
<li>散列表的大小。</li>
<li>关键字的分布情况。</li>
<li>记录查找的频率。</li>
</ol>
<p>综合这些因素，才能决策选择哪种散列函数更合适。  </p>
<h2 id="8-11-处理散列冲突的方法"><a href="#8-11-处理散列冲突的方法" class="headerlink" title="8.11 处理散列冲突的方法"></a>8.11 处理散列冲突的方法</h2><h3 id="8-11-1-开放定址法"><a href="#8-11-1-开放定址法" class="headerlink" title="8.11.1 开放定址法"></a>8.11.1 开放定址法</h3><p>所谓的<strong>开放定址法就是一旦发生了冲突，就代入公式去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</strong><br>公式是： <code>fi(key)=(f(key)+di) MOD m   (di=1,2,3,……,m-1)</code><br>我们把这种解决冲突的开放定址法称为线性探测法。<br>从这个例子我们也看到，我们在解决冲突的时候，还会碰到如48和37这种本来都不是同义词却需要<strong>争夺一个地址的情况，我们称这种现象为堆积</strong>。很显然，堆积的出现，使得我们需要不断处理冲突，无论是存入还是查找效率都会大大降低。<br>我们可以把di该进为(di)²，增加平方运算的目的是<strong>为了不让关键字都聚集在某一块区域。我们称这种方法为二次探测法</strong>。<br><code>fi（key）=（f（key）+di）MOD m  （di=1²，(-1)²，2²,(-2)²,…，q²，(-q)²,q≤m/2）</code><br>还有一种方法是，<strong>在冲突时，对于位移量d采用随机函数计算得到，我们称之为随机探测法。</strong><br><code>fi（key）=（f（key）+di）MOD m   （di是一个随机数列）</code>  </p>
<h3 id="8-11-2-再散列函数法"><a href="#8-11-2-再散列函数法" class="headerlink" title="8.11.2 再散列函数法"></a>8.11.2 再散列函数法</h3><p>对于我们的散列表来说，我们事先准备多个散列函数。<br>f$_i$（key）=RH$_i$（key）（i=1,2,…,k）<br>这里RH$_i$，就是不同的散列函数，你可以把我们前面说的什么除留余数、折叠、平方取中全部用上。每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一个可以把冲突解决掉。这种方法能够使得关键字不产生聚集，当然，相应地也增加了计算的时间。  </p>
<h3 id="8-11-3-链地址法"><a href="#8-11-3-链地址法" class="headerlink" title="8.11.3 链地址法"></a>8.11.3 链地址法</h3><p>将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。对于关键字集合{12，67，56，16，25，37，22，29，15，47，48，34}，我们用前面同样的12为除数，进行除留余数法，可得到如图8-11-1结构，此时，已经不存在什么冲突换址的问题，无论有多少个冲突，都只是在当前位置给单链表增加结点的问题。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-11-1.JPG?raw=true" srcset="/img/loading.gif" alt="8-11-1"><br>链地址法对于可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障。当然，这也就带来了查找时需要遍历单链表的性能损耗。  </p>
<h3 id="8-11-4-公共溢出区法"><a href="#8-11-4-公共溢出区法" class="headerlink" title="8.11.4 公共溢出区法"></a>8.11.4 公共溢出区法</h3><p>这个方法其实就更加好理解，你不是冲突吗？好吧，凡是冲突的都跟我走，我给你们这些冲突找个地儿待着。这就如同孤儿院收留所有无家可归的孩子一样，我们为所有冲突的关键字建立了一个公共的溢出区来存放。<br>就前面的例子而言，我们共有三个关键字{37，48，34}与之前的关键字位置有冲突，那么就将它们存储到溢出表中，如图8-11-2所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0/8-11-2.JPG?raw=true" srcset="/img/loading.gif" alt="8-11-2"><br>图8-11-2在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功；如果不相等，则到溢出表去进行顺序查找。如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。  </p>
<h2 id="8-12-散列表查找实现"><a href="#8-12-散列表查找实现" class="headerlink" title="8.12 散列表查找实现"></a>8.12 散列表查找实现</h2><h3 id="8-12-1-散列表查找算法实现"><a href="#8-12-1-散列表查找算法实现" class="headerlink" title="8.12.1 散列表查找算法实现"></a>8.12.1 散列表查找算法实现</h3><p>首先是需要定义一个散列表的结构以及一些相关的常数。其中HashTable 就是散列表结构。结构当中的elem为一个动态数组。  </p>
<pre><code class="c">#define SUCCESS 1
#define UNSUCCESS 0
#define HASHSIZE 12 /* 定义散列表长为数组的长度 */
#define NULLKEY -32768
typedef struct{
    int *elem; /* 数据元素存储基址，动态分配数组 */
    int count; /*  当前数据元素个数 */
}HashTable;
int m = 0; /* 散列表表长，全局变量 */</code></pre>
<p>有了结构的定义，我们可以对散列表进行初始化。  </p>
<pre><code class="c">/* 初始化散列表 */
Status InitHashTable(HashTable *H){
    int i;
    m = HASHSIZE;
    H-&gt;count = m;
    H-&gt;elem = (int *)malloc(m * sizeof(int));
    for (i = 0; i &lt; m; i++)
        H-&gt;elem[i] = NULLKEY;
    return OK;
}</code></pre>
<p>为了插入时计算地址，我们需要定义散列函数，散列函数可以根据不同情况更改算法。  </p>
<pre><code class="c">/* 散列函数 */
int Hash(int key)
{
    return key % m; /* 除留余数法 */
}</code></pre>
<p>初始化完成后，我们可以对散列表进行插入操作。假设我们插入的关键字集合就是前面的{12，67，56，16，25，37，22，29，15，47，48，34}。  </p>
<pre><code class="c">/* 插入关键字进散列表 */
void InsertHash(HashTable *H, int key)
{
    int addr = Hash(key); /* 求散列地址 */
    while (H-&gt;elem[addr] != NULLKEY) /* 如果不为空，则冲突 */
        addr = (addr + 1) % m; /* 开放定址法的线性探测 */
    H-&gt;elem[addr] = key; /* 直到有空位后插入关键字 */
}</code></pre>
<p>代码中插入关键字时，首先算出散列地址，如果当前地址不为空关键字，则说明有冲突。此时我们应用开放定址法的线性探测进行重新寻址，此处也可更改为链地址法等其他解决冲突的办法。<br>散列表存在后，我们在需要时就可以通过散列表查找要的记录。  </p>
<pre><code class="c">/* 散列表查找关键字 */
Status SearchHash(HashTable H, int key, int *addr)
{
    *addr = Hash(key);  /* 求散列地址 */
    while (H.elem[*addr] != key) /* 如果不为空，则冲突 */
    {
        *addr = (*addr + 1) % m; /* 开放定址法的线性探测 */
        if (H.elem[*addr] == NULLKEY || *addr == Hash(key)) /* 如果循环回到原点 */
            return UNSUCCESS;    /* 则说明关键字不存在 */
    }
    return SUCCESS;
}</code></pre>
<p>查找的代码与插入的代码非常类似，只需做一个不存在关键字的判断而已。  </p>
<h3 id="8-12-2-散列表查找性能分析"><a href="#8-12-2-散列表查找性能分析" class="headerlink" title="8.12.2 散列表查找性能分析"></a>8.12.2 散列表查找性能分析</h3><p>最后，我们对散列表查找的性能作一个简单分析。如果没有冲突，散列查找是我们本章介绍的所有查找中效率最高的，因为它的时间复杂度为O(1)。可惜，我说的只是“如果”，没有冲突的散列只是一种理想，在实际的应用中，冲突是不可避免的。那么散列查找的平均查找长度取决于哪些因素呢？  </p>
<ol>
<li>散列函数是否均匀<br>散列函数的好坏直接影响着出现冲突的频繁程度，不过，由于不同的散列函数对同一组随机的关键字，产生冲突的可能性是相同的，因此我们可以不考虑它对平均查找长度的影响。</li>
<li>处理冲突的方法<br>相同的关键字、相同的散列函数，但处理冲突的方法不同，会使得平均查找长度不同。比如线性探测处理冲突可能会产生堆积，显然就没有二次探测法好，而链地址法处理冲突不会产生任何堆积，因而具有更佳的平均查找性能。</li>
<li>散列表的装填因子<br>所谓的装填因子α=填入表中的记录个数/散列表长度。α标志着散列表的装满的程度。当填入表中的记录越多，α就越大，产生冲突的可能性就越大。比如我们前面的例子，如图8-11-5所示，如果你的散列表长度是12，而填入表中的记录个数为11，那么此时的装填因子α=11/12=0.9167，再填入最后一个关键字产生冲突的可能性就非常之大。也就是说，散列表的平均查找长度取决于装填因子，而不是取决于查找集合中的记录个数。  </li>
</ol>
<p>不管记录个数n有多大，我们总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围之内，此时我们散列查找的时间复杂度就真的是O(1)了。为了做到这一点，通常我们都是将散列表的空间设置得比查找集合大，此时虽然是浪费了一定的空间，但换来的是查找效率的大大提升，总的来说，还是非常值得的。  </p>
<h2 id="8-13-总结回顾"><a href="#8-13-总结回顾" class="headerlink" title="8.13 总结回顾"></a>8.13 总结回顾</h2><p>我们这一章全都是围绕一个主题“查找”来作文章的。<br>首先我们要弄清楚查找表、记录、关键字、主关键字、静态查找表、动态查找表等这些概念。<br>然后，对于顺序表查找来说，尽管很土（简单），但它却是后面很多查找的基础，注意设置“哨兵”的技巧，可以使得本已经很难提升的简单算法里还是提高了性能。<br>有序查找，我们着重讲了折半查找的思想，它在性能上比原来的顺序查找有了质的飞跃，由O（n）变成了O（㏒n）。之后我们又讲解了另外两种优秀的有序查找：插值查找和斐波那契查找，三者各有优缺点，望大家要仔细体会。<br>线性索引查找，我们讲解了稠密索引、分块索引和倒排索引。索引技术被广泛的用于文件检索、数据库和搜索引擎等技术领域，是进一步学习这些技术的基础。<br>二叉排序树是动态查找最重要的数据结构，它可以在兼顾查找性能的基础上，让插入和删除也变得效率较高。不过为了达到最优的状态，二叉排序树最好是构造成平衡的二叉树才最佳。因此我们就需要再学习关于平衡二叉树（AVL树）的数据结构，了解AVL树是如何处理平衡性的问题。这部分是本章重点，需要认真学习掌握。<br>B树这种数据结构是针对内存与外存之间的存取而专门设计的。由于内外存的查找性能更多取决于读取的次数，因此在设计中要考虑B树的平衡和层次。我们讲解时是先通过最最简单的B树（2-3树）来理解如何构建、插入、删除元素的操作，再通过2-3-4树的深化，最终来理解B树的原理。之后，我们还介绍了B+树的设计思想。<br>散列表是一种非常高效的查找数据结构，在原理上也与前面的查找不尽相同，它回避了关键字之间反复比较的烦琐，而是直接一步到位查找结果。当然，这也就带来了记录之间没有任何关联的弊端。应该说，散列表对于那种查找性能要求高，记录之间关系无要求的数据有非常好的适用性。在学习中要注意的是散列函数的选择和处理冲突的方法。  </p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>缪雪峰MySQL教程</title>
    <url>/2020/01/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/MySQL/%E7%BC%AA%E9%9B%AA%E5%B3%B0MySQL%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一：-MySQL执行外部sql脚本文件的命令"><a href="#一：-MySQL执行外部sql脚本文件的命令" class="headerlink" title="一： MySQL执行外部sql脚本文件的命令"></a>一： MySQL执行外部sql脚本文件的命令</h1><p>sql脚本是包含一到多个sql命令的sql语句，我们可以将这些sql脚本放在一个文本文件中（我们称之为“sql脚本文件”），然后通过相关的命令执行这个sql脚本文件。基本步骤如下：  </p>
<h2 id="1-1-创建包含sql命令的sql脚本文件"><a href="#1-1-创建包含sql命令的sql脚本文件" class="headerlink" title="1.1 创建包含sql命令的sql脚本文件"></a>1.1 创建包含sql命令的sql脚本文件</h2><p>文件中包含一些列的sql语句，每条语句最后以;结尾，文件内容示例如下：<br>–创建表，使用“–”进行注释</p>
<pre><code class="sql">create table 表名称
(
  Guid Varchar(38) not null primary key,  
  Title Varchar(255),

) TYPE=InnoDB;</code></pre>
<a id="more"></a>
<ul>
<li>在表A中增加字段Status<br><code>alter table A add Status TinyInt default &#39;0&#39;;</code></li>
<li>在表A上创建索引<br><code>create index XX_TaskId_1 on A(Id_);</code></li>
<li>在A表中添加一条记录<br><code>Insert into A (Id,ParentId, Name) values(1,0,&#39;名称&#39;);</code></li>
<li>添加、修改、删除数据后，有可能需要提交事务<br><code>Commit;</code></li>
</ul>
<h2 id="1-2-执行sql脚本文件"><a href="#1-2-执行sql脚本文件" class="headerlink" title="1.2 执行sql脚本文件"></a>1.2 执行sql脚本文件</h2><h3 id="1-2-1-方法一-：使用cmd命令执行-windows下，unix或linux在的其控制台下"><a href="#1-2-1-方法一-：使用cmd命令执行-windows下，unix或linux在的其控制台下" class="headerlink" title="1.2.1 方法一 ：使用cmd命令执行(windows下，unix或linux在的其控制台下)"></a>1.2.1 方法一 ：使用cmd命令执行(windows下，unix或linux在的其控制台下)</h3><p>【Mysql的bin目录】\mysql –u用户名 –p密码 –D数据库&lt;【sql脚本文件路径全名】，示例：<br><code>D:\mysql\bin\mysql –uroot –p123456 -Dtest&lt;d:\test\ss.sql</code><br>注意：<br>A、如果在sql脚本文件中使用了use 数据库，则-D数据库选项可以忽略<br>B、如果【Mysql的bin目录】中包含空格，则需要使用“”包含，如：<code>“C:\Program Files\mysql\bin\mysql” –u用户名 –p密码 –D数据库&lt;【sql脚本文件路径全名】</code></p>
<h3 id="1-2-2-方法二-：进入mysql的控制台后，使用source命令执行"><a href="#1-2-2-方法二-：进入mysql的控制台后，使用source命令执行" class="headerlink" title="1.2.2 方法二 ：进入mysql的控制台后，使用source命令执行"></a>1.2.2 方法二 ：进入mysql的控制台后，使用source命令执行</h3><p>Mysql&gt;source 【sql脚本文件的路径全名】 或 Mysql&gt;. 【sql脚本文件的路径全名】，示例：<code>source d:\test\ss.sql</code> 或者 <code>\. d:\test\ss.sql</code></p>
<h1 id="二：-关系数据库概述"><a href="#二：-关系数据库概述" class="headerlink" title="二： 关系数据库概述"></a>二： 关系数据库概述</h1><p>数据库按照数据结构来组织、存储和管理数据，实际上，数据库一共有三种模型：  </p>
<ul>
<li>层次模型</li>
<li>网状模型</li>
<li>关系模型</li>
</ul>
<p>随着时间的推移和市场竞争，最终，基于<strong>关系模型</strong>的关系数据库获得了绝对市场份额。  </p>
<h2 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h2><p>对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：  </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>INT</td>
<td>整型</td>
<td>4字节整数类型，范围约+/-21亿</td>
</tr>
<tr>
<td>BIGINT</td>
<td>长整型</td>
<td>8字节整数类型，范围约+/-922亿亿</td>
</tr>
<tr>
<td>REAL</td>
<td>浮点型</td>
<td>4字节浮点数，范围约+/-1038</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>浮点型</td>
<td>8字节浮点数，范围约+/-10308</td>
</tr>
<tr>
<td>DECIMAL(M,N)</td>
<td>高精度小数</td>
<td>由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算</td>
</tr>
<tr>
<td>CHAR(N)</td>
<td>定长字符串</td>
<td>存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串</td>
</tr>
<tr>
<td>VARCHAR(N)</td>
<td>变长字符串</td>
<td>存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串</td>
</tr>
<tr>
<td>BOOLEAN</td>
<td>布尔类型</td>
<td>存储True或者False</td>
</tr>
<tr>
<td>DATE</td>
<td>日期类型</td>
<td>存储日期，例如，2018-06-22</td>
</tr>
<tr>
<td>TIME</td>
<td>时间类型</td>
<td>存储时间，例如，12:20:59</td>
</tr>
<tr>
<td>DATETIME</td>
<td>日期和时间类型</td>
<td>存储日期+时间，例如，2018-06-22 12:20:59</td>
</tr>
</tbody></table>
<h2 id="2-2-SQL-DML-和-DDL"><a href="#2-2-SQL-DML-和-DDL" class="headerlink" title="2.2 SQL DML 和 DDL"></a>2.2 SQL DML 和 DDL</h2><p>总的来说，可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。<br>SQL (结构化查询语言)是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。<br>查询和更新指令构成了 SQL 的 DML 部分：  </p>
<ol>
<li>SELECT - 从数据库表中获取数据</li>
<li>UPDATE - 更新数据库表中的数据</li>
<li>DELETE - 从数据库表中删除数据</li>
<li>INSERT INTO - 向数据库表中插入数据</li>
</ol>
<p>SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。<br>SQL 中最重要的 DDL 语句:  </p>
<ol>
<li>CREATE DATABASE - 创建新数据库</li>
<li>ALTER DATABASE - 修改数据库</li>
<li>CREATE TABLE - 创建新表</li>
<li>ALTER TABLE - 变更（改变）数据库表</li>
<li>DROP TABLE - 删除表</li>
<li>CREATE INDEX - 创建索引（搜索键）</li>
<li>DROP INDEX - 删除索引</li>
</ol>
<h2 id="2-3-安装MySQL"><a href="#2-3-安装MySQL" class="headerlink" title="2.3 安装MySQL"></a>2.3 安装MySQL</h2><p>要在Windows或Mac上安装MySQL，首先从MySQL官方网站下载最新的MySQL Community Server版本：<br><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">MySQL官方网站</a><br>选择对应的操作系统版本，下载安装即可。在安装过程中，MySQL会自动创建一个root用户，并提示输入root口令。<br>要在Linux上安装MySQL，可以使用发行版的包管理器。例如，Debian和Ubuntu用户可以简单地通过命令<code>apt-get install mysql-server</code>安装最新的MySQL版本。  </p>
<h2 id="2-4-运行MySQL"><a href="#2-4-运行MySQL" class="headerlink" title="2.4 运行MySQL"></a>2.4 运行MySQL</h2><p>MySQL安装后会自动在后台运行。为了验证MySQL安装是否正确，我们需要通过mysql这个命令行程序来连接MySQL服务器。<br>在命令提示符下输入mysql -u root -p，然后输入口令，如果一切正确，就会连接到MySQL服务器，同时提示符变为mysql&gt;。<br>输入exit退出MySQL命令行。注意，MySQL服务器仍在后台运行。  </p>
<h1 id="三：-关系模型"><a href="#三：-关系模型" class="headerlink" title="三： 关系模型"></a>三： 关系模型</h1><p>我们已经知道，关系数据库是建立在关系模型上的。而关系模型本质上就是若干个存储数据的二维表，可以把它们看作很多Excel表。<br>表的每一行称为记录（Record），记录是一个逻辑意义上的数据。<br>表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。<br>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL。注意NULL表示字段数据不存在。一个整型字段如果为NULL不表示它的值为0，同样的，一个字符串型字段为NULL也不表示它的值为空串’’。  </p>
<blockquote>
<p>通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。  </p>
</blockquote>
<p>在关系数据库中，关系是通过主键和外键来维护的。</p>
<h2 id="3-1-主键"><a href="#3-1-主键" class="headerlink" title="3.1 主键"></a>3.1 主键</h2><p>在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。<br>每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。<br><strong>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为主键。</strong><br>对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。<br>由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。<br>所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。<br>因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。<br>作为主键最好是完全业务无关的字段，我们一般把这个字段命名为id。常见的可作为id字段的类型有：  </p>
<ul>
<li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li>
<li>全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li>
</ul>
<p>对于大部分应用来说，通常自增类型的主键就能满足需求。  </p>
<blockquote>
<p>PS:如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。  </p>
</blockquote>
<p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为<strong>联合主键</strong>。<br>对于联合主键，允许一列有重复，只要不是所有主键列都重复即可。<br>没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。  </p>
<p><strong>小结</strong><br><strong>主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用<code>BIGINT自增</code>或者<code>GUID类型</code>。主键也不应该允许<code>NULL</code>。可以使用多个列作为联合主键，但联合主键并不常用。</strong></p>
<h2 id="3-2-外键"><a href="#3-2-外键" class="headerlink" title="3.2 外键"></a>3.2 外键</h2><p>由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个<code>classes</code>的记录可以对应多个<code>students</code>表的记录。<br>为了表达这种一对多的关系，我们需要在<code>students</code>表中加入一列<code>class_id</code>，让它的值与<code>classes</code>表的某条记录相对应。<br>这样，我们就可以根据<code>class_id</code>这个列直接定位出一个<code>students</code>表的记录应该对应到<code>classes</code>的哪条记录。<br>在<code>students</code>表中，通过<code>class_id</code>的字段，可以把数据与另一张表关联起来，这种列称为外键。<br>外键并不是通过列名实现的，而是通过定义外键约束实现的：</p>
<pre><code class="sql">ALTER TABLE students
ADD CONSTRAINT fk_class_id
FOREIGN KEY (class_id)
REFERENCES classes (id);</code></pre>
<p>其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的id列（即<code>classes</code>表的主键）。<br>通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果<code>classes</code>表不存在id=99的记录，<code>students</code>表就无法插入<code>class_id=99</code>的记录。<br>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，<code>class_id</code>仅仅是一个普通的列，只是它起到了外键的作用而已。<br>要删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</p>
<pre><code class="sql">ALTER TABLE students
DROP FOREIGN KEY fk_class_id;</code></pre>
<blockquote>
<p>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。  </p>
</blockquote>
<p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。<br>多对多关系实际上是通过两个一对多关系实现的，即<strong>通过一个中间表，关联两个一对多关系，就形成了多对多关系</strong>。<br>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。  目的是把经常读取和不经常读取的字段分开，提高查询速度，以获得更高的性能。  </p>
<p><strong>小结</strong><br><strong>关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。</strong></p>
<h2 id="3-3-索引"><a href="#3-3-索引" class="headerlink" title="3.3 索引"></a>3.3 索引</h2><p>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。<br>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。<br>如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引：</p>
<pre><code class="sql">ALTER TABLE students
ADD INDEX idx_score (score);</code></pre>
<p>使用<code>ADD INDEX idx_score (score)</code>就创建了一个名称为<code>idx_score</code>，使用列<code>score</code>的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：</p>
<pre><code class="sql">ALTER TABLE students
ADD INDEX idx_name_score (name, score);</code></pre>
<p>索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如<code>gender</code>列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。<br>可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。<br>对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。  </p>
<p><strong>小结</strong><br><strong>通过对数据库表创建索引，可以提高查询速度。</strong><br><strong>通过创建唯一索引，可以保证某一列的值具有唯一性。</strong><br><strong>数据库索引对于用户和应用程序来说都是透明的。</strong></p>
<h1 id="四：-查询数据"><a href="#四：-查询数据" class="headerlink" title="四： 查询数据"></a>四： 查询数据</h1><p>在关系数据库中，最常用的操作就是查询。</p>
<h2 id="4-1-基本查询"><a href="#4-1-基本查询" class="headerlink" title="4.1 基本查询"></a>4.1 基本查询</h2><p>要查询数据库表的数据，我们使用如下的SQL语句：<br><code>SELECT * FROM &lt;表名&gt;</code><br>假设表名是<code>students</code>，要查询<code>students</code>表的所有行，我们用如下SQL语句：<br><code>SELECT * FROM students;</code>。<br>使用<code>SELECT * FROM students</code>时，<code>SELECT</code>是关键字，表示将要执行一个查询，<code>*</code>表示“所有列”，<code>FROM</code>表示将要从哪个表查询，本例中是<code>students</code>表。<br>该SQL将查询出<code>students</code>表的所有数据。注意：查询结果也是一个二维表，它包含列名和每一行的数据。  </p>
<p>在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。<br>关键词 DISTINCT 用于返回唯一不同的值。语法：</p>
<pre><code class="sql">SELECT DISTINCT 列名称 FROM 表名称</code></pre>
<p><strong>小结</strong><br><strong>使用<code>SELECT(选择、挑选、选拔)</code>查询的基本语句<code>SELECT * FROM &lt;表名&gt;</code>可以查询一个表的所有行和所有列的数据。<code>SELECT</code>查询的结果是一个二维表。</strong>  </p>
<h2 id="4-2-条件查询"><a href="#4-2-条件查询" class="headerlink" title="4.2 条件查询"></a>4.2 条件查询</h2><p><code>SELECT</code>语句可以通过<code>WHERE（到哪里）</code>条件来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成<code>WHERE</code>条件就是:<br><code>SELECT * FROM students WHERE score &gt;= 80;</code>。<br>其中，<code>WHERE</code>关键字后面的<code>score &gt;= 80</code>就是条件。<code>score</code>是列名，该列存储了学生的成绩，因此，<code>score &gt;= 80</code>就筛选出了指定条件的记录：<br><code>SELECT * FROM students WHERE score &gt;= 80;</code>。<br>因此，条件查询的语法就是：<br><code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;</code>  </p>
<p>条件表达式可以用<code>&lt;条件1&gt; AND &lt;条件2&gt;</code>表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来：</p>
<ul>
<li>条件1：根据score列的数据判断：score &gt;= 80；</li>
<li>条件2：根据gender列的数据判断：gender = ‘M’，注意gender列存储的是字符串，需要用单引号括起来。</li>
</ul>
<p>就可以写出<code>WHERE</code>条件：<br><code>SELECT * FROM students WHERE score &gt;= 80 AND gender = &#39;M&#39;;</code>。<br>第二种条件是&lt;条件1&gt; OR &lt;条件2&gt;，表示满足条件1或者满足条件2。例如：<br><code>SELECT * FROM students WHERE score &gt;= 80 OR gender = &#39;M&#39;;</code><br>第三种条件是NOT &lt;条件&gt;，表示“不符合该条件”的记录。例如：<br><code>SELECT * FROM students WHERE NOT class_id = 2;</code>表示不是2班的学生。<br>要组合三个或者更多的条件，就需要用小括号()表示如何进行条件运算。例如，编写一个复杂的条件：分数在80以下或者90以上，并且是男生：<br><code>SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = &#39;M&#39;;</code><br>如果不加括号，条件运算按照<code>NOT、AND、OR</code>的优先级进行，即<code>NOT</code>优先级最高，其次是<code>AND</code>，最后是<code>OR</code>。加上括号可以改变优先级。  </p>
<p>常用的条件表达式：  </p>
<table>
<thead>
<tr>
<th>条件</th>
<th>表达式举例1</th>
<th>表达式举例2</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>使用=判断相等</td>
<td>score = 80</td>
<td>name = ‘abc’</td>
<td>字符串需要用单引号括起来</td>
</tr>
<tr>
<td>使用&gt;判断大于</td>
<td>score &gt; 80</td>
<td>name &gt; ‘abc’</td>
<td>字符串比较根据ASCII码，中文字符比较根据数据库设置</td>
</tr>
<tr>
<td>使用&gt;=判断大于或相等</td>
<td>score &gt;= 80</td>
<td>name &gt;= ‘abc’</td>
<td></td>
</tr>
<tr>
<td>使用&lt;判断小于</td>
<td>score &lt; 80</td>
<td>name &lt;= ‘abc’</td>
<td></td>
</tr>
<tr>
<td>使用&lt;=判断小于或相等</td>
<td>score &lt;= 80</td>
<td>name &lt;= ‘abc’</td>
<td></td>
</tr>
<tr>
<td>使用&lt;&gt;判断不相等</td>
<td>score &lt;&gt; 80</td>
<td>name &lt;&gt; ‘abc’</td>
<td></td>
</tr>
<tr>
<td>使用LIKE判断相似</td>
<td>name LIKE ‘ab%’</td>
<td>name LIKE ‘%bc%’</td>
<td>%表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’</td>
</tr>
</tbody></table>
<p><strong>小结</strong><br><strong>通过WHERE条件查询，可以筛选出符合指定条件的记录，而不是整个表的所有记录。</strong></p>
<h2 id="4-3-投影查询"><a href="#4-3-投影查询" class="headerlink" title="4.3 投影查询"></a>4.3 投影查询</h2><p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用<code>SELECT 列1, 列2, 列3 FROM ...</code>，让结果集仅包含指定列。这种操作称为投影查询。<br>例如，从<code>students</code>表中返回<code>id、score和name</code>这三列：<br><code>SELECT id, score, name FROM students;</code><br>这样返回的结果集就只包含了我们指定的列，并且，结果集的列的顺序和原表可以不一样。  </p>
<p>使用<code>SELECT 列1, 列2, 列3 FROM ...</code>时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code>。</p>
<p>例如，以下<code>SELECT</code>语句将列名<code>score</code>重命名为<code>points</code>，而<code>id</code>和<code>name</code>列名保持不变：<code>SELECT id, score points, name FROM students;</code><br>投影查询同样可以接<code>WHERE</code>条件，实现复杂的查询：<br><code>SELECT id, score points, name FROM students WHERE gender = &#39;M&#39;;</code>  </p>
<p><strong>小结</strong><br><strong>使用<code>SELECT *</code>表示查询表的所有列，使用<code>SELECT 列1, 列2, 列3</code>则可以仅返回指定列，这种操作称为投影。<code>SELECT</code>语句可以对结果集的列进行重命名。</strong>  </p>
<h2 id="4-4-排序"><a href="#4-4-排序" class="headerlink" title="4.4 排序"></a>4.4 排序</h2><p>可以加上<code>ORDER BY</code>子句。可以按照成绩从低到高进行排序：<br><code>SELECT id, name, gender, score FROM students ORDER BY score;</code><br>如果要反过来，按照成绩从高到底排序，我们可以加上DESC表示“倒序”：<br><code>SELECT id, name, gender, score FROM students ORDER BY score DESC;</code><br>如果score列有相同的数据，要进一步排序，可以继续添加列名。例如，使用ORDER BY score DESC, gender表示先按score列倒序，如果有相同分数的，再按gender列排序：<br><code>SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;</code><br>默认的排序规则是<code>ASC</code>：“升序”，即从小到大。<code>ASC</code>可以省略，即<code>ORDER BY score ASC</code>和<code>ORDER BY score</code>效果一样。<br>如果有<code>WHERE</code>子句，那么<code>ORDER BY</code>子句要放到<code>WHERE</code>子句后面。例如，查询一班的学生成绩，并按照倒序排序：</p>
<pre><code class="sql">SELECT id, name, gender, score
FROM students
WHERE class_id = 1
ORDER BY score DESC;</code></pre>
<p>这样，结果集仅包含符合WHERE条件的记录，并按照ORDER BY的设定排序。<br><strong>小结</strong><br><strong>使用ORDER BY可以对结果集进行排序；可以对多列进行升序、倒序排序。</strong>  </p>
<h2 id="4-5-分页查询"><a href="#4-5-分页查询" class="headerlink" title="4.5 分页查询"></a>4.5 分页查询</h2><p>要实现分页功能，实际上就是从结果集中显示第1<del>100条记录作为第1页，显示第101</del>200条记录作为第2页，以此类推。<br>因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>子句实现。我们先把所有学生按照成绩从高到低进行排序，我们把结果集分页，每页3条记录。要获取第1页的记录，可以使用<code>LIMIT 3 OFFSET 0</code>：  </p>
<pre><code class="sql">SELECT id, name, gender, score
FROM students
ORDER BY score DESC
LIMIT 3 OFFSET 0;</code></pre>
<p>上述查询<code>LIMIT 3 OFFSET 0</code>表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。<br>如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3：<code>LIMIT 3 OFFSET 3;</code><br>LIMIT 3表示的意思是“最多3条记录”。  </p>
<p>可见，分页查询的关键在于，首先要确定每页需要显示的结果数量pageSize（这里是3），然后根据当前页的索引pageIndex（从1开始），确定LIMIT和OFFSET应该设定的值：</p>
<ul>
<li>LIMIT总是设定为pageSize；</li>
<li>OFFSET计算公式为pageSize * (pageIndex - 1)。</li>
</ul>
<p>这样就能正确查询出第N页的记录集。</p>
<blockquote>
<p>PS:OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集。<br>OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。<br>在MySQL中，<code>LIMIT 15 OFFSET 30</code>还可以简写成<code>LIMIT 30, 15</code>。<br>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>分页时，随着N越来越大，查询效率也会越来越低。  </p>
</blockquote>
<p><strong>小结</strong><br><strong>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>可以对结果集进行分页，每次查询返回结果集的一部分；分页查询需要先确定每页的数量和当前页数，然后确定LIMIT和OFFSET的值。</strong></p>
<h2 id="4-6-聚合查询"><a href="#4-6-聚合查询" class="headerlink" title="4.6 聚合查询"></a>4.6 聚合查询</h2><h3 id="4-6-1-聚合函数"><a href="#4-6-1-聚合函数" class="headerlink" title="4.6.1 聚合函数"></a>4.6.1 聚合函数</h3><p>对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。<br>仍然以查询students表一共有多少条记录为例，我们可以使用SQL内置的COUNT()函数查询：<br><code>SELECT COUNT(*) FROM students;</code><br><code>COUNT(*)</code>表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是<code>COUNT(*)</code>。<br>通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果：<br><code>SELECT COUNT(*) num FROM students;</code><br><code>COUNT(*)</code>和<code>COUNT(id)</code>实际上是一样的效果。另外注意，聚合查询同样可以使用WHERE条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等：<br><code>SELECT COUNT(*) boys FROM students WHERE gender = &#39;M&#39;;</code><br>除了COUNT()函数外，SQL还提供了如下聚合函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SUM</td>
<td>计算某一列的合计值，该列必须为数值类型</td>
</tr>
<tr>
<td>AVG</td>
<td>计算某一列的平均值，该列必须为数值类型</td>
</tr>
<tr>
<td>MAX</td>
<td>计算某一列的最大值</td>
</tr>
<tr>
<td>MIN</td>
<td>计算某一列的最小值</td>
</tr>
</tbody></table>
<p>注意，MAX()和MIN()函数并不限于数值类型。如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。<br>要统计男生的平均成绩，我们用下面的聚合查询：<br><code>SELECT AVG(score) average FROM students WHERE gender = &#39;M&#39;;</code><br>要特别注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL。<br>通过聚合查询获得总页数:<br><code>SELECT CEILING(COUNT(*) / 3) FROM students;</code>  </p>
<h3 id="4-6-2-分组聚合"><a href="#4-6-2-分组聚合" class="headerlink" title="4.6.2 分组聚合"></a>4.6.2 分组聚合</h3><p>对于聚合查询，SQL还提供了“分组聚合”的功能。我们观察下面的聚合查询：<br><code>SELECT COUNT(*) num FROM students GROUP BY class_id;</code><br>执行这个查询，COUNT()的结果不再是一个，而是3个，这是因为，<code>GROUP(组) BY</code>子句指定了按class_id分组，因此，执行该SELECT语句时，会把class_id相同的列先分组，再分别计算，因此，得到了3行结果。<br>但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把class_id列也放入结果集中：<br><code>SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;</code>这下结果集就可以一目了然地看出各个班级的学生人数。<br>也可以使用多个列进行分组。例如，我们想统计各班的男生和女生人数：<br><code>SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;</code><br><strong>小结</strong><br><strong>使用SQL提供的聚合查询，我们可以方便地计算总数、合计值、平均值、最大值和最小值；聚合查询也可以添加WHERE条件。</strong></p>
<h2 id="4-7-多表查询"><a href="#4-7-多表查询" class="headerlink" title="4.7 多表查询"></a>4.7 多表查询</h2><p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：<code>SELECT * FROM &lt;表1&gt; &lt;表2&gt;</code>。<br>例如，同时从students表和classes表的“乘积”，即查询数据，可以这么写：<code>SELECT * FROM students, classes;</code><br>这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。<br>这种多表查询又称<strong>笛卡尔查询</strong>，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。  </p>
<p>上述查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理。要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名：</p>
<pre><code class="sql">SELECT
    students.id sid,
    students.name,
    students.gender,
    students.score,
    classes.id cid,
    classes.name cname
FROM students, classes;</code></pre>
<p>注意，多表查询时，要使用<code>表名.列名</code>这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用<code>表名.列名</code>这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：</p>
<pre><code class="sql">SELECT
    s.id sid,
    s.name,
    s.gender,
    s.score,
    c.id cid,
    c.name cname
FROM students s, classes c;</code></pre>
<p>注意到FROM子句给表设置别名的语法是<code>FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;</code>。这样我们用别名s和c分别表示students表和classes表。<br>多表查询也是可以添加WHERE条件的：</p>
<pre><code class="sql">SELECT
    s.id sid,
    s.name,
    s.gender,
    s.score,
    c.id cid,
    c.name cname
FROM students s, classes c
WHERE s.gender = &#39;M&#39; AND c.id = 1;</code></pre>
<p><strong>小结</strong><br><strong>使用多表查询可以获取M x N行记录；多表查询的结果集可能非常巨大，要小心使用。</strong></p>
<h2 id="4-8-连接查询"><a href="#4-8-连接查询" class="headerlink" title="4.8 连接查询"></a>4.8 连接查询</h2><p>连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。<br>例如，我们想要选出students表的所有学生信息，可以用一条简单的SELECT语句完成：  </p>
<pre><code class="sql">SELECT s.id, s.name, s.class_id, s.gender, s.score FROM students s;</code></pre>
<p>但是，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有class_id列，缺少对应班级的name列。<br>现在问题来了，存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。<br>这时，连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现：  </p>
<pre><code class="sql">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
INNER JOIN classes c
ON s.class_id = c.id;</code></pre>
<p>注意INNER JOIN查询的写法是：</p>
<ol>
<li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li>
<li>再确定需要连接的表，使用<code>INNER(里面的) JOIN &lt;表2&gt;</code>的语法；</li>
<li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示students表的class_id列与classes表的id列相同的行需要连接；</li>
<li>可选：加上WHERE子句、ORDER BY等子句。</li>
</ol>
<p>那什么是内连接（INNER JOIN）呢？先别着急，有内连接（INNER JOIN）就有外连接（OUTER JOIN）。我们把内连接查询改成外连接查询，看看效果：</p>
<pre><code class="SQL">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
RIGHT OUTER JOIN classes c
ON s.class_id = c.id;</code></pre>
<p>执行上述RIGHT OUTER JOIN可以看到，和INNER JOIN相比，RIGHT OUTER JOIN多了一行，多出来的一行是“四班”，但是，学生相关的列如name、gender、score都为NULL。<br>这也容易理解，因为根据ON条件<code>s.class_id = c.id</code>，classes表的id=4的行正是“四班”，但是，students表中并不存在class_id=4的行。<br>有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是：  </p>
<ul>
<li>INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件<code>s.class_id = c.id</code>返回的结果集仅包含1，2，3。</li>
<li>RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。</li>
<li>LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的class_name是NULL。</li>
</ul>
<p>对于这么多种JOIN查询，到底什么使用应该用哪种呢？其实我们用图来表示结果集就一目了然了。假设查询语句是：<br><code>SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2;</code><br>我们把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录：<br><img src="https://www.liaoxuefeng.com/files/attachments/1246892164662976/l" srcset="/img/loading.gif" alt="inner-join"><br>LEFT OUTER JOIN是选出左表存在的记录：<br><img src="https://www.liaoxuefeng.com/files/attachments/1246893588481376/l" srcset="/img/loading.gif" alt="left-outer-join"><br>RIGHT OUTER JOIN是选出右表存在的记录：<br><img src="https://www.liaoxuefeng.com/files/attachments/1246893609222688/l" srcset="/img/loading.gif" alt="right-outer-join"><br>FULL OUTER JOIN则是选出左右表都存在的记录：<br><img src="https://www.liaoxuefeng.com/files/attachments/1246893632359424/l" srcset="/img/loading.gif" alt="full-outer-join">  </p>
<p><strong>小结</strong><br><strong>JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上；  INNER JOIN是最常用的一种JOIN查询，它的语法是<code>SELECT ... FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件...&gt;</code>；  JOIN查询仍然可以使用WHERE条件和ORDER BY排序。</strong></p>
<h1 id="五：-修改数据"><a href="#五：-修改数据" class="headerlink" title="五： 修改数据"></a>五： 修改数据</h1><p>关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。其中，对于查询，我们已经详细讲述了SELECT语句的详细用法。<br>而对于增、删、改，对应的SQL语句分别是：</p>
<ul>
<li>INSERT：插入新记录；</li>
<li>UPDATE：更新已有记录；</li>
<li>DELETE：删除已有记录。</li>
</ul>
<h2 id="5-1-INSERT"><a href="#5-1-INSERT" class="headerlink" title="5.1 INSERT"></a>5.1 INSERT</h2><p>当我们需要向数据库表中插入一条新记录时，就必须使用<code>INSERT</code>语句。<br>INSERT语句的基本语法是：<br><code>INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</code><br>例如，我们向students表插入一条新记录，先列举出需要插入的字段名称，然后在VALUES子句中依次写出对应字段的值：<br><code>INSERT INTO students (class_id, name, gender, score) VALUES (2, &#39;大牛&#39;, &#39;M&#39;, 80);</code><br>注意到我们并没有列出id字段，也没有列出id字段对应的值，这是因为id字段是一个自增主键，它的值可以由数据库自己推算出来。此外，如果一个字段有默认值，那么在INSERT语句中也可以不出现。<br>要注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。也就是说，可以写:<br><code>INSERT INTO students (score, gender, name, class_id) ...</code>，但是对应的VALUES就得变成<code>(80, &#39;M&#39;, &#39;大牛&#39;, 2)</code>。<br>还可以一次性添加多条记录，只需要在VALUES子句中指定多个记录值，每个记录是由(…)包含的一组值：  </p>
<pre><code class="sql">INSERT INTO students (class_id, name, gender, score) VALUES
  (1, &#39;大宝&#39;, &#39;M&#39;, 87),
  (2, &#39;二宝&#39;, &#39;M&#39;, 81);
--
SELECT * FROM students;</code></pre>
<p><strong>小结</strong><br><strong>使用INSERT，我们就可以一次向一个表中插入一条或多条记录。</strong></p>
<h2 id="5-2-UPDATE"><a href="#5-2-UPDATE" class="headerlink" title="5.2 UPDATE"></a>5.2 UPDATE</h2><p>如果要更新数据库表中的记录，我们就必须使用UPDATE语句。<br>UPDATE语句的基本语法是：<br><code>UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;</code><br>例如，我们想更新students表id=1的记录的name和score这两个字段：<br><code>UPDATE students SET name=&#39;大牛&#39;, score=66 WHERE id=1;</code><br>注意到UPDATE语句的WHERE条件和SELECT语句的WHERE条件其实是一样的，因此完全可以一次更新多条记录：<br><code>UPDATE students SET name=&#39;小牛&#39;, score=77 WHERE id&gt;=5 AND id&lt;=7;</code><br>在UPDATE语句中，更新字段时可以使用表达式。例如，把所有80分以下的同学的成绩加10分：<br><code>UPDATE students SET score=score+10 WHERE score&lt;80;</code><br>其中，SET score=score+10就是给当前行的score字段的值加上了10。<br>如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新。<br>最后，要特别小心的是，UPDATE语句可以没有WHERE条件，例如：<br><code>UPDATE students SET score=60;</code><br>这时，整个表的所有记录都会被更新。所以，在执行UPDATE语句时要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新。<br>在使用MySQL这类真正的关系数据库时，UPDATE语句会返回更新的行数以及WHERE条件匹配的行数。  </p>
<p><strong>小结</strong><br><strong>使用UPDATE，我们就可以一次更新表中的一条或多条记录。</strong></p>
<h2 id="5-3-DELETE"><a href="#5-3-DELETE" class="headerlink" title="5.3 DELETE"></a>5.3 DELETE</h2><p>如果要删除数据库表中的记录，我们可以使用DELETE语句。<br>DELETE语句的基本语法是：<br><code>DELETE FROM &lt;表名&gt; WHERE ...;</code><br>例如，我们想删除students表中id=1的记录，就需要这么写：<br><code>DELETE FROM students WHERE id=1;</code><br>注意到DELETE语句的WHERE条件也是用来筛选需要删除的行，因此和UPDATE类似，DELETE语句也可以一次删除多条记录：<br><code>DELETE FROM students WHERE id&gt;=5 AND id&lt;=7;</code><br>如果WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除。<br>最后，要特别小心的是，和UPDATE类似，不带WHERE条件的DELETE语句会删除整个表的数据：<br><code>DELETE FROM students;</code><br>这时，整个表的所有记录都会被删除。所以，在执行DELETE语句时也要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用DELETE删除。<br>在使用MySQL这类真正的关系数据库时，DELETE语句也会返回删除的行数以及WHERE条件匹配的行数。  </p>
<p><strong>小结</strong><br><strong>使用DELETE，我们就可以一次删除表中的一条或多条记录。</strong></p>
<h1 id="六：-MySQL"><a href="#六：-MySQL" class="headerlink" title="六： MySQL"></a>六： MySQL</h1><p>安装完MySQL后，除了MySQL Server，即真正的MySQL服务器外，还附赠一个MySQL Client程序。MySQL Client是一个命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行。<br>打开命令提示符，输入命令<code>mysql -u root -p</code>，提示输入口令。填入MySQL的root口令，如果正确，就连上了MySQL Server，同时提示符变为mysql&gt;：<br>输入exit断开与MySQL Server的连接并返回到命令提示符。</p>
<blockquote>
<p>MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。</p>
</blockquote>
<p>在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是127.0.0.1:3306。<br>也可以只安装MySQL Client，然后连接到远程MySQL Server。假设远程MySQL Server的IP地址是10.0.1.99，那么就使用-h指定IP或域名：<br><code>mysql -h 10.0.1.99 -u root -p 密码</code>  </p>
<p><strong>小结</strong><br><strong>命令行程序mysql实际上是MySQL客户端，真正的MySQL服务器程序是mysqld，在后台运行。</strong></p>
<h2 id="6-1-管理MySQL"><a href="#6-1-管理MySQL" class="headerlink" title="6.1 管理MySQL"></a>6.1 管理MySQL</h2><p>要管理MySQL，可以使用可视化图形界面<a href="https://dev.mysql.com/downloads/workbench/" target="_blank" rel="noopener">MySQL Workbench</a>。<br>MySQL Workbench可以用可视化的方式查询、创建和修改数据库表，但是，归根到底，MySQL Workbench是一个图形客户端，它对MySQL的操作仍然是发送SQL语句并执行。因此，本质上，MySQL Workbench和MySQL Client命令行都是客户端，和MySQL交互，唯一的接口就是SQL。<br>因此，MySQL提供了大量的SQL语句用于管理。虽然可以使用MySQL Workbench图形界面来直接管理MySQL，但是，很多时候，通过SSH远程连接时，只能使用SQL命令，所以，了解并掌握常用的SQL管理操作是必须的。  </p>
<h3 id="6-1-1-数据库"><a href="#6-1-1-数据库" class="headerlink" title="6.1.1 数据库"></a>6.1.1 数据库</h3><p>在一个运行MySQL的服务器上，实际上可以创建多个数据库（Database）。要列出所有数据库，使用命令：  </p>
<pre><code class="sql">SHOW DATABASES;</code></pre>
<p>其中，<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>和<code>sys</code>四个是系统库，不要去改动它们。其他的是用户创建的数据库。<br>要创建一个新数据库，使用命令：  </p>
<pre><code class="sql">CREATE DATABASE test;</code></pre>
<p>要删除一个数据库，使用命令：  </p>
<pre><code class="sql">DROP DATABASE test;</code></pre>
<p><em>注意：删除一个数据库将导致该数据库的所有表全部被删除。</em><br>对一个数据库进行操作时，要首先将其切换为当前数据库：  </p>
<pre><code class="sql">USE test;</code></pre>
<h3 id="6-1-2-表"><a href="#6-1-2-表" class="headerlink" title="6.1.2 表"></a>6.1.2 表</h3><p>列出当前数据库的所有表，使用命令：  </p>
<pre><code class="sql">SHOW TABLES;</code></pre>
<p>要查看一个表的结构，使用命令：  </p>
<pre><code class="sql">DESC students;</code></pre>
<p>还可以使用以下命令查看创建表的SQL语句：  </p>
<pre><code class="sql">SHOW CREATE TABLE students;</code></pre>
<p>创建表使用CREATE TABLE语句，而删除表使用DROP TABLE语句：  </p>
<pre><code class="sql">DROP TABLE students;</code></pre>
<p>修改表就比较复杂。如果要给students表新增一列birth，使用：  </p>
<pre><code class="sql">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</code></pre>
<p>要修改birth列，例如把列名改为birthday，类型改为VARCHAR(20)：</p>
<pre><code class="sql">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</code></pre>
<p>要删除列，使用：</p>
<pre><code class="sql">ALTER TABLE students DROP COLUMN birthday;</code></pre>
<h3 id="6-1-3-退出MySQL"><a href="#6-1-3-退出MySQL" class="headerlink" title="6.1.3 退出MySQL"></a>6.1.3 退出MySQL</h3><p>使用EXIT命令退出MySQL：<br><code>EXIT</code><br>注意EXIT仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。  </p>
<h2 id="6-2-实用SQL语句"><a href="#6-2-实用SQL语句" class="headerlink" title="6.2 实用SQL语句"></a>6.2 实用SQL语句</h2><p>在编写SQL时，灵活运用一些技巧，可以大大简化程序逻辑。  </p>
<p><strong>一. 插入或替换</strong><br>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用<code>REPLACE</code>语句，这样就不必先查询，再决定是否先删除再插入：<br><code>REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</code><br>若id=1的记录不存在，REPLACE语句将插入新记录，否则，当前id=1的记录将被删除，然后再插入新记录。  </p>
<p><strong>二. 插入或更新</strong><br>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用<code>INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code>语句：<br><code>INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99) ON DUPLICATE KEY UPDATE name=&#39;小明&#39;, gender=&#39;F&#39;, score=99;</code><br>若id=1的记录不存在，INSERT语句将插入新记录，否则，当前id=1的记录将被更新，更新的字段由UPDATE指定。  </p>
<p><strong>三. 插入或忽略</strong><br>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用<code>INSERT IGNORE INTO ...</code>语句：<br><code>INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</code><br>若id=1的记录不存在，INSERT语句将插入新记录，否则，不执行任何操作。  </p>
<p><strong>四. 快照</strong><br>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合CREATE TABLE和SELECT：  </p>
<pre><code class="sql">-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:  
CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id=1;</code></pre>
<p>新创建的表结构和SELECT使用的表结构完全一致。</p>
<p><strong>五. 写入查询结果集</strong><br>如果查询结果集需要写入到表中，可以结合INSERT和SELECT，将SELECT语句的结果集直接插入到指定表中。<br>例如，创建一个统计成绩的表statistics，记录各班的平均成绩：  </p>
<pre><code class="sql">CREATE TABLE statistics (
    id BIGINT NOT NULL AUTO_INCREMENT,
    class_id BIGINT NOT NULL,
    average DOUBLE NOT NULL,
    PRIMARY KEY (id)
);</code></pre>
<p>然后，我们就可以用一条语句写入各班的平均成绩：  </p>
<pre><code class="sql">INSERT INTO statistics (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id;</code></pre>
<p>确保INSERT语句的列和SELECT语句的列能一一对应，就可以在statistics表中直接保存查询的结果：  </p>
<pre><code class="sql">SELECT * FROM statistics;</code></pre>
<p><strong>六. 强制使用指定索引</strong><br>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引。例如：  </p>
<pre><code class="sql">SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC;</code></pre>
<p>指定索引的前提是索引idx_class_id必须存在。  </p>
<h1 id="七：-事务"><a href="#七：-事务" class="headerlink" title="七： 事务"></a>七： 事务</h1><p>在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：  </p>
<pre><code class="sql">-- 从id=1的账户给id=2的账户转账100元
-- 第一步：将id=1的A账户余额减去100
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- 第二步：将id=2的B账户余额加上100
UPDATE accounts SET balance = balance + 100 WHERE id = 2;</code></pre>
<p>这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。<br>这种把<strong>多条语句作为一个整体进行操作的功能，被称为数据库事务</strong>。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。<br>可见，数据库事务具有ACID这4个特性：</p>
<ol>
<li>A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li>
<li>C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；</li>
<li>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；</li>
<li>D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li>
</ol>
<p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为隐式事务。<br>要手动把多条SQL语句作为一个事务执行，使用<code>BEGIN</code>开启一个事务，使用<code>COMMIT</code>提交一个事务，这种事务被称为<strong>显式事务</strong>，例如，把上述的转账操作作为一个显式事务：</p>
<pre><code class="sql">BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;</code></pre>
<p>很显然多条SQL语句要想作为一个事务执行，就必须使用显式事务。<br>COMMIT是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果COMMIT语句执行失败了，整个事务也会失败。<br>有些时候，我们希望主动让事务失败，这时，可以用ROLLBACK回滚事务，整个事务会失败：  </p>
<pre><code class="sql">BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
ROLLBACK;</code></pre>
<p>数据库事务是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以。  </p>
<p><strong>隔离级别</strong></p>
<p>对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。<br>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：  </p>
<table>
<thead>
<tr>
<th>Isolation Level</th>
<th>脏读（Dirty Read）</th>
<th>不可重复读（Non Repeatable Read）</th>
<th>幻读（Phantom Read）</th>
</tr>
</thead>
<tbody><tr>
<td>Read Uncommitted</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Read Committed</td>
<td>-</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td>-</td>
<td>-</td>
<td>Yes</td>
</tr>
<tr>
<td>Serializable</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>我们会依次介绍4种隔离级别的数据一致性问题。  </p>
<p><strong>小结</strong><br><strong>数据库事务具有ACID特性，用来保证多条SQL的全部执行。</strong></p>
<h2 id="7-1-Read-Uncommitted"><a href="#7-1-Read-Uncommitted" class="headerlink" title="7.1 Read Uncommitted"></a>7.1 Read Uncommitted</h2><p>Read Uncommitted是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。<br>我们来看一个例子。首先，我们准备好students表的数据，该表仅一行记录。<br>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td>
<td>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td>
</tr>
<tr>
<td>2</td>
<td>BEGIN;</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td>UPDATE students SET name = ‘Bob’ WHERE id = 1;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td>5</td>
<td>ROLLBACK;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody></table>
<p>当事务A执行完第3步时，它更新了id=1的记录，但并未提交，而事务B在第4步读取到的数据就是未提交的数据。<br>随后，事务A在第5步进行了回滚，事务B再次读取id=1的记录，发现和上一次读取到的数据不一致，这就是脏读。<br>可见，在Read Uncommitted隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据。  </p>
<h2 id="7-2-Read-Committed"><a href="#7-2-Read-Committed" class="headerlink" title="7.2 Read Committed"></a>7.2 Read Committed</h2><p>在Read Committed隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。<br>不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。<br>我们仍然先准备好students表的数据，然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：  </p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td>
<td>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td>
</tr>
<tr>
<td>2</td>
<td>BEGIN;</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td>4</td>
<td>UPDATE students SET name = ‘Bob’ WHERE id = 1;</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>COMMIT;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody></table>
<p>当事务B第一次执行第3步的查询时，得到的结果是Alice，随后，由于事务A在第4步更新了这条记录并提交，所以，事务B在第6步再次执行同样的查询时，得到的结果就变成了Bob，因此，在Read Committed隔离级别下，事务不可重复读同一条记录，因为很可能读到的结果不一致。  </p>
<h2 id="7-3-Repeatable-Read"><a href="#7-3-Repeatable-Read" class="headerlink" title="7.3 Repeatable Read"></a>7.3 Repeatable Read</h2><p>在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。<br>幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。<br>我们仍然先准备好students表的数据，然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：  </p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td>
<td>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td>
</tr>
<tr>
<td>2</td>
<td>BEGIN;</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>SELECT * FROM students WHERE id = 99;</td>
</tr>
<tr>
<td>4</td>
<td>INSERT INTO students (id, name) VALUES (99, ‘Bob’);</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>COMMIT;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>SELECT * FROM students WHERE id = 99;</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>UPDATE students SET name = ‘Alice’ WHERE id = 99;</td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>SELECT * FROM students WHERE id = 99;</td>
</tr>
<tr>
<td>9</td>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody></table>
<p>事务B在第3步第一次读取id=99的记录时，读到的记录为空，说明不存在id=99的记录。随后，事务A在第4步插入了一条id=99的记录并提交。事务B在第6步再次读取id=99的记录时，读到的记录仍然为空，但是，事务B在第7步试图更新这条不存在的记录时，竟然成功了，并且，事务B在第8步再次读取id=99的记录时，记录出现了。<br>可见，幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。  </p>
<h2 id="7-4-Serializable"><a href="#7-4-Serializable" class="headerlink" title="7.4 Serializable"></a>7.4 Serializable</h2><p>Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。<br>虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。  </p>
<p><strong>默认隔离级别</strong><br><strong>如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read。</strong>  </p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构第七章 图</title>
    <url>/2020/01/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC7%E7%AB%A0%20%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="7-1-7-2-图的定义"><a href="#7-1-7-2-图的定义" class="headerlink" title="7.1-7.2 图的定义"></a>7.1-7.2 图的定义</h2><p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。<br>对于图的定义，我们需要明确几个注意的地方。</p>
<a id="more"></a>

<ul>
<li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，<strong>在图中数据元素，我们则称之为顶点（Vertex）</strong>。</li>
<li>线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。我们根本不认为一张空白纸算作画的。同样，在图结构中，不允许没有顶点。在定义中，若V是顶点的集合，则强调了顶点集合V有穷非空。</li>
<li>线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。</li>
</ul>
<h3 id="7-2-1-各种图定义"><a href="#7-2-1-各种图定义" class="headerlink" title="7.2.1 各种图定义"></a>7.2.1 各种图定义</h3><p><strong>无向边：若顶点vi到vj之间的边没有方向，则称这条边为无向边（Edge），用无序偶对（ViVj）来表示</strong>。<br>如果图中任意两个顶点之间的边都是无向边，则称该图为无向图（Undirected graphs）。<br>有向边：若从顶点Vi到Vj的边有方向，则称这条边为有向边，也称为弧（Arc）。<br>用有序偶&lt;vi，vj&gt;来表示，vi称为弧尾（Tail），vj称为弧头（Head）。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图（Directed graphs）。图7-2-3就是一个有向图。连接顶点A到D的有向边就是弧，A是弧尾，D是弧头，&lt;A，D&gt;表示弧，注意不能写成&lt;D，A&gt;。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-2-3.JPG?raw=true" srcset="/img/loading.gif" alt="7-2-3"><br>对于图7-2-3中的有向图G2来说，G2=(V2,{E2})，其中顶点集合V2={A.B，C，D}；弧集合E2={&lt;A，D&gt;，&lt;B，A&gt;，&lt;C，A&gt;，&lt;B，C&gt;}。<br>看清楚了，无向边用小括号“（）”表示，而有向边则是用尖括号“&lt;&gt;”表示。<br>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。<br><strong>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图</strong>。含有n个顶点的无向完全图有（nx(n-1)）/2条边。<br><strong>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图</strong>。含有n个顶点的有向完全图有n×（n-1）条边。<br><strong>有很少条边或弧的图称为稀疏图，反之称为稠密图</strong>。<br>有些图的边或弧具有与它相关的数字，这种<strong>与图的边或弧相关的数叫做权（Weight）</strong>。这些权可以表示从一个顶点到另一个顶点的距离或耗费。<strong>这种带权的图通常称为网（Network）</strong>。图7-2-7就是一张带权的图，即标识中国四大城市的直线距离的网，此图中的权就是两地的距离。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-2-7.JPG?raw=true" srcset="/img/loading.gif" alt="7-2-7"><br>假设有两个图G=（V，{E}）和G’=（V’,{E’}），如果V’⊆V且E’⊆E，则称G’为G的子图（SubGraph）。  </p>
<h3 id="7-2-2-图的顶点与边间关系"><a href="#7-2-2-图的顶点与边间关系" class="headerlink" title="7.2.2 图的顶点与边间关系"></a>7.2.2 图的顶点与边间关系</h3><p>对于无向图G=（V,{E}），如果边（v,v’）∈E，则称顶点v和v’互为邻接点（Adjacent），即v和v’相邻接。边（v，v’）依附（incident）于顶点v和v’，或者说（v,v’）与顶点v和v’相关联。顶点v的度（Degree）是和v相关联的边的数目，记为TD（v）。<br>对于有向图G=（V,{E}），如果弧&lt;v,v’&gt;∈E，则称顶点v邻接到顶点v’，顶点v’邻接自顶点v。弧&lt;v，v’&gt;和顶点v，v’相关联。以顶点v为头的弧的数目称为v的入度（InDegree），记为ID（v）；以v为尾的弧的数目称为v的出度（OutDegree），记为OD（v）；顶点v的度为TD（v）=ID（v）+OD（v）。<br>无向图G=（V，{E}）中从顶点v到顶点v’的路径（Path）是一个顶点序列（v=$v_{i,0}$,$v_{i,1}$,…,$v_{i,m}$=v’），其中（$v_{i,j-1}$，$v_{i,j}$）∈E，1≤j≤m。<br>树中根结点到任意结点的路径是唯一的，但是图中顶点与顶点之间的路径却是不唯一的。<br><strong>路径的长度是路径上的边或弧的数目。</strong><br>第一个顶点到最后一个顶点相同的路径称为回路或环（Cycle）。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。  </p>
<h3 id="7-2-3-连通图相关术语"><a href="#7-2-3-连通图相关术语" class="headerlink" title="7.2.3 连通图相关术语"></a>7.2.3 连通图相关术语</h3><p>在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。如果对于图中任意两个顶点$v_i$、$v_j$∈E，$v_i$和$v_j$都是连通的，则称G是连通图（Connected Graph）。<br><strong>无向图中的极大连通子图称为连通分量</strong>。注意连通分量的概念，它强调：</p>
<ul>
<li>要是子图；</li>
<li>子图要是连通的；</li>
<li>连通子图含有极大顶点数；</li>
<li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</li>
</ul>
<p><strong>在有向图G中，如果对于每一对$v_i$、$v_j$∈V、$v_i$≠$v_j$，从$v_i$到$v_j$和从$v_j$到$v_i$都存在路径，则称G是强连通图。有向图中的极大强连通子图称做有向图的强连通分量</strong>。<br><strong>所谓的一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边</strong>。<br>如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树。<br>一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。  </p>
<h3 id="7-2-4-图的定义与术语总结"><a href="#7-2-4-图的定义与术语总结" class="headerlink" title="7.2.4 图的定义与术语总结"></a>7.2.4 图的定义与术语总结</h3><p>术语终于介绍得差不多了，可能有不少同学有些头晕，我们再来整理一下。<br>图按照有无方向分为无向图和有向图。无向图由顶点和边构成，有向图由顶点和弧构成。弧有弧尾和弧头之分。<br>图按照边或弧的多少分稀疏图和稠密图。如果任意两个顶点之间都存在边叫完全图，有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图。<br>图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度，有向图顶点分为入度和出度。<br>图上的边或弧上带权则称为网。<br>图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复叫简单路径。若任意两顶点都是连通的，则图就是连通图，有向则称强连通图。图中有子图，若子图极大连通则就是连通分量，有向的则称强连通分量。<br>无向图中连通且n个顶点n-1条边叫生成树。有向图中一顶点入度为0其余顶点入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林。  </p>
<h2 id="7-3-图的抽象数据类型"><a href="#7-3-图的抽象数据类型" class="headerlink" title="7.3 图的抽象数据类型"></a>7.3 图的抽象数据类型</h2><pre><code class="c">ADT图（Graph）
Data
  顶点的有穷非空集合和边的集合。
Operation
  CreateGraph（*G，V，VR）：按照顶点集V和边弧集VR的定义构造图G。
  DestroyGraph（*G）：图G存在则销毁。
  LocateVex（G，u）：若图G中存在顶点u，则返回图中的位置。
  GetVex（G，v）：返回图G中顶点v的值。
  PutVex（G，v，value）：将图G中顶点v赋值value。
  FirstAdjVex（G，*v）：返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。
  NextAdjVex（G，v，*w）：返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后一个邻接点则返回“空”。
  InsertVex（*G，v）：在图G中增添新顶点v。
  DeleteVex（*G，v）：删除图G中顶点v及其相关的弧。
  InsertArc（*G，V，w）：在图G中增添弧&lt;v，w&gt;，若G是无向图，还需要增添对称弧&lt;w，v&gt;。
  DeleteArc（*G，V，w）：在图G中删除弧&lt;v，w&gt;，若G是无向图，则还删除对称弧&lt;w，v&gt;。
  DFSTraverse（G）：对图G中进行深度优先遍历，在遍历过程对每个顶点调用。
  HFSTraverse（G）：对图G中进行广度优先遍历，在遍历过程对每个顶点调用。
endADT</code></pre>
<h2 id="7-4-图的存储结构"><a href="#7-4-图的存储结构" class="headerlink" title="7.4 图的存储结构"></a>7.4 图的存储结构</h2><p>前辈们提供了五种不同的存储结构。</p>
<h3 id="7-4-1-邻接矩阵"><a href="#7-4-1-邻接矩阵" class="headerlink" title="7.4.1 邻接矩阵"></a>7.4.1 邻接矩阵</h3><p><strong>图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息</strong>。<br>无向图的边数组构成的是一个对称矩阵。<br>有了这个矩阵，我们就可以很容易地知道图中的信息。</p>
<ol>
<li>我们要判定任意两顶点是否有边无边就非常容易了。</li>
<li>我们要知道某个顶点的度，其实就是这个顶点vi在邻接矩阵中第i行（或第i列）的元素之和。比如顶点v1的度就是1+0+1+0=2。</li>
<li>求顶点vi的所有邻接点就是将矩阵中第i行元素扫描一遍，arc[i][j]为1就是邻接点。</li>
</ol>
<p>在图的术语中，我们提到了网的概念，也就是每条边上带有权的图叫做网。那么这些权值就需要存下来，如何处理这个矩阵来适应这个需求呢？我们有办法。<br>设图G是网图，有n个顶点，则邻接矩阵是一个n×n的方阵，定义为：<br>arc[i][j]=</p>
<ol>
<li>$W_{ij}$,若（$v_i$，$v_j$）∈E或&lt;$v_i$,$v_j$&gt;∈E</li>
<li>0,若i=j</li>
<li>∞，反之</li>
</ol>
<p>这里$W_{ij}$表示（$v_i$，$v_j$）或&lt;$v_i$,$v_j$&gt;上的权值。∞表示一个计算机允许的、大于所有边上权值的值，也就是一个不可能的极限值。<br>如图7-4-4左图就是一个有向网图，右图就是它的邻接矩阵。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-4.JPG?raw=true" srcset="/img/loading.gif" alt="7-4-4">  </p>
<p>图的邻接矩阵存储的结构，代码如下。</p>
<pre><code class="c">typedef char VertexType; /* 顶点类型应由用户定义  */
typedef int EdgeType; /* 边上的权值类型应由用户定义 */
#define MAXVEX 100 /* 最大顶点数，应由用户定义 */
#define INFINITY 65535
typedef struct
{
    VertexType vexs[MAXVEX]; /* 顶点表 */
    EdgeType arc[MAXVEX][MAXVEX];/* 邻接矩阵，可看作边表 */
    int numVertexes, numEdges; /* 图中当前的顶点数和边数  */
}MGraph;</code></pre>
<p>有了这个结构定义，我们构造一个图，其实就是给顶点表和边表输入数据的过程。我们来看看无向网图的创建代码。</p>
<pre><code class="c">/* 建立无向网图的邻接矩阵表示 */
void CreateMGraph(MGraph *G)
{
    int i, j, k, w;
    printf(&quot;输入顶点数和边数:\n&quot;);
    scanf(&quot;%d,%d&quot;, &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges); /* 输入顶点数和边数 */
    for (i = 0; i &lt; G-&gt;numVertexes; i++) /* 读入顶点信息,建立顶点表 */
        scanf(&amp;G-&gt;vexs[i]);
    for (i = 0; i &lt; G-&gt;numVertexes; i++)
        for (j = 0; j &lt; G-&gt;numVertexes; j++)
            G-&gt;arc[i][j] = INFINITY;    /* 邻接矩阵初始化 */
    for (k = 0; k &lt; G-&gt;numEdges; k++) /* 读入numEdges条边，建立邻接矩阵 */
    {
        printf(&quot;输入边(vi,vj)上的下标i，下标j和权w:\n&quot;);
        scanf(&quot;%d,%d,%d&quot;, &amp;i, &amp;j, &amp;w); /* 输入边(vi,vj)上的权w */
        G-&gt;arc[i][j] = w;
        G-&gt;arc[j][i] = G-&gt;arc[i][j]; /* 因为是无向图，矩阵对称 */
    }
}</code></pre>
<p>从代码中也可以得到，n个顶点和e条边的无向网图的创建，时间复杂度为O（n+n²+e），其中对邻接矩阵Garc的初始化耗费了O（n²）的时间。</p>
<h3 id="7-4-2-邻接表"><a href="#7-4-2-邻接表" class="headerlink" title="7.4.2 邻接表"></a>7.4.2 邻接表</h3><p>将结点存入数组，并对结点的数组进行链式存储，不管有多少结点，也不会存在空间浪费问题。我们把这种数组与链表相结合的存储方法称为邻接表（Adjacency List）。<br>邻接表的处理办法是这样。</p>
<ol>
<li>图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。</li>
<li>图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。</li>
</ol>
<p>例如图7-4-6所示的就是一个无向图的邻接表结构。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-6.JPG?raw=true" srcset="/img/loading.gif" alt="7-4-6"><br>从图中我们知道，顶点表的各个结点由data和firstedge两个域表示，data是数据域，存储顶点的信息，firstedge是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由adjvex和next两个域组成。adjvex是邻接点域，存储某顶点的邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针。比如v1顶点与v0、v2互为邻接点，则在v1的边表中，adjvex分别为v0的0和v2的2。<br>若是有向图，邻接表结构是类似的，比如图7-4-7中第一幅图的邻接表就是第二幅图。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-7.JPG?raw=true" srcset="/img/loading.gif" alt="7-4-7"><br>但要注意的是有向图由于有方向，我们是以顶点为弧尾来存储边表的，这样很容易就可以得到每个顶点的出度。但也有时为了便于确定顶点的入度或以顶点为弧头的弧，我们可以建立一个有向图的逆邻接表，即对每个顶点vi都建立一个链接为vi为弧头的表。如图7-4-7的第三幅图所示。<br>对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可。<br>有了这些结构的图，下面关于结点定义的代码就很好理解了。  </p>
<pre><code class="c">typedef char VertexType; /* 顶点类型应由用户定义 */
typedef int EdgeType; /* 边上的权值类型应由用户定义 */

typedef struct EdgeNode /* 边表结点  */
{
    int adjvex;    /* 邻接点域,存储该顶点对应的下标 */
    EdgeType info;        /* 用于存储权值,对于非网图可以不需要 */
    struct EdgeNode *next; /* 链域,指向下一个邻接点 */
}EdgeNode;

typedef struct VertexNode /* 顶点表结点 */
{
    VertexType data; /* 顶点域,存储顶点信息 */
    EdgeNode *firstedge;/* 边表头指针 */
}VertexNode, AdjList[MAXVEX];

typedef struct
{
    AdjList adjList;
    int numNodes,numEdges; /* 图中当前顶点数和边数 */
}GraphAdjList;</code></pre>
<p>对于邻接表的创建，也就是顺理成章之事。无向图的邻接表创建代码如下。</p>
<pre><code class="c">/* 建立图的邻接表结构 */
void  CreateALGraph(GraphAdjList *G)
{
    int i,j,k;
    EdgeNode *e;
    printf(&quot;输入顶点数和边数:\n&quot;);
    scanf(&quot;%d,%d&quot;,&amp;G-&gt;numNodes,&amp;G-&gt;numEdges); /* 输入顶点数和边数 */
    for(i = 0;i &lt; G-&gt;numNodes;i++) /* 读入顶点信息,建立顶点表 */
    {
        scanf(&amp;G-&gt;adjList[i].data);     /* 输入顶点信息 */
        G-&gt;adjList[i].firstedge=NULL;     /* 将边表置为空表 */
    }
    for(k = 0;k &lt; G-&gt;numEdges;k++)/* 建立边表 */
    {
        printf(&quot;输入边(vi,vj)上的顶点序号:\n&quot;);
        scanf(&quot;%d,%d&quot;,&amp;i,&amp;j); /* 输入边(vi,vj)上的顶点序号 */
        e=(EdgeNode *)malloc(sizeof(EdgeNode)); /* 向内存申请空间,生成边表结点 */
        e-&gt;adjvex=j;                    /* 邻接序号为j */
        e-&gt;next=G-&gt;adjList[i].firstedge;    /* 将e的指针指向当前顶点上指向的结点 */
        G-&gt;adjList[i].firstedge=e;        /* 将当前顶点的指针指向e */
        e=(EdgeNode *)malloc(sizeof(EdgeNode)); /* 向内存申请空间,生成边表结点 */
        e-&gt;adjvex=i;                    /* 邻接序号为i */
        e-&gt;next=G-&gt;adjList[j].firstedge;    /* 将e的指针指向当前顶点上指向的结点 */
        G-&gt;adjList[j].firstedge=e;        /* 将当前顶点的指针指向e */
    }
}</code></pre>
<p>这里代码，是应用了我们在单链表创建中讲解到的头插法，由于对于无向图，一条边对应都是两个顶点，所以在循环中，一次就针对i和j分别进行了插入。本算法的时间复杂度，对于n个顶点e条边来说，很容易得出是O（n+e）。</p>
<h3 id="7-4-3-十字链表"><a href="#7-4-3-十字链表" class="headerlink" title="7.4.3 十字链表"></a>7.4.3 十字链表</h3><p>有向图的一种存储方法：十字链表是邻接表与逆邻接表的结合。<br>我们重新定义顶点表结点结构如表7-4-1所示。<br>表7-4-1<br>data|firstin|firstout<br>-|-|-<br>其中firstin表示入边表头指针，指向该顶点的入边表中第一个结点，firstout表示出边表头指针，指向该顶点的出边表中的第一个结点。<br>重新定义的边表结点结构如表7-4-2所示。<br>表7-4-2<br>tailvex|headvex|headlink|taillink<br>-|-|-|-<br>其中tailvex是指弧起点在顶点表的下标，headvex是指弧终点在顶点表中的下标，headlink是指入边表指针域，指向终点相同的下一条边，taillink是指边表指针域，指向起点相同的下一条边。如果是网，还可以再增加一个weight域来存储权值。<br>比如图7-4-10，顶点依然是存入一个一维数组{v0，v1，v2，v3}，实线箭头指针的图示完全与图7-4-7的邻接表相同。就以顶点v0来说，firstout 指向的是出边表中的第一个结点v3。所以v0边表结点的headvex=3，而tailvex其实就是当前顶点v0的下标0，由于v0只有一个出边顶点，所以headlink和taillink都是空。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-10.JPG?raw=true" srcset="/img/loading.gif" alt="7-4-10"><br>我们重点需要来解释虚线箭头的含义，它其实就是此图的逆邻接表的表示。对于v0来说，它有两个顶点v1和v2的入边。因此v0的firstin指向顶点v1的边表结点中headvex为0的结点，如图7-4-10右图中的①。接着由入边结点的headlink指向下一个入边顶点v2，如图中的②。对于顶点v1，它有一个入边顶点v2，所以它的firstin指向顶点v2的边表结点中headvex为1的结点，如图中的③。顶点v2和v3也是同样有一个入边顶点，如图中④和⑤。<br>十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以vi为尾的弧，也容易找到以vi为头的弧，因而容易求得顶点的出度和入度。而且它除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的，因此，在有向图的应用中，十字链表是非常好的数据结构模型。  </p>
<h3 id="7-4-4-邻接多重表"><a href="#7-4-4-邻接多重表" class="headerlink" title="7.4.4 邻接多重表"></a>7.4.4 邻接多重表</h3><p>仿照十字链表的方式，对边表结点的结构进行一些改造，可以优化无向图的邻接表的便操作。<br>重新定义的边表结点结构如表7-4-3所示。<br>ivex|ilink|jvex|jlink<br>-|-|-|-<br>其中<strong>ivex和jvex是与某条边依附的两个顶点在顶点表中下标。ilink 指向依附顶点ivex的下一条边，jlink 指向依附顶点jvex的下一条边。这就是邻接多重表结构</strong>。<br>我们来看结构示意图的绘制过程，理解了它是如何连线的，也就理解邻接多重表构造原理了。如图7-4-12所示，左图告诉我们它有4个顶点和5条边，显然，我们就应该先将4个顶点和5条边的边表结点画出来。由于是无向图，所以ivex是0、jvex是1还是反过来都是无所谓的，不过为了绘图方便，都将ivex值设置得与一旁的顶点下标相同。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-12.JPG?raw=true" srcset="/img/loading.gif" alt="7-4-12"><br>我们开始连线，如图7-4-13。首先连线的①②③④就是将顶点的firstedge指向一条边，顶点下标要与ivex的值相同，这很好理解。接着，由于顶点v0的（v0，v1）边的邻边有（v0，v3）和（v0，v2）。因此⑤⑥的连线就是满足指向下一条依附于顶点v0的边的目标，注意ilink指向的结点的jvex一定要和它本身的ivex的值相同。同样的道理，连线⑦就是指（v1,v0）这条边，它是相当于顶点v1指向（v1，v2）边后的下一条。v2有三条边依附，所以在③之后就有了⑧⑨。连线⑩的就是顶点v3在连线④之后的下一条边。左图一共有5条边，所以右图有10条连线，完全符合预期。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-4-13.JPG?raw=true" srcset="/img/loading.gif" alt="7-4-13"><br>到这里，大家应该可以明白，邻接多重表与邻接表的差别，仅仅是在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。这样对边的操作就方便多了，若要删除左图的（v0，v2）这条边，只需要将右图的⑥⑨的链接指向改为^即可。由于各种基本操作的实现也和邻接表是相似的，这里我们就不讲解代码了。</p>
<h3 id="7-4-5-边集数组"><a href="#7-4-5-边集数组" class="headerlink" title="7.4.5 边集数组"></a>7.4.5 边集数组</h3><p>边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标（begin）、终点下标（end）和权（weight）组成。</p>
<h2 id="7-5-图的遍历"><a href="#7-5-图的遍历" class="headerlink" title="7.5 图的遍历"></a>7.5 图的遍历</h2><p>从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历（Traversing Graph）。<br>对于图的遍历来说，如何避免因回路陷入死循环，就需要科学地设计遍历方案，通常有两种遍历次序方案：它们是深度优先遍历和广度优先遍历。  </p>
<h3 id="7-5-1-深度优先遍历"><a href="#7-5-1-深度优先遍历" class="headerlink" title="7.5.1 深度优先遍历"></a>7.5.1 深度优先遍历</h3><p>深度优先遍历（Depth_FirstSearch），也有称为深度优先搜索，简称为DFS。<br>深度优先遍历其实就是一个递归的过程，就像是一棵树的前序遍历，从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。<br>若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。<br>如果我们用的是邻接矩阵的方式，则代码如下：</p>
<pre><code class="c">typedef int Boolean; /* Boolean是布尔类型,其值是TRUE或FALSE */
Boolean visited[MAXVEX]; /* 访问标志的数组 */
/* 邻接矩阵的深度优先递归算法 */
void DFS(MGraph G, int i)
{
    int j;
    visited[i] = TRUE;
    printf(&quot;%c &quot;, G.vexs[i]);/* 打印顶点，也可以其它操作 */
    for(j = 0; j &lt; G.numVertexes; j++)
        if(G.arc[i][j] == 1 &amp;&amp; !visited[j])
            DFS(G, j);/* 对为访问的邻接顶点递归调用 */
}

/* 邻接矩阵的深度遍历操作 */
void DFSTraverse(MGraph G)
{
    int i;
    for(i = 0; i &lt; G.numVertexes; i++)
        visited[i] = FALSE; /* 初始所有顶点状态都是未访问过状态 */
    for(i = 0; i &lt; G.numVertexes; i++)
        if(!visited[i]) /* 对未访问过的顶点调用DFS，若是连通图，只会执行一次 */
            DFS(G, i);
}</code></pre>
<p>代码的执行过程，其实就是我们刚才迷宫找寻所有顶点的过程。<br>如果图结构是邻接表结构，其DFSTraverse函数的代码是几乎相同的，只是在递归函数中因为将数组换成了链表而有不同，代码如下。  </p>
<pre><code class="c">/* 邻接表的深度优先递归算法 */
void DFS(GraphAdjList GL, int i)
{
    EdgeNode *p;
    visited[i] = TRUE;
    printf(&quot;%c &quot;,GL-&gt;adjList[i].data);/* 打印顶点,也可以其它操作 */
    p = GL-&gt;adjList[i].firstedge;
    while(p)
    {
        if(!visited[p-&gt;adjvex])
            DFS(GL, p-&gt;adjvex);/* 对为访问的邻接顶点递归调用 */
        p = p-&gt;next;
    }
}

/* 邻接表的深度遍历操作 */
void DFSTraverse(GraphAdjList GL)
{
    int i;
    for(i = 0; i &lt; GL-&gt;numVertexes; i++)
        visited[i] = FALSE; /* 初始所有顶点状态都是未访问过状态 */
    for(i = 0; i &lt; GL-&gt;numVertexes; i++)
        if(!visited[i]) /* 对未访问过的顶点调用DFS,若是连通图,只会执行一次 */ 
            DFS(GL, i);
}</code></pre>
<p>对比两个不同存储结构的深度优先遍历算法，对于n个顶点e条边的图来说，邻接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此都需要O(n²)的时间。而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是O（n+e）。显然对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。  </p>
<h3 id="7-5-2-广度优先遍历"><a href="#7-5-2-广度优先遍历" class="headerlink" title="7.5.2 广度优先遍历"></a>7.5.2 广度优先遍历</h3><p>广度优先遍历（Breadth_First_Search），又称为广度优先搜索，简称BFS。<br>如果说图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树的层序遍历了。我们将图7-5-3的第一幅图稍微变形，变形原则是顶点A放置在最上第一层，让与它有边的顶点B、F为第二层，再让与B和F有边的顶点C、I、G、E为第三层，再将这四个顶点有边的D、H放在第四层，如图7-5-3的第二幅图所示。<br>此时在视觉上感觉图的形状发生了变化，其实顶点和边的关系还是完全相同的。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-5-3.JPG?raw=true" srcset="/img/loading.gif" alt="7-5-3"><br>有了这个讲解，我们来看代码就非常容易了。以下是邻接矩阵结构的广度优先遍历算法。  </p>
<pre><code class="c">/* 邻接矩阵的广度遍历算法 */
void BFSTraverse(MGraph G)
{
    int i, j;
    Queue Q;
    for(i = 0; i &lt; G.numVertexes; i++)
        visited[i] = FALSE;
    InitQueue(&amp;Q);        /* 初始化一辅助用的队列 */
    for(i = 0; i &lt; G.numVertexes; i++)  /* 对每一个顶点做循环 */
    {
        if (!visited[i])    /* 若是未访问过就处理 */
        {
            visited[i]=TRUE;        /* 设置当前顶点访问过 */
            printf(&quot;%c &quot;, G.vexs[i]);/* 打印顶点，也可以其它操作 */
            EnQueue(&amp;Q,i);        /* 将此顶点入队列 */
            while(!QueueEmpty(Q))    /* 若当前队列不为空 */
            {
                DeQueue(&amp;Q,&amp;i);/* 将队对元素出队列，赋值给i */
                for(j=0;j&lt;G.numVertexes;j++) 
                {
                    /* 判断其它顶点若与当前顶点存在边且未访问过  */
                    if(G.arc[i][j] == 1 &amp;&amp; !visited[j])
                    {
                        visited[j]=TRUE;            /* 将找到的此顶点标记为已访问 */
                        printf(&quot;%c &quot;, G.vexs[j]);    /* 打印顶点 */
                        EnQueue(&amp;Q,j);                /* 将找到的此顶点入队列  */
                    }
                }
            }
        }
    }
}</code></pre>
<p>对于邻接表的广度优先遍历，代码与邻接矩阵差异不大，代码如下。</p>
<pre><code class="c">/* 邻接表的广度遍历算法 */
void BFSTraverse(GraphAdjList GL)
{
    int i;
    EdgeNode *p;
    Queue Q;
    for(i = 0; i &lt; GL-&gt;numVertexes; i++)
        visited[i] = FALSE;
    InitQueue(&amp;Q);
    for(i = 0; i &lt; GL-&gt;numVertexes; i++)
    {
        if (!visited[i])
        {
            visited[i]=TRUE;
            printf(&quot;%c &quot;,GL-&gt;adjList[i].data);/* 打印顶点,也可以其它操作 */
            EnQueue(&amp;Q,i);
            while(!QueueEmpty(Q))
            {
                DeQueue(&amp;Q,&amp;i);
                p = GL-&gt;adjList[i].firstedge;    /* 找到当前顶点的边表链表头指针 */
                while(p)
                {
                    if(!visited[p-&gt;adjvex])    /* 若此顶点未被访问 */
                     {
                        visited[p-&gt;adjvex]=TRUE;
                        printf(&quot;%c &quot;,GL-&gt;adjList[p-&gt;adjvex].data);
                        EnQueue(&amp;Q,p-&gt;adjvex);    /* 将此顶点入队列 */
                    }
                    p = p-&gt;next;    /* 指针指向下一个邻接点 */
                }
            }
        }
    }
}</code></pre>
<p>对比图的深度优先遍历与广度优先遍历算法，你会发现，它们在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同。可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。<br>不过如果图顶点和边非常多，不能在短时间内遍历完成，遍历的目的是为了寻找合适的顶点，那么选择哪种遍历就要仔细斟酌了。深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况。  </p>
<h2 id="7-6-最小生成树"><a href="#7-6-最小生成树" class="headerlink" title="7.6 最小生成树"></a>7.6 最小生成树</h2><p>我们把构造连通网的最小代价生成树称为最小生成树（Minimum Cost Spanning Tree）。</p>
<h3 id="7-6-1-普里姆（Prim）算法"><a href="#7-6-1-普里姆（Prim）算法" class="headerlink" title="7.6.1 普里姆（Prim）算法"></a>7.6.1 普里姆（Prim）算法</h3><p>普里姆（Prim）算法代码如下，左侧数字为行号。其中INFINITY为权值极大值，不妨是65535，MAXVEX为顶点个数最大值，此处大于等于9即可。现在假设我们自己就是计算机，在调用MiniSpanTree_Prim函数，输入上述的邻接矩阵后，看看它是如何运行并打印出最小生成树的。  </p>
<pre><code class="c">/* Prim算法生成最小生成树  */
void MiniSpanTree_Prim(MGraph G)
{
    int min, i, j, k;
    int adjvex[MAXVEX];        /* 保存相关顶点下标 */
    int lowcost[MAXVEX];    /* 保存相关顶点间边的权值 */
    lowcost[0] = 0;/* 初始化第一个权值为0，即v0加入生成树 */
            /* lowcost的值为0，在这里就是此下标的顶点已经加入生成树 */
    adjvex[0] = 0;            /* 初始化第一个顶点下标为0 */
    for(i = 1; i &lt; G.numVertexes; i++)    /* 循环除下标为0外的全部顶点 */
    {
        lowcost[i] = G.arc[0][i];    /* 将v0顶点与之有边的权值存入数组 */
        adjvex[i] = 0;                    /* 初始化都为v0的下标 */
    }
    for(i = 1; i &lt; G.numVertexes; i++)
    {
        min = INFINITY;    /* 初始化最小权值为∞， */
                        /* 通常设置为不可能的大数字如32767、65535等 */
        j = 1;k = 0;
        while(j &lt; G.numVertexes)    /* 循环全部顶点 */
        {
            if(lowcost[j]!=0 &amp;&amp; lowcost[j] &lt; min)/* 如果权值不为0且权值小于min */
            {
                min = lowcost[j];    /* 则让当前权值成为最小值 */
                k = j;            /* 将当前最小值的下标存入k */
            }
            j++;
        }
        printf(&quot;(%d, %d)\n&quot;, adjvex[k], k);/* 打印当前顶点边中权值最小的边 */
        lowcost[k] = 0;/* 将当前顶点的权值设置为0,表示此顶点已经完成任务 */
        for(j = 1; j &lt; G.numVertexes; j++)    /* 循环所有顶点 */
        {
            if(lowcost[j]!=0 &amp;&amp; G.arc[k][j] &lt; lowcost[j])
            {/* 如果下标为k顶点各边权值小于此前这些顶点未被加入生成树权值 */
                lowcost[j] = G.arc[k][j];/* 将较小的权值存入lowcost相应位置 */
                adjvex[j] = k;                /* 将下标为k的顶点存入adjvex */
            }
        }
    }
}</code></pre>
<p>假设N=（P,{E}）是连通网，TE是N上最小生成树中边的集合。算法从U={u0}（u0∈V），TE={}开始。重复执行下述操作：在所有u∈U，v∈V-U的边（u，v）∈E中找一条代价最小的边（u0，v0）并入集合TE，同时v0并入U，直至U=V为止。此时TE中必有n-1条边，则T=（V.{TE}）为N的最小生成树。<br>由算法代码中的循环嵌套可得知此算法的时间复杂度为O(n²)。</p>
<h3 id="7-6-2-克鲁斯卡尔（Kruskal）算法"><a href="#7-6-2-克鲁斯卡尔（Kruskal）算法" class="headerlink" title="7.6.2 克鲁斯卡尔（Kruskal）算法"></a>7.6.2 克鲁斯卡尔（Kruskal）算法</h3><p>现在我们来换一种思考方式，普里姆（Prim）算法是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树的。<br>同样的思路，我们也可以直接就以边为目标去构建，因为权值是在边上，直接去找最小权值的边来构建生成树也是很自然的想法，只不过构建时要考虑是否会形成环路而已。此时我们就用到了图的存储结构中的边集数组结构。以下是edge边集数组结构的定义代码：  </p>
<pre><code class="c">typedef struct
{
    int begin;
    int end;
    int weight;
}Edge;   /* 对边集数组Edge结构的定义 */</code></pre>
<p>我们将图7-6-3的邻接矩阵通过程序转化为图7-6-7的右图的边集数组，并且对它们按权值从小到大排序。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-6-7.JPG?raw=true" srcset="/img/loading.gif" alt="7-6-7"><br>于是克鲁斯卡尔（Kruskal）算法代码如下，左侧数字为行号。其中MAXEDGE为边数量的极大值，此处大于等于15即可，MAXVEX为顶点个数最大值，此处大于等于9即可。现在假设我们自己就是计算机，在调用MiniSpanTree_Kruskal函数，输入图7-6-3右图的邻接矩阵后，看看它是如何运行并打印出最小生成树的。  </p>
<pre><code class="c">/* 查找连线顶点的尾部下标 */
int Find(int *parent, int f)
{
    while ( parent[f] &gt; 0)
    {
        f = parent[f];
    }
    return f;
}

/* Kruskal算法生成最小生成树 */
void MiniSpanTree_Kruskal(MGraph G)
{
    int i, j, n, m;
    int k = 0;
    int parent[MAXVEX];/* 定义一数组用来判断边与边是否形成环路 */
    Edge edges[MAXEDGE];/* 定义边集数组,edge的结构为begin,end,weight,均为整型 */

    /* 用来构建边集数组并排序********************* */
    for ( i = 0; i &lt; G.numVertexes-1; i++)
    {
        for (j = i + 1; j &lt; G.numVertexes; j++)
        {
            if (G.arc[i][j]&lt;INFINITY)
            {
                edges[k].begin = i;
                edges[k].end = j;
                edges[k].weight = G.arc[i][j];
                k++;
            }
        }
    }
    sort(edges, &amp;G);
    /* ******************************************* */
    for (i = 0; i &lt; G.numVertexes; i++)
        parent[i] = 0;    /* 初始化数组值为0 */
    printf(&quot;打印最小生成树：\n&quot;);
    for (i = 0; i &lt; G.numEdges; i++)    /* 循环每一条边 */
    {
        n = Find(parent,edges[i].begin);
        m = Find(parent,edges[i].end);
        if (n != m) /* 假如n与m不等，说明此边没有与现有的生成树形成环路 */
        {
            parent[n] = m;    /* 将此边的结尾顶点放入下标为起点的parent中。 */
                            /* 表示此顶点已经在生成树集合中 */
            printf(&quot;(%d, %d) %d\n&quot;, edges[i].begin, edges[i].end, edges[i].weight);
        }
    }
}</code></pre>
<p>好了，我们来把克鲁斯卡尔（Kruskal）算法的实现定义归纳一下结束这一节的讲解。<br>假设N=（V,{E}）是连通网，则令最小生成树的初始状态为只有n个顶点而无边的非连通图T={V，{}}，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。依次类推，直至T中所有顶点都在同一连通分量上为止。<br>此算法的Find函数由边数e决定，时间复杂度为O（㏒e），而外面有一个for 循环e次。所以克鲁斯卡尔算法的时间复杂度为O（e㏒e）。<br>对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以对于稀疏图有很大的优势；而普里姆算法对于稠密图，即边数非常多的情况会更好一些。  </p>
<h2 id="7-7-最短路径"><a href="#7-7-最短路径" class="headerlink" title="7.7 最短路径"></a>7.7 最短路径</h2><p>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。  </p>
<h3 id="7-7-1-迪杰斯特拉（Djkstra）算法"><a href="#7-7-1-迪杰斯特拉（Djkstra）算法" class="headerlink" title="7.7.1 迪杰斯特拉（Djkstra）算法"></a>7.7.1 迪杰斯特拉（Djkstra）算法</h3><p>迪杰斯特拉（Dijkstra）算法并不是一下子就求出了v0到Vn的最短路径，而是一步步求出它们之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到你要的结果。  </p>
<pre><code class="c">#define MAXVEX 20
#define INFINITY 65535
typedef int Patharc[MAXVEX];    /* 用于存储最短路径下标的数组 */
typedef int ShortPathTable[MAXVEX]; /* 用于存储到各点最短路径的权值和 */
/* Dijkstra算法，求有向网G的v0顶点到其余顶点v的最短路径P[v]及带权长度D[v] */
/* P[v]的值为前驱顶点下标,D[v]表示v0到v的最短路径长度和 */  
void ShortestPath_Dijkstra(MGraph G, int v0, Patharc *P, ShortPathTable *D)
{
    int v,w,k,min;
    int final[MAXVEX];/* final[w]=1表示求得顶点v0至vw的最短路径 */
    for(v=0; v&lt;G.numVertexes; v++)    /* 初始化数据 */
    {
        final[v] = 0;            /* 全部顶点初始化为未知最短路径状态 */
        (*D)[v] = G.arc[v0][v];/* 将与v0点有连线的顶点加上权值 */
        (*P)[v] = -1;                /* 初始化路径数组P为-1  */
    }
    (*D)[v0] = 0;  /* v0至v0路径为0 */  
    final[v0] = 1;    /* v0至v0不需要求路径 */
    /* 开始主循环，每次求得v0到某个v顶点的最短路径 */
    for(v=1; v&lt;G.numVertexes; v++)
    {
        min=INFINITY;    /* 当前所知离v0顶点的最近距离 */
        for(w=0; w&lt;G.numVertexes; w++) /* 寻找离v0最近的顶点 */
        {
            if(!final[w] &amp;&amp; (*D)[w]&lt;min)
            {
                k=w;
                min = (*D)[w];    /* w顶点离v0顶点更近 */
            }
        }
        final[k] = 1;    /* 将目前找到的最近的顶点置为1 */
        for(w=0; w&lt;G.numVertexes; w++) /* 修正当前最短路径及距离 */
        {
            /* 如果经过v顶点的路径比现在这条路径的长度短的话 */
            if(!final[w] &amp;&amp; (min+G.arc[k][w]&lt;(*D)[w]))
            { /*  说明找到了更短的路径，修改D[w]和P[w] */
                (*D)[w] = min + G.arc[k][w];  /* 修改当前路径长度 */
                (*P)[w]=k;
            }
        }
    }
}</code></pre>
<p>此算法的时间复杂度为O（n²）。  </p>
<h3 id="7-7-2-弗洛伊德（Floyd）算法"><a href="#7-7-2-弗洛伊德（Floyd）算法" class="headerlink" title="7.7.2 弗洛伊德（Floyd）算法"></a>7.7.2 弗洛伊德（Floyd）算法</h3><pre><code class="c">typedef int Patharc[MAXVEX][MAXVEX];
typedef int ShortPathTable[MAXVEX][MAXVEX];
/* Floyd算法，求网图G中各顶点v到其余顶点w的最短路径P[v][w]及带权长度D[v][w]。 */
void ShortestPath_Floyd(MGraph G, Patharc *P, ShortPathTable *D)
{
    int v,w,k;
    for(v=0; v&lt;G.numVertexes; ++v) /* 初始化D与P */  
    {
        for(w=0; w&lt;G.numVertexes; ++w)  
        {
            (*D)[v][w]=G.arc[v][w];    /* D[v][w]值即为对应点间的权值 */
            (*P)[v][w]=w;                /* 初始化P */
        }
    }
    for(k=0; k&lt;G.numVertexes; ++k)
    {
        for(v=0; v&lt;G.numVertexes; ++v)  
        {
            for(w=0; w&lt;G.numVertexes; ++w)
            {
                if ((*D)[v][w]&gt;(*D)[v][k]+(*D)[k][w])
                {/* 如果经过下标为k顶点路径比原两点间路径更短 */
                    (*D)[v][w]=(*D)[v][k]+(*D)[k][w];/* 将当前两点间权值设为更小的一个 */
                    (*P)[v][w]=(*P)[v][k];/* 路径设置为经过下标为k的顶点 */
                }
            }
        }
    }
}</code></pre>
<p>求最短路径的显示代码可以这样写：  </p>
<pre><code class="c">    for(v=0; v&lt;G.numVertexes; ++v)
    {
        for(w=v+1; w&lt;G.numVertexes; w++)  
        {
            printf(&quot;v%d-v%d weight: %d &quot;,v,w,D[v][w]);
            k=P[v][w];                /* 获得第一个路径顶点下标 */
            printf(&quot; path: %d&quot;,v);    /* 打印源点 */
            while(k!=w)                /* 如果路径顶点下标不是终点 */
            {
                printf(&quot; -&gt; %d&quot;,k);    /* 打印路径顶点 */
                k=P[k][w];            /* 获得下一个路径顶点下标 */
            }
            printf(&quot; -&gt; %d\n&quot;,w);    /* 打印终点 */
        }
        printf(&quot;\n&quot;);
    }</code></pre>
<p>再次回过头来看看弗洛伊德（Floyd）算法，它的代码简洁到就是一个二重循环初始化加一个三重循环权值修正，就完成了所有顶点到所有顶点的最短路径计算。几乎就如同是我们在学习C语言循环嵌套的样例代码而已。如此简单的实现，真是巧妙之极，在我看来，这是非常漂亮的算法，不知道你们是否喜欢？很可惜由于它的三重循环，因此也是O（n³）时间复杂度。如果你面临需要求所有顶点至所有顶点的最短路径问题时，弗洛伊德（Floyd）算法应该是不错的选择。  </p>
<h2 id="7-8-拓扑排序"><a href="#7-8-拓扑排序" class="headerlink" title="7.8 拓扑排序"></a>7.8 拓扑排序</h2><p>说了两个有环的图应用，现在我们来谈谈无环的图应用。无环，即是图中没有回路的意思。  </p>
<h3 id="7-8-1-拓扑排序介绍"><a href="#7-8-1-拓扑排序介绍" class="headerlink" title="7.8.1 拓扑排序介绍"></a>7.8.1 拓扑排序介绍</h3><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网（Activity On Vertex Network）。<br>设G=（V，E）是一个具有n个顶点的有向图，V中的顶点序列v1，V2，……，Vn，满足若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必在顶点vj之前。则我们称这样的顶点序列为一个拓扑序列。<br><strong>所谓拓扑排序，其实就是对一个有向图构造拓扑序列的过程。</strong>构造时会有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环（回路）的AOV网；如果输出顶点数少了，哪怕是少了一个，也说明这个网存在环（回路），不是AOV网。  </p>
<h3 id="7-8-2-拓扑排序算法"><a href="#7-8-2-拓扑排序算法" class="headerlink" title="7.8.2 拓扑排序算法"></a>7.8.2 拓扑排序算法</h3><p>对AOV网进行拓扑排序的基本思路是：从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AOV网中不存在入度为0的顶点为止。<br>首先我们需要确定一下这个图需要使用的数据结构。前面求最小生成树和最短路径时，我们用的都是邻接矩阵，但由于拓扑排序的过程中，需要删除顶点，显然用邻接表会更加方便。因此我们需要为AOV网建立一个邻接表。考虑到算法过程中始终要查找入度为0的顶点，我们在原来顶点表结点结构中，增加一个入度域in，结构如表7-8-1所示，其中in就是入度的数字。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-8-1.JPG?raw=true" srcset="/img/loading.gif" alt="7-8-1"><br>因此对于图7-8-2的第一幅图AOV网，我们可以得到如第二幅图的邻接表数据结构。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-8-2.JPG?raw=true" srcset="/img/loading.gif" alt="7-8-2"><br>在拓扑排序算法中，涉及的结构代码如下:</p>
<pre><code class="c">typedef struct EdgeNode /* 边表结点  */
{
    int adjvex;    /* 邻接点域，存储该顶点对应的下标 */
    int weight;        /* 用于存储权值，对于非网图可以不需要 */
    struct EdgeNode *next; /* 链域，指向下一个邻接点 */
}EdgeNode;

typedef struct VertexNode /* 顶点表结点 */
{
    int in;    /* 顶点入度 */
    int data; /* 顶点域，存储顶点信息 */
    EdgeNode *firstedge;/* 边表头指针 */
}VertexNode, AdjList[MAXVEX];

typedef struct
{
    AdjList adjList;
    int numVertexes,numEdges; /* 图中当前顶点数和边数 */
}graphAdjList,*GraphAdjList;</code></pre>
<p>在算法中，我还需要辅助的数据结构一栈，用来存储处理过程中入度为0的顶点，目的是为了避免每个查找时都要去遍历顶点表找有没有入度为0的顶点。<br>现在我们来看代码:  </p>
<pre><code class="c">/* 拓扑排序，若GL无回路，则输出拓扑排序序列并返回1，若有回路返回0。 */
Status TopologicalSort(GraphAdjList GL)
{
    EdgeNode *e;
    int i,k,gettop;
    int top=0;  /* 用于栈指针下标  */
    int count=0;/* 用于统计输出顶点的个数  */
    int *stack;    /* 建栈将入度为0的顶点入栈  */
    stack=(int *)malloc(GL-&gt;numVertexes * sizeof(int) );

    for(i = 0; i&lt;GL-&gt;numVertexes; i++)
        if(0 == GL-&gt;adjList[i].in) /* 将入度为0的顶点入栈 */
            stack[++top]=i;
    while(top!=0)
    {
        gettop=stack[top--];  /* 出栈 */
        printf(&quot;%d -&gt; &quot;,GL-&gt;adjList[gettop].data);
        count++;        /* 输出i号顶点，并计数 */
        for(e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next)
        {/* 对此顶点弧表遍历 */
            k=e-&gt;adjvex;
            if( !(--GL-&gt;adjList[k].in) )  /* 将k号顶点的邻接点的入度减1，如果减1后为0，则入栈 */
                stack[++top]=k;
        }
    }
    printf(&quot;\n&quot;);
    if(count &lt; GL-&gt;numVertexes)/* 如果 count小于顶点数，说明存在环 */
        return ERROR;
    else
        return OK;
}</code></pre>
<p>分析整个算法，对一个具有n个顶点e条弧的AOV网来说，扫描顶点表，将入度为0的顶点入栈的时间复杂为O（n），而之后的while循环中，每个顶点进一次栈，出一次栈，入度减1的操作共执行了e次，所以整个算法的时间复杂度为O（n+e）。  </p>
<h2 id="7-9-关键路径"><a href="#7-9-关键路径" class="headerlink" title="7.9 关键路径"></a>7.9 关键路径</h2><p>在前面讲了AOV网的基础上，我们来介绍一个新的概念。在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为AOE网（Activity On Edge Network）。<br>我们把AOE网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点。<br>我们把路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动。<br>如果我们需要缩短整个工期，去改进轮子的生产效率，哪怕改动成0.1也是无益于整个工期的变化，只有缩短关键路径上的关键活动时间才可以减少整个工期长度。<br>那么现在的问题就是如何找出关键路径。  </p>
<h3 id="7-9-1-关键路径算法原理"><a href="#7-9-1-关键路径算法原理" class="headerlink" title="7.9.1 关键路径算法原理"></a>7.9.1 关键路径算法原理</h3><p>我们只需要找到所有活动的最早开始时间和最晚开始时间，并且比较它们，如果相等就意味着此活动是关键活动，活动间的路径为关键路径。如果不等，则就不是。<br>为此，我们需要定义如下几个参数。</p>
<ol>
<li>事件的最早发生时间etv（earliest time of vertex）：即顶点vk的最早发生时间。</li>
<li>事件的最晚发生时间ltv（latest time of vertex）：即顶点Vk的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期。</li>
<li>活动的最早开工时间ete（earliest time ofedge）：即弧ak的最早发生时间。</li>
<li>活动的最晚开工时间lte（latest time of edge）：即弧ak的最晚发生时间，也就是不推迟工期的最晚开工时间。  </li>
</ol>
<p>我们是由1和2可以求得3和4，然后再根据ete[k]是否与lte[k]相等来判断ak是否是关键活动。  </p>
<h3 id="7-9-2-关键路径算法"><a href="#7-9-2-关键路径算法" class="headerlink" title="7.9.2 关键路径算法"></a>7.9.2 关键路径算法</h3><p>我们将图7-9-2的AOE网转化为邻接表结构如图7-9-4所示，注意与拓扑排序时邻接表结构不同的地方在于，这里弧链表增加了weight域，用来存储弧的权值。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-9-4.JPG?raw=true" srcset="/img/loading.gif" alt="7-9-4"><br>求事件的最早发生时间etv的过程，就是我们从头至尾找拓扑序列的过程，因此，在求关键路径之前，需要先调用一次拓扑序列算法的代码来计算etv和拓扑序列列表。为此，我们首先在程序开始处声明几个全局变量。  </p>
<pre><code class="c">int *etv,*ltv; /* 事件最早发生时间和最迟发生时间数组，全局变量 */
int *stack2;   /* 用于存储拓扑序列的栈 */
int top2;      /* 用于stack2的指针 */</code></pre>
<p>其中stack2用来存储拓扑序列，以便后面求关键路径时使用。<br>下面是改进过的求拓扑序列算法。  </p>
<pre><code class="c">/* 拓扑排序,用于关键路径计算 */
Status TopologicalSort(GraphAdjList GL)
{    /* 若GL无回路，则输出拓扑排序序列并返回1，若有回路返回0。 */
    EdgeNode *e;
    int i,k,gettop;
    int top=0;  /* 用于栈指针下标  */
    int count=0;/* 用于统计输出顶点的个数 */
    int *stack;    /* 建栈将入度为0的顶点入栈  */
    stack=(int *)malloc(GL-&gt;numVertexes * sizeof(int) );
    for(i = 0; i&lt;GL-&gt;numVertexes; i++)
        if(0 == GL-&gt;adjList[i].in) /* 将入度为0的顶点入栈 */
            stack[++top]=i;

    top2=0;         /* 初始化为0 */
    etv=(int *)malloc(GL-&gt;numVertexes * sizeof(int) ); /* 事件最早发生时间数组 */
    for(i=0; i&lt;GL-&gt;numVertexes; i++)
        etv[i]=0;    /* 初始化为0 */
    stack2=(int *)malloc(GL-&gt;numVertexes * sizeof(int) );/* 初始化拓扑序列栈 */

    printf(&quot;TopologicalSort:\t&quot;);
    while(top!=0)
    {
        gettop=stack[top--];
        printf(&quot;%d -&gt; &quot;,GL-&gt;adjList[gettop].data);
        count++;        /* 输出i号顶点，并计数 */

        stack2[++top2]=gettop;        /* 将弹出的顶点序号压入拓扑序列的栈 */

        for(e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next)
        {
            k=e-&gt;adjvex;
            if( !(--GL-&gt;adjList[k].in) )        /* 将i号顶点的邻接点的入度减1，如果减1后为0，则入栈 */
                stack[++top]=k;

            if((etv[gettop] + e-&gt;weight)&gt;etv[k])    /* 求各顶点事件的最早发生时间etv值 */
                etv[k] = etv[gettop] + e-&gt;weight;
        }
    }
    if(count &lt; GL-&gt;numVertexes)
        return ERROR;
    else
        return OK;
}</code></pre>
<p>下面我们来看求关键路径的算法代码。</p>
<pre><code class="c">/* 求关键路径,GL为有向网，输出G的各项关键活动 */
void CriticalPath(GraphAdjList GL)
{
    EdgeNode *e;
    int i,gettop,k,j;
    int ete,lte;  /* 声明活动最早发生时间和最迟发生时间变量 */
    TopologicalSort(GL);   /* 求拓扑序列，计算数组etv和stack2的值 */
    ltv=(int *)malloc(GL-&gt;numVertexes*sizeof(int));/* 事件最早发生时间数组 */
    for(i=0; i&lt;GL-&gt;numVertexes; i++)
        ltv[i]=etv[GL-&gt;numVertexes-1];    /* 初始化 */
    while(top2!=0)    /* 出栈是求ltv */
    {
        gettop=stack2[top2--];
        for(e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next)
        {/* 求各顶点事件的最迟发生时间ltv值 */
            k=e-&gt;adjvex;
            if(ltv[k] - e-&gt;weight &lt; ltv[gettop])
                ltv[gettop] = ltv[k] - e-&gt;weight;
        }
    }
    for(j=0; j&lt;GL-&gt;numVertexes; j++)        /* 求ete,lte和关键活动 */
    {
        for(e = GL-&gt;adjList[j].firstedge; e; e = e-&gt;next)
        {
            k=e-&gt;adjvex;
            ete = etv[j];        /* 活动最早发生时间 */
            lte = ltv[k] - e-&gt;weight; /* 活动最迟发生时间 */
            if(ete == lte)    /* 两者相等即在关键路径上 */
                printf(&quot;&lt;v%d - v%d&gt; length: %d \n&quot;,GL-&gt;adjList[j].data,GL-&gt;adjList[k].data,e-&gt;weight);
        }
    }
}</code></pre>
<p>最终求关键路径算法的时间复杂度依然是O（n+e）。<br>实践证明，通过这样的算法对于工程的前期工期估算和中期的计划调整都有很大的帮助。不过注意，本例是唯一一条关键路径，这并不等于不存在多条关键路径的有向无环图。如果是多条关键路径，则单是提高一条关键路径上的关键活动的速度并不能导致整个工程缩短工期，而必须提高同时在几条关键路径上的活动的速度。这就像仅仅是有事业的成功，而没有健康的身体以及快乐的生活，是根本谈不上幸福的人生一样，三者缺一不可。  </p>
<h2 id="7-10-总结回顾"><a href="#7-10-总结回顾" class="headerlink" title="7.10 总结回顾"></a>7.10 总结回顾</h2><p>图是计算机科学中非常常用的一类数据结构，有许许多多的计算问题都是用图来定义的。由于图也是最复杂的数据结构，对它讲解时，涉及到数组、链表、栈、队列、树等之前学的几乎所有数据结构。因此从某种角度来说，学好了图，基本就等于理解了数据结构这门课的精神。<br>我们在图的定义这一节，介绍了一大堆定义和术语，一开始可能会有些迷茫，不过一回生二回熟，多读几遍，基本都可以理解并记住它们的特征，在图的定义这一节的末尾，我们已经有所总结，这里就不再赘述了。<br>图的存储结构我们一共讲了五种，如图7-10-1所示，其中比较重要的是邻接矩阵和邻接表，它们分别代表着边集是用数组还是链表的方式存储。十字链表是邻接矩阵的一种升级，而邻接多重表则是邻接表的升级。边集数组更多考虑的是对边的关注。用什么存储结构需要具体问题具体分析，通常稠密图，或读存数据较多，结构修改较少的图，用邻接矩阵要更合适，反之则应该考虑邻接表。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0/7-10-1.JPG?raw=true" srcset="/img/loading.gif" alt="7-10-1"><br>图的遍历分为深度和广度两种，各有优缺点，就像人在追求卓越时，是着重深度还是看重广度，总是很难说得清楚。<br>图的应用是我们这一章浓墨重彩的一部分，一共谈了三种应用：最小生成树、最短路径和有向无环图的应用。<br>最小生成树，我们讲了两种算法：普里姆（Prim）算法和克鲁斯卡尔（Kruskal）算法。普里姆算法像是走一步看一步的思维方式，逐步生成最小生成树。而克鲁斯卡尔算法则更有全局意识，直接从图中最短权值的边入手，找寻最后的答案。<br>最短路径的现实应用非常多，我们也介绍了两种算法。迪杰斯特拉（Dijkstra）算法更强调单源顶点查找路径的方式，比较符合我们正常的思路，容易理解原理，但算法代码相对复杂。而弗洛伊德（Floyd）算法则完全抛开了单点的局限思维方式，巧妙地应用矩阵的变换，用最清爽的代码实现了多顶点间最短路径求解的方案，原理理解有难度，但算法编写很简洁。<br>有向无环图时常应用于工程规划中，对于整个工程或系统来说，我们一方面关心的是工程能否顺利进行的问题，通过拓扑排序的方式，我们可以有效地分析出一个有向图是否存在环，如果不存在，那它的拓扑序列是什么？另一方面关心的是整个工程完成所必须的最短时间问题，利用求关键路径的算法，可以得到最短完成工程的工期以及关键的活动有哪些。  </p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构第六章 树</title>
    <url>/2019/12/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC6%E7%AB%A0%20%E6%A0%91/</url>
    <content><![CDATA[<h2 id="6-1-6-2-树的定义"><a href="#6-1-6-2-树的定义" class="headerlink" title="6.1-6.2 树的定义"></a>6.1-6.2 树的定义</h2><p><strong>树(Tree)是n(n≥0)个结点的有限集。n=0时称为空树。在任意一棵非空树中：1)有且仅有一个特定的称为根(Root)的结点；2)当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。</strong> </p>
<a id="more"></a>

<p>对于树的定义还需要强调两点：  </p>
<ol>
<li>n&gt;0时根结点是唯一的，不可能存在多个根结点，数据结构中的树是只能有一个根结点。</li>
<li>m&gt;0时，子树的个数没有限制，但它们一定是互不相交的。  </li>
</ol>
<h3 id="6-2-1-结点分类"><a href="#6-2-1-结点分类" class="headerlink" title="6.2.1 结点分类"></a>6.2.1 结点分类</h3><p>树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。如图6-2-4所示，因为这棵树结点的度的最大值是结点D的度为3，所以树的度也为3。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-2-4.JPG?raw=true" srcset="/img/loading.gif" alt="6-2-4">  </p>
<h3 id="6-2-2-结点间关系"><a href="#6-2-2-结点间关系" class="headerlink" title="6.2.2 结点间关系"></a>6.2.2 结点间关系</h3><p>结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）。同一个双亲的孩子之间互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。  </p>
<h3 id="6-2-3-树的其他相关概念"><a href="#6-2-3-树的其他相关概念" class="headerlink" title="6.2.3 树的其他相关概念"></a>6.2.3 树的其他相关概念</h3><p>结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。其双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度。<br>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。<br>森林（Forest）是m（m&gt;0）棵互不相交的树的集合。<br>对比线性表与树的结构，它们有很大的不同，如图6-2-7所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-2-7.JPG?raw=true" srcset="/img/loading.gif" alt="6-2-7"></p>
<h2 id="6-3-树的抽象数据类型"><a href="#6-3-树的抽象数据类型" class="headerlink" title="6.3 树的抽象数据类型"></a>6.3 树的抽象数据类型</h2><pre><code class="c">ADT 树（tree）
Data
  树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。
Operation
  InitTree（*T）：构造空树T。
  DestroyTree（*T）：销毁树T。
  CreateTree（*T，definition）：按definition中给出树的定义来构造树。
  ClearTree（*T）：若树T存在，则将树T清为空树。
  TreeEmpty（T）：若T为空树，返回true，否则返回false。
  TreeDepth（T）：返回T的深度。
  Root（T）：返回T的根结点。
  Value（T，cur_e）：cur_e是树T中一个结点，返回此结点的值。
  Assign（T，cur_e，value）：给树T的结点cur_e赋值为value。
  Parent（T，cur_e）：若cur_e是树T的非根结点，则返回它的双亲，否则返回空。
  LeftChild（T，cure）：若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空。
  RightSibling（T，cur_e）：若cur_e有右兄弟，则返回它的右兄弟，否则返回空。
  InsertChild（*T，*p，i，c）：其中p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树。
  DeleteChild（*T，*p，i）：其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树。
endADT</code></pre>
<h2 id="6-4-树的存储结构"><a href="#6-4-树的存储结构" class="headerlink" title="6.4 树的存储结构"></a>6.4 树的存储结构</h2><p>充分利用顺序存储和链式存储结构的特点，可以实现对树的存储结构的表示。我们这里要介绍三种不同的表示法：双亲表示法、孩子表示法、孩子兄弟表示法。  </p>
<h3 id="6-4-1-双亲表示法"><a href="#6-4-1-双亲表示法" class="headerlink" title="6.4.1 双亲表示法"></a>6.4.1 双亲表示法</h3><p>树除了根结点外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲。<br>我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。<br>data数据域，存储结点的数据信息。而parent指针域，存储该结点的双亲在数组中的下标。<br>以下是我们的双亲表示法的结点结构定义代码:  </p>
<pre><code class="c">/* 树的双亲表示法结点结构定义 */
#define MAX_TREE_SIZE 100 /* 二叉树的最大结点数 */
typedef int TElemType;  /* 树结点的数据类型，目前暂定为整型 */
typedef struct PTNode/*结点结构*/
{
  TElemType data;/*结点数据*/
  int parent;/*双亲位置*/
}PTNode;
typedef struct /* 树结构 */
{
  PTNode nodes[MAX_TREE_SI2E];/* 结点数组 */
  int r，n;/* 根的位置和结点数 */
}PTree;</code></pre>
<p>有了这样的结构定义，我们就可以来实现双亲表示法了。由于根结点是没有双亲的，所以我们约定根结点的位置域设置为-1，这也就意味着，我们所有的结点都存有它双亲的位置。如图6-4-1中的树结构和表6-4-2中的树双亲表示所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-1.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-1">  </p>
<p>这样的存储结构，我们可以根据结点的parent指针很容易找到它的双亲结点，所用的时间复杂度为O(1)，直到parent为-1时，表示找到了树结点的根。可如果我们要知道结点的孩子是什么，请遍历整个结构才行。如何改进呢？<br>我们增加一个结点最左边孩子的域，不妨叫它长子域，这样就可以很容易得到结点的孩子。如果没有孩子的结点，这个长子域就设置为-1，如表6-4-3所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-3.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-3">  </p>
<p>对于有0个或1个孩子结点来说，这样的结构是解决了要找结点孩子的问题了。甚至是有2个孩子，知道了长子是谁，另一个当然就是次子了。<br>另外一个问题是，我们很关注各兄弟之间的关系，双亲表示法无法体现这样的关系，那我们怎么办？嗯，可以增加一个右兄弟域来体现兄弟关系，也就是说，每一个结点如果它存在右兄弟，则记录下右兄弟的下标。同样的，如果右兄弟不存在，则赋值为-1。<br>但如果结点的孩子很多，超过了2个。我们又关注结点的双亲、又关注结点的孩子、还关注结点的兄弟，而且对时间遍历要求还比较高，那么我们还可以把此结构扩展为有双亲域、长子域、再有右兄弟域。存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。注意也不是越多越好，有需要时再设计相应的结构。  </p>
<h3 id="6-4-2-孩子表示法"><a href="#6-4-2-孩子表示法" class="headerlink" title="6.4.2 孩子表示法"></a>6.4.2 孩子表示法</h3><p>换一种完全不同的考虑方法。由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。不过，树的每个结点的度，也就是它的孩子个数是不同的。所以可以设计两种方案来解决。  </p>
<h4 id="6-4-2-1-方案一"><a href="#6-4-2-1-方案一" class="headerlink" title="6.4.2.1 方案一"></a>6.4.2.1 方案一</h4><p>一种是指针域的个数就等于树的度，复习一下，树的度是树各个结点度的最大值。其结构如表6-4-5所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-5.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-5"><br>其中data是数据域。child1到child d是指针域，用来指向该结点的孩子结点。<br>对于图6-4-1的树来说，树的度是3，所以我们的指针域的个数是3，这种方法实现如图6-4-2所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-2.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-2"><br>这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。不过如果树的各结点度相差很小时，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。<br>既然很多指针域都可能为空，那么我们可以按需分配空间。  </p>
<h4 id="6-4-2-2-方案二"><a href="#6-4-2-2-方案二" class="headerlink" title="6.4.2.2 方案二"></a>6.4.2.2 方案二</h4><p>第二种方案每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数，其结构如表6-4-6所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-6.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-6"><br>其中data为数据域，degree为度域，也就是存储该结点的孩子结点的个数，child1到child d为指针域，指向该结点的各个孩子的结点。<br>对于图6-4-2的树来说，这种方法实现如图6-4-3所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-7.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-7"><br>这种方法克服了浪费空间的缺点，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。  </p>
<p>孩子表示法。具体办法是，<strong>把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</strong>，如图6-4-4所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-8.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-8"><br>以下是我们的孩子表示法的结构定义代码:  </p>
<pre><code class="c">/*树的孩子表示法结构定义*/
#define MAX_TREE_SIZE 100
typedef struct cTNode/* 孩子结点 */
{
  int child;
  struct CTNode *next;
}*ChildPtr;
typedef struct  /* 表头结构 */
{
  TElemType data;
  ChildPtr firstChild;
}CTBox;
typedef struct  /* 树结构 */
{
  CTBox nodes[MAX_TREE_SIZE];  /* 结点数组 */
  int r，n;  /* 根的位置和结点数 */
}CTree;</code></pre>
<p>这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。<br>但是，这也存在着问题，我如何知道某个结点的双亲是谁呢？比较麻烦，需要整棵树遍历才行，难道就不可以把双亲表示法和孩子表示法综合一下吗？当然是可以。如图6-4-5所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-9.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-9"><br>我们把这种方法称为双亲孩子表示法。</p>
<h3 id="6-4-3-孩子兄弟表示法"><a href="#6-4-3-孩子兄弟表示法" class="headerlink" title="6.4.3 孩子兄弟表示法"></a>6.4.3 孩子兄弟表示法</h3><p><strong>我们观察后发现，任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。</strong><br>结点结构如下所示。<br>data | firstChild | rightSib<br>—–|————|———<br>其中data是数据域，firstChild为指针域，存储该结点的第一个孩子结点的存储地址，rightSib是指针域，存储该结点的右兄弟结点的存储地址。<br>结构定义代码如下:  </p>
<pre><code class="c">/*树的孩子兄弟表示法结构定义*/
typedef struct CSNode
{
  TElemType data;
  struct CSNode *firstChild， *rightSib;
}CSNode,*CSTree;</code></pre>
<p>对于图6-4-1的树来说，这种方法实现的示意图如图6-4-6所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-4-10.JPG?raw=true" srcset="/img/loading.gif" alt="6-4-10"><br>这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过firstChild找到此结点的长子，然后再通过长子结点的rightSib找到它的二弟，接着一直下去，直到找到具体的孩子。</p>
<h2 id="6-5-二叉树的定义"><a href="#6-5-二叉树的定义" class="headerlink" title="6.5 二叉树的定义"></a>6.5 二叉树的定义</h2><p><strong>二叉树（Binary Tree）是n（n≥0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</strong></p>
<h3 id="6-5-1-二叉树特点"><a href="#6-5-1-二叉树特点" class="headerlink" title="6.5.1 二叉树特点"></a>6.5.1 二叉树特点</h3><p>二叉树的特点有：</p>
<ul>
<li>每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。</li>
<li>左子树和右子树是有顺序的，次序不能任意颠倒。</li>
<li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。  </li>
</ul>
<p>二叉树具有五种基本形态：</p>
<ol>
<li>空二叉树。</li>
<li>只有一个根结点。</li>
<li>根结点只有左子树。</li>
<li>根结点只有右子树。</li>
<li>根结点既有左子树又有右子树。</li>
</ol>
<h3 id="6-5-2-特殊二叉树"><a href="#6-5-2-特殊二叉树" class="headerlink" title="6.5.2 特殊二叉树"></a>6.5.2 特殊二叉树</h3><p>一、斜树:所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p>
<p>二、满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。<br>满二叉树的特点有：</p>
<ul>
<li>叶子只能出现在最下一层。出现在其他层就不可能达成平衡。</li>
<li>非叶子结点的度一定是2。否则就是“缺胳膊少腿”了。</li>
<li>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li>
</ul>
<p>三、完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。<br>完全二叉树的特点：</p>
<ol>
<li>叶子结点只能出现在最下两层。</li>
<li>最下层的叶子一定集中在左部连续位置。</li>
<li>倒数二层，若有叶子结点，一定都在右部连续位置。</li>
<li>如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。</li>
<li>同样结点数的二叉树，完全二叉树的深度最小。</li>
</ol>
<h2 id="6-6-二叉树的性质"><a href="#6-6-二叉树的性质" class="headerlink" title="6.6 二叉树的性质"></a>6.6 二叉树的性质</h2><p>二叉树有一些需要理解并记住的特性，以便于我们更好地使用它。</p>
<h3 id="6-6-1-二叉树性质1"><a href="#6-6-1-二叉树性质1" class="headerlink" title="6.6.1 二叉树性质1"></a>6.6.1 二叉树性质1</h3><p>性质1：在二叉树的第i层上至多有$2^{i-1}$个结点（i≥1）。</p>
<h3 id="6-6-2-二叉树性质2"><a href="#6-6-2-二叉树性质2" class="headerlink" title="6.6.2 二叉树性质2"></a>6.6.2 二叉树性质2</h3><p>性质2：深度为k的二叉树至多有$2^k-1$个结点（k≥1）。</p>
<h3 id="6-6-3-二叉树性质3"><a href="#6-6-3-二叉树性质3" class="headerlink" title="6.6.3 二叉树性质3"></a>6.6.3 二叉树性质3</h3><p>性质3：对任何一棵二叉树T，如果其叶子结点数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$。  </p>
<h3 id="6-6-4-二叉树性质4"><a href="#6-6-4-二叉树性质4" class="headerlink" title="6.6.4 二叉树性质4"></a>6.6.4 二叉树性质4</h3><p>性质4：具有n个结点的完全二叉树的深度为[㏒$_2$n]+1（[x]表示不大于x的最大整数）。</p>
<h3 id="6-6-5-二叉树性质5"><a href="#6-6-5-二叉树性质5" class="headerlink" title="6.6.5 二叉树性质5"></a>6.6.5 二叉树性质5</h3><p>性质5：如果对一棵有n个结点的完全二叉树（其深度为[㏒$_2$n]+1）的结点按层序编号（从第1层到第[㏒$_2$n]+1层，每层从左到右），对任一结点i（1≤i≤n）有：</p>
<ol>
<li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点[i/2]。</li>
<li>如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。</li>
<li>如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1。</li>
</ol>
<h2 id="6-7-二叉树的存储结构"><a href="#6-7-二叉树的存储结构" class="headerlink" title="6.7 二叉树的存储结构"></a>6.7 二叉树的存储结构</h2><h3 id="6-7-1-二叉树顺序存储结构"><a href="#6-7-1-二叉树顺序存储结构" class="headerlink" title="6.7.1 二叉树顺序存储结构"></a>6.7.1 二叉树顺序存储结构</h3><p>二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系。<br>所以用来表示完全二叉树比较好。由于它定义的严格，所以用顺序结构也可以表现出二叉树的结构来。<br>当然对于一般的二叉树，尽管层序编号不能反映逻辑关系，但是可以将其按完全二叉树编号，只不过，把不存在的结点设置为“^”而已。如图6-7-3所示，浅色结点表示不存在。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-7-3.JPG?raw=true" srcset="/img/loading.gif" alt="6-7-3"><br>但是对于一般二叉树，一棵深度为k的右斜树，它只有k个结点，却需要分配$2^k$-1个存储单元空间，这显然是对存储空间的浪费。<br>所以，顺序存储结构一般只用于完全二叉树。  </p>
<h3 id="6-7-2-二叉链表"><a href="#6-7-2-二叉链表" class="headerlink" title="6.7.2 二叉链表"></a>6.7.2 二叉链表</h3><p>链式存储结构中。二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。结点结构图如表格6-7-1所示。<br>lChild|data|rChild|<br>–|–|–<br>其中data是数据域，lChild和rChild都是指针域，分别存放指向左孩子和右孩子的指针。<br>以下是我们的二叉链表的结点结构定义代码。</p>
<pre><code class="c">typedef struct BiTNode  /* 结点结构 */
{
   TElemType data;    /* 结点数据 */
   struct BiTNode *lchild,*rchild; /* 左右孩子指针 */
}BiTNode,*BiTree;</code></pre>
<p>就如同树的存储结构中讨论的一样，如果有需要，还可以再增加一个指向其双亲的指针域，那样就称之为三叉链表。  </p>
<h2 id="6-8遍历二叉树"><a href="#6-8遍历二叉树" class="headerlink" title="6.8遍历二叉树"></a>6.8遍历二叉树</h2><h3 id="6-8-1二叉树遍历原理"><a href="#6-8-1二叉树遍历原理" class="headerlink" title="6.8.1二叉树遍历原理"></a>6.8.1二叉树遍历原理</h3><p>二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。  </p>
<h3 id="6-8-2二叉树遍历方法"><a href="#6-8-2二叉树遍历方法" class="headerlink" title="6.8.2二叉树遍历方法"></a>6.8.2二叉树遍历方法</h3><p>二叉树的遍历方式可以很多，如果我们限制了从左到右的习惯方式，那么主要就分为四种：  </p>
<ol>
<li><p>前序遍历-根左右<br>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</p>
</li>
<li><p>中序遍历-左根右<br>规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。</p>
</li>
<li><p>后序遍历-左右根<br>规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。</p>
</li>
<li><p>层序遍历<br>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p>
</li>
</ol>
<p>技巧：每个结点单独看。比如后序遍历，每个右结点的左边是该结点的左节点，右边必然是对应的根结点。</p>
<h3 id="6-8-3-前序遍历算法"><a href="#6-8-3-前序遍历算法" class="headerlink" title="6.8.3 前序遍历算法"></a>6.8.3 前序遍历算法</h3><p>二叉树的定义是用递归的方式，所以，实现遍历算法也可以采用递归，而且极其简洁明了。先来看看二叉树的前序遍历算法。代码如下：  </p>
<pre><code class="c">/* 二叉树的前序遍历递归算法 */
void PreOrderTraverse(BiTree T)
{
    if (T == NULL)
        return;
    printf(&quot;%c&quot;, T-&gt;data); /* 显示结点数据，可以更改为其它对结点操作 */
    PreOrderTraverse(T-&gt;lchild); /* 再先序遍历左子树 */
    PreOrderTraverse(T-&gt;rchild); /* 最后先序遍历右子树 */
}</code></pre>
<h3 id="6-8-4-中序遍历算法"><a href="#6-8-4-中序遍历算法" class="headerlink" title="6.8.4 中序遍历算法"></a>6.8.4 中序遍历算法</h3><p>二叉树的中序遍历算法和前序遍历算法仅仅只是代码的顺序上的差异。</p>
<pre><code class="c">/* 二叉树的中序遍历递归算法 */
void InOrderTraverse(BiTree T)
{
    if (T == NULL)
        return;
    InOrderTraverse(T-&gt;lchild); /* 中序遍历左子树 */
    printf(&quot;%c&quot;, T-&gt;data);/* 显示结点数据，可以更改为其它对结点操作 */
    InOrderTraverse(T-&gt;rchild); /* 最后中序遍历右子树 */
}</code></pre>
<h3 id="6-8-5后序遍历算法"><a href="#6-8-5后序遍历算法" class="headerlink" title="6.8.5后序遍历算法"></a>6.8.5后序遍历算法</h3><p>那么同样的，后序遍历也就很容易想到应该如何写代码了。</p>
<pre><code class="c">/* 二叉树的后序遍历递归算法 */
void PostOrderTraverse(BiTree T)
{
    if (T == NULL)
        return;
    PostOrderTraverse(T-&gt;lchild); /* 先后序遍历左子树  */
    PostOrderTraverse(T-&gt;rchild); /* 再后序遍历右子树  */
    printf(&quot;%c&quot;, T-&gt;data);/* 显示结点数据，可以更改为其它对结点操作 */
}</code></pre>
<h3 id="6-8-6-推导遍历结果"><a href="#6-8-6-推导遍历结果" class="headerlink" title="6.8.6 推导遍历结果"></a>6.8.6 推导遍历结果</h3><p>题目是这样：二叉树的中序序列是ABCDEFG，后序序列是BDCAFGE，求前序序列。<br>这次简单点，由后序的BDCAFG E，得到E是根结点，因此前序首字母是E。<br>于是根据中序序列分为两棵树ABCD和FG，由后序序列的BDCA FGE，知道A是E的左孩子，前序序列目前分析为EA。<br>再由中序序列的A BCDEFG，知道BCD是A结点的右子孙，再由后序序列的BDC AFGE知道C结点是A结点的右孩子，前序序列目前分析得到EAC。<br>中序序列AB C DEFG，得到B是C的左孩子，D是C的右孩子，所以前序序列目前分析结果为EACBD。<br>由后序序列BDCAF G E，得到G是E的右孩子，于是F就是G的孩子。前序遍历序列的最终结果就是EACBDGF。  </p>
<p>两个二叉树遍历的性质。</p>
<ul>
<li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li>
<li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li>
</ul>
<p>但要注意了，已知前序和后序遍历，是不能确定一棵二叉树的，原因也很简单，比如前序序列是ABC，后序序列是CBA。我们可以确定A一定是根结点，但接下来，我们无法知道，哪个结点是左子树，哪个是右子树。这棵树可能有如图6-8-24所示的四种可能。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-8-24.JPG?raw=true" srcset="/img/loading.gif" alt="6-8-24">  </p>
<h2 id="6-9-二叉树的建立"><a href="#6-9-二叉树的建立" class="headerlink" title="6.9 二叉树的建立"></a>6.9 二叉树的建立</h2><p>如果我们要在内存中建立一个二叉树，为了能让每个结点确认是否有左右孩子，我们对它进行了扩展，也就是将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，比如“#”。我们称这种处理后的二叉树为原二叉树的扩展二叉树。扩展二叉树就可以做到一个遍历序列确定一棵二叉树了。<br>前序遍历序列生成二叉树的代码如下：</p>
<pre><code class="c">/* 按前序输入二叉树中结点的值（一个字符） */
/* #表示空树，构造二叉链表表示二叉树T。 */
void CreateBiTree(BiTree *T)
{
    TElemType ch;
    /* scanf(&quot;%c&quot;,&amp;ch); */
    ch = str[index++];
    if (ch == &#39;#&#39;)
        *T = NULL;
    else
    {
        *T = (BiTree)malloc(sizeof(BiTNode));
        if (!*T)
            exit(OVERFLOW);
        (*T)-&gt;data = ch; /* 生成根结点 */
        CreateBiTree(&amp;(*T)-&gt;lchild); /* 构造左子树 */
        CreateBiTree(&amp;(*T)-&gt;rchild); /* 构造右子树 */
    }
}</code></pre>
<p>当然，你完全也可以用中序或后序遍历的方式实现二叉树的建立，只不过代码里生成结点和构造左右子树的代码顺序交换一下。另外，输入的字符也要做相应的更改。</p>
<h2 id="6-10-线索二叉树"><a href="#6-10-线索二叉树" class="headerlink" title="6.10 线索二叉树"></a>6.10 线索二叉树</h2><h3 id="6-10-1-线索二叉树原理"><a href="#6-10-1-线索二叉树原理" class="headerlink" title="6.10.1 线索二叉树原理"></a>6.10.1 线索二叉树原理</h3><p><strong>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）。</strong><br>其实线索二叉树，等于是把一棵二叉树转变成了一个双向链表，这样对我们的插入删除结点、查找某个结点都带来了方便。所以<strong>我们对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化</strong>。<br>但是变为线索二叉树，我们并不知道某个结点的lChild是指向它的左孩子还是指向前驱…<br>因此，我们在每个结点再增设两个标志域lTag和rTag，注意lTag和rTag只是存放0或1数字的布尔型变量，其占用的内存空间要小于像lchild和rchild的指针变量。结点结构如下表所示。<br>lChild|lTag|data|rTag|rChild<br>-|-|-|-|-<br>其中：</p>
<ul>
<li>lTag为0时指向该结点的左孩子，为1时指向该结点的前驱。</li>
<li>rTag为0时指向该结点的右孩子，为1时指向该结点的后继。</li>
</ul>
<h3 id="6-10-2-线索二叉树结构实现"><a href="#6-10-2-线索二叉树结构实现" class="headerlink" title="6.10.2 线索二叉树结构实现"></a>6.10.2 线索二叉树结构实现</h3><p>由此二叉树的线索存储结构定义代码如下：</p>
<pre><code class="c">/* 二叉树的二叉线索存储结构定义 */
typedef enum { Link, Thread } PointerTag; /* Link==0表示指向左右孩子指针, */
                                          /* Thread==1表示指向前驱或后继的线索 */
typedef  struct BiThrNode                 /* 二叉线索存储结点结构 */
{
    TElemType data;    /* 结点数据 */
    struct BiThrNode *lchild, *rchild;    /* 左右孩子指针 */
    PointerTag LTag;
    PointerTag RTag;        /* 左右标志 */
} BiThrNode, *BiThrTree;</code></pre>
<p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以<strong>线索化的过程就是在遍历的过程中修改空指针的过程</strong>。<br>中序遍历线索化的递归函数代码如下：</p>
<pre><code class="c">BiThrTree pre; /* 全局变量,始终指向刚刚访问过的结点 */
/* 中序遍历进行中序线索化 */
void InThreading(BiThrTree p)
{
    if (p)
    {
        InThreading(p-&gt;lchild); /* 递归左子树线索化 */
        if (!p-&gt;lchild) /* 没有左孩子 */
        {
            p-&gt;LTag = Thread; /* 前驱线索 */
            p-&gt;lchild = pre; /* 左孩子指针指向前驱 */
        }
        if (!pre-&gt;rchild) /* 前驱没有右孩子 */
        {
            pre-&gt;RTag = Thread; /* 后继线索 */
            pre-&gt;rchild = p; /* 前驱右孩子指针指向后继(当前结点p) */
        }
        pre = p; /* 保持pre指向p的前驱 */
        InThreading(p-&gt;rchild); /* 递归右子树线索化 */
    }
}</code></pre>
<p>if（!p-&gt;lChild）表示如果某结点的左指针域为空，因为其前驱结点刚刚访问过，赋值给了pre，所以可以将pre赋值给p-&gt;lChild，并修改p-&gt;LTag=Thread（也就是定义为1）以完成前驱结点的线索化。<br>后继就要稍稍麻烦一些。因为此时p结点的后继还没有访问到，因此只能对它的前驱结点pre的右指针rchild做判断，if（!pre-&gt;rchild）表示如果为空，则p就是pre的后继，于是pre-&gt;rchild=p，并且设置pre-&gt;RTag=Thread，完成后继结点的线素化。<br>完成前驱和后继的判断后，别忘记将当前的结点p赋值给pre，以便于下一次使用。<br>有了线索二叉树后，我们对它进行遍历时发现，其实就等于是操作一个双向链表结构。<br>和双向链表结构一样，在二叉树线素链表上添加一个头结点，如图6-10-6所示，并令其lchild域的指针指向二叉树的根结点（图中的①），其rchild域的指针指向中序遍历时访问的最后一个结点（图中的②）。反之，令二叉树的中序序列中的第一个结点中，lchild 域指针和最后一个结点的rchild 域指针均指向头结点（图中的③和④）。这样定义的好处就是我们既可以从第一个结点起顺后继进行遍历，也可以从最后一个结点起顺前驱进行遍历。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-10-6.JPG?raw=true" srcset="/img/loading.gif" alt="6-10-6">  </p>
<p>遍历的代码如下：</p>
<pre><code class="c">/*T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的*/
/*最后一个结点。中序遍历二叉线索链表表示的二叉树T*/
Status InOrderTraverse_Thr(BiThrTree T)
{
    BiThrTree p;
    p = T-&gt;lchild; /* p指向根结点 */
    while (p != T) /* 空树或遍历结束时，p==T */
    { /* 空树或遍历结束时,p==T */
        while (p-&gt;LTag == Link) /*当LTag==0时循环到中序序列第一个结点 */
            p = p-&gt;lchild;
        printf(&quot;%c&quot;,p-&gt;data); /* 显示结点数据，可以更改为其他对结点操作 */
        while (p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != T)
        {
            p = p-&gt;rchild;
            printf(&quot;%c&quot;,p-&gt;data);
        }
        p = p-&gt;rchild; /* p进至其右子树根 */
    }
    return OK;
}</code></pre>
<p>从这段代码也可以看出，它等于是一个链表的扫描，所以时间复杂度为O(n)。<br>由于它充分利用了空指针域的空间（这等于节省了空间），又保证了创建时的一次遍历就可以终生受用前驱后继的信息（这意味着节省了时间）。所以在实际问题中，<strong>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择</strong>。</p>
<h2 id="6-11-树、森林与二叉树的转换"><a href="#6-11-树、森林与二叉树的转换" class="headerlink" title="6.11 树、森林与二叉树的转换"></a>6.11 树、森林与二叉树的转换</h2><h3 id="6-11-1-树转换为二叉树"><a href="#6-11-1-树转换为二叉树" class="headerlink" title="6.11.1 树转换为二叉树"></a>6.11.1 树转换为二叉树</h3><p>将树转换为二叉树的步骤如下</p>
<ol>
<li>加线。在所有兄弟结点之间加一条连线。</li>
<li>去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。</li>
<li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</li>
</ol>
<h3 id="6-11-2-森林转换为二叉树"><a href="#6-11-2-森林转换为二叉树" class="headerlink" title="6.11.2 森林转换为二叉树"></a>6.11.2 森林转换为二叉树</h3><p>森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。步骤如下：</p>
<ol>
<li>把每个树转换为二叉树。</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。</li>
</ol>
<h3 id="6-11-3-二叉树转换为树"><a href="#6-11-3-二叉树转换为树" class="headerlink" title="6.11.3 二叉树转换为树"></a>6.11.3 二叉树转换为树</h3><p>二叉树转换为树是树转换为二叉树的逆过程，也就是反过来做而已。如图6-11-4所示。步骤如下：</p>
<ol>
<li>加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……哈，反正就是左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。</li>
<li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li>
<li>层次调整。使之结构层次分明。</li>
</ol>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-11-4.JPG?raw=true" srcset="/img/loading.gif" alt="6-11-4"></p>
<h3 id="6-11-4-二叉树转换为森林"><a href="#6-11-4-二叉树转换为森林" class="headerlink" title="6.11.4 二叉树转换为森林"></a>6.11.4 二叉树转换为森林</h3><p>判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。<br>那么如果是转换成森林，步骤如下：</p>
<ol>
<li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。</li>
<li>再将每棵分离后的二叉树转换为树即可。</li>
</ol>
<p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-11-5.JPG?raw=true" srcset="/img/loading.gif" alt="6-11-5"></p>
<h3 id="6-11-5-树与森林的遍历"><a href="#6-11-5-树与森林的遍历" class="headerlink" title="6.11.5 树与森林的遍历"></a>6.11.5 树与森林的遍历</h3><p>树的遍历分为两种方式。</p>
<ol>
<li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。</li>
<li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。比如图6-11-4中最右侧的树，它的先根遍历序列为ABEFCDG，后根遍历序列为EFBCGDA。</li>
</ol>
<p>森林的遍历也分为两种方式：</p>
<ol>
<li>前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。比如图6-11-5右侧三棵树的森林，前序遍历序列的结果就是ABCDEFGHJI。</li>
<li>后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。比如图6-11-5右侧三棵树的森林，后序遍历序列的结果就是BCDAFEJHIG。</li>
</ol>
<p>可如果我们对二叉树进行分析就会发现，森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。<br>这也就告诉我们，当以二叉链表作树的存储结构时，树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现。这其实也就证实，我们找到了对树和森林这种复杂问题的简单解决办法。  </p>
<h2 id="6-12-赫夫曼树及其应用"><a href="#6-12-赫夫曼树及其应用" class="headerlink" title="6.12 赫夫曼树及其应用"></a>6.12 赫夫曼树及其应用</h2><h3 id="6-12-1-赫夫曼树"><a href="#6-12-1-赫夫曼树" class="headerlink" title="6.12.1 赫夫曼树"></a>6.12.1 赫夫曼树</h3><p>压缩软件如何做到压缩而不出错的呢？简单说，就是把我们要压缩的文本进行重新编码，以减少不必要的空间。我们今天就来介绍一下最基本的压缩编码方法——赫夫曼编码。<br>由美国数学家赫夫曼（David Huffman）在1952年发明了赫夫曼编码。他在编码中用到的特殊的二叉树称之为赫夫曼树，他的编码方法称为赫夫曼编码。  </p>
<h3 id="6-12-2-赫夫曼树定义与原理"><a href="#6-12-2-赫夫曼树定义与原理" class="headerlink" title="6.12.2 赫夫曼树定义与原理"></a>6.12.2 赫夫曼树定义与原理</h3><p><strong>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度。</strong><br><strong>树的路径长度就是从树根到每一结点的路径长度之和。</strong><br>如果考虑到带权的结点，结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。假设有n个权值{w1，w2，…，Wn}，构造一棵有n个叶子结点的二叉树，每个叶子结点带权Wk，每个叶子的路径长度为lk，我们通常记作，则其中<strong>带权路径长度WPL最小的二叉树称做赫夫曼树</strong>。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-12-4.JPG?raw=true" srcset="/img/loading.gif" alt="6-12-4"><br>有了赫夫曼对带权路径长度的定义，我们来计算一下图6-12-4这两棵树的WPL值。<br>二叉树a的WPL=5×1+15×2+40×3+30×4+10×4=315<br>注意：这里5是A结点的权，1是A结点的路径长度，其他同理。<br>二叉树b的WPL=5×3+15×3+40×2+30×2+10×2=220<br>参考图6-12-4的二叉树b，最优赫夫曼树的解法如下：</p>
<ol>
<li>先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即：A5，E10，B15，D30，C40。</li>
<li>取头两个最小权值的结点作为一个新节点N1的两个子结点，注意相对较小的是左孩子，这里就是A为N1的左孩子，E为N1的右孩子，如图6-12-5所示。新结点的权值为两个叶子权值的和5+10=15。</li>
<li>将N1替换A与E，插入有序序列中，保持从小到大排列。即：N1 15，B15，D30，C40。</li>
<li>重复步骤2。将N1与B作为一个新节点N2的两个子结点。如图6-12-6所示。N2的权值=15+15=30。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-12-5.JPG?raw=true" srcset="/img/loading.gif" alt="6-12-5"></li>
<li>将N2替换N1与B，插入有序序列中，保持从小到大排列。即：N2 30，D30，C40。</li>
<li>重复步骤2。将N2与D作为一个新节点N3的两个子结点。如图6-12-7所示。N3的权值=30+30=60。</li>
<li>将N3替换N2与D，插入有序序列中，保持从小到大排列。即：C40，N3 60。</li>
<li>重复步骤2。将C与N3作为一个新节点T的两个子结点，如图6-12-8所示。由于T即是根结点，完成赫夫曼树的构造。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0/6-12-7.JPG?raw=true" srcset="/img/loading.gif" alt="6-12-7">  </li>
</ol>
<p>此时的图6-12-8二叉树的带权路径长度WPL=40×1+30×2+15×3+10×4+5×4=205。与图6-12-4的二叉树b的WPL值220相比，还少了15。显然此时构造出来的二叉树才是最优的赫夫曼树。<br>通过刚才的步骤，我们可以得出构造赫夫曼树的赫夫曼算法描述。</p>
<ol>
<li>根据给定的n个权值{w1，W2，…，Wn}构成n棵二叉树的集合F={T1，T2，…，Tn}，其中每棵二叉树Ti中只有一个带权为wi根结点，其左右子树均为空。</li>
<li>在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li>
<li>在F中删除这两棵树，同时将新得到的二叉树加入F中。</li>
<li>重复2和3步骤，直到F只含一棵树为止。这棵树便是赫夫曼树。</li>
</ol>
<h3 id="6-12-3-赫夫曼编码"><a href="#6-12-3-赫夫曼编码" class="headerlink" title="6.12.3 赫夫曼编码"></a>6.12.3 赫夫曼编码</h3><p>按照不同字母出现的频率重新按照赫夫曼树来规划它们。将规划出来的树权值左分支改为0，右分支改为1后。对字母从树根到叶子所经过路径的0或1来编码，可以看出结果串变小了，编码得到了压缩，节约了存储和传输成本。<br>当我们接收到压缩过的新编码时，我们应该如何把它解码出来呢？<br>编码中非0即1，长短不等的话其实是很容易混淆的，所以<strong>若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称做前缀编码</strong>。<br>可仅仅是这样不足以让我们去方便地解码的，因此在解码时，还是要用到赫夫曼树，即发送方和接收方必须要约定好同样的赫夫曼编码规则。<br><strong>一般地，设需要编码的字符集为{d1，d2，…，dn}，各个字符在电文中出现的次数或频率集合为{W1，w2，…，Wn}，以d1，d2，…，dn作为叶子结点，以w1，W2，Wn作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是赫夫曼编码</strong>。  </p>
<h2 id="6-13-总结回顾"><a href="#6-13-总结回顾" class="headerlink" title="6.13 总结回顾"></a>6.13 总结回顾</h2><p>终于到了总结的时间，这一章与前面章节相比，显得过于庞大了些，原因也就在于树的复杂性和变化丰富度是前面的线性表所不可比拟的。即使在本章之后，我们还要讲解关于树这一数据结构的相关知识，可见它的重要性。<br>开头我们提到了树的定义，讲到了递归在树定义中的应用。提到了如子树、结点、度、叶子、分支结点、双亲、孩子、层次、深度、森林等诸多概念，这些都是需要在理解的基础上去记忆的。<br>我们谈到了树的存储结构时，讲了双亲表示法、孩子表示法、孩子兄弟表示法等不同的存储结构。<br>并由孩子兄弟表示法引出了我们这章中最重要一种树，二叉树。<br>二叉树每个结点最多两棵子树，有左右之分。提到了斜树，满二叉树、完全二叉树等特殊二叉树的概念。<br>我们接着谈到它的各种性质，这些性质给我们研究二叉树带来了方便。<br>二叉树的存储结构由于其特殊性使得既可以用顺序存储结构又可以用链式存储结构表示。<br>遍历是二叉树最重要的一门学问，前序、中序、后序以及层序遍历都是需要熟练掌握的知识。要让自己要学会用计算机的运行思维去模拟递归的实现，可以加深我们对递归的理解。不过，并非二叉树遍历就一定要用到递归，只不过递归的实现比较优雅而已。这点需要明确。<br>二叉树的建立自然也是可以通过递归来实现。<br>研究中也发现，二叉链表有很多浪费的空指针可以利用，查找某个结点的前驱和后继为什么非要每次遍历才可以得到，这就引出了如何构造一棵线索二叉树的问题。<br>线索二叉树给二叉树的结点查找和遍历带来了高效率。<br>树、森林看似复杂，其实它们都可以转化为简单的二叉树来处理，我们提供了树、森林与二叉树的互相转换的办法，这样就使得面对树和森林的数据结构时，编码实现成为了可能。<br>最后，我们提到了关于二叉树的一个应用，赫夫曼树和赫夫曼编码，对于带权路径的二叉树做了详尽地讲述，让你初步理解数据压缩的原理，并明白其是如何做到无损编码和无错解码的。  </p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构第五章 串</title>
    <url>/2019/12/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC5%E7%AB%A0%20%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="5-1-5-2-串的定义"><a href="#5-1-5-2-串的定义" class="headerlink" title="5.1-5.2 串的定义"></a>5.1-5.2 串的定义</h2><p>串(string)是由零个或多个字符组成的有限序列，又名叫字符串。<br>一般记为s=“a1a2……an”(n&gt;0)，其中，s是串的名称，用双引号(有些书中也用单引号)括起来的字符序列是串的值，注意单引号不属于串的内容。ai(1≤i≤n)可以是字母、数字或其他字符，i就是该字符在串中的位置。串中的字符数目n称为串的长度，定义中谈到“有限”是指长度n是一个有限的数值。零个字符的串称为空串(null string)，它的长度为零，可以直接用两双引号“”””表示，也可以用希腊字母“Φ”来表示。所谓的序列，说明串的相邻字符之间具有前驱和后继的关系。  </p>
<a id="more"></a>

<p>还有一些概念需要解释：  </p>
<ul>
<li>空格串，是只包含空格的串。注意它与空串的区别，空格串是有内容有长度的，而且可以不止一个空格。</li>
<li>子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。</li>
<li>子串在主串中的位置就是子串的第一个字符在主串中的序号。</li>
</ul>
<p>开头我所提到的“over”、“end”、“lie”其实可以认为是“over”、“friend”、“believe”这些单词字符串的子串。  </p>
<h2 id="5-3-串的比较"><a href="#5-3-串的比较" class="headerlink" title="5.3 串的比较"></a>5.3 串的比较</h2><p>两个字符串的长度以及它们每个位置各个对应位置的字符都相等时，才算是相等。<br>那么对于两个串不相等时，如何判定它们的大小呢。我们这样定义：<br>给定两个串：s=“a1a2……an”，t=“b1b2……bm”，当满足以下条件之一时，<code>s&lt;t</code>。</p>
<ol>
<li><code>n&lt;m</code>，且ai=bi(i=1，2，…，n)。<br>例如当s=“hap”，t=“happy”，就有sst。因为t比s多出了两个字母。</li>
<li>存在某个<code>k&lt;min(m，n)</code>，使得ai=bi；(i=1，2，……，k-1)，<code>ak&lt;bk</code>。<br>例如当s=“happen”，t=“happy”，因为两串的前4个子母均相同，间内串第5个字母(k值)，字母e的ASCII码是101，而字母y的ASCII码是121，显然<code>e&lt;y</code>，所以<code>s&lt;t</code>。</li>
</ol>
<h2 id="5-4-串的抽象数据类型"><a href="#5-4-串的抽象数据类型" class="headerlink" title="5.4 串的抽象数据类型"></a>5.4 串的抽象数据类型</h2><pre><code class="c">ADT 串(string)
Data
  串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。
Operation
  strAssign(T，*chars)：生成一个其值等于字符串常量chars的串T。
  StrCopy(T，S)：串S存在，由串S复制得串T。
  ClearString(S)：串S存在，将串清空。
  StringEmpty(S)；若串S为空，返回true，否则返回false。
  StrLength(S)：返回串S的元素个数，即串的长度。
  StrCompare(S，T)：若S&gt;T，返回值&gt;0，若S=T，返回0，若S&lt;T，返回值&lt;0。
  Concat(T，S1，S2)：用T返回由S1和S2联接而成的新串。
  SubString(Sub，S，pos，len)：串S存在，1≤pos≤StrLength(S)，且0≤len≤StrLength(S)-pos+1，用Sub返回串S的第pos个字符起长度为len的子串。
  Index(S，T，pos)：串S和T存在，T是非空串，1≤pos≤StrLength(S)。若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回0。
  Replace(S，T，V)：串S、T和v存在，T是非空串。用V替换主串S中出现的所有与T相等的不重叠的子串。
  StrInsert(S，pos，T)：串s和T存在，1≤pos≤StrLength(S)+1。在串S的第pos个字符之前插入串T。
  StrDelete(S，pos，len)：串S存在，1≤pos≤StrLength(S)-len+1。从串S中删除第pos个字符起长度为len的子串。
endADT</code></pre>
<h2 id="5-5-串的存储结构"><a href="#5-5-串的存储结构" class="headerlink" title="5.5 串的存储结构"></a>5.5 串的存储结构</h2><p>串的存储结构与线性表相同，分为两种。  </p>
<h3 id="5-5-1-串的顺序存储结构"><a href="#5-5-1-串的顺序存储结构" class="headerlink" title="5.5.1 串的顺序存储结构"></a>5.5.1 串的顺序存储结构</h3><p>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义。<br>既然是定长数组，就存在一个预定义的最大串长度，一般可以将实际的串长度值保存在数组的0下标位置，有的书中也会定义存储在数组的最后一个下标位置。但也有些编程语言不想这么干，觉得存个数字占个空间麻烦。它规定在串值后面加一个不计入串长度的结束标记字符，比如“\0”来表示串值的终结，这个时候，你要想知道此时的串长度，就需要遍历计算一下才知道了，其实这还是需要占用一个空间，何必呢。</p>
<h3 id="5-5-2-串的链式存储结构"><a href="#5-5-2-串的链式存储结构" class="headerlink" title="5.5.2 串的链式存储结构"></a>5.5.2 串的链式存储结构</h3><p>对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用“#”或其他非串值字符补全，如图5-5-3所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0/5-5-3.JPG?raw=true" srcset="/img/loading.gif" alt="5-5-3"><br>当然，这里一个结点存多少个字符才合适就变得很重要，这会直接影响着串处理的效率，需要根据实际情况做出选择。<br>但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。  </p>
<h2 id="5-6-朴素的模式匹配算法-暴力算法匹配"><a href="#5-6-朴素的模式匹配算法-暴力算法匹配" class="headerlink" title="5.6 朴素的模式匹配算法(暴力算法匹配)"></a>5.6 朴素的模式匹配算法(暴力算法匹配)</h2><p>子串的定位操作通常称做串的模式匹配，也算是串中最重要的操作之一。<br>用基本的数组来实现朴素的模式匹配算法。我们假设主串S和要匹配的子串T的长度存在S[0]与T[0]中。实现代码如下：  </p>
<pre><code class="c">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在,则函数返回值为0。 */
/* 其中,T非空,1≤pos≤StrLength(S)。 */
int Index(String S, String T, int pos)
{
    int i = pos;    /* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */
    int j = 1;                /* j用于子串T中当前位置下标值 */
    while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */
    {
        if (S[i] == T[j])     /* 两字母相等则继续 */
          {
            ++i;
            ++j;
          }
          else                 /* 指针后退重新开始匹配 */
          {  
             i = i-j+2;        /* i退回到上次匹配首位的下一位 */
             j = 1;             /* j退回到子串T的首位 */
          }
    }
    if (j &gt; T[0])
        return i-T[0];
    else
        return 0;
}</code></pre>
<p>非最坏情况下，只需要匹配2个串的首字母，所以根据等概率原则，平均是(n+m)/2次查找，时间复杂度为O(n+m)。<br>而最坏情况就是0000000000000000001，此时时间复杂度为O((n-m+1)*m)。  </p>
<h2 id="5-7-KMP-模式匹配算法"><a href="#5-7-KMP-模式匹配算法" class="headerlink" title="5.7 KMP 模式匹配算法"></a>5.7 KMP 模式匹配算法</h2><p>有三位前辈，D.E.Knuth、J.H.Morris 和V.R.Pratt（其中Knuth和Pratt 共同研究，Morris独立研究）发表一个模式匹配算法，可以大大避免重复遍历的情况，我们把它称之为克努特一莫里斯一普拉特算法，简称KMP算法。  </p>
<h3 id="5-7-1-KMP模式匹配算法原理"><a href="#5-7-1-KMP模式匹配算法原理" class="headerlink" title="5.7.1 KMP模式匹配算法原理"></a>5.7.1 KMP模式匹配算法原理</h3><p>首先要理解上面的朴素模式的匹配算法，主串设为S，要匹配的模式串设为T。<br>对于在子串中有与首字符相等的字符，也是可以省略一部分不必要的判断步骤。<br>我们在朴素的模式匹配算法中，主串的i值是不断地回溯来完成的。而我们的分析发现，这种回溯其实是可以不需要的，我们的KMP模式匹配算法就是为了让这没必要的回溯不发生。<br>既然i值不回溯，也就是不可以变小，那么要考虑的变化就是j(j在模式串中所在的位置)值了。通过观察也可发现，我们屡屡提到了T串的首字符与自身后面字符的比较，发现如果有相等字符，j(j在模式串中所在的位置)值的变化就会不相同。也就是说，这个j(j在模式串中所在的位置)值的变化与主串其实没什么关系，关键就取决于T串的结构中是否有重复的问题。<br>我们可以得出规律，j(j在模式串中所在的位置)值的多少取决于当前字符之前的串的前后缀的相似度。<br>我们把T串各个位置的j(j在模式串中所在的位置)值的变化定义为一个数组next，那么next的长度就是T串的长度。于是我们可以得到下面的函数定义：<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0/5-7-6.JPG?raw=true" srcset="/img/loading.gif" alt="5-7-6"></p>
<h3 id="5-7-2-next数组值推导"><a href="#5-7-2-next数组值推导" class="headerlink" title="5.7.2 next数组值推导"></a>5.7.2 next数组值推导</h3><p>“前缀”指除了最后一个字符以外，一个字符串的全部头部组合；<br>“后缀”指除了第一个字符以外，一个字符串的全部尾部组合。<br>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例，</p>
<ul>
<li>“A”的前缀和后缀都为空集，共有元素的长度为0；</li>
<li>“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</li>
<li>“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</li>
<li>“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</li>
<li>“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</li>
<li>“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</li>
<li>“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。  </li>
</ul>
<p>我们可以根据经验得到:如果前缀后缀最长共有元素的长度为1，k值是2，最长的共有元素的长度为2，k值是3。<br><strong>最长的共有元素的长度为n，k值就是n+1</strong>。  </p>
<h3 id="5-7-3KMP模式匹配算法实现"><a href="#5-7-3KMP模式匹配算法实现" class="headerlink" title="5.7.3KMP模式匹配算法实现"></a>5.7.3KMP模式匹配算法实现</h3><p>next代码如下：</p>
<pre><code class="c">/* 通过计算返回子串T的next数组。 */
void get_next(String T, int *next)
{
    int i, j;
    i = 1;
    j = 0;
    next[1] = 0;
    while (i &lt; T[0])  /* 此处T[0]表示串T的长度 */
    {
        if (j == 0 || T[i] == T[j])     /* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */
        {
            ++i;
            ++j;
            next[i] = j;
        }
        else
            j = next[j];    /* 若字符不相同，则j值回溯 */
    }
}</code></pre>
<p>这段代码的目的就是为了计算出当前要匹配的串T的next数组。  </p>
<pre><code class="c">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。 */
/*  T非空，1≤pos≤StrLength(S)。 */
int Index_KMP(String S, String T, int pos)
{
    int i = pos;        /* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */
    int j = 1;            /* j用于子串T中当前位置下标值 */
    int next[255];        /* 定义一next数组 */
    get_next(T, next);    /* 对串T作分析，得到next数组 */
    while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */
    {
        if (j == 0 || S[i] == T[j])     /* 两字母相等则继续，与朴素算法增加了j=0判断 */
        {
            ++i;
            ++j;
        }
        else             /* 指针后退重新开始匹配 */
            j = next[j];/* j退回合适的位置，i值不变 */
    }
    if (j &gt; T[0])
        return i - T[0];
    else
        return 0;
}</code></pre>
<p>对于get_next函数来说，若模式串的长度为m，因只涉及到简单的单循环，其时间复杂度为O(m)，而由于i值的不回溯，使得indexKMP算法效率得到了提高，while 循环的时间复杂度为O(n)。因此，整个算法的时间复杂度为O(n+m)。相较于朴素模式匹配算法的O((n-m+1)*m)来说，是要好一些。  </p>
<h3 id="5-7-4-KMP模式匹配算法改进"><a href="#5-7-4-KMP模式匹配算法改进" class="headerlink" title="5.7.4 KMP模式匹配算法改进"></a>5.7.4 KMP模式匹配算法改进</h3><pre><code class="c">/* 求模式串T的next函数修正值并存入数组nextval */
void get_nextval(String T, int *nextval)
{
    int i, j;
    i = 1;
    j = 0;
    nextval[1] = 0;
    while (i &lt; T[0])  /* 此处T[0]表示串T的长度 */
    {
        if (j == 0 || T[i] == T[j])     /* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */
        {
            ++i;
            ++j;
            if (T[i] != T[j])      /* 若当前字符与前缀字符不同 */
                nextval[i] = j;    /* 则当前的j为nextval在i位置的值 */
            else
                nextval[i] = nextval[j];    /* 如果与前缀字符相同，则将前缀字符的 */
                                            /* nextval值赋值给nextval在i位置的值 */
        }
        else
            j = nextval[j];            /* 若字符不相同，则j值回溯 */
    }
}</code></pre>
<h3 id="5-7-5-nextval-数组值推导"><a href="#5-7-5-nextval-数组值推导" class="headerlink" title="5.7.5 nextval 数组值推导"></a>5.7.5 nextval 数组值推导</h3><p>总结改进过的KMP算法，它是在计算出next值的同时，如果a位字符与它next值指向的b位字符相等，则该a位的nextval就指向b位的nextval值，如果不等，则该a位的nextval值就是它自己a位的next的值。  </p>
<h2 id="5-8-总结回顾"><a href="#5-8-总结回顾" class="headerlink" title="5.8 总结回顾"></a>5.8 总结回顾</h2><p>这一章节我们重点讲了“串”这样的数据结构，串（string）是由零个或多个字符组成的有限序列，又名叫字符串。本质上，它是一种线性表的扩展，但相对于线性表关注一个个元素来说，我们对串这种结构更多的是关注它子串的应用问题，如查找、替换等操作。现在的高级语言都有针对串的函数可以调用。我们在使用这些函数的时候，同时也应该要理解它当中的原理，以便于在碰到复杂的问题时，可以更加灵活的使用，比如KMP模式匹配算法的学习，就是更有效地去理解index函数当中的实现细节。  </p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo next主题导航栏图标显示问号解决方案</title>
    <url>/2019/12/10/hexo/hexo-next%E4%B8%BB%E9%A2%98%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA%E9%97%AE%E5%8F%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>导航栏图标显示问号，当修改<code>hexo\themes\next\_config.yml</code>主题配置文件后，图标显示正常，但是点击链接不能打开相应主页、标签页、归档页…<br>经研究，应该把menu下面的不同页面的/后面的空格删掉，即可。<br>具体配置如下：  </p>
<a id="more"></a>
<pre><code class="yml">menu:
  home: /|| home                  #主页
  archives: /archives/|| archive  #归档
  categories: /categories/|| th   #分类
  tags: /tags/|| tags             #标签
  about: /about/|| user           #关于我
  #search: /search
  #schedule: /schedule/ || calendar
  #sitemap: /sitemap.xml || sitemap
  #commonweal: /404.html

# Enable/Disable menu icons.
menu_icons:
  enable: true
  # Icon Mapping.
  home: home
  archives: archive
  categories: th
  tags: tags
  about: user
  #commonweal: heartbeat
  #search: search
</code></pre>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 多客户端上更新博客</title>
    <url>/2019/12/09/hexo/hexo%20%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><code>git add source/ &amp;&amp; git commit -m &quot;blog update&quot; &amp;&amp; git push githuborigin hexo &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; exit</code></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>静态网页文件存放在<code>master主分支</code>，个人文件存放在<code>hexo分支</code>。  </p>
<a id="more"></a>

<h2 id="一、本地电脑设置"><a href="#一、本地电脑设置" class="headerlink" title="一、本地电脑设置"></a>一、本地电脑设置</h2><p>先新建一个hexo文件夹，在git bash下cd进入hexo文件夹。</p>
<p>1.<code>git init</code></p>
<p>2.<code>git checkout -b hexo</code> //新建hexo分支并切换到hexo</p>
<p>3.将原来博客文件夹里面的<code>_config.yml</code>，<code>theme/</code>，<code>source/</code>，<code>scaffolds/</code>，<code>package.json</code>，<code>.gitignore</code>，共6个文件/文件夹 拷贝到hexo文件夹下面。</p>
<p>需要拷贝的文件如下:  </p>
<ul>
<li>_config.yml（站点配置）；</li>
<li>theme文件夹里面的主题；</li>
<li>source文件夹；</li>
<li>scaffolds文件夹（文章的模板）；</li>
<li>package.json（说明使用哪些包）；</li>
<li>.gitignore（限定在提交的时候哪些文件可以忽略）；  </li>
<li><strong>注意：不要<code>hexo init</code>去整体初始化，因为需要的文件我们已经拷贝过来了。</strong></li>
</ul>
<p>4.将theme文件夹里面的你的主题文件夹下的.git文件夹删除。</p>
<p>5.<code>git add scaffolds/ source/ themes/ .gitignore _config.yml package.json</code><br>   <code>git commit -m &quot;init&quot;</code>  </p>
<p>6.<code>git remote add githuborigin git@github.com:你的ID/你的仓库名字</code>  //添加本地hexo和远程仓库的关联</p>
<p>7.登录github，将分支仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为hexo，Update保存。</p>
<p>8.<code>git push githuborigin hexo</code>  //上传更新</p>
<h2 id="二、另外一台电脑上配置"><a href="#二、另外一台电脑上配置" class="headerlink" title="二、另外一台电脑上配置"></a>二、另外一台电脑上配置</h2><ol>
<li>官网下载安装：  </li>
</ol>
<ul>
<li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">安装 Node.js；</a></li>
<li><a href="https://git-scm.com/" target="_blank" rel="noopener">安装 Git。</a></li>
</ul>
<ol start="2">
<li>新建hexo目录，cd进入。</li>
<li><code>git clone https://github.com/你的ID/你的ID.github.io.git</code>  //克隆到本地</li>
<li>将新电脑生成的ssh key添加到gitHub账户上。<br>需要配置 git。</li>
</ol>
<ul>
<li><code>git config --global user.email &quot;xxx@qq.com&quot;</code> 引号内的<a href="mailto:xxx@qq.com">xxx@qq.com</a>改为你github注册并且验证的邮箱；</li>
<li><code>git config --global user.name &quot;xxxx&quot;</code>   引号内的xxxx改为你的 github 用户名；</li>
<li><code>ssh-keygen</code> 会出现下面的内容，一直按Enter键就行；</li>
<li>打开用户目录下的 <code>.ssh</code>目录下面生成 <code>id_rsa(私钥)id_rsa.pub(公钥)</code>两个文件，打开<code>id_rsa.pub</code>，复制里面的内容,到 github: <code>Settings -&gt; SSH and GPG keys -&gt; SSH keys -&gt; New SSH key -&gt; (填写)Title -&gt; (粘贴)Key -&gt; Add SSH Key</code>；</li>
<li>测试 <code>ssh -T git@github.com</code>，输出 <strong>You’ve successfully authenticated</strong> 表示添加key 成功。</li>
</ul>
<ol start="5">
<li><code>npm install hexo-cli -g</code> //安装hexo</li>
<li><code>npm install</code> //安装依赖包  </li>
</ol>
<ul>
<li>如果出现报错<code>ERROR Try runing: &#39;npm install hexo --save</code>则执行命令<code>npm install hexo --save</code>，如果没有，则忽略。</li>
</ul>
<ol start="7">
<li><code>git remote remove origin</code> //和origin远程库解除关联</li>
<li><code>git remote add githuborigin git@github.com:你的ID/你的ID.github.io.git</code> //和GitHuborigin库添加关联</li>
</ol>
<h2 id="三、发布博客"><a href="#三、发布博客" class="headerlink" title="三、发布博客"></a>三、发布博客</h2><ol>
<li>cd进入博客目录</li>
<li><code>git pull githuborigin hexo</code> //保证和分支同步</li>
<li><code>hexo n &quot;新建博客&quot;</code></li>
<li><code>git add source/</code>      //因为博客文件是在source文件夹下面的</li>
<li><code>git commit -m &quot;博客更新&quot;</code></li>
<li><code>git push githuborigin hexo</code>//上传更新</li>
<li><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>//部署博客</li>
</ol>
<p>至此，多终端发布博客已经配置完成。</p>
<h2 id="四、更新主题"><a href="#四、更新主题" class="headerlink" title="四、更新主题"></a>四、更新主题</h2><p>配置好主题文件后，执行：<br><code>git add scaffolds/ source/ themes/ .gitignore _config.yml package.json</code><br><code>git commit -m &quot;更新主题&quot;</code><br><code>git push githuborigin hexo</code>  //上传更新</p>
<h2 id="五、快速上传部署命令"><a href="#五、快速上传部署命令" class="headerlink" title="五、快速上传部署命令"></a>五、快速上传部署命令</h2><p>只更新博客内容，可以从上述第 三 大步第 4 步后可以这样子发布：<br><code>git add source/ &amp;&amp; git commit -m &quot;blog update&quot; &amp;&amp; git push githuborigin hexo &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; exit</code><br>把所有命令用<code>&amp;&amp;</code>串起来，有一个失败就会停止；成功，最后一条命令就会退出终端。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>多客户端</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo配置文件设置</title>
    <url>/2019/12/09/hexo/hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="hexo配置文件设置"><a href="#hexo配置文件设置" class="headerlink" title="hexo配置文件设置"></a>hexo配置文件设置</h2><p>hexo配置文件<code>_config.yml</code>基本配置</p>
<a id="more"></a>
<pre><code class="yml"># Hexo Configuration
## Docs: https://hexo.io/docs/configuration.html
## Source: https://github.com/hexojs/hexo/

# Site 网站
title: closer的个人博客
subtitle: welcome!
description: up up up
keywords:
author: closer
language: zh-CN #语言
timezone: &#39;&#39;

# URL 网址
## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;
url: https://closer_laps.gitee.io/
root: / #根目录位置，如果只是github pages的子目录需要更改
permalink: :year/:month/:day/:title/
permalink_defaults:
pretty_urls:
  trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks
  trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks

# Directory #文件结构 默认即可
source_dir: source
public_dir: public
tag_dir: tags
archive_dir: archives
category_dir: categories
code_dir: downloads/code
i18n_dir: lang
skip_render:

# Writing #编辑博文的选项
new_post_name: :title.md # File name of new posts
default_layout: post
auto_spacing: false
titlecase: false # 把标题转换为 title case
external_link:
  enable: true # Open external links in new tab
  field: site # Apply to the whole site
  exclude: &#39;&#39;
filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写 
render_drafts: false #显示草稿
post_asset_folder: false #启动 Asset 文件夹 
relative_link: false #把链接改为与根目录的相对位址 
future: true #显示未来的文章 
highlight:  #代码块的设置 
 enable: false  #开启代码块高亮 
 auto_detect: false #如果未指定语言，则启用自动检测 
 line_number: true #显示行数 
 tab_replace: &#39;&#39; #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs 
 wrap: true
 hljs: false

# Home page setting
# path: Root path for your blogs index page. (default = &#39;&#39;)
# per_page: Posts displayed per page. (0 = disable pagination)
# order_by: Posts order. (Order by date descending by default)
index_generator:
  path: &#39;&#39;
  per_page: 10
  order_by: -date

# Category &amp; Tag #分类 &amp; 标签
default_category: uncategorized
category_map:
tag_map:

# Metadata elements
## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta
meta_generator: true

# Date / Time format #日期显示格式
## Hexo uses Moment.js to parse and display date
## You can customize the date format as defined in
## http://momentjs.com/docs/#/displaying/format/
date_format: YYYY-MM-DD #日期格式 
time_format: HH:mm:ss #时间格式
## Use post&#39;s date for updated date unless set in front-matter
use_date_for_updated: false

# Pagination #分页器
## Set per_page to 0 to disable pagination
per_page: 10 #每页显示的文章量 (0 = 关闭分页功能) 10
pagination_dir: page #分页目录 

# Include / Exclude file(s)
## include:/exclude: options only apply to the &#39;source/&#39; folder
include:
exclude:
ignore:

# Extensions #拓展
## Plugins: http://hexo.io/plugins/
## Themes: http://hexo.io/themes/
theme: hexo-theme-next-7.7.0 #主题更换

# Deployment #部署参数
## Docs: http://hexo.io/docs/deployment.html
deploy:
  type: git
  repo:
        github: git@github.com:closer2018/closer2018.github.io.git
        gitee: git@gitee.com:closer_laps/closer_laps.git
        coding: git@e.coding.net:closer2018/closer2018.coding.me.git
  branch: master

# 搜索设置
search:
  path: search.xml
  field: post
  format: html
  limit: 10000

# 发布字数统计
symbols_count_time:
    symbols: true
    time: true
    total_symbols: true
    total_time: true</code></pre>
<p>以上就是配置文件的基础设置。</p>
<h2 id="更换主题NexT"><a href="#更换主题NexT" class="headerlink" title="更换主题NexT"></a>更换主题NexT</h2><p>Hexo安装主题的方式非常简单，只需要将主题文件放置于站点目录的themes下，然后修改下配置文件即可。这里我以NexT主题为例。<br>在git bash操作下cd至博客根目录，执行如下代码：  </p>
<p><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p>
<p>等待下载完成后，修改根目录下_config.yml文件的theme字段为next即可启用NexT主题，十分简单便捷。<br>其它具体设置可参照<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT官方文档</a>。</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>cd至blog根目录。  </p>
<pre><code class="yml">npm install hexo-generator-searchdb --save  #搜索插件
npm install --save hexo-generator-feed   #RSS插件
npm install hexo-wordcount --save   #字符统计及阅读时长估计
npm install hexo-generator-sitemap --save  #博客添加网站地图sitemap
npm install hexo-generator-index-pin-top --save   #置顶插件</code></pre>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo上传部署命令</title>
    <url>/2019/12/01/hexo/hexo%E4%B8%8A%E4%BC%A0%E9%83%A8%E7%BD%B2%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="hexo上传部署三连杀命令-先cd进入git目录"><a href="#hexo上传部署三连杀命令-先cd进入git目录" class="headerlink" title="hexo上传部署三连杀命令(先cd进入git目录)"></a>hexo上传部署三连杀命令(先<code>cd</code>进入git目录)</h2><pre><code class="bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre>
<a id="more"></a>

<h2 id="我们运行测试时，经常用到的有三个命令"><a href="#我们运行测试时，经常用到的有三个命令" class="headerlink" title="我们运行测试时，经常用到的有三个命令"></a>我们运行测试时，经常用到的有三个命令</h2><pre><code class="bash">hexo clean #用来清理缓存文件
hexo g      #生成文件
hexo  d   #上传到服务器</code></pre>
<h2 id="本地检测时运行"><a href="#本地检测时运行" class="headerlink" title="本地检测时运行"></a>本地检测时运行</h2><pre><code class="bash">hexo s</code></pre>
<p>然后打开浏览器，输入localhost:4000，就能看到博客了。<br>这样说明本地环境搭建完成。</p>
<h2 id="特别感谢B站up主CodeSheep的帮助和细心指导"><a href="#特别感谢B站up主CodeSheep的帮助和细心指导" class="headerlink" title="特别感谢B站up主CodeSheep的帮助和细心指导"></a>特别感谢<a href="https://space.bilibili.com/384068749/" target="_blank" rel="noopener">B站up主CodeSheep</a>的帮助和细心指导</h2>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构第三章 线性表</title>
    <url>/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC3%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<p>线性表：零个或多个数据元素的有限序列。</p>
<h2 id="3-1-3-2线性表的定义"><a href="#3-1-3-2线性表的定义" class="headerlink" title="3.1-3.2线性表的定义"></a>3.1-3.2线性表的定义</h2><p>线性表（List）：零个或多个数据元素的有限序列。</p>
<p>若将线性表记为（a_1，…，a_(i−1)，a_i，a_(i+1)，…，a_n），则表中a_(i−1) 领先于a_i，a_i 领先于a_(i+1)，称a_(i−1) 是a_i 的直接前驱元素，a_(i+1) 是a_i 的直接后继元素。当i=1，2，…，n-1时，a_i 有且仅有一个直接后继，当i=2，3，…，n时，a_i 有且仅有一个直接前驱。<br>如图3-2-1所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.2.1.GIF?raw=true" srcset="/img/loading.gif" alt="3-2-1"></p>
<p>所以线性表元素的个数n（n&gt;0）定义为线性表的长度，当n=0时，称为空表。</p>
<a id="more"></a>

<p>在较复杂的线性表中，一个数据元素可以由若干个数据项组成。</p>
<h2 id="3-3线性表的抽象数据类型"><a href="#3-3线性表的抽象数据类型" class="headerlink" title="3.3线性表的抽象数据类型"></a>3.3线性表的抽象数据类型</h2><p>线性表的抽象数据类型定义如下：</p>
<pre><code class="c">ADT线性表（List）
Data
    线性表的数据对象集合为{a1，a2…，an），每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
Operation
    InitList（*L）；初始化操作，建立一个空的线性表L。
    ListEmpty（L）；若线性表为空，返回true，否则返回false。
    ClearList（*L）；将线性表清空。
    GetElem（L，i，*e）；将线性表L中的第i个位置元素值返回给e。
    LocateElem（L，e）；在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。
    ListInsert（*L，i，e）；在线性表L中的第i个位置插入新元素e。
    ListDelete（*L，i，*e）；删除线性表L中第i个位置元素，并用e返回其值。
    ListLength（L）；返回线性表L的元素个数。
endADT</code></pre>
<h3 id="3-3-1两个线性表集合的并集操作"><a href="#3-3-1两个线性表集合的并集操作" class="headerlink" title="3.3.1两个线性表集合的并集操作"></a>3.3.1两个线性表集合的并集操作</h3><p>要使得集合A=AUB。说白了，就是把存在集合B中但并不存在A中的数据元素插入到A中即可。<br>仔细分析一下这个操作，发现我们只要循环集合B中的每个元素，判断当前元素是否存在A中，若不存在，则插入到A中即可。思路应该是很容易想到的。<br>我们假设La表示集合A，Lb表示集合B，则实现的代码如下：</p>
<pre><code class="c">    /*将所有的在线性表Lb中但不在La中的数据元素插入到La中*/
    void unionL(SqList *La, SqList Lb)
    {
        int La_len, Lb_len, i;
        ElemType e;                          /*声明与La和Lb相同的数据元素e*/
        La_len = ListLength(*La);                /*求线性表的长度*/
        Lb_len = ListLength(Lb);
        for (i = 1; i &lt;= Lb_len; i++)
        {
            GetElem(Lb, i, &amp;e);           /*取Lb中第i个数据元素赋给e*/
            if (!LocateElem(*La, e))           /*La中不存在和e相同数据元素*/
                ListInsert(La, ++La_len, e);          /*插入*/
        }
    }</code></pre>
<h2 id="3-4线性表的顺序存储结构"><a href="#3-4线性表的顺序存储结构" class="headerlink" title="3.4线性表的顺序存储结构"></a>3.4线性表的顺序存储结构</h2><h3 id="3-4-1顺序存储定义"><a href="#3-4-1顺序存储定义" class="headerlink" title="3.4.1顺序存储定义"></a>3.4.1顺序存储定义</h3><p>线性表的两种物理结构的第一种——顺序存储结构。<br>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p>
<h3 id="3-4-2顺序存储方式"><a href="#3-4-2顺序存储方式" class="headerlink" title="3.4.2顺序存储方式"></a>3.4.2顺序存储方式</h3><p>可以用C语言（其他语言也相同）的一维数组来实现顺序存储结构。<br>线性表的顺序存储的结构代码如下</p>
<pre><code class="c">    #define MAXSIZE 20/*存储空间初始分配量*/
    typedef int ElemType;  /*ElemType 类型根据实际情况而定，这里假设为int*/
    typedef struct
    {
        ElemType data[MAXSIZE];/*数组存储数据元素，最大值为MAXSIZE*/
        int length;  /*线性表当前长度*/
    }SqList;</code></pre>
<p>这里，我们就发现描述顺序存储结构需要三个属性：<br>    • 存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。<br>    • 线性表的最大存储容量：数组长度MaxSize。<br>    • 线性表的当前长度：length。</p>
<h3 id="3-4-3数据长度与线性表长度区别"><a href="#3-4-3数据长度与线性表长度区别" class="headerlink" title="3.4.3数据长度与线性表长度区别"></a>3.4.3数据长度与线性表长度区别</h3><p>数组的长度是存放线性表的存储空间的长度，存储分配后这个量是一般是不变的。<br>线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。<br>在任意时刻，线性表的长度应该小于等于数组的长度。</p>
<h3 id="3-4-4地址计算方法"><a href="#3-4-4地址计算方法" class="headerlink" title="3.4.4地址计算方法"></a>3.4.4地址计算方法</h3><p>存储器中的每个存储单元都有自己的编号，这个编号称为地址。<br>假设占用的是c个存储单元，那么线性表中第i+1个数据元素的存储位置和第i个数据元素的存储位置满足下列关系（LOC表示获得存储位置的函数）。<br>    LOC（a_(i+1)）=LOC（a_i）+c<br>所以对于第i个数据元素ai的存储位置可以由a1推算得出：<br>    LOC（a_i）=LOC（a_1）+（i-1）*c</p>
<h2 id="3-5顺序存储结构的插入与删除"><a href="#3-5顺序存储结构的插入与删除" class="headerlink" title="3.5顺序存储结构的插入与删除"></a>3.5顺序存储结构的插入与删除</h2><h3 id="3-5-1获得元素操作"><a href="#3-5-1获得元素操作" class="headerlink" title="3.5.1获得元素操作"></a>3.5.1获得元素操作</h3><p>我们要实现GetElem操作，即将线性表L中的第i个位置元素值返回。只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。</p>
<pre><code class="c">    #define OK 1
    #define ERROR 0
    #define TRUE 1
    #define FALSE 0
    typedef int Status;          /* Status是函数的类型,其值是函数结果状态代码，如OK等 */
    /* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
    /* 操作结果：用e返回L中第i个数据元素的值,注意i是指位置，第1个位置的数组是从0开始 */
    Status GetElem(SqList L, int i, ElemType *e)
    {
        if (L.length == 0 || i&lt;1 || i&gt;L.length)
            return ERROR;
        *e = L.data[i - 1];
        return OK;
    }</code></pre>
<h3 id="3-5-2插入操作"><a href="#3-5-2插入操作" class="headerlink" title="3.5.2插入操作"></a>3.5.2插入操作</h3><p>插入算法的思路：<br>    • 如果插入位置不合理，抛出异常；<br>    • 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；<br>    • 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；<br>    • 将要插入元素填入位置i处；<br>    • 表长加1。<br>实现代码如下：</p>
<pre><code class="c">    /* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */
    /* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */
    Status ListInsert(SqList *L, int i, ElemType e)
    {
        int k;
        if (L-&gt;length == MAXSIZE)  /* 顺序线性表已经满 */
            return ERROR;
        if (i&lt;1 || i&gt;L-&gt;length + 1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */
            return ERROR;
        if (i &lt;= L-&gt;length)        /* 若插入数据位置不在表尾 */
        {
            for (k = L-&gt;length - 1; k &gt;= i - 1; k--)  /* 将要插入位置之后的数据元素向后移动一位 */
                L-&gt;data[k + 1] = L-&gt;data[k];
        }
        L-&gt;data[i - 1] = e;          /* 将新元素插入 */
        L-&gt;length++;
        return OK;
    }</code></pre>
<h3 id="3-5-3删除操作"><a href="#3-5-3删除操作" class="headerlink" title="3.5.3删除操作"></a>3.5.3删除操作</h3><p>删除算法的思路：<br>    • 如果删除位置不合理，抛出异常；<br>    • 取出删除元素；<br>    • 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；<br>    • 表长减1。<br>实现代码如下：</p>
<pre><code class="c">    /* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
    /* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */
    Status ListDelete(SqList *L, int i, ElemType *e)
    {
        int k;
        if (L-&gt;length == 0)               /* 线性表为空 */
            return ERROR;
        if (i&lt;1 || i&gt;L-&gt;length)         /* 删除位置不正确 */
            return ERROR;
        *e = L-&gt;data[i - 1];
        if (i &lt; L-&gt;length)                /* 如果删除不是最后位置 */
        {
            for (k = i; k &lt; L-&gt;length; k++)/* 将删除位置后继元素前移 */
                L-&gt;data[k - 1] = L-&gt;data[k];
        }
        L-&gt;length--;
        return OK;
    }</code></pre>
<p>线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O（1）；而插入或删除时，时间复杂度都是O（n）。</p>
<h3 id="3-5-4线性表顺序存储结构的优缺点"><a href="#3-5-4线性表顺序存储结构的优缺点" class="headerlink" title="3.5.4线性表顺序存储结构的优缺点"></a>3.5.4线性表顺序存储结构的优缺点</h3><p>线性表的顺序存储结构的优缺点如图3-5-3所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.5.3.GIF?raw=true" srcset="/img/loading.gif" alt="3-5-3"></p>
<h3 id="3-6线性表的链式存储结构"><a href="#3-6线性表的链式存储结构" class="headerlink" title="3.6线性表的链式存储结构"></a>3.6线性表的链式存储结构</h3><h3 id="3-6-2线性表链式存储结构定义"><a href="#3-6-2线性表链式存储结构定义" class="headerlink" title="3.6.2线性表链式存储结构定义"></a>3.6.2线性表链式存储结构定义</h3><p>为了表示每个数据元素a_i 与其直接后继数据元素a_(i+1) 之间的逻辑关系，对数据元素a1来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素a_i 的存储映像，称为结点（Node）。<br>n个结点（a_i 的存储映像）链结成一个链表，即为线性表（a_1，a_2，…，a_n）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。<br>我们把链表中第一个结点的存储位置叫做头指针,线性链表的最后一个结点指针为“空”（通常用NULL或“^”符号表示）。<br>有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息。</p>
<h3 id="3-6-3头指针与头结点的异同"><a href="#3-6-3头指针与头结点的异同" class="headerlink" title="3.6.3头指针与头结点的异同"></a>3.6.3头指针与头结点的异同</h3><p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.6.3.GIF?raw=true" srcset="/img/loading.gif" alt="3-6-3"></p>
<h3 id="3-6-4线性表链式存储结构代码描述"><a href="#3-6-4线性表链式存储结构代码描述" class="headerlink" title="3.6.4线性表链式存储结构代码描述"></a>3.6.4线性表链式存储结构代码描述</h3><pre><code class="c">//线性表的单链表存储结构
typedef struct Node
{
    ElemType data;
    struct Node *next;
}Node;
typedef struct Node *LinkList;/* 定义LinkList */</code></pre>
<p>节点Node是由存放数据元素的数据域和存放后继节点地址的指针域组成。  </p>
<h2 id="3-7单链表的读取"><a href="#3-7单链表的读取" class="headerlink" title="3.7单链表的读取"></a>3.7单链表的读取</h2><p>获得链表第i个的数据的算法思路：  </p>
<ol>
<li>声明一个结点p指向链表第一个结点，初始化j从1开始;  </li>
<li>当<code>j&lt;i</code>时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1;  </li>
<li>若到链表末尾p为空，则说明第i个元素不存在;  </li>
<li>否则查找成功，返回结点p的数据。  </li>
</ol>
<p>实现代码算法如下：</p>
<pre><code class="c">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
/* 操作结果：用e返回L中第i个数据元素的值 */
Status GetElem(LinkList L,int i,ElemType *e)
{
    int j;
    LinkList p;  /* 声明一结点p */
    p = L-&gt;next;  /* 让p指向链表L的第一个结点 */
    j = 1;        /*  j为计数器 */
    while (p &amp;&amp; j&lt;i)  /* p不为空或者计数器j还没有等于i时，循环继续 */
    {
        p = p-&gt;next;  /* 让p指向下一个结点 */
        ++j;
    }
    if ( !p || j&gt;i )
        return ERROR;  /*  第i个元素不存在 */
    *e = p-&gt;data;   /*  取第i个元素的数据 */
    return OK;
}</code></pre>
<p>这个算法的最坏情况时间复杂度为O(n)。  </p>
<h2 id="3-8-单链表的插入和删除"><a href="#3-8-单链表的插入和删除" class="headerlink" title="3.8 单链表的插入和删除"></a>3.8 单链表的插入和删除</h2><h3 id="3-8-1-单链表的插入"><a href="#3-8-1-单链表的插入" class="headerlink" title="3.8.1 单链表的插入"></a>3.8.1 单链表的插入</h3><p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.8.1.GIF?raw=true" srcset="/img/loading.gif" alt="图3-8-1"><br>假设上一个结点是p，下一个结点是p-&gt;next,现在要把结点s插入这两个结点中去。只需要2行代码：<br><code>s-&gt;next=p-&gt;next;//先让s的指针域指向p-&gt;next</code><br><code>p-&gt;next=s;//把s的地址赋给p的指针域</code></p>
<p>ps:这两句顺序不能交换。<br>如果先<code>p-&gt;next=s</code>;再<code>s-&gt;next=p-&gt;next</code>;就等于<code>s-&gt;next=s</code>;<br>所以这2句如论如何都不能反，这点初学者一定要注意。  </p>
<p>单链表第i个数据插入结点的算法思路：</p>
<ol>
<li>声明一结点p指向链表第一个结点，初始化j从1开始;</li>
<li>当j&lt;1时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1;</li>
<li>若到链表末尾p为空，则说明第i个元素不存在;</li>
<li>否则查找成功，在系统中生成一个空结点s;</li>
<li>将数据元素e赋值给<code>s-&gt;data</code>;</li>
<li>单链表的插入标准语句<code>s-&gt;next=p-&gt;next;p-&gt;next=s;</code>;</li>
<li>返回成功;  </li>
</ol>
<p>实现代码算法如下:</p>
<pre><code class="c">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */
/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */
Status ListInsert(LinkList *L,int i,ElemType e)
{
    int j;
    LinkList p,s;
    p = *L;
    j = 1;
    while (p &amp;&amp; j &lt; i)     /* 寻找第i个结点 */
    {
        p = p-&gt;next;
        ++j;
    }
    if (!p || j &gt; i)
        return ERROR;   /* 第i个元素不存在 */
    s = (LinkList)malloc(sizeof(Node));  /*  生成新结点(C语言标准函数) */
    s-&gt;data = e;  
    s-&gt;next = p-&gt;next;      /* 将p的后继结点赋值给s的后继  */
    p-&gt;next = s;          /* 将s赋值给p的后继 */
    return OK;
}</code></pre>
<h3 id="3-8-2-单链表的删除"><a href="#3-8-2-单链表的删除" class="headerlink" title="3.8.2 单链表的删除"></a>3.8.2 单链表的删除</h3><p><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.8.5.GIF?raw=true" srcset="/img/loading.gif" alt="3-8-5"><br>要删除节点q，其实就是要让<code>p-&gt;next=q-&gt;next</code>;<br>单链表第i个数据删除结点的算法思路：</p>
<ol>
<li>声明一结点p指向链表第一个结点，初始化j从1开始</li>
<li>当<code>j&lt;i</code>时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；</li>
<li>若到链表末尾p为空，则说明第i个元素不存在；</li>
<li>否则查找成功，将欲删除的结点<code>p-&gt;next</code>赋值给q；</li>
<li>单链表的删除标准语句<code>p-&gt;next=q-&gt;next</code>；</li>
<li>将q结点中的数据赋值给e，作为返回；</li>
<li>释放q结点；</li>
<li>返回成功。  </li>
</ol>
<p>实现代码算法如下：</p>
<pre><code class="c">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */
Status ListDelete(LinkList *L,int i,ElemType *e)
{
    int j;
    LinkList p,q;
    p = *L;
    j = 1;
    while (p-&gt;next &amp;&amp; j &lt; i)    /* 遍历寻找第i个元素 */
    {
        p = p-&gt;next;
        ++j;
    }
    if (!(p-&gt;next) || j &gt; i)
        return ERROR;           /* 第i个元素不存在 */
    q = p-&gt;next;              //q结点指向要删除的结点（即要删除的结点地址赋值给q）
    p-&gt;next = q-&gt;next;            /* 将q的后继(第三个结点)赋值给p的后继 */
    *e = q-&gt;data;               /* 将q结点中的数据给e */
    free(q);                    /* 让系统回收此结点，释放内存 */
    return OK;
}</code></pre>
<p>分析一下刚才我们讲解的单链表插入和删除算法，我们很容易推导出：它们的时间复杂度都是O（n）。<br>显然，对于<strong>插入或删除数据越频繁的操作，单链表的效率优势就越是明显</strong>。</p>
<h2 id="3-9单链表的整表创建"><a href="#3-9单链表的整表创建" class="headerlink" title="3.9单链表的整表创建"></a>3.9单链表的整表创建</h2><p>单链表整表创建的算法思路：</p>
<ol>
<li>声明一结点p和计数器变量i；</li>
<li>初始化一空链表L；</li>
<li>让L的头结点的指针指向NULL，即建立一个带头结点的单链表；</li>
<li>循环：<ul>
<li>生成一新结点赋值给p；</li>
<li>随机生成一数字赋值给p的数据域p&gt;data；  </li>
<li>将p插入到头结点与前一新结点之间。  </li>
</ul>
</li>
</ol>
<p>实现头插法的代码算法如下(这段算法代码里,我们用插队的办法，始终让新结点在第一的位置。这种算法简称为头插法)：</p>
<pre><code class="c">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */
void CreateListHead(LinkList *L, int n)
{
    LinkList p;
    int i;
    srand(time(0));                         /* 初始化随机数种子 */
    *L = (LinkList)malloc(sizeof(Node));
    (*L)-&gt;next = NULL;                      /*  先建立一个带头结点的单链表 */
    for (i=0; i&lt;n; i++)
    {
        p = (LinkList)malloc(sizeof(Node)); /*  生成新结点 */
        p-&gt;data = rand()%100+1;             /*  随机生成100以内的数字 */
        p-&gt;next = (*L)-&gt;next;
        (*L)-&gt;next = p;                        /*  插入到表头 */
    }
}</code></pre>
<p>事实上，我们一般插队都是放在最后的。如果我们把每次的新结点都插在终端结点的后面，这种算法称之为尾插法。  </p>
<p>实现尾插法代码算法如下：</p>
<pre><code class="c">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */
void CreateListTail(LinkList *L, int n)
{
    LinkList p,r;
    int i;
    srand(time(0));                      /* 初始化随机数种子 */
    *L = (LinkList)malloc(sizeof(Node)); /* L为整个线性表 */
    r=*L;                                /* r为指向尾部的结点 */
    for (i=0; i&lt;n; i++)
    {
        p = (Node *)malloc(sizeof(Node)); /*  生成新结点 */
        p-&gt;data = rand()%100+1;           /*  随机生成100以内的数字 */
        r-&gt;next=p;                        /* 将表尾终端结点的指针指向新结点 */
        r = p;                            /* 将当前的新结点定义为表尾终端结点 */
    }
    r-&gt;next = NULL;                       /* 表示当前链表结束 */
}</code></pre>
<p>PS：这里需解释一下，<code>r-&gt;next=p</code>的意思，其实就是将刚才的表尾终端结点r的指针指向新结点p，如图3-9-2所示，当中①位置的连线就是表示这个意思。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.9.2.GIF?raw=true" srcset="/img/loading.gif" alt="3-9-2"><br><code>r=p</code>的意思请看图3-9-3，就是本来r是a_(i-1)元素的结点，现在它已经不是最后的结点了，现在最后的结点是a_i，所以应该将p结点这个最后的结点赋值给r。此时r又是最终的尾结点了。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.9.3.GIF?raw=true" srcset="/img/loading.gif" alt="3-9-3">  </p>
<p>循环结束后，那么应该让这个链表的指针域置空，因此有了<code>r-&gt;next=NULL</code>，以便以后遍历时可以确认其是尾部。  </p>
<h2 id="3-10单链表的整表删除"><a href="#3-10单链表的整表删除" class="headerlink" title="3.10单链表的整表删除"></a>3.10单链表的整表删除</h2><p>单链表整表删除的算法思路如下：</p>
<ol>
<li>声明一结点p和q；</li>
<li>将第一个结点赋值给p；</li>
<li>循环：<ul>
<li>将下一结点赋值给q；</li>
<li>释放p；将q赋值给p。  </li>
</ul>
</li>
</ol>
<p>实现代码算法如下：  </p>
<pre><code class="c">/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */
Status ClearList(LinkList *L)
{
    LinkList p,q;
    p=(*L)-&gt;next;           /*  p指向第一个结点 */
    while(p)                /*  没到表尾 */
    {
        q=p-&gt;next;   //下一个结点地址赋值给临时结点q
        free(p);     //释放p结点内存
        p=q;         //临时结点q的地址赋值给p，使p能够指向继续指向下一个结点
    }
    (*L)-&gt;next=NULL;        /* 头结点指针域为空 */
    return OK;
}</code></pre>
<h2 id="3-11单链表结构与顺序存储结构优缺点"><a href="#3-11单链表结构与顺序存储结构优缺点" class="headerlink" title="3.11单链表结构与顺序存储结构优缺点"></a>3.11单链表结构与顺序存储结构优缺点</h2><p>简单地对单链表结构和顺序存储结构做对比,如图3-11-1：<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.11.1.GIF?raw=true" srcset="/img/loading.gif" alt="3-11-1">  </p>
<p>通过上面的对比，我们可以得出一些经验性的结论：</p>
<ul>
<li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。</li>
<li>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。  </li>
</ul>
<p>总之，线性表的顺序存储结构和单链表结构各有其优缺点，不能简单的说哪个好，哪个不好，需要根据实际情况，来综合平衡采用哪种数据结构更能满足和达到需求和性能。  </p>
<h2 id="3-12静态链表"><a href="#3-12静态链表" class="headerlink" title="3.12静态链表"></a>3.12静态链表</h2><p>静态链表是由数组组成。<br>我们让数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下标都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而游标cur相当于单链表中的next 指针，存放该元素的后继在数组中的下标。<br>我们把这种用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。<br>静态链表的结构定义如下：  </p>
<pre><code class="c">/* 线性表的静态链表存储结构 */
typedef struct
{
    ElemType data;
    int cur;  /* 游标(Cursor) ，为0时表示无指向 */
} Component,StaticLinkList[MAXSIZE];</code></pre>
<p>另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据。我们通常把未被使用的数组元素称为备用链表。而数组第一个元素，即<strong>下标为0的元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标</strong>，相当于单链表中的头结点作用，当整个链表为空时，则为0。如图3-12-1所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.12.1.GIF?raw=true" srcset="/img/loading.gif" alt="3-12-1">  </p>
<p>初始化数组状态，代码如下：  </p>
<pre><code class="c">/* 将一维数组space中各分量链成一个备用链表，space[0].cur为头指针，&quot;0&quot;表示空指针 */
Status InitList(StaticLinkList space)
{
    int i;
    for (i=0; i&lt;MAXSIZE-1; i++)  
        space[i].cur = i+1;
    space[MAXSIZE-1].cur = 0; /* 目前静态链表为空，最后一个元素的cur为0 */
    return OK;
}</code></pre>
<h3 id="3-12-1静态链表的插入操作"><a href="#3-12-1静态链表的插入操作" class="headerlink" title="3.12.1静态链表的插入操作"></a>3.12.1静态链表的插入操作</h3><p>在静态链表中，需要我们自己实现结点的申请和释放这2个函数，才可以做插入和删除的操作。<br>为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。  </p>
<pre><code class="c">/* 若备用空间链表非空，则返回分配的结点下标，否则返回0 */
int Malloc_SSL(StaticLinkList space)
{
    int i = space[0].cur;                   /* 当前数组第一个元素的cur存的值 */
                                            /* 就是要返回的第一个备用空闲的下标 */
    if (space[0]. cur)
        space[0]. cur = space[i].cur;       /* 由于要拿出一个分量来使用了， */
                               ll             /* 所以我们就得把它的下一个 */
                                            /* 分量用来做备用 */
    return i;
}</code></pre>
<p>这段代码有意思，它的作用就是返回一个下标值，这个值就是数组头元素的cur存的第一个空闲的下标,同时把这个空闲的下标给<code>space[0].cur</code>，之后就可以继续分配新的空闲分量，实现类似mallbc（）函数的作用。<br>插入操作的实现代码如下：  </p>
<pre><code class="c">/*  在L中第i个元素之前插入新的数据元素e   */
Status ListInsert(StaticLinkList L, int i, ElemType e)
{  
    int j, k, l;
    k = MAXSIZE - 1;   /* 注意k首先是最后一个元素的下标 */
    if (i &lt; 1 || i &gt; ListLength(L) + 1)
        return ERROR;
    j = Malloc_SSL(L);   /* 获得空闲分量的下标 */
    if (j)
    {
        L[j].data = e;   /* 将数据赋值给此分量的data */
        for(l = 1; l &lt;= i - 1; l++)   /* 找到第i个元素之前的位置 */
           k = L[k].cur;
        L[j].cur = L[k].cur;    /* 把第i个元素之前的cur赋值给新元素的cur */
        L[k].cur = j;           /* 把新元素的下标赋值给第i个元素之前元素的ur */
        return OK;
    }
    return ERROR;
}</code></pre>
<h3 id="3-12-2静态链表的删除操作"><a href="#3-12-2静态链表的删除操作" class="headerlink" title="3.12.2静态链表的删除操作"></a>3.12.2静态链表的删除操作</h3><p>删除元素时，实现的代码如下：  </p>
<pre><code class="c">/*  删除在L中第i个数据元素   */
Status ListDelete(StaticLinkList L, int i)
{
    int j, k;
    if (i &lt; 1 || i &gt; ListLength(L))
        return ERROR;
    k = MAXSIZE - 1;
    for (j = 1; j &lt;= i - 1; j++)
        k = L[k].cur;
    j = L[k].cur;
    L[k].cur = L[j].cur;
    Free_SSL(L, j);
    return OK;
}</code></pre>
<p>释放结点的函数代码如下：  </p>
<pre><code class="c">/*  将下标为k的空闲结点回收到备用链表 */
void Free_SSL(StaticLinkList space, int k)
{  
    space[k].cur = space[0].cur;    /* 把第一个元素的cur值赋给要删除的分量cur */
    space[0].cur = k;               /* 把要删除的分量下标赋值给第一个元素的cur */
}</code></pre>
<p>返回静态链表长度的代码实现如下：  </p>
<pre><code class="c">/* 初始条件：静态链表L已存在。操作结果：返回L中数据元素个数 */
int ListLength(StaticLinkList L)
{
    int j=0;
    int i=L[MAXSIZE-1].cur;
    while(i)
    {
        i=L[i].cur;
        j++;
    }
    return j;
}</code></pre>
<h3 id="3-12-3静态链表优缺点"><a href="#3-12-3静态链表优缺点" class="headerlink" title="3.12.3静态链表优缺点"></a>3.12.3静态链表优缺点</h3><p>总结一下静态链表的优缺点（见图3-12-5）：<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.12.5.GIF?raw=true" srcset="/img/loading.gif" alt="3-12-5"><br>总的来说，静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。尽管大家不一定会用得上，但这样的思考方式是非常巧妙的，应该理解其思想，以备不时之需。  </p>
<h2 id="3-13循环链表"><a href="#3-13循环链表" class="headerlink" title="3.13循环链表"></a>3.13循环链表</h2><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。<br>其实循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断<code>p-&gt;next</code>是否为空，现在则是<code>p-&gt;next</code>不等于头结点，则循环未结束。<br>在单链表中，我们有了头结点时，我们可以用O（1）的时间访问第一个结点，但如果想要用O（1）的时间访问到最后一个结点，则需要改造一下这个循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表（如图3-13-5）。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.5.GIF?raw=true" srcset="/img/loading.gif" alt="3-13-5"><br>从上图可以看出，终端结点用尾指针rear指示，则查找终端结点是O（1），而开始结点，其实就是<code>rear-&gt;next-&gt;next</code>，其时间复杂也为O（1）。<br>举个程序的例子，要将两个循环链表合并成一个表时，有了尾指针就非常简单了。比如下面的这两个循环链表，它们的尾指针分别是rearA和rearB，如图3-13-6所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.6.GIF?raw=true" srcset="/img/loading.gif" alt="3-13-6"><br>要想把它们合并，只需要如下的操作即可，如图3-13-7所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.13.7.GIF?raw=true" srcset="/img/loading.gif" alt="3-13-7"><br>具体代码如下：  </p>
<pre><code class="c">p=rearA-&gt;next;     /*保存A表的头结点，即①*/
rearA-&gt;next=rearB-&gt;next-&gt;next;     /*将本是指向B表的第一个结点（不是头结点）赋值给reaA-&gt;next,即②*/
rearB-&gt;next=p;/*将原A表的头结点赋值给rearB-&gt;next，即③**/
free(p);/*释放p*/</code></pre>
<h2 id="3-14双向链表"><a href="#3-14双向链表" class="headerlink" title="3.14双向链表"></a>3.14双向链表</h2><p>双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。<br>所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。  </p>
<pre><code class="c">/*线性表的双向链表存储结构*/
typedef struct DulNode
{
    ElemType data；
    struct DuLNode *prior；/*直接前驱指针*/
    struct DuLNode *next；/*直接后继指针*/
}DulNode，*DuLinkList；</code></pre>
<p>既然单链表也可以有循环链表，那么双向链表当然也可以是循环表。<br>双向链表的循环带头结点的空链表如图3-14-3所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.3.GIF?raw=true" srcset="/img/loading.gif" alt="3-14-3"><br>非空的循环的带头结点的双向链表如图3-14-4所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.4.GIF?raw=true" srcset="/img/loading.gif" alt="3-14-4"><br>PS：双向链表在插入和删除时，需要更改两个指针变量。<br>插入操作时，其实并不复杂，不过<strong>顺序很重要，千万不能写反了</strong>。<br>我们现在假设存储元素e的结点为s，要实现将结点s插入到结点p和<code>p-&gt;next</code>之间需要下面几步，如图3-14-5所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.5.GIF?raw=true" srcset="/img/loading.gif" alt="3-14-5">  </p>
<pre><code class="c">s-&gt;prior=p;/*把p赋值给s的前驱，如图中①*/
s-&gt;next=p-&gt;next;/*把p-&gt;next赋值给s的后继，如图中②*/
p-&gt;next-&gt;prior=s;/*把s赋值给p-&gt;next的前驱，如图中③*/
p-&gt;next=s;/*把s赋值给p的后继，如图中④*/</code></pre>
<p>关键在于它们的顺序，由于第2步和第3步都用到了<code>p-&gt;next</code>。如果第4步先执行，则会使得<code>p-&gt;next</code>提前变成了s，使得插入的工作完不成。所以我们不妨把上面这张图在理解的基础上记忆，顺序是先搞定s的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。  </p>
<p>若要删除结点p，只需要下面两步骤，如图3-14-6所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.14.6.GIF?raw=true" srcset="/img/loading.gif" alt="3-14-6">  </p>
<pre><code class="c">p-&gt;prior-&gt;next=p-&gt;next；/*把p-&gt;next赋值给p-&gt;prior的后继，如图中①*/
p-&gt;next-&gt;prior=p-&gt;prior；/*把p-&gt;prior 赋值给p-&gt;next的前驱，如图中②*/
free（p）；/*释放结点*/</code></pre>
<h2 id="3-15总结回顾"><a href="#3-15总结回顾" class="headerlink" title="3.15总结回顾"></a>3.15总结回顾</h2><p>这一章，主要讲的是线性表。<br>先谈了它的定义，线性表是零个或多个具有相同类型的数据元素的有限序列。然后谈了线性表的抽象数据类型，如它的一些基本操作。<br>之后我们就线性表的两大结构做了讲述，先讲的是比较容易的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。通常我们都是用数组来实现这一结构。<br>后来是我们的重点，由顺序存储结构的插入和删除操作不方便，引出了链式存储结构。它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。然后我们分别就链式存储结构的不同形式，如单链表、循环链表和双向链表做了讲解，另外我们还讲了若不使用指针如何处理链表结构的静态链表方法。<br>总的来说，线性表的这两种结构（如图3-15-1所示）是后面其他数据结构的基础，把它们学明白了，对后面的学习有着至关重要的作用。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.15.1.GIF?raw=true" srcset="/img/loading.gif" alt="3-15-1"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构第四章 栈与队列</title>
    <url>/2019/11/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E7%AC%AC4%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="4-1-4-2-栈的定义"><a href="#4-1-4-2-栈的定义" class="headerlink" title="4.1-4.2 栈的定义"></a>4.1-4.2 栈的定义</h2><h3 id="4-2-1-栈的定义"><a href="#4-2-1-栈的定义" class="headerlink" title="4.2.1 栈的定义"></a>4.2.1 栈的定义</h3><p><strong>栈是限定仅在表尾进行插入和删除操作的线性表。</strong><br>我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简尔LIFO结构。<br>它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。<br>栈的插入操作，叫作进栈，也称压栈、入栈(push)。  </p>
<a id="more"></a>

<p>栈的删除操作，叫作出栈，也有的叫作弹栈(pop)。  </p>
<h2 id="4-3-栈的抽象数据类型"><a href="#4-3-栈的抽象数据类型" class="headerlink" title="4.3 栈的抽象数据类型"></a>4.3 栈的抽象数据类型</h2><pre><code class="c">ADT 栈(stack)
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
    InitStack(*s)：初始化操作，建立一个空栈s。
    DestroyStack(*s)：若楼存在，则销毁它。
    ClearStack(*s)：将栽清空。
    StackEmpty(S)：若为空，返回true，否则返回false。
    GetTop(s，*e)：若栽存在且非空，用e返回s的栽顶元素。
    Push(*s，e)：若栈S存在，插入新元素e到栈S中并成为栈顶元素。
    Pop(*S，*e)：删除栈S中栈顶元素，并用e返回其值。
    StackLength(s)：返回栈s的元素个数。
endADT</code></pre>
<h2 id="4-4-栈的顺序存储结构及实现"><a href="#4-4-栈的顺序存储结构及实现" class="headerlink" title="4.4 栈的顺序存储结构及实现"></a>4.4 栈的顺序存储结构及实现</h2><h3 id="4-4-1-栈的顺序存储结构"><a href="#4-4-1-栈的顺序存储结构" class="headerlink" title="4.4.1 栈的顺序存储结构"></a>4.4.1 栈的顺序存储结构</h3><p>栈是线性表的特例，那么栈的顺序存储其实也是线性表顺序存储的简化，我们简称为顺序栈。线性表是用数组来实现的。<br>我们定义一个top变量来指示栈顶元素在数组中的位置，它可以来回移动，意味着栈顶的top可以变大变小，但无论如何游标不能超出栈的长度。同理，若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判定条件定为top等于-1。</p>
<p>栈的结构定义：  </p>
<pre><code class="c">typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */
/* 顺序栈结构 */
typedef struct
{
        SElemType data[MAXSIZE];
        int top; /* 用于栈顶指针 */
}SqStack;</code></pre>
<p>若现在有一个栈，StackSize是5，则栈普通情况、空栈和栈满的情况示意图如图4-4-2所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-4-2.JPG?raw=true" srcset="/img/loading.gif" alt="4-4-2">  </p>
<h3 id="4-4-2-栈的顺序存储结构——进栈操作"><a href="#4-4-2-栈的顺序存储结构——进栈操作" class="headerlink" title="4.4.2 栈的顺序存储结构——进栈操作"></a>4.4.2 栈的顺序存储结构——进栈操作</h3><p>对于栈的插入，即进栈操作，其实就是在栈顶插入一个元素。<br>进栈操作push，其代码如下：  </p>
<pre><code class="c">/* 插入元素e为新的栈顶元素 */
Status Push(SqStack *S,SElemType e)
{
        if(S-&gt;top == MAXSIZE -1) /* 栈满 */
        {
            return ERROR;
        }
        S-&gt;top++;   /* 栈顶指针增加一 */
        S-&gt;data[S-&gt;top]=e;  /* 将新插入元素赋值给栈顶空间 */
        return OK;
}</code></pre>
<h3 id="4-4-3-栈的顺序存储结构——出栈操作"><a href="#4-4-3-栈的顺序存储结构——出栈操作" class="headerlink" title="4.4.3 栈的顺序存储结构——出栈操作"></a>4.4.3 栈的顺序存储结构——出栈操作</h3><p>出栈操作pop，代码如下：  </p>
<pre><code class="c">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */
Status Pop(SqStack *S,SElemType *e)
{
        if(S-&gt;top==-1)
                return ERROR;
        *e=S-&gt;data[S-&gt;top]; /* 将要删除的栈顶元素赋值给e */
        S-&gt;top--;   /* 栈顶指针减一 */
        return OK;
}</code></pre>
<p>两者没有涉及到任何循环语句，因此时间复杂度均是O(1)。  </p>
<h2 id="4-5-两栈共享空间"><a href="#4-5-两栈共享空间" class="headerlink" title="4.5 两栈共享空间"></a>4.5 两栈共享空间</h2><p>如果我们有两个相同类型的栈，我们为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。这又何必呢？我们完全可以用一个数组来存储两个栈，只不过需要点小技巧。<br>数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为栈的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。<br>其实关键思路是：它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。<br>从这里也就可以分析出来，栈1为空时，就是top1等于-1时；而当top2等于n时，即是栈2为空时，那什么时候栈满呢？<br>想想极端的情况，若栈2是空栈，栈1的top1等于n-1时，就是栈1满了。反之，当栈1为空栈时，top2等于0时，为栈2满。但更多的情况，其实就是我刚才说的，两个栈见面之时，也就是两个指针之间相差1时，即top1+1==top2为栈满。<br>两栈共享空间的结构的代码如下：</p>
<pre><code class="c">/* 两栈共享空间结构 */
typedef struct
{
    SElemType data[MAXSIZE];
    int top1;    /* 栈1栈顶指针 */
    int top2;    /* 栈2栈顶指针 */
}SqDoubleStack;</code></pre>
<p>对于两栈共享空间的push方法，我们除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber。插入元素的代码如下：</p>
<pre><code class="c">/* 插入元素e为新的栈顶元素 */
Status Push(SqDoubleStack *S, SElemType e, int stackNumber)
{
    if (S-&gt;top1 + 1 == S-&gt;top2)    /* 栈已满，不能再push新元素了 */
        return ERROR;
    if (stackNumber == 1)            /* 栈1有元素进栈 */
        S-&gt;data[++S-&gt;top1] = e; /* 若是栈1则先top1+1后给数组元素赋值。 */
    else if (stackNumber == 2)    /* 栈2有元素进栈 */
        S-&gt;data[--S-&gt;top2] = e; /* 若是栈2则先top2-1后给数组元素赋值。 */
    return OK;
}</code></pre>
<p>因为在开始已经判断了是否有栈满的情况，所以后面的top1+1或top2-1是不担心溢出问题的。<br>对于两栈共享空间的pop方法，参数就只是判断栈1栈2的参数stackNumber，代码如下：</p>
<pre><code class="c">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */
Status Pop(SqDoubleStack *S, SElemType *e, int stackNumber)
{
    if (stackNumber == 1)
    {
        if (S-&gt;top1 == -1)
            return ERROR; /* 说明栈1已经是空栈，溢出 */
        *e = S-&gt;data[S-&gt;top1--]; /* 将栈1的栈顶元素出栈 */
    }
    else if (stackNumber == 2)
    {
        if (S-&gt;top2 == MAXSIZE)
            return ERROR; /* 说明栈2已经是空栈，溢出 */
        *e = S-&gt;data[S-&gt;top2++]; /* 将栈2的栈顶元素出栈 */
    }
    return OK;
}</code></pre>
<p>事实上，使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。就像买卖股票一样，你买入时，一定是有一个你不知道的人在做卖出操作。有人赚钱，就一定是有人赔钱。这样使用两栈共享空间存储方法才有比较大的意义。否则两个栈都在不停地增长，那很快就会因栈满而溢出了。  </p>
<h2 id="4-6-栈的链式存储结构及实现"><a href="#4-6-栈的链式存储结构及实现" class="headerlink" title="4.6 栈的链式存储结构及实现"></a>4.6 栈的链式存储结构及实现</h2><h3 id="4-6-1-栈的链式存储结构"><a href="#4-6-1-栈的链式存储结构" class="headerlink" title="4.6.1 栈的链式存储结构"></a>4.6.1 栈的链式存储结构</h3><p>栈的链式存储结构，简称为链栈。<br>链栈的结构代码如下：  </p>
<pre><code class="c">/* 链栈结构 */
typedef struct StackNode
{
    SElemType data;
    struct StackNode *next;
}StackNode,*LinkStackPtr;

typedef struct LinkStack
{
    LinkStackPtr top;
    int count;
}LinkStack;</code></pre>
<h3 id="4-6-2-栈的链式存储结构-进栈操作"><a href="#4-6-2-栈的链式存储结构-进栈操作" class="headerlink" title="4.6.2 栈的链式存储结构-进栈操作"></a>4.6.2 栈的链式存储结构-进栈操作</h3><p>对于链栈的进栈push操作，假设元素值为e的新结点是s，top为栈顶指针，示意图如图4-6-2所示代码如下。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-6-2.JPG?raw=true" srcset="/img/loading.gif" alt="4-6-2">  </p>
<pre><code class="c">/* 插入元素e为新的栈顶元素 */
Status Push(LinkStack *S,SElemType e)
{
    LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode));
    s-&gt;data=e;
    s-&gt;next=S-&gt;top;/* 把当前的栈顶元素赋值给新结点的直接后继，见图中① */
    S-&gt;top=s;         /* 将新的结点s赋值给栈顶指针，见图中② */
    S-&gt;count++;
    return OK;
}</code></pre>
<h3 id="4-6-3-栈的链式存储结构——出栈操作"><a href="#4-6-3-栈的链式存储结构——出栈操作" class="headerlink" title="4.6.3 栈的链式存储结构——出栈操作"></a>4.6.3 栈的链式存储结构——出栈操作</h3><p>至于链栈的出栈pop操作，也是很简单的三句操作。假设变量p用来存储要删除的栈顶结点，将栈顶指针下移一位，最后释放p即可，如图4-6-3所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-6-3.JPG?raw=true" srcset="/img/loading.gif" alt="4-6-3">  </p>
<pre><code class="c">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */
Status Pop(LinkStack *S,SElemType *e)
{
        LinkStackPtr p;
        if(StackEmpty(*S))
                return ERROR;
        *e=S-&gt;top-&gt;data;
        p=S-&gt;top;               /* 将栈顶结点赋值给p，见图中③ */
        S-&gt;top=S-&gt;top-&gt;next;    /* 使得栈顶指针下移一位，指向后一结点，见图中④ */
        free(p);                    /* 释放结点p */
        S-&gt;count--;
        return OK;
}</code></pre>
<p>链栈的进栈push和出栈pop操作都很简单，时间复杂度均是O(1)。<br>对比一下顺序栈与链栈，它们在时间复杂度上是一样的，均为O(1)。对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以它们的区别是如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。  </p>
<h2 id="4-7-栈的作用"><a href="#4-7-栈的作用" class="headerlink" title="4.7 栈的作用"></a>4.7 栈的作用</h2><p>栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。  </p>
<h2 id="4-8-栈的应用——递归"><a href="#4-8-栈的应用——递归" class="headerlink" title="4.8 栈的应用——递归"></a>4.8 栈的应用——递归</h2><h3 id="4-8-1-4-8-2递归定义"><a href="#4-8-1-4-8-2递归定义" class="headerlink" title="4.8.1-4.8.2递归定义"></a>4.8.1-4.8.2递归定义</h3><p>我们<strong>把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数</strong>。<br>当然，写递归程序最怕的就是陷入永不结束的无穷递归中，所以，<strong>每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出</strong>。  </p>
<h2 id="4-9-栈的应用——四则运算表达式求值"><a href="#4-9-栈的应用——四则运算表达式求值" class="headerlink" title="4.9 栈的应用——四则运算表达式求值"></a>4.9 栈的应用——四则运算表达式求值</h2><h3 id="4-9-1-后缀-逆波兰-表示法定义"><a href="#4-9-1-后缀-逆波兰-表示法定义" class="headerlink" title="4.9.1 后缀(逆波兰)表示法定义"></a>4.9.1 后缀(逆波兰)表示法定义</h3><p>栈的现实应用也很多，我们再来重点讲一个比较常见的应用：数学表达式的求值。<br>一种不需要括号的后缀表达法，我们也把它称为逆波兰(Reverse Polish Notation，RPN)表示。<br>我们先来看看，对于“<code>9+(3-1)×3+10÷2</code>”，如果要用后缀表示法应该是：“<code>9 3 1-3*+10 2/+</code>”，这样的表达式称为后缀表达式，叫后缀的原因在于<strong>所有的符号都是在要运算数字的后面出现</strong>。  </p>
<h3 id="4-9-2-后缀表达式计算结果"><a href="#4-9-2-后缀表达式计算结果" class="headerlink" title="4.9.2 后缀表达式计算结果"></a>4.9.2 后缀表达式计算结果</h3><p>后缀表达式：<code>9 3 1-3*+10 2/+</code><br>规则：<strong>从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</strong>  </p>
<h3 id="4-9-3-中缀表达式转后缀表达式"><a href="#4-9-3-中缀表达式转后缀表达式" class="headerlink" title="4.9.3 中缀表达式转后缀表达式"></a>4.9.3 中缀表达式转后缀表达式</h3><p>我们把平时所用的标准四则运算表达式，即“<code>9+(3-1)×3+10÷2</code>”叫做中缀表达式。因为所有的运算符号都在两数字的中间。<br>中缀表达式“<code>9+(3-1)×3+10÷2</code>”转化为后缀表达式“<code>9 3 1-3*+10 2/+</code>”。<br>规则：<strong>从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号(乘除优先加减)则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</strong>  </p>
<h2 id="4-10-队列的定义"><a href="#4-10-队列的定义" class="headerlink" title="4.10 队列的定义"></a>4.10 队列的定义</h2><p>队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。  </p>
<h2 id="4-11-队列的抽象数据类型"><a href="#4-11-队列的抽象数据类型" class="headerlink" title="4.11 队列的抽象数据类型"></a>4.11 队列的抽象数据类型</h2><pre><code class="c">ADT 队列(Queue)
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
    InitQueue(*Q)：初始化操作，建立一个空队列Q。
    DestroyQueue(*Q)：若队列Q存在，则销毁它。
    ClearQueue(*Q)：将队列Q清空。
    QueueEmpty(Q)：若队列Q为空，返回true，否则返回false。
    GetHead(Q，*e)：若队列Q存在且非空，用e返回队列Q的队头元素。
    EnQueue(*Q，e)：若队列Q存在，插入新元素e到队列Q中并成为队尾元素。
    DeQueue(*Q，*e)：删除队列Q中队头元素，并用e返回其值。
    QueueLength(Q)：返回队列Q的元素个数
endADT</code></pre>
<h2 id="4-12-循环队列"><a href="#4-12-循环队列" class="headerlink" title="4.12 循环队列"></a>4.12 循环队列</h2><h3 id="4-12-1-队列顺序存储的不足"><a href="#4-12-1-队列顺序存储的不足" class="headerlink" title="4.12.1 队列顺序存储的不足"></a>4.12.1 队列顺序存储的不足</h3><p>入队的时间复杂度为O(1)。<br>与栈不同的是，队列元素的出列是在队头，即下标为0的位置，那也就意味着，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为0的位置不为空，此时时间复杂度为出队的时间复杂度为O(n)，效率太低。<br>如果队列前面的位置空的，后面的位置排满了，那么新进的元素可以排到前面，这就引进了循环队列的概念。<br>为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列是空队列。  </p>
<h3 id="4-12-2-循环队列定义"><a href="#4-12-2-循环队列定义" class="headerlink" title="4.12.2 循环队列定义"></a>4.12.2 循环队列定义</h3><p>队列中头尾相接的顺序存储结构称为循环队列。<br>此时问题又出来了，空队列时，front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？</p>
<ol>
<li>办法一是设置一个标志变量flag，当<code>front==rear</code>，且flag=0时为队列空，当<code>front==rear</code>，且flag=1时为队列满。</li>
<li>办法二是当队列空时，条件就是<code>front=rear</code>，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。<br>我们重点来讨论第二种方法，由于rear可能比front大，也可能比front小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的最大尺寸为QueueSize，那么队列满的条件是“<code>(rear+1)%QueueSize==front</code>”(取模“%”的目的就是为了整合rear与front大小为一个问题)。<br>通用的计算队列长度公式为：<code>(rear-front+QueueSize)%QueueSize</code>。<br>循环队列的顺序存储结构代码如下：</li>
</ol>
<pre><code class="c">typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */
/* 循环队列的顺序存储结构 */
typedef struct
{
    QElemType data[MAXSIZE];
    int front;      /* 头指针 */
    int rear;       /* 尾指针，若队列不空，指向队列尾元素的下一个位置 */
}SqQueue;</code></pre>
<p>循环队列的初始化代码如下：</p>
<pre><code class="c">/* 初始化一个空队列Q */
Status InitQueue(SqQueue *Q)
{
    Q-&gt;front = 0;
    Q-&gt;rear = 0;
    return  OK;
}</code></pre>
<p>循环队列求队列长度代码如下：</p>
<pre><code class="c">/* 返回Q的元素个数，也就是队列的当前长度 */
int QueueLength(SqQueue Q)
{
    return  (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
}</code></pre>
<p>循环队列的入队列操作代码如下：</p>
<pre><code class="c">/* 若队列未满，则插入元素e为Q新的队尾元素 */
Status EnQueue(SqQueue *Q, QElemType e)
{
    if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front)    /* 队列满的判断 */
        return ERROR;
    Q-&gt;data[Q-&gt;rear] = e;               /* 将元素e赋值给队尾 */
    Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE;/* rear指针向后移一位置， */
                                      /* 若到最后则转到数组头部 */
    return  OK;
}</code></pre>
<p>循环队列的出队列操作代码如下：</p>
<pre><code class="c">/* 若队列不空，则删除Q中队头元素，用e返回其值 */
Status DeQueue(SqQueue *Q, QElemType *e)
{
    if (Q-&gt;front == Q-&gt;rear)            /* 队列空的判断 */
        return ERROR;
    *e = Q-&gt;data[Q-&gt;front];                /* 将队头元素赋值给e */
    Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;    /* front指针向后移一位置 */
                                    /* 若到最后则转到数组头部 */
    return  OK;
}</code></pre>
<h2 id="4-13-队列的链式存储结构及实现"><a href="#4-13-队列的链式存储结构及实现" class="headerlink" title="4.13 队列的链式存储结构及实现"></a>4.13 队列的链式存储结构及实现</h2><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。<br>为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点，如图4-13-1所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-1.JPG?raw=true" srcset="/img/loading.gif" alt="4-13-1"><br>空队列时，front和rear都指向头结点，如图4-13-2所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-2.JPG?raw=true" srcset="/img/loading.gif" alt="4-13-2"><br>链队列的结构为：  </p>
<pre><code class="c">typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */

typedef struct QNode    /* 结点结构 */
{
    QElemType data;
    struct QNode *next;
}QNode, *QueuePtr;

typedef struct            /* 队列的链表结构 */
{
    QueuePtr front, rear; /* 队头、队尾指针 */
}LinkQueue;</code></pre>
<h3 id="4-13-1-队列的链式存储结构——入队操作"><a href="#4-13-1-队列的链式存储结构——入队操作" class="headerlink" title="4.13.1 队列的链式存储结构——入队操作"></a>4.13.1 队列的链式存储结构——入队操作</h3><p>入队操作时，其实就是在链表尾部插入结点，如图4-13-3所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-3.JPG?raw=true" srcset="/img/loading.gif" alt="4-13-3"><br>入队代码如下：</p>
<pre><code class="c">/* 插入元素e为Q的新的队尾元素 */
Status EnQueue(LinkQueue *Q, QElemType e)
{
    QueuePtr s = (QueuePtr)malloc(sizeof(QNode));
    if (!s) /* 存储分配失败 */
        exit(OVERFLOW);
    s-&gt;data = e;
    s-&gt;next = NULL;
    Q-&gt;rear-&gt;next = s;    /* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */
    Q-&gt;rear = s;        /* 把当前的s设置为队尾结点，rear指向s，见图中② */
    return OK;
}</code></pre>
<h3 id="4-13-2-队列的链式存储结构——出队操作"><a href="#4-13-2-队列的链式存储结构——出队操作" class="headerlink" title="4.13.2 队列的链式存储结构——出队操作"></a>4.13.2 队列的链式存储结构——出队操作</h3><p>出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将rear指向头结点，如图4-13-4所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-13-4.JPG?raw=true" srcset="/img/loading.gif" alt="4-13-4">  </p>
<p>出队代码如下：</p>
<pre><code class="c">/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */
Status DeQueue(LinkQueue *Q, QElemType *e)
{
    QueuePtr p;
    if (Q-&gt;front == Q-&gt;rear)
        return ERROR;
    p = Q-&gt;front-&gt;next;        /* 将欲删除的队头结点暂存给p，见图中① */
    *e = p-&gt;data;                /* 将欲删除的队头结点的值赋值给e */
    Q-&gt;front-&gt;next = p-&gt;next;/* 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中② */
    if (Q-&gt;rear == p)/* 空队列的时候 */ /* 若队头就是队尾，则删除后将rear指向头结点，见图中③ */
        Q-&gt;rear = Q-&gt;front;
    free(p);
    return OK;
}</code></pre>
<p>对于循环队列与链队列的比较，可以从两方面来考虑，从时间上，其实它们的基本操作都是常数时间，即都为O（1）的，不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。对于空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。<br>总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。  </p>
<h2 id="4-14-总结回顾"><a href="#4-14-总结回顾" class="headerlink" title="4.14 总结回顾"></a>4.14 总结回顾</h2><p>这一章讲的是栈和队列，它们都是特殊的线性表，只不过对插入和删除操作做了限制。<br>栈(stack)是限定仅在表尾进行插入和删除操作的线性表。<br>队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。因此它们各自有各自的技巧来解决这个问题。<br>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。<br>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。<br>它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同如图4-14-1所示。<br><img src="https://closer_laps.coding.net/p/picture/d/picture/git/raw/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0/4-14-1.JPG?raw=true" srcset="/img/loading.gif" alt="4-14-1">  </p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
</search>
